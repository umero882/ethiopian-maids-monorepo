schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """refresh the cache entry"""
  refresh: Boolean! = false

  """measured in seconds"""
  ttl: Int! = 60
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_array_comparison_exp {
  """is the array contained in the given array value"""
  _contained_in: [Int!]

  """does the array contain the given value"""
  _contains: [Int!]
  _eq: [Int!]
  _gt: [Int!]
  _gte: [Int!]
  _in: [[Int!]!]
  _is_null: Boolean
  _lt: [Int!]
  _lte: [Int!]
  _neq: [Int!]
  _nin: [[Int!]!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_array_comparison_exp {
  """is the array contained in the given array value"""
  _contained_in: [String!]

  """does the array contain the given value"""
  _contains: [String!]
  _eq: [String!]
  _gt: [String!]
  _gte: [String!]
  _in: [[String!]!]
  _is_null: Boolean
  _lt: [String!]
  _lte: [String!]
  _neq: [String!]
  _nin: [[String!]!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

scalar aal_level

"""
Boolean expression to compare columns of type "aal_level". All fields are combined with logical 'AND'.
"""
input aal_level_comparison_exp {
  _eq: aal_level
  _gt: aal_level
  _gte: aal_level
  _in: [aal_level!]
  _is_null: Boolean
  _lt: aal_level
  _lte: aal_level
  _neq: aal_level
  _nin: [aal_level!]
}

"""User activity based announcements (registrations, hires, etc.)"""
type activity_announcements {
  activity_type: String!
  agency_id: uuid
  created_at: timestamptz
  description: String
  id: uuid!
  is_public: Boolean
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  title: String!

  """An object relationship"""
  user: auth_users
  user_id: uuid
}

"""
aggregated selection of "activity_announcements"
"""
type activity_announcements_aggregate {
  aggregate: activity_announcements_aggregate_fields
  nodes: [activity_announcements!]!
}

"""
aggregate fields of "activity_announcements"
"""
type activity_announcements_aggregate_fields {
  count(columns: [activity_announcements_select_column!], distinct: Boolean): Int!
  max: activity_announcements_max_fields
  min: activity_announcements_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input activity_announcements_append_input {
  metadata: jsonb
}

"""
Boolean expression to filter rows from the table "activity_announcements". All fields are combined with a logical 'AND'.
"""
input activity_announcements_bool_exp {
  _and: [activity_announcements_bool_exp!]
  _not: activity_announcements_bool_exp
  _or: [activity_announcements_bool_exp!]
  activity_type: String_comparison_exp
  agency_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  is_public: Boolean_comparison_exp
  metadata: jsonb_comparison_exp
  title: String_comparison_exp
  user: auth_users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "activity_announcements"
"""
enum activity_announcements_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  activity_announcements_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input activity_announcements_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input activity_announcements_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input activity_announcements_delete_key_input {
  metadata: String
}

"""
input type for inserting data into table "activity_announcements"
"""
input activity_announcements_insert_input {
  activity_type: String
  agency_id: uuid
  created_at: timestamptz
  description: String
  id: uuid
  is_public: Boolean
  metadata: jsonb
  title: String
  user: auth_users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type activity_announcements_max_fields {
  activity_type: String
  agency_id: uuid
  created_at: timestamptz
  description: String
  id: uuid
  title: String
  user_id: uuid
}

"""aggregate min on columns"""
type activity_announcements_min_fields {
  activity_type: String
  agency_id: uuid
  created_at: timestamptz
  description: String
  id: uuid
  title: String
  user_id: uuid
}

"""
response of any mutation on the table "activity_announcements"
"""
type activity_announcements_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [activity_announcements!]!
}

"""
on_conflict condition type for table "activity_announcements"
"""
input activity_announcements_on_conflict {
  constraint: activity_announcements_constraint!
  update_columns: [activity_announcements_update_column!]! = []
  where: activity_announcements_bool_exp
}

"""Ordering options when selecting data from "activity_announcements"."""
input activity_announcements_order_by {
  activity_type: order_by
  agency_id: order_by
  created_at: order_by
  description: order_by
  id: order_by
  is_public: order_by
  metadata: order_by
  title: order_by
  user: auth_users_order_by
  user_id: order_by
}

"""primary key columns input for table: activity_announcements"""
input activity_announcements_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input activity_announcements_prepend_input {
  metadata: jsonb
}

"""
select columns of table "activity_announcements"
"""
enum activity_announcements_select_column {
  """column name"""
  activity_type

  """column name"""
  agency_id

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  is_public

  """column name"""
  metadata

  """column name"""
  title

  """column name"""
  user_id
}

"""
input type for updating data in table "activity_announcements"
"""
input activity_announcements_set_input {
  activity_type: String
  agency_id: uuid
  created_at: timestamptz
  description: String
  id: uuid
  is_public: Boolean
  metadata: jsonb
  title: String
  user_id: uuid
}

"""
Streaming cursor of the table "activity_announcements"
"""
input activity_announcements_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: activity_announcements_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input activity_announcements_stream_cursor_value_input {
  activity_type: String
  agency_id: uuid
  created_at: timestamptz
  description: String
  id: uuid
  is_public: Boolean
  metadata: jsonb
  title: String
  user_id: uuid
}

"""
update columns of table "activity_announcements"
"""
enum activity_announcements_update_column {
  """column name"""
  activity_type

  """column name"""
  agency_id

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  is_public

  """column name"""
  metadata

  """column name"""
  title

  """column name"""
  user_id
}

input activity_announcements_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: activity_announcements_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: activity_announcements_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: activity_announcements_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: activity_announcements_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: activity_announcements_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: activity_announcements_set_input

  """filter the rows which have to be updated"""
  where: activity_announcements_bool_exp!
}

"""Tracks user actions and events throughout the application"""
type activity_log {
  action: String!
  action_type: String!
  created_at: timestamptz
  description: String
  details(
    """JSON select path"""
    path: String
  ): jsonb
  entity_id: uuid
  entity_type: String
  id: uuid!
  ip_address: inet
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  user_agent: String
  user_id: uuid!
}

"""
aggregated selection of "activity_log"
"""
type activity_log_aggregate {
  aggregate: activity_log_aggregate_fields
  nodes: [activity_log!]!
}

"""
aggregate fields of "activity_log"
"""
type activity_log_aggregate_fields {
  count(columns: [activity_log_select_column!], distinct: Boolean): Int!
  max: activity_log_max_fields
  min: activity_log_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input activity_log_append_input {
  details: jsonb
  metadata: jsonb
}

"""
Boolean expression to filter rows from the table "activity_log". All fields are combined with a logical 'AND'.
"""
input activity_log_bool_exp {
  _and: [activity_log_bool_exp!]
  _not: activity_log_bool_exp
  _or: [activity_log_bool_exp!]
  action: String_comparison_exp
  action_type: String_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  details: jsonb_comparison_exp
  entity_id: uuid_comparison_exp
  entity_type: String_comparison_exp
  id: uuid_comparison_exp
  ip_address: inet_comparison_exp
  metadata: jsonb_comparison_exp
  user_agent: String_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "activity_log"
"""
enum activity_log_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  activity_log_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input activity_log_delete_at_path_input {
  details: [String!]
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input activity_log_delete_elem_input {
  details: Int
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input activity_log_delete_key_input {
  details: String
  metadata: String
}

"""
input type for inserting data into table "activity_log"
"""
input activity_log_insert_input {
  action: String
  action_type: String
  created_at: timestamptz
  description: String
  details: jsonb
  entity_id: uuid
  entity_type: String
  id: uuid
  ip_address: inet
  metadata: jsonb
  user_agent: String
  user_id: uuid
}

"""aggregate max on columns"""
type activity_log_max_fields {
  action: String
  action_type: String
  created_at: timestamptz
  description: String
  entity_id: uuid
  entity_type: String
  id: uuid
  user_agent: String
  user_id: uuid
}

"""aggregate min on columns"""
type activity_log_min_fields {
  action: String
  action_type: String
  created_at: timestamptz
  description: String
  entity_id: uuid
  entity_type: String
  id: uuid
  user_agent: String
  user_id: uuid
}

"""
response of any mutation on the table "activity_log"
"""
type activity_log_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [activity_log!]!
}

"""
on_conflict condition type for table "activity_log"
"""
input activity_log_on_conflict {
  constraint: activity_log_constraint!
  update_columns: [activity_log_update_column!]! = []
  where: activity_log_bool_exp
}

"""Ordering options when selecting data from "activity_log"."""
input activity_log_order_by {
  action: order_by
  action_type: order_by
  created_at: order_by
  description: order_by
  details: order_by
  entity_id: order_by
  entity_type: order_by
  id: order_by
  ip_address: order_by
  metadata: order_by
  user_agent: order_by
  user_id: order_by
}

"""primary key columns input for table: activity_log"""
input activity_log_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input activity_log_prepend_input {
  details: jsonb
  metadata: jsonb
}

"""
select columns of table "activity_log"
"""
enum activity_log_select_column {
  """column name"""
  action

  """column name"""
  action_type

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  details

  """column name"""
  entity_id

  """column name"""
  entity_type

  """column name"""
  id

  """column name"""
  ip_address

  """column name"""
  metadata

  """column name"""
  user_agent

  """column name"""
  user_id
}

"""
input type for updating data in table "activity_log"
"""
input activity_log_set_input {
  action: String
  action_type: String
  created_at: timestamptz
  description: String
  details: jsonb
  entity_id: uuid
  entity_type: String
  id: uuid
  ip_address: inet
  metadata: jsonb
  user_agent: String
  user_id: uuid
}

"""
Streaming cursor of the table "activity_log"
"""
input activity_log_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: activity_log_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input activity_log_stream_cursor_value_input {
  action: String
  action_type: String
  created_at: timestamptz
  description: String
  details: jsonb
  entity_id: uuid
  entity_type: String
  id: uuid
  ip_address: inet
  metadata: jsonb
  user_agent: String
  user_id: uuid
}

"""
update columns of table "activity_log"
"""
enum activity_log_update_column {
  """column name"""
  action

  """column name"""
  action_type

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  details

  """column name"""
  entity_id

  """column name"""
  entity_type

  """column name"""
  id

  """column name"""
  ip_address

  """column name"""
  metadata

  """column name"""
  user_agent

  """column name"""
  user_id
}

input activity_log_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: activity_log_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: activity_log_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: activity_log_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: activity_log_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: activity_log_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: activity_log_set_input

  """filter the rows which have to be updated"""
  where: activity_log_bool_exp!
}

"""
columns and relationships of "admin_activity_logs"
"""
type admin_activity_logs {
  action: String!
  admin_id: uuid!

  """An object relationship"""
  admin_user: admin_users!
  created_at: timestamptz
  details(
    """JSON select path"""
    path: String
  ): jsonb
  id: uuid!
  ip_address: inet
  resource_id: String
  resource_type: String!
  user_agent: String
}

"""
aggregated selection of "admin_activity_logs"
"""
type admin_activity_logs_aggregate {
  aggregate: admin_activity_logs_aggregate_fields
  nodes: [admin_activity_logs!]!
}

input admin_activity_logs_aggregate_bool_exp {
  count: admin_activity_logs_aggregate_bool_exp_count
}

input admin_activity_logs_aggregate_bool_exp_count {
  arguments: [admin_activity_logs_select_column!]
  distinct: Boolean
  filter: admin_activity_logs_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "admin_activity_logs"
"""
type admin_activity_logs_aggregate_fields {
  count(columns: [admin_activity_logs_select_column!], distinct: Boolean): Int!
  max: admin_activity_logs_max_fields
  min: admin_activity_logs_min_fields
}

"""
order by aggregate values of table "admin_activity_logs"
"""
input admin_activity_logs_aggregate_order_by {
  count: order_by
  max: admin_activity_logs_max_order_by
  min: admin_activity_logs_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input admin_activity_logs_append_input {
  details: jsonb
}

"""
input type for inserting array relation for remote table "admin_activity_logs"
"""
input admin_activity_logs_arr_rel_insert_input {
  data: [admin_activity_logs_insert_input!]!

  """upsert condition"""
  on_conflict: admin_activity_logs_on_conflict
}

"""
Boolean expression to filter rows from the table "admin_activity_logs". All fields are combined with a logical 'AND'.
"""
input admin_activity_logs_bool_exp {
  _and: [admin_activity_logs_bool_exp!]
  _not: admin_activity_logs_bool_exp
  _or: [admin_activity_logs_bool_exp!]
  action: String_comparison_exp
  admin_id: uuid_comparison_exp
  admin_user: admin_users_bool_exp
  created_at: timestamptz_comparison_exp
  details: jsonb_comparison_exp
  id: uuid_comparison_exp
  ip_address: inet_comparison_exp
  resource_id: String_comparison_exp
  resource_type: String_comparison_exp
  user_agent: String_comparison_exp
}

"""
unique or primary key constraints on table "admin_activity_logs"
"""
enum admin_activity_logs_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  admin_activity_logs_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input admin_activity_logs_delete_at_path_input {
  details: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input admin_activity_logs_delete_elem_input {
  details: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input admin_activity_logs_delete_key_input {
  details: String
}

"""
input type for inserting data into table "admin_activity_logs"
"""
input admin_activity_logs_insert_input {
  action: String
  admin_id: uuid
  admin_user: admin_users_obj_rel_insert_input
  created_at: timestamptz
  details: jsonb
  id: uuid
  ip_address: inet
  resource_id: String
  resource_type: String
  user_agent: String
}

"""aggregate max on columns"""
type admin_activity_logs_max_fields {
  action: String
  admin_id: uuid
  created_at: timestamptz
  id: uuid
  resource_id: String
  resource_type: String
  user_agent: String
}

"""
order by max() on columns of table "admin_activity_logs"
"""
input admin_activity_logs_max_order_by {
  action: order_by
  admin_id: order_by
  created_at: order_by
  id: order_by
  resource_id: order_by
  resource_type: order_by
  user_agent: order_by
}

"""aggregate min on columns"""
type admin_activity_logs_min_fields {
  action: String
  admin_id: uuid
  created_at: timestamptz
  id: uuid
  resource_id: String
  resource_type: String
  user_agent: String
}

"""
order by min() on columns of table "admin_activity_logs"
"""
input admin_activity_logs_min_order_by {
  action: order_by
  admin_id: order_by
  created_at: order_by
  id: order_by
  resource_id: order_by
  resource_type: order_by
  user_agent: order_by
}

"""
response of any mutation on the table "admin_activity_logs"
"""
type admin_activity_logs_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [admin_activity_logs!]!
}

"""
on_conflict condition type for table "admin_activity_logs"
"""
input admin_activity_logs_on_conflict {
  constraint: admin_activity_logs_constraint!
  update_columns: [admin_activity_logs_update_column!]! = []
  where: admin_activity_logs_bool_exp
}

"""Ordering options when selecting data from "admin_activity_logs"."""
input admin_activity_logs_order_by {
  action: order_by
  admin_id: order_by
  admin_user: admin_users_order_by
  created_at: order_by
  details: order_by
  id: order_by
  ip_address: order_by
  resource_id: order_by
  resource_type: order_by
  user_agent: order_by
}

"""primary key columns input for table: admin_activity_logs"""
input admin_activity_logs_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input admin_activity_logs_prepend_input {
  details: jsonb
}

"""
select columns of table "admin_activity_logs"
"""
enum admin_activity_logs_select_column {
  """column name"""
  action

  """column name"""
  admin_id

  """column name"""
  created_at

  """column name"""
  details

  """column name"""
  id

  """column name"""
  ip_address

  """column name"""
  resource_id

  """column name"""
  resource_type

  """column name"""
  user_agent
}

"""
input type for updating data in table "admin_activity_logs"
"""
input admin_activity_logs_set_input {
  action: String
  admin_id: uuid
  created_at: timestamptz
  details: jsonb
  id: uuid
  ip_address: inet
  resource_id: String
  resource_type: String
  user_agent: String
}

"""
Streaming cursor of the table "admin_activity_logs"
"""
input admin_activity_logs_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: admin_activity_logs_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input admin_activity_logs_stream_cursor_value_input {
  action: String
  admin_id: uuid
  created_at: timestamptz
  details: jsonb
  id: uuid
  ip_address: inet
  resource_id: String
  resource_type: String
  user_agent: String
}

"""
update columns of table "admin_activity_logs"
"""
enum admin_activity_logs_update_column {
  """column name"""
  action

  """column name"""
  admin_id

  """column name"""
  created_at

  """column name"""
  details

  """column name"""
  id

  """column name"""
  ip_address

  """column name"""
  resource_id

  """column name"""
  resource_type

  """column name"""
  user_agent
}

input admin_activity_logs_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: admin_activity_logs_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: admin_activity_logs_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: admin_activity_logs_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: admin_activity_logs_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: admin_activity_logs_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: admin_activity_logs_set_input

  """filter the rows which have to be updated"""
  where: admin_activity_logs_bool_exp!
}

scalar admin_role_enum

"""
Boolean expression to compare columns of type "admin_role_enum". All fields are combined with logical 'AND'.
"""
input admin_role_enum_comparison_exp {
  _eq: admin_role_enum
  _gt: admin_role_enum
  _gte: admin_role_enum
  _in: [admin_role_enum!]
  _is_null: Boolean
  _lt: admin_role_enum
  _lte: admin_role_enum
  _neq: admin_role_enum
  _nin: [admin_role_enum!]
}

"""
columns and relationships of "admin_users"
"""
type admin_users {
  """An array relationship"""
  admin_activity_logs(
    """distinct select on columns"""
    distinct_on: [admin_activity_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_activity_logs_order_by!]

    """filter the rows returned"""
    where: admin_activity_logs_bool_exp
  ): [admin_activity_logs!]!

  """An aggregate relationship"""
  admin_activity_logs_aggregate(
    """distinct select on columns"""
    distinct_on: [admin_activity_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_activity_logs_order_by!]

    """filter the rows returned"""
    where: admin_activity_logs_bool_exp
  ): admin_activity_logs_aggregate!

  """An object relationship"""
  admin_user: admin_users

  """An array relationship"""
  admin_users(
    """distinct select on columns"""
    distinct_on: [admin_users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_users_order_by!]

    """filter the rows returned"""
    where: admin_users_bool_exp
  ): [admin_users!]!

  """An aggregate relationship"""
  admin_users_aggregate(
    """distinct select on columns"""
    distinct_on: [admin_users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_users_order_by!]

    """filter the rows returned"""
    where: admin_users_bool_exp
  ): admin_users_aggregate!

  """An array relationship"""
  content_moderation_flags(
    """distinct select on columns"""
    distinct_on: [content_moderation_flags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [content_moderation_flags_order_by!]

    """filter the rows returned"""
    where: content_moderation_flags_bool_exp
  ): [content_moderation_flags!]!

  """An aggregate relationship"""
  content_moderation_flags_aggregate(
    """distinct select on columns"""
    distinct_on: [content_moderation_flags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [content_moderation_flags_order_by!]

    """filter the rows returned"""
    where: content_moderation_flags_bool_exp
  ): content_moderation_flags_aggregate!
  created_at: timestamptz
  created_by: uuid
  department: String
  email: String!
  full_name: String!
  id: uuid!
  is_active: Boolean
  last_login_at: timestamptz
  permissions(
    """JSON select path"""
    path: String
  ): jsonb
  role: admin_role_enum!

  """An array relationship"""
  security_events(
    """distinct select on columns"""
    distinct_on: [security_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [security_events_order_by!]

    """filter the rows returned"""
    where: security_events_bool_exp
  ): [security_events!]!

  """An aggregate relationship"""
  security_events_aggregate(
    """distinct select on columns"""
    distinct_on: [security_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [security_events_order_by!]

    """filter the rows returned"""
    where: security_events_bool_exp
  ): security_events_aggregate!

  """An array relationship"""
  system_settings(
    """distinct select on columns"""
    distinct_on: [system_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [system_settings_order_by!]

    """filter the rows returned"""
    where: system_settings_bool_exp
  ): [system_settings!]!

  """An aggregate relationship"""
  system_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [system_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [system_settings_order_by!]

    """filter the rows returned"""
    where: system_settings_bool_exp
  ): system_settings_aggregate!
  updated_at: timestamptz

  """An object relationship"""
  user: auth_users!

  """An array relationship"""
  video_interviews(
    """distinct select on columns"""
    distinct_on: [video_interviews_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [video_interviews_order_by!]

    """filter the rows returned"""
    where: video_interviews_bool_exp
  ): [video_interviews!]!

  """An aggregate relationship"""
  video_interviews_aggregate(
    """distinct select on columns"""
    distinct_on: [video_interviews_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [video_interviews_order_by!]

    """filter the rows returned"""
    where: video_interviews_bool_exp
  ): video_interviews_aggregate!
}

"""
aggregated selection of "admin_users"
"""
type admin_users_aggregate {
  aggregate: admin_users_aggregate_fields
  nodes: [admin_users!]!
}

input admin_users_aggregate_bool_exp {
  bool_and: admin_users_aggregate_bool_exp_bool_and
  bool_or: admin_users_aggregate_bool_exp_bool_or
  count: admin_users_aggregate_bool_exp_count
}

input admin_users_aggregate_bool_exp_bool_and {
  arguments: admin_users_select_column_admin_users_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: admin_users_bool_exp
  predicate: Boolean_comparison_exp!
}

input admin_users_aggregate_bool_exp_bool_or {
  arguments: admin_users_select_column_admin_users_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: admin_users_bool_exp
  predicate: Boolean_comparison_exp!
}

input admin_users_aggregate_bool_exp_count {
  arguments: [admin_users_select_column!]
  distinct: Boolean
  filter: admin_users_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "admin_users"
"""
type admin_users_aggregate_fields {
  count(columns: [admin_users_select_column!], distinct: Boolean): Int!
  max: admin_users_max_fields
  min: admin_users_min_fields
}

"""
order by aggregate values of table "admin_users"
"""
input admin_users_aggregate_order_by {
  count: order_by
  max: admin_users_max_order_by
  min: admin_users_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input admin_users_append_input {
  permissions: jsonb
}

"""
input type for inserting array relation for remote table "admin_users"
"""
input admin_users_arr_rel_insert_input {
  data: [admin_users_insert_input!]!

  """upsert condition"""
  on_conflict: admin_users_on_conflict
}

"""
Boolean expression to filter rows from the table "admin_users". All fields are combined with a logical 'AND'.
"""
input admin_users_bool_exp {
  _and: [admin_users_bool_exp!]
  _not: admin_users_bool_exp
  _or: [admin_users_bool_exp!]
  admin_activity_logs: admin_activity_logs_bool_exp
  admin_activity_logs_aggregate: admin_activity_logs_aggregate_bool_exp
  admin_user: admin_users_bool_exp
  admin_users: admin_users_bool_exp
  admin_users_aggregate: admin_users_aggregate_bool_exp
  content_moderation_flags: content_moderation_flags_bool_exp
  content_moderation_flags_aggregate: content_moderation_flags_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  created_by: uuid_comparison_exp
  department: String_comparison_exp
  email: String_comparison_exp
  full_name: String_comparison_exp
  id: uuid_comparison_exp
  is_active: Boolean_comparison_exp
  last_login_at: timestamptz_comparison_exp
  permissions: jsonb_comparison_exp
  role: admin_role_enum_comparison_exp
  security_events: security_events_bool_exp
  security_events_aggregate: security_events_aggregate_bool_exp
  system_settings: system_settings_bool_exp
  system_settings_aggregate: system_settings_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
  video_interviews: video_interviews_bool_exp
  video_interviews_aggregate: video_interviews_aggregate_bool_exp
}

"""
unique or primary key constraints on table "admin_users"
"""
enum admin_users_constraint {
  """
  unique or primary key constraint on columns "email"
  """
  admin_users_email_key

  """
  unique or primary key constraint on columns "id"
  """
  admin_users_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input admin_users_delete_at_path_input {
  permissions: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input admin_users_delete_elem_input {
  permissions: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input admin_users_delete_key_input {
  permissions: String
}

"""
input type for inserting data into table "admin_users"
"""
input admin_users_insert_input {
  admin_activity_logs: admin_activity_logs_arr_rel_insert_input
  admin_user: admin_users_obj_rel_insert_input
  admin_users: admin_users_arr_rel_insert_input
  content_moderation_flags: content_moderation_flags_arr_rel_insert_input
  created_at: timestamptz
  created_by: uuid
  department: String
  email: String
  full_name: String
  id: uuid
  is_active: Boolean
  last_login_at: timestamptz
  permissions: jsonb
  role: admin_role_enum
  security_events: security_events_arr_rel_insert_input
  system_settings: system_settings_arr_rel_insert_input
  updated_at: timestamptz
  user: auth_users_obj_rel_insert_input
  video_interviews: video_interviews_arr_rel_insert_input
}

"""aggregate max on columns"""
type admin_users_max_fields {
  created_at: timestamptz
  created_by: uuid
  department: String
  email: String
  full_name: String
  id: uuid
  last_login_at: timestamptz
  role: admin_role_enum
  updated_at: timestamptz
}

"""
order by max() on columns of table "admin_users"
"""
input admin_users_max_order_by {
  created_at: order_by
  created_by: order_by
  department: order_by
  email: order_by
  full_name: order_by
  id: order_by
  last_login_at: order_by
  role: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type admin_users_min_fields {
  created_at: timestamptz
  created_by: uuid
  department: String
  email: String
  full_name: String
  id: uuid
  last_login_at: timestamptz
  role: admin_role_enum
  updated_at: timestamptz
}

"""
order by min() on columns of table "admin_users"
"""
input admin_users_min_order_by {
  created_at: order_by
  created_by: order_by
  department: order_by
  email: order_by
  full_name: order_by
  id: order_by
  last_login_at: order_by
  role: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "admin_users"
"""
type admin_users_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [admin_users!]!
}

"""
input type for inserting object relation for remote table "admin_users"
"""
input admin_users_obj_rel_insert_input {
  data: admin_users_insert_input!

  """upsert condition"""
  on_conflict: admin_users_on_conflict
}

"""
on_conflict condition type for table "admin_users"
"""
input admin_users_on_conflict {
  constraint: admin_users_constraint!
  update_columns: [admin_users_update_column!]! = []
  where: admin_users_bool_exp
}

"""Ordering options when selecting data from "admin_users"."""
input admin_users_order_by {
  admin_activity_logs_aggregate: admin_activity_logs_aggregate_order_by
  admin_user: admin_users_order_by
  admin_users_aggregate: admin_users_aggregate_order_by
  content_moderation_flags_aggregate: content_moderation_flags_aggregate_order_by
  created_at: order_by
  created_by: order_by
  department: order_by
  email: order_by
  full_name: order_by
  id: order_by
  is_active: order_by
  last_login_at: order_by
  permissions: order_by
  role: order_by
  security_events_aggregate: security_events_aggregate_order_by
  system_settings_aggregate: system_settings_aggregate_order_by
  updated_at: order_by
  user: auth_users_order_by
  video_interviews_aggregate: video_interviews_aggregate_order_by
}

"""primary key columns input for table: admin_users"""
input admin_users_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input admin_users_prepend_input {
  permissions: jsonb
}

"""
select columns of table "admin_users"
"""
enum admin_users_select_column {
  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  department

  """column name"""
  email

  """column name"""
  full_name

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  last_login_at

  """column name"""
  permissions

  """column name"""
  role

  """column name"""
  updated_at
}

"""
select "admin_users_aggregate_bool_exp_bool_and_arguments_columns" columns of table "admin_users"
"""
enum admin_users_select_column_admin_users_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_active
}

"""
select "admin_users_aggregate_bool_exp_bool_or_arguments_columns" columns of table "admin_users"
"""
enum admin_users_select_column_admin_users_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_active
}

"""
input type for updating data in table "admin_users"
"""
input admin_users_set_input {
  created_at: timestamptz
  created_by: uuid
  department: String
  email: String
  full_name: String
  id: uuid
  is_active: Boolean
  last_login_at: timestamptz
  permissions: jsonb
  role: admin_role_enum
  updated_at: timestamptz
}

"""
Streaming cursor of the table "admin_users"
"""
input admin_users_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: admin_users_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input admin_users_stream_cursor_value_input {
  created_at: timestamptz
  created_by: uuid
  department: String
  email: String
  full_name: String
  id: uuid
  is_active: Boolean
  last_login_at: timestamptz
  permissions: jsonb
  role: admin_role_enum
  updated_at: timestamptz
}

"""
update columns of table "admin_users"
"""
enum admin_users_update_column {
  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  department

  """column name"""
  email

  """column name"""
  full_name

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  last_login_at

  """column name"""
  permissions

  """column name"""
  role

  """column name"""
  updated_at
}

input admin_users_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: admin_users_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: admin_users_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: admin_users_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: admin_users_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: admin_users_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: admin_users_set_input

  """filter the rows which have to be updated"""
  where: admin_users_bool_exp!
}

"""Audit trail for all agency dashboard actions"""
type agency_audit_logs {
  """Type of action performed"""
  action: String!

  """Agency that owns this audit log entry"""
  agency_id: uuid!
  created_at: timestamptz!

  """JSON object with action-specific details"""
  details(
    """JSON select path"""
    path: String
  ): jsonb

  """Specific entity ID affected (optional)"""
  entity_id: String

  """Type of entity affected by the action"""
  entity_type: String!
  id: uuid!

  """IP address of the client"""
  ip_address: String

  """Browser user agent string"""
  user_agent: String

  """User who performed the action (or system)"""
  user_id: String!
}

"""
aggregated selection of "agency_audit_logs"
"""
type agency_audit_logs_aggregate {
  aggregate: agency_audit_logs_aggregate_fields
  nodes: [agency_audit_logs!]!
}

"""
aggregate fields of "agency_audit_logs"
"""
type agency_audit_logs_aggregate_fields {
  count(columns: [agency_audit_logs_select_column!], distinct: Boolean): Int!
  max: agency_audit_logs_max_fields
  min: agency_audit_logs_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input agency_audit_logs_append_input {
  """JSON object with action-specific details"""
  details: jsonb
}

"""
Boolean expression to filter rows from the table "agency_audit_logs". All fields are combined with a logical 'AND'.
"""
input agency_audit_logs_bool_exp {
  _and: [agency_audit_logs_bool_exp!]
  _not: agency_audit_logs_bool_exp
  _or: [agency_audit_logs_bool_exp!]
  action: String_comparison_exp
  agency_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  details: jsonb_comparison_exp
  entity_id: String_comparison_exp
  entity_type: String_comparison_exp
  id: uuid_comparison_exp
  ip_address: String_comparison_exp
  user_agent: String_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "agency_audit_logs"
"""
enum agency_audit_logs_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  agency_audit_logs_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input agency_audit_logs_delete_at_path_input {
  """JSON object with action-specific details"""
  details: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input agency_audit_logs_delete_elem_input {
  """JSON object with action-specific details"""
  details: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input agency_audit_logs_delete_key_input {
  """JSON object with action-specific details"""
  details: String
}

"""
input type for inserting data into table "agency_audit_logs"
"""
input agency_audit_logs_insert_input {
  """Type of action performed"""
  action: String

  """Agency that owns this audit log entry"""
  agency_id: uuid
  created_at: timestamptz

  """JSON object with action-specific details"""
  details: jsonb

  """Specific entity ID affected (optional)"""
  entity_id: String

  """Type of entity affected by the action"""
  entity_type: String
  id: uuid

  """IP address of the client"""
  ip_address: String

  """Browser user agent string"""
  user_agent: String

  """User who performed the action (or system)"""
  user_id: String
}

"""aggregate max on columns"""
type agency_audit_logs_max_fields {
  """Type of action performed"""
  action: String

  """Agency that owns this audit log entry"""
  agency_id: uuid
  created_at: timestamptz

  """Specific entity ID affected (optional)"""
  entity_id: String

  """Type of entity affected by the action"""
  entity_type: String
  id: uuid

  """IP address of the client"""
  ip_address: String

  """Browser user agent string"""
  user_agent: String

  """User who performed the action (or system)"""
  user_id: String
}

"""aggregate min on columns"""
type agency_audit_logs_min_fields {
  """Type of action performed"""
  action: String

  """Agency that owns this audit log entry"""
  agency_id: uuid
  created_at: timestamptz

  """Specific entity ID affected (optional)"""
  entity_id: String

  """Type of entity affected by the action"""
  entity_type: String
  id: uuid

  """IP address of the client"""
  ip_address: String

  """Browser user agent string"""
  user_agent: String

  """User who performed the action (or system)"""
  user_id: String
}

"""
response of any mutation on the table "agency_audit_logs"
"""
type agency_audit_logs_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [agency_audit_logs!]!
}

"""
on_conflict condition type for table "agency_audit_logs"
"""
input agency_audit_logs_on_conflict {
  constraint: agency_audit_logs_constraint!
  update_columns: [agency_audit_logs_update_column!]! = []
  where: agency_audit_logs_bool_exp
}

"""Ordering options when selecting data from "agency_audit_logs"."""
input agency_audit_logs_order_by {
  action: order_by
  agency_id: order_by
  created_at: order_by
  details: order_by
  entity_id: order_by
  entity_type: order_by
  id: order_by
  ip_address: order_by
  user_agent: order_by
  user_id: order_by
}

"""primary key columns input for table: agency_audit_logs"""
input agency_audit_logs_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input agency_audit_logs_prepend_input {
  """JSON object with action-specific details"""
  details: jsonb
}

"""
select columns of table "agency_audit_logs"
"""
enum agency_audit_logs_select_column {
  """column name"""
  action

  """column name"""
  agency_id

  """column name"""
  created_at

  """column name"""
  details

  """column name"""
  entity_id

  """column name"""
  entity_type

  """column name"""
  id

  """column name"""
  ip_address

  """column name"""
  user_agent

  """column name"""
  user_id
}

"""
input type for updating data in table "agency_audit_logs"
"""
input agency_audit_logs_set_input {
  """Type of action performed"""
  action: String

  """Agency that owns this audit log entry"""
  agency_id: uuid
  created_at: timestamptz

  """JSON object with action-specific details"""
  details: jsonb

  """Specific entity ID affected (optional)"""
  entity_id: String

  """Type of entity affected by the action"""
  entity_type: String
  id: uuid

  """IP address of the client"""
  ip_address: String

  """Browser user agent string"""
  user_agent: String

  """User who performed the action (or system)"""
  user_id: String
}

"""
Streaming cursor of the table "agency_audit_logs"
"""
input agency_audit_logs_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: agency_audit_logs_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input agency_audit_logs_stream_cursor_value_input {
  """Type of action performed"""
  action: String

  """Agency that owns this audit log entry"""
  agency_id: uuid
  created_at: timestamptz

  """JSON object with action-specific details"""
  details: jsonb

  """Specific entity ID affected (optional)"""
  entity_id: String

  """Type of entity affected by the action"""
  entity_type: String
  id: uuid

  """IP address of the client"""
  ip_address: String

  """Browser user agent string"""
  user_agent: String

  """User who performed the action (or system)"""
  user_id: String
}

"""
update columns of table "agency_audit_logs"
"""
enum agency_audit_logs_update_column {
  """column name"""
  action

  """column name"""
  agency_id

  """column name"""
  created_at

  """column name"""
  details

  """column name"""
  entity_id

  """column name"""
  entity_type

  """column name"""
  id

  """column name"""
  ip_address

  """column name"""
  user_agent

  """column name"""
  user_id
}

input agency_audit_logs_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: agency_audit_logs_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: agency_audit_logs_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: agency_audit_logs_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: agency_audit_logs_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: agency_audit_logs_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: agency_audit_logs_set_input

  """filter the rows which have to be updated"""
  where: agency_audit_logs_bool_exp!
}

"""Credit balance per agency from failed placements"""
type agency_credits {
  agency_id: uuid!

  """Automatically use credits for new placements"""
  auto_apply_credits: Boolean

  """Credits ready to be used for next placement"""
  available_credits: numeric!
  created_at: timestamptz
  credit_transactions(
    """JSON select path"""
    path: String
  ): jsonb
  id: uuid!
  last_credit_earned_at: timestamptz
  last_credit_used_at: timestamptz

  """Credits reserved for pending placements"""
  reserved_credits: numeric!
  total_credits: numeric!
  updated_at: timestamptz

  """An object relationship"""
  user: auth_users!
}

"""
aggregated selection of "agency_credits"
"""
type agency_credits_aggregate {
  aggregate: agency_credits_aggregate_fields
  nodes: [agency_credits!]!
}

"""
aggregate fields of "agency_credits"
"""
type agency_credits_aggregate_fields {
  avg: agency_credits_avg_fields
  count(columns: [agency_credits_select_column!], distinct: Boolean): Int!
  max: agency_credits_max_fields
  min: agency_credits_min_fields
  stddev: agency_credits_stddev_fields
  stddev_pop: agency_credits_stddev_pop_fields
  stddev_samp: agency_credits_stddev_samp_fields
  sum: agency_credits_sum_fields
  var_pop: agency_credits_var_pop_fields
  var_samp: agency_credits_var_samp_fields
  variance: agency_credits_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input agency_credits_append_input {
  credit_transactions: jsonb
}

"""aggregate avg on columns"""
type agency_credits_avg_fields {
  """Credits ready to be used for next placement"""
  available_credits: Float

  """Credits reserved for pending placements"""
  reserved_credits: Float
  total_credits: Float
}

"""
Boolean expression to filter rows from the table "agency_credits". All fields are combined with a logical 'AND'.
"""
input agency_credits_bool_exp {
  _and: [agency_credits_bool_exp!]
  _not: agency_credits_bool_exp
  _or: [agency_credits_bool_exp!]
  agency_id: uuid_comparison_exp
  auto_apply_credits: Boolean_comparison_exp
  available_credits: numeric_comparison_exp
  created_at: timestamptz_comparison_exp
  credit_transactions: jsonb_comparison_exp
  id: uuid_comparison_exp
  last_credit_earned_at: timestamptz_comparison_exp
  last_credit_used_at: timestamptz_comparison_exp
  reserved_credits: numeric_comparison_exp
  total_credits: numeric_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
}

"""
unique or primary key constraints on table "agency_credits"
"""
enum agency_credits_constraint {
  """
  unique or primary key constraint on columns "agency_id"
  """
  agency_credits_agency_id_key

  """
  unique or primary key constraint on columns "id"
  """
  agency_credits_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input agency_credits_delete_at_path_input {
  credit_transactions: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input agency_credits_delete_elem_input {
  credit_transactions: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input agency_credits_delete_key_input {
  credit_transactions: String
}

"""
input type for incrementing numeric columns in table "agency_credits"
"""
input agency_credits_inc_input {
  """Credits ready to be used for next placement"""
  available_credits: numeric

  """Credits reserved for pending placements"""
  reserved_credits: numeric
  total_credits: numeric
}

"""
input type for inserting data into table "agency_credits"
"""
input agency_credits_insert_input {
  agency_id: uuid

  """Automatically use credits for new placements"""
  auto_apply_credits: Boolean

  """Credits ready to be used for next placement"""
  available_credits: numeric
  created_at: timestamptz
  credit_transactions: jsonb
  id: uuid
  last_credit_earned_at: timestamptz
  last_credit_used_at: timestamptz

  """Credits reserved for pending placements"""
  reserved_credits: numeric
  total_credits: numeric
  updated_at: timestamptz
  user: auth_users_obj_rel_insert_input
}

"""aggregate max on columns"""
type agency_credits_max_fields {
  agency_id: uuid

  """Credits ready to be used for next placement"""
  available_credits: numeric
  created_at: timestamptz
  id: uuid
  last_credit_earned_at: timestamptz
  last_credit_used_at: timestamptz

  """Credits reserved for pending placements"""
  reserved_credits: numeric
  total_credits: numeric
  updated_at: timestamptz
}

"""aggregate min on columns"""
type agency_credits_min_fields {
  agency_id: uuid

  """Credits ready to be used for next placement"""
  available_credits: numeric
  created_at: timestamptz
  id: uuid
  last_credit_earned_at: timestamptz
  last_credit_used_at: timestamptz

  """Credits reserved for pending placements"""
  reserved_credits: numeric
  total_credits: numeric
  updated_at: timestamptz
}

"""
response of any mutation on the table "agency_credits"
"""
type agency_credits_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [agency_credits!]!
}

"""
on_conflict condition type for table "agency_credits"
"""
input agency_credits_on_conflict {
  constraint: agency_credits_constraint!
  update_columns: [agency_credits_update_column!]! = []
  where: agency_credits_bool_exp
}

"""Ordering options when selecting data from "agency_credits"."""
input agency_credits_order_by {
  agency_id: order_by
  auto_apply_credits: order_by
  available_credits: order_by
  created_at: order_by
  credit_transactions: order_by
  id: order_by
  last_credit_earned_at: order_by
  last_credit_used_at: order_by
  reserved_credits: order_by
  total_credits: order_by
  updated_at: order_by
  user: auth_users_order_by
}

"""primary key columns input for table: agency_credits"""
input agency_credits_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input agency_credits_prepend_input {
  credit_transactions: jsonb
}

"""
select columns of table "agency_credits"
"""
enum agency_credits_select_column {
  """column name"""
  agency_id

  """column name"""
  auto_apply_credits

  """column name"""
  available_credits

  """column name"""
  created_at

  """column name"""
  credit_transactions

  """column name"""
  id

  """column name"""
  last_credit_earned_at

  """column name"""
  last_credit_used_at

  """column name"""
  reserved_credits

  """column name"""
  total_credits

  """column name"""
  updated_at
}

"""
input type for updating data in table "agency_credits"
"""
input agency_credits_set_input {
  agency_id: uuid

  """Automatically use credits for new placements"""
  auto_apply_credits: Boolean

  """Credits ready to be used for next placement"""
  available_credits: numeric
  created_at: timestamptz
  credit_transactions: jsonb
  id: uuid
  last_credit_earned_at: timestamptz
  last_credit_used_at: timestamptz

  """Credits reserved for pending placements"""
  reserved_credits: numeric
  total_credits: numeric
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type agency_credits_stddev_fields {
  """Credits ready to be used for next placement"""
  available_credits: Float

  """Credits reserved for pending placements"""
  reserved_credits: Float
  total_credits: Float
}

"""aggregate stddev_pop on columns"""
type agency_credits_stddev_pop_fields {
  """Credits ready to be used for next placement"""
  available_credits: Float

  """Credits reserved for pending placements"""
  reserved_credits: Float
  total_credits: Float
}

"""aggregate stddev_samp on columns"""
type agency_credits_stddev_samp_fields {
  """Credits ready to be used for next placement"""
  available_credits: Float

  """Credits reserved for pending placements"""
  reserved_credits: Float
  total_credits: Float
}

"""
Streaming cursor of the table "agency_credits"
"""
input agency_credits_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: agency_credits_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input agency_credits_stream_cursor_value_input {
  agency_id: uuid

  """Automatically use credits for new placements"""
  auto_apply_credits: Boolean

  """Credits ready to be used for next placement"""
  available_credits: numeric
  created_at: timestamptz
  credit_transactions: jsonb
  id: uuid
  last_credit_earned_at: timestamptz
  last_credit_used_at: timestamptz

  """Credits reserved for pending placements"""
  reserved_credits: numeric
  total_credits: numeric
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type agency_credits_sum_fields {
  """Credits ready to be used for next placement"""
  available_credits: numeric

  """Credits reserved for pending placements"""
  reserved_credits: numeric
  total_credits: numeric
}

"""
update columns of table "agency_credits"
"""
enum agency_credits_update_column {
  """column name"""
  agency_id

  """column name"""
  auto_apply_credits

  """column name"""
  available_credits

  """column name"""
  created_at

  """column name"""
  credit_transactions

  """column name"""
  id

  """column name"""
  last_credit_earned_at

  """column name"""
  last_credit_used_at

  """column name"""
  reserved_credits

  """column name"""
  total_credits

  """column name"""
  updated_at
}

input agency_credits_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: agency_credits_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: agency_credits_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: agency_credits_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: agency_credits_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: agency_credits_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: agency_credits_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: agency_credits_set_input

  """filter the rows which have to be updated"""
  where: agency_credits_bool_exp!
}

"""aggregate var_pop on columns"""
type agency_credits_var_pop_fields {
  """Credits ready to be used for next placement"""
  available_credits: Float

  """Credits reserved for pending placements"""
  reserved_credits: Float
  total_credits: Float
}

"""aggregate var_samp on columns"""
type agency_credits_var_samp_fields {
  """Credits ready to be used for next placement"""
  available_credits: Float

  """Credits reserved for pending placements"""
  reserved_credits: Float
  total_credits: Float
}

"""aggregate variance on columns"""
type agency_credits_variance_fields {
  """Credits ready to be used for next placement"""
  available_credits: Float

  """Credits reserved for pending placements"""
  reserved_credits: Float
  total_credits: Float
}

"""
columns and relationships of "agency_disputes"
"""
type agency_disputes {
  agency_id: uuid!
  created_at: timestamptz
  description: String!
  dispute_type: String!
  id: uuid!
  priority: String
  related_user_id: uuid
  resolution_notes: String
  resolved_at: timestamptz
  status: String
  title: String!
  updated_at: timestamptz

  """An object relationship"""
  user: auth_users!

  """An object relationship"""
  userByRelatedUserId: auth_users
}

"""
aggregated selection of "agency_disputes"
"""
type agency_disputes_aggregate {
  aggregate: agency_disputes_aggregate_fields
  nodes: [agency_disputes!]!
}

"""
aggregate fields of "agency_disputes"
"""
type agency_disputes_aggregate_fields {
  count(columns: [agency_disputes_select_column!], distinct: Boolean): Int!
  max: agency_disputes_max_fields
  min: agency_disputes_min_fields
}

"""
Boolean expression to filter rows from the table "agency_disputes". All fields are combined with a logical 'AND'.
"""
input agency_disputes_bool_exp {
  _and: [agency_disputes_bool_exp!]
  _not: agency_disputes_bool_exp
  _or: [agency_disputes_bool_exp!]
  agency_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  dispute_type: String_comparison_exp
  id: uuid_comparison_exp
  priority: String_comparison_exp
  related_user_id: uuid_comparison_exp
  resolution_notes: String_comparison_exp
  resolved_at: timestamptz_comparison_exp
  status: String_comparison_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
  userByRelatedUserId: auth_users_bool_exp
}

"""
unique or primary key constraints on table "agency_disputes"
"""
enum agency_disputes_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  agency_disputes_pkey
}

"""
input type for inserting data into table "agency_disputes"
"""
input agency_disputes_insert_input {
  agency_id: uuid
  created_at: timestamptz
  description: String
  dispute_type: String
  id: uuid
  priority: String
  related_user_id: uuid
  resolution_notes: String
  resolved_at: timestamptz
  status: String
  title: String
  updated_at: timestamptz
  user: auth_users_obj_rel_insert_input
  userByRelatedUserId: auth_users_obj_rel_insert_input
}

"""aggregate max on columns"""
type agency_disputes_max_fields {
  agency_id: uuid
  created_at: timestamptz
  description: String
  dispute_type: String
  id: uuid
  priority: String
  related_user_id: uuid
  resolution_notes: String
  resolved_at: timestamptz
  status: String
  title: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type agency_disputes_min_fields {
  agency_id: uuid
  created_at: timestamptz
  description: String
  dispute_type: String
  id: uuid
  priority: String
  related_user_id: uuid
  resolution_notes: String
  resolved_at: timestamptz
  status: String
  title: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "agency_disputes"
"""
type agency_disputes_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [agency_disputes!]!
}

"""
on_conflict condition type for table "agency_disputes"
"""
input agency_disputes_on_conflict {
  constraint: agency_disputes_constraint!
  update_columns: [agency_disputes_update_column!]! = []
  where: agency_disputes_bool_exp
}

"""Ordering options when selecting data from "agency_disputes"."""
input agency_disputes_order_by {
  agency_id: order_by
  created_at: order_by
  description: order_by
  dispute_type: order_by
  id: order_by
  priority: order_by
  related_user_id: order_by
  resolution_notes: order_by
  resolved_at: order_by
  status: order_by
  title: order_by
  updated_at: order_by
  user: auth_users_order_by
  userByRelatedUserId: auth_users_order_by
}

"""primary key columns input for table: agency_disputes"""
input agency_disputes_pk_columns_input {
  id: uuid!
}

"""
select columns of table "agency_disputes"
"""
enum agency_disputes_select_column {
  """column name"""
  agency_id

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  dispute_type

  """column name"""
  id

  """column name"""
  priority

  """column name"""
  related_user_id

  """column name"""
  resolution_notes

  """column name"""
  resolved_at

  """column name"""
  status

  """column name"""
  title

  """column name"""
  updated_at
}

"""
input type for updating data in table "agency_disputes"
"""
input agency_disputes_set_input {
  agency_id: uuid
  created_at: timestamptz
  description: String
  dispute_type: String
  id: uuid
  priority: String
  related_user_id: uuid
  resolution_notes: String
  resolved_at: timestamptz
  status: String
  title: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "agency_disputes"
"""
input agency_disputes_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: agency_disputes_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input agency_disputes_stream_cursor_value_input {
  agency_id: uuid
  created_at: timestamptz
  description: String
  dispute_type: String
  id: uuid
  priority: String
  related_user_id: uuid
  resolution_notes: String
  resolved_at: timestamptz
  status: String
  title: String
  updated_at: timestamptz
}

"""
update columns of table "agency_disputes"
"""
enum agency_disputes_update_column {
  """column name"""
  agency_id

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  dispute_type

  """column name"""
  id

  """column name"""
  priority

  """column name"""
  related_user_id

  """column name"""
  resolution_notes

  """column name"""
  resolved_at

  """column name"""
  status

  """column name"""
  title

  """column name"""
  updated_at
}

input agency_disputes_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: agency_disputes_set_input

  """filter the rows which have to be updated"""
  where: agency_disputes_bool_exp!
}

"""
columns and relationships of "agency_document_requirements"
"""
type agency_document_requirements {
  agency_id: uuid!
  created_at: timestamptz
  description: String
  document_name: String!
  document_type: String!
  due_date: timestamptz
  id: uuid!
  maid_id: uuid
  reviewed_at: timestamptz
  status: String
  submitted_at: timestamptz
  updated_at: timestamptz

  """An object relationship"""
  user: auth_users!

  """An object relationship"""
  userByMaidId: auth_users
}

"""
aggregated selection of "agency_document_requirements"
"""
type agency_document_requirements_aggregate {
  aggregate: agency_document_requirements_aggregate_fields
  nodes: [agency_document_requirements!]!
}

"""
aggregate fields of "agency_document_requirements"
"""
type agency_document_requirements_aggregate_fields {
  count(columns: [agency_document_requirements_select_column!], distinct: Boolean): Int!
  max: agency_document_requirements_max_fields
  min: agency_document_requirements_min_fields
}

"""
Boolean expression to filter rows from the table "agency_document_requirements". All fields are combined with a logical 'AND'.
"""
input agency_document_requirements_bool_exp {
  _and: [agency_document_requirements_bool_exp!]
  _not: agency_document_requirements_bool_exp
  _or: [agency_document_requirements_bool_exp!]
  agency_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  document_name: String_comparison_exp
  document_type: String_comparison_exp
  due_date: timestamptz_comparison_exp
  id: uuid_comparison_exp
  maid_id: uuid_comparison_exp
  reviewed_at: timestamptz_comparison_exp
  status: String_comparison_exp
  submitted_at: timestamptz_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
  userByMaidId: auth_users_bool_exp
}

"""
unique or primary key constraints on table "agency_document_requirements"
"""
enum agency_document_requirements_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  agency_document_requirements_pkey
}

"""
input type for inserting data into table "agency_document_requirements"
"""
input agency_document_requirements_insert_input {
  agency_id: uuid
  created_at: timestamptz
  description: String
  document_name: String
  document_type: String
  due_date: timestamptz
  id: uuid
  maid_id: uuid
  reviewed_at: timestamptz
  status: String
  submitted_at: timestamptz
  updated_at: timestamptz
  user: auth_users_obj_rel_insert_input
  userByMaidId: auth_users_obj_rel_insert_input
}

"""aggregate max on columns"""
type agency_document_requirements_max_fields {
  agency_id: uuid
  created_at: timestamptz
  description: String
  document_name: String
  document_type: String
  due_date: timestamptz
  id: uuid
  maid_id: uuid
  reviewed_at: timestamptz
  status: String
  submitted_at: timestamptz
  updated_at: timestamptz
}

"""aggregate min on columns"""
type agency_document_requirements_min_fields {
  agency_id: uuid
  created_at: timestamptz
  description: String
  document_name: String
  document_type: String
  due_date: timestamptz
  id: uuid
  maid_id: uuid
  reviewed_at: timestamptz
  status: String
  submitted_at: timestamptz
  updated_at: timestamptz
}

"""
response of any mutation on the table "agency_document_requirements"
"""
type agency_document_requirements_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [agency_document_requirements!]!
}

"""
on_conflict condition type for table "agency_document_requirements"
"""
input agency_document_requirements_on_conflict {
  constraint: agency_document_requirements_constraint!
  update_columns: [agency_document_requirements_update_column!]! = []
  where: agency_document_requirements_bool_exp
}

"""
Ordering options when selecting data from "agency_document_requirements".
"""
input agency_document_requirements_order_by {
  agency_id: order_by
  created_at: order_by
  description: order_by
  document_name: order_by
  document_type: order_by
  due_date: order_by
  id: order_by
  maid_id: order_by
  reviewed_at: order_by
  status: order_by
  submitted_at: order_by
  updated_at: order_by
  user: auth_users_order_by
  userByMaidId: auth_users_order_by
}

"""primary key columns input for table: agency_document_requirements"""
input agency_document_requirements_pk_columns_input {
  id: uuid!
}

"""
select columns of table "agency_document_requirements"
"""
enum agency_document_requirements_select_column {
  """column name"""
  agency_id

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  document_name

  """column name"""
  document_type

  """column name"""
  due_date

  """column name"""
  id

  """column name"""
  maid_id

  """column name"""
  reviewed_at

  """column name"""
  status

  """column name"""
  submitted_at

  """column name"""
  updated_at
}

"""
input type for updating data in table "agency_document_requirements"
"""
input agency_document_requirements_set_input {
  agency_id: uuid
  created_at: timestamptz
  description: String
  document_name: String
  document_type: String
  due_date: timestamptz
  id: uuid
  maid_id: uuid
  reviewed_at: timestamptz
  status: String
  submitted_at: timestamptz
  updated_at: timestamptz
}

"""
Streaming cursor of the table "agency_document_requirements"
"""
input agency_document_requirements_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: agency_document_requirements_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input agency_document_requirements_stream_cursor_value_input {
  agency_id: uuid
  created_at: timestamptz
  description: String
  document_name: String
  document_type: String
  due_date: timestamptz
  id: uuid
  maid_id: uuid
  reviewed_at: timestamptz
  status: String
  submitted_at: timestamptz
  updated_at: timestamptz
}

"""
update columns of table "agency_document_requirements"
"""
enum agency_document_requirements_update_column {
  """column name"""
  agency_id

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  document_name

  """column name"""
  document_type

  """column name"""
  due_date

  """column name"""
  id

  """column name"""
  maid_id

  """column name"""
  reviewed_at

  """column name"""
  status

  """column name"""
  submitted_at

  """column name"""
  updated_at
}

input agency_document_requirements_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: agency_document_requirements_set_input

  """filter the rows which have to be updated"""
  where: agency_document_requirements_bool_exp!
}

"""
columns and relationships of "agency_documents"
"""
type agency_documents {
  agency_id: uuid!

  """An array relationship"""
  compliance_items(
    """distinct select on columns"""
    distinct_on: [compliance_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [compliance_items_order_by!]

    """filter the rows returned"""
    where: compliance_items_bool_exp
  ): [compliance_items!]!

  """An aggregate relationship"""
  compliance_items_aggregate(
    """distinct select on columns"""
    distinct_on: [compliance_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [compliance_items_order_by!]

    """filter the rows returned"""
    where: compliance_items_bool_exp
  ): compliance_items_aggregate!
  created_at: timestamptz
  description: String
  document_type: String!
  expires_at: timestamptz
  file_name: String
  file_path: String
  file_size: bigint
  file_url: String
  id: uuid!
  mime_type: String
  notes: String

  "Profile ID from maid_profiles, sponsor_profiles, or agency_profiles (not    \r\n   auth.users)"
  owner_id: uuid
  owner_name: String!
  owner_type: String!
  rejection_reason: String
  status: String
  title: String!
  updated_at: timestamptz
  uploaded_at: timestamptz

  """An object relationship"""
  user: auth_users!
  verification_status: String
  verified_at: timestamptz

  """Agency user ID who verified the document"""
  verified_by_id: uuid
  verified_by_name: String
}

"""
aggregated selection of "agency_documents"
"""
type agency_documents_aggregate {
  aggregate: agency_documents_aggregate_fields
  nodes: [agency_documents!]!
}

"""
aggregate fields of "agency_documents"
"""
type agency_documents_aggregate_fields {
  avg: agency_documents_avg_fields
  count(columns: [agency_documents_select_column!], distinct: Boolean): Int!
  max: agency_documents_max_fields
  min: agency_documents_min_fields
  stddev: agency_documents_stddev_fields
  stddev_pop: agency_documents_stddev_pop_fields
  stddev_samp: agency_documents_stddev_samp_fields
  sum: agency_documents_sum_fields
  var_pop: agency_documents_var_pop_fields
  var_samp: agency_documents_var_samp_fields
  variance: agency_documents_variance_fields
}

"""aggregate avg on columns"""
type agency_documents_avg_fields {
  file_size: Float
}

"""
Boolean expression to filter rows from the table "agency_documents". All fields are combined with a logical 'AND'.
"""
input agency_documents_bool_exp {
  _and: [agency_documents_bool_exp!]
  _not: agency_documents_bool_exp
  _or: [agency_documents_bool_exp!]
  agency_id: uuid_comparison_exp
  compliance_items: compliance_items_bool_exp
  compliance_items_aggregate: compliance_items_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  document_type: String_comparison_exp
  expires_at: timestamptz_comparison_exp
  file_name: String_comparison_exp
  file_path: String_comparison_exp
  file_size: bigint_comparison_exp
  file_url: String_comparison_exp
  id: uuid_comparison_exp
  mime_type: String_comparison_exp
  notes: String_comparison_exp
  owner_id: uuid_comparison_exp
  owner_name: String_comparison_exp
  owner_type: String_comparison_exp
  rejection_reason: String_comparison_exp
  status: String_comparison_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  uploaded_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
  verification_status: String_comparison_exp
  verified_at: timestamptz_comparison_exp
  verified_by_id: uuid_comparison_exp
  verified_by_name: String_comparison_exp
}

"""
unique or primary key constraints on table "agency_documents"
"""
enum agency_documents_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  agency_documents_pkey
}

"""
input type for incrementing numeric columns in table "agency_documents"
"""
input agency_documents_inc_input {
  file_size: bigint
}

"""
input type for inserting data into table "agency_documents"
"""
input agency_documents_insert_input {
  agency_id: uuid
  compliance_items: compliance_items_arr_rel_insert_input
  created_at: timestamptz
  description: String
  document_type: String
  expires_at: timestamptz
  file_name: String
  file_path: String
  file_size: bigint
  file_url: String
  id: uuid
  mime_type: String
  notes: String

  "Profile ID from maid_profiles, sponsor_profiles, or agency_profiles (not    \r\n   auth.users)"
  owner_id: uuid
  owner_name: String
  owner_type: String
  rejection_reason: String
  status: String
  title: String
  updated_at: timestamptz
  uploaded_at: timestamptz
  user: auth_users_obj_rel_insert_input
  verification_status: String
  verified_at: timestamptz

  """Agency user ID who verified the document"""
  verified_by_id: uuid
  verified_by_name: String
}

"""aggregate max on columns"""
type agency_documents_max_fields {
  agency_id: uuid
  created_at: timestamptz
  description: String
  document_type: String
  expires_at: timestamptz
  file_name: String
  file_path: String
  file_size: bigint
  file_url: String
  id: uuid
  mime_type: String
  notes: String

  "Profile ID from maid_profiles, sponsor_profiles, or agency_profiles (not    \r\n   auth.users)"
  owner_id: uuid
  owner_name: String
  owner_type: String
  rejection_reason: String
  status: String
  title: String
  updated_at: timestamptz
  uploaded_at: timestamptz
  verification_status: String
  verified_at: timestamptz

  """Agency user ID who verified the document"""
  verified_by_id: uuid
  verified_by_name: String
}

"""aggregate min on columns"""
type agency_documents_min_fields {
  agency_id: uuid
  created_at: timestamptz
  description: String
  document_type: String
  expires_at: timestamptz
  file_name: String
  file_path: String
  file_size: bigint
  file_url: String
  id: uuid
  mime_type: String
  notes: String

  "Profile ID from maid_profiles, sponsor_profiles, or agency_profiles (not    \r\n   auth.users)"
  owner_id: uuid
  owner_name: String
  owner_type: String
  rejection_reason: String
  status: String
  title: String
  updated_at: timestamptz
  uploaded_at: timestamptz
  verification_status: String
  verified_at: timestamptz

  """Agency user ID who verified the document"""
  verified_by_id: uuid
  verified_by_name: String
}

"""
response of any mutation on the table "agency_documents"
"""
type agency_documents_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [agency_documents!]!
}

"""
input type for inserting object relation for remote table "agency_documents"
"""
input agency_documents_obj_rel_insert_input {
  data: agency_documents_insert_input!

  """upsert condition"""
  on_conflict: agency_documents_on_conflict
}

"""
on_conflict condition type for table "agency_documents"
"""
input agency_documents_on_conflict {
  constraint: agency_documents_constraint!
  update_columns: [agency_documents_update_column!]! = []
  where: agency_documents_bool_exp
}

"""Ordering options when selecting data from "agency_documents"."""
input agency_documents_order_by {
  agency_id: order_by
  compliance_items_aggregate: compliance_items_aggregate_order_by
  created_at: order_by
  description: order_by
  document_type: order_by
  expires_at: order_by
  file_name: order_by
  file_path: order_by
  file_size: order_by
  file_url: order_by
  id: order_by
  mime_type: order_by
  notes: order_by
  owner_id: order_by
  owner_name: order_by
  owner_type: order_by
  rejection_reason: order_by
  status: order_by
  title: order_by
  updated_at: order_by
  uploaded_at: order_by
  user: auth_users_order_by
  verification_status: order_by
  verified_at: order_by
  verified_by_id: order_by
  verified_by_name: order_by
}

"""primary key columns input for table: agency_documents"""
input agency_documents_pk_columns_input {
  id: uuid!
}

"""
select columns of table "agency_documents"
"""
enum agency_documents_select_column {
  """column name"""
  agency_id

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  document_type

  """column name"""
  expires_at

  """column name"""
  file_name

  """column name"""
  file_path

  """column name"""
  file_size

  """column name"""
  file_url

  """column name"""
  id

  """column name"""
  mime_type

  """column name"""
  notes

  """column name"""
  owner_id

  """column name"""
  owner_name

  """column name"""
  owner_type

  """column name"""
  rejection_reason

  """column name"""
  status

  """column name"""
  title

  """column name"""
  updated_at

  """column name"""
  uploaded_at

  """column name"""
  verification_status

  """column name"""
  verified_at

  """column name"""
  verified_by_id

  """column name"""
  verified_by_name
}

"""
input type for updating data in table "agency_documents"
"""
input agency_documents_set_input {
  agency_id: uuid
  created_at: timestamptz
  description: String
  document_type: String
  expires_at: timestamptz
  file_name: String
  file_path: String
  file_size: bigint
  file_url: String
  id: uuid
  mime_type: String
  notes: String

  "Profile ID from maid_profiles, sponsor_profiles, or agency_profiles (not    \r\n   auth.users)"
  owner_id: uuid
  owner_name: String
  owner_type: String
  rejection_reason: String
  status: String
  title: String
  updated_at: timestamptz
  uploaded_at: timestamptz
  verification_status: String
  verified_at: timestamptz

  """Agency user ID who verified the document"""
  verified_by_id: uuid
  verified_by_name: String
}

"""aggregate stddev on columns"""
type agency_documents_stddev_fields {
  file_size: Float
}

"""aggregate stddev_pop on columns"""
type agency_documents_stddev_pop_fields {
  file_size: Float
}

"""aggregate stddev_samp on columns"""
type agency_documents_stddev_samp_fields {
  file_size: Float
}

"""
Streaming cursor of the table "agency_documents"
"""
input agency_documents_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: agency_documents_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input agency_documents_stream_cursor_value_input {
  agency_id: uuid
  created_at: timestamptz
  description: String
  document_type: String
  expires_at: timestamptz
  file_name: String
  file_path: String
  file_size: bigint
  file_url: String
  id: uuid
  mime_type: String
  notes: String

  "Profile ID from maid_profiles, sponsor_profiles, or agency_profiles (not    \r\n   auth.users)"
  owner_id: uuid
  owner_name: String
  owner_type: String
  rejection_reason: String
  status: String
  title: String
  updated_at: timestamptz
  uploaded_at: timestamptz
  verification_status: String
  verified_at: timestamptz

  """Agency user ID who verified the document"""
  verified_by_id: uuid
  verified_by_name: String
}

"""aggregate sum on columns"""
type agency_documents_sum_fields {
  file_size: bigint
}

"""
update columns of table "agency_documents"
"""
enum agency_documents_update_column {
  """column name"""
  agency_id

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  document_type

  """column name"""
  expires_at

  """column name"""
  file_name

  """column name"""
  file_path

  """column name"""
  file_size

  """column name"""
  file_url

  """column name"""
  id

  """column name"""
  mime_type

  """column name"""
  notes

  """column name"""
  owner_id

  """column name"""
  owner_name

  """column name"""
  owner_type

  """column name"""
  rejection_reason

  """column name"""
  status

  """column name"""
  title

  """column name"""
  updated_at

  """column name"""
  uploaded_at

  """column name"""
  verification_status

  """column name"""
  verified_at

  """column name"""
  verified_by_id

  """column name"""
  verified_by_name
}

input agency_documents_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: agency_documents_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: agency_documents_set_input

  """filter the rows which have to be updated"""
  where: agency_documents_bool_exp!
}

"""aggregate var_pop on columns"""
type agency_documents_var_pop_fields {
  file_size: Float
}

"""aggregate var_samp on columns"""
type agency_documents_var_samp_fields {
  file_size: Float
}

"""aggregate variance on columns"""
type agency_documents_variance_fields {
  file_size: Float
}

"""Individual earning records for agencies from various sources"""
type agency_earnings {
  agency_id: uuid!

  """An object relationship"""
  agency_payout: agency_payouts
  amount: numeric!
  available_at: timestamptz
  created_at: timestamptz
  currency: String
  id: uuid!
  maid_id: uuid
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  notes: String
  paid_out_at: timestamptz
  payout_id: uuid
  source_description: String
  source_id: uuid
  source_type: String!
  sponsor_id: uuid
  status: String!
  updated_at: timestamptz

  """An object relationship"""
  user: auth_users!
}

"""
aggregated selection of "agency_earnings"
"""
type agency_earnings_aggregate {
  aggregate: agency_earnings_aggregate_fields
  nodes: [agency_earnings!]!
}

input agency_earnings_aggregate_bool_exp {
  count: agency_earnings_aggregate_bool_exp_count
}

input agency_earnings_aggregate_bool_exp_count {
  arguments: [agency_earnings_select_column!]
  distinct: Boolean
  filter: agency_earnings_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "agency_earnings"
"""
type agency_earnings_aggregate_fields {
  avg: agency_earnings_avg_fields
  count(columns: [agency_earnings_select_column!], distinct: Boolean): Int!
  max: agency_earnings_max_fields
  min: agency_earnings_min_fields
  stddev: agency_earnings_stddev_fields
  stddev_pop: agency_earnings_stddev_pop_fields
  stddev_samp: agency_earnings_stddev_samp_fields
  sum: agency_earnings_sum_fields
  var_pop: agency_earnings_var_pop_fields
  var_samp: agency_earnings_var_samp_fields
  variance: agency_earnings_variance_fields
}

"""
order by aggregate values of table "agency_earnings"
"""
input agency_earnings_aggregate_order_by {
  avg: agency_earnings_avg_order_by
  count: order_by
  max: agency_earnings_max_order_by
  min: agency_earnings_min_order_by
  stddev: agency_earnings_stddev_order_by
  stddev_pop: agency_earnings_stddev_pop_order_by
  stddev_samp: agency_earnings_stddev_samp_order_by
  sum: agency_earnings_sum_order_by
  var_pop: agency_earnings_var_pop_order_by
  var_samp: agency_earnings_var_samp_order_by
  variance: agency_earnings_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input agency_earnings_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "agency_earnings"
"""
input agency_earnings_arr_rel_insert_input {
  data: [agency_earnings_insert_input!]!

  """upsert condition"""
  on_conflict: agency_earnings_on_conflict
}

"""aggregate avg on columns"""
type agency_earnings_avg_fields {
  amount: Float
}

"""
order by avg() on columns of table "agency_earnings"
"""
input agency_earnings_avg_order_by {
  amount: order_by
}

"""
Boolean expression to filter rows from the table "agency_earnings". All fields are combined with a logical 'AND'.
"""
input agency_earnings_bool_exp {
  _and: [agency_earnings_bool_exp!]
  _not: agency_earnings_bool_exp
  _or: [agency_earnings_bool_exp!]
  agency_id: uuid_comparison_exp
  agency_payout: agency_payouts_bool_exp
  amount: numeric_comparison_exp
  available_at: timestamptz_comparison_exp
  created_at: timestamptz_comparison_exp
  currency: String_comparison_exp
  id: uuid_comparison_exp
  maid_id: uuid_comparison_exp
  metadata: jsonb_comparison_exp
  notes: String_comparison_exp
  paid_out_at: timestamptz_comparison_exp
  payout_id: uuid_comparison_exp
  source_description: String_comparison_exp
  source_id: uuid_comparison_exp
  source_type: String_comparison_exp
  sponsor_id: uuid_comparison_exp
  status: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
}

"""
unique or primary key constraints on table "agency_earnings"
"""
enum agency_earnings_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  agency_earnings_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input agency_earnings_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input agency_earnings_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input agency_earnings_delete_key_input {
  metadata: String
}

"""
input type for incrementing numeric columns in table "agency_earnings"
"""
input agency_earnings_inc_input {
  amount: numeric
}

"""
input type for inserting data into table "agency_earnings"
"""
input agency_earnings_insert_input {
  agency_id: uuid
  agency_payout: agency_payouts_obj_rel_insert_input
  amount: numeric
  available_at: timestamptz
  created_at: timestamptz
  currency: String
  id: uuid
  maid_id: uuid
  metadata: jsonb
  notes: String
  paid_out_at: timestamptz
  payout_id: uuid
  source_description: String
  source_id: uuid
  source_type: String
  sponsor_id: uuid
  status: String
  updated_at: timestamptz
  user: auth_users_obj_rel_insert_input
}

"""aggregate max on columns"""
type agency_earnings_max_fields {
  agency_id: uuid
  amount: numeric
  available_at: timestamptz
  created_at: timestamptz
  currency: String
  id: uuid
  maid_id: uuid
  notes: String
  paid_out_at: timestamptz
  payout_id: uuid
  source_description: String
  source_id: uuid
  source_type: String
  sponsor_id: uuid
  status: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "agency_earnings"
"""
input agency_earnings_max_order_by {
  agency_id: order_by
  amount: order_by
  available_at: order_by
  created_at: order_by
  currency: order_by
  id: order_by
  maid_id: order_by
  notes: order_by
  paid_out_at: order_by
  payout_id: order_by
  source_description: order_by
  source_id: order_by
  source_type: order_by
  sponsor_id: order_by
  status: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type agency_earnings_min_fields {
  agency_id: uuid
  amount: numeric
  available_at: timestamptz
  created_at: timestamptz
  currency: String
  id: uuid
  maid_id: uuid
  notes: String
  paid_out_at: timestamptz
  payout_id: uuid
  source_description: String
  source_id: uuid
  source_type: String
  sponsor_id: uuid
  status: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "agency_earnings"
"""
input agency_earnings_min_order_by {
  agency_id: order_by
  amount: order_by
  available_at: order_by
  created_at: order_by
  currency: order_by
  id: order_by
  maid_id: order_by
  notes: order_by
  paid_out_at: order_by
  payout_id: order_by
  source_description: order_by
  source_id: order_by
  source_type: order_by
  sponsor_id: order_by
  status: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "agency_earnings"
"""
type agency_earnings_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [agency_earnings!]!
}

"""
on_conflict condition type for table "agency_earnings"
"""
input agency_earnings_on_conflict {
  constraint: agency_earnings_constraint!
  update_columns: [agency_earnings_update_column!]! = []
  where: agency_earnings_bool_exp
}

"""Ordering options when selecting data from "agency_earnings"."""
input agency_earnings_order_by {
  agency_id: order_by
  agency_payout: agency_payouts_order_by
  amount: order_by
  available_at: order_by
  created_at: order_by
  currency: order_by
  id: order_by
  maid_id: order_by
  metadata: order_by
  notes: order_by
  paid_out_at: order_by
  payout_id: order_by
  source_description: order_by
  source_id: order_by
  source_type: order_by
  sponsor_id: order_by
  status: order_by
  updated_at: order_by
  user: auth_users_order_by
}

"""primary key columns input for table: agency_earnings"""
input agency_earnings_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input agency_earnings_prepend_input {
  metadata: jsonb
}

"""
select columns of table "agency_earnings"
"""
enum agency_earnings_select_column {
  """column name"""
  agency_id

  """column name"""
  amount

  """column name"""
  available_at

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  id

  """column name"""
  maid_id

  """column name"""
  metadata

  """column name"""
  notes

  """column name"""
  paid_out_at

  """column name"""
  payout_id

  """column name"""
  source_description

  """column name"""
  source_id

  """column name"""
  source_type

  """column name"""
  sponsor_id

  """column name"""
  status

  """column name"""
  updated_at
}

"""
input type for updating data in table "agency_earnings"
"""
input agency_earnings_set_input {
  agency_id: uuid
  amount: numeric
  available_at: timestamptz
  created_at: timestamptz
  currency: String
  id: uuid
  maid_id: uuid
  metadata: jsonb
  notes: String
  paid_out_at: timestamptz
  payout_id: uuid
  source_description: String
  source_id: uuid
  source_type: String
  sponsor_id: uuid
  status: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type agency_earnings_stddev_fields {
  amount: Float
}

"""
order by stddev() on columns of table "agency_earnings"
"""
input agency_earnings_stddev_order_by {
  amount: order_by
}

"""aggregate stddev_pop on columns"""
type agency_earnings_stddev_pop_fields {
  amount: Float
}

"""
order by stddev_pop() on columns of table "agency_earnings"
"""
input agency_earnings_stddev_pop_order_by {
  amount: order_by
}

"""aggregate stddev_samp on columns"""
type agency_earnings_stddev_samp_fields {
  amount: Float
}

"""
order by stddev_samp() on columns of table "agency_earnings"
"""
input agency_earnings_stddev_samp_order_by {
  amount: order_by
}

"""
Streaming cursor of the table "agency_earnings"
"""
input agency_earnings_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: agency_earnings_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input agency_earnings_stream_cursor_value_input {
  agency_id: uuid
  amount: numeric
  available_at: timestamptz
  created_at: timestamptz
  currency: String
  id: uuid
  maid_id: uuid
  metadata: jsonb
  notes: String
  paid_out_at: timestamptz
  payout_id: uuid
  source_description: String
  source_id: uuid
  source_type: String
  sponsor_id: uuid
  status: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type agency_earnings_sum_fields {
  amount: numeric
}

"""
order by sum() on columns of table "agency_earnings"
"""
input agency_earnings_sum_order_by {
  amount: order_by
}

"""
update columns of table "agency_earnings"
"""
enum agency_earnings_update_column {
  """column name"""
  agency_id

  """column name"""
  amount

  """column name"""
  available_at

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  id

  """column name"""
  maid_id

  """column name"""
  metadata

  """column name"""
  notes

  """column name"""
  paid_out_at

  """column name"""
  payout_id

  """column name"""
  source_description

  """column name"""
  source_id

  """column name"""
  source_type

  """column name"""
  sponsor_id

  """column name"""
  status

  """column name"""
  updated_at
}

input agency_earnings_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: agency_earnings_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: agency_earnings_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: agency_earnings_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: agency_earnings_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: agency_earnings_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: agency_earnings_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: agency_earnings_set_input

  """filter the rows which have to be updated"""
  where: agency_earnings_bool_exp!
}

"""aggregate var_pop on columns"""
type agency_earnings_var_pop_fields {
  amount: Float
}

"""
order by var_pop() on columns of table "agency_earnings"
"""
input agency_earnings_var_pop_order_by {
  amount: order_by
}

"""aggregate var_samp on columns"""
type agency_earnings_var_samp_fields {
  amount: Float
}

"""
order by var_samp() on columns of table "agency_earnings"
"""
input agency_earnings_var_samp_order_by {
  amount: order_by
}

"""aggregate variance on columns"""
type agency_earnings_variance_fields {
  amount: Float
}

"""
order by variance() on columns of table "agency_earnings"
"""
input agency_earnings_variance_order_by {
  amount: order_by
}

"""
columns and relationships of "agency_interviews"
"""
type agency_interviews {
  agency_id: uuid!

  """An object relationship"""
  agency_job: agency_jobs
  created_at: timestamptz
  duration_minutes: Int
  id: uuid!
  job_id: uuid
  location: String
  maid_id: uuid
  meeting_link: String
  notes: String
  scheduled_date: timestamptz!
  sponsor_id: uuid
  status: String
  updated_at: timestamptz

  """An object relationship"""
  user: auth_users!

  """An object relationship"""
  userByMaidId: auth_users

  """An object relationship"""
  userBySponsorId: auth_users
}

"""
aggregated selection of "agency_interviews"
"""
type agency_interviews_aggregate {
  aggregate: agency_interviews_aggregate_fields
  nodes: [agency_interviews!]!
}

input agency_interviews_aggregate_bool_exp {
  count: agency_interviews_aggregate_bool_exp_count
}

input agency_interviews_aggregate_bool_exp_count {
  arguments: [agency_interviews_select_column!]
  distinct: Boolean
  filter: agency_interviews_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "agency_interviews"
"""
type agency_interviews_aggregate_fields {
  avg: agency_interviews_avg_fields
  count(columns: [agency_interviews_select_column!], distinct: Boolean): Int!
  max: agency_interviews_max_fields
  min: agency_interviews_min_fields
  stddev: agency_interviews_stddev_fields
  stddev_pop: agency_interviews_stddev_pop_fields
  stddev_samp: agency_interviews_stddev_samp_fields
  sum: agency_interviews_sum_fields
  var_pop: agency_interviews_var_pop_fields
  var_samp: agency_interviews_var_samp_fields
  variance: agency_interviews_variance_fields
}

"""
order by aggregate values of table "agency_interviews"
"""
input agency_interviews_aggregate_order_by {
  avg: agency_interviews_avg_order_by
  count: order_by
  max: agency_interviews_max_order_by
  min: agency_interviews_min_order_by
  stddev: agency_interviews_stddev_order_by
  stddev_pop: agency_interviews_stddev_pop_order_by
  stddev_samp: agency_interviews_stddev_samp_order_by
  sum: agency_interviews_sum_order_by
  var_pop: agency_interviews_var_pop_order_by
  var_samp: agency_interviews_var_samp_order_by
  variance: agency_interviews_variance_order_by
}

"""
input type for inserting array relation for remote table "agency_interviews"
"""
input agency_interviews_arr_rel_insert_input {
  data: [agency_interviews_insert_input!]!

  """upsert condition"""
  on_conflict: agency_interviews_on_conflict
}

"""aggregate avg on columns"""
type agency_interviews_avg_fields {
  duration_minutes: Float
}

"""
order by avg() on columns of table "agency_interviews"
"""
input agency_interviews_avg_order_by {
  duration_minutes: order_by
}

"""
Boolean expression to filter rows from the table "agency_interviews". All fields are combined with a logical 'AND'.
"""
input agency_interviews_bool_exp {
  _and: [agency_interviews_bool_exp!]
  _not: agency_interviews_bool_exp
  _or: [agency_interviews_bool_exp!]
  agency_id: uuid_comparison_exp
  agency_job: agency_jobs_bool_exp
  created_at: timestamptz_comparison_exp
  duration_minutes: Int_comparison_exp
  id: uuid_comparison_exp
  job_id: uuid_comparison_exp
  location: String_comparison_exp
  maid_id: uuid_comparison_exp
  meeting_link: String_comparison_exp
  notes: String_comparison_exp
  scheduled_date: timestamptz_comparison_exp
  sponsor_id: uuid_comparison_exp
  status: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
  userByMaidId: auth_users_bool_exp
  userBySponsorId: auth_users_bool_exp
}

"""
unique or primary key constraints on table "agency_interviews"
"""
enum agency_interviews_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  agency_interviews_pkey
}

"""
input type for incrementing numeric columns in table "agency_interviews"
"""
input agency_interviews_inc_input {
  duration_minutes: Int
}

"""
input type for inserting data into table "agency_interviews"
"""
input agency_interviews_insert_input {
  agency_id: uuid
  agency_job: agency_jobs_obj_rel_insert_input
  created_at: timestamptz
  duration_minutes: Int
  id: uuid
  job_id: uuid
  location: String
  maid_id: uuid
  meeting_link: String
  notes: String
  scheduled_date: timestamptz
  sponsor_id: uuid
  status: String
  updated_at: timestamptz
  user: auth_users_obj_rel_insert_input
  userByMaidId: auth_users_obj_rel_insert_input
  userBySponsorId: auth_users_obj_rel_insert_input
}

"""aggregate max on columns"""
type agency_interviews_max_fields {
  agency_id: uuid
  created_at: timestamptz
  duration_minutes: Int
  id: uuid
  job_id: uuid
  location: String
  maid_id: uuid
  meeting_link: String
  notes: String
  scheduled_date: timestamptz
  sponsor_id: uuid
  status: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "agency_interviews"
"""
input agency_interviews_max_order_by {
  agency_id: order_by
  created_at: order_by
  duration_minutes: order_by
  id: order_by
  job_id: order_by
  location: order_by
  maid_id: order_by
  meeting_link: order_by
  notes: order_by
  scheduled_date: order_by
  sponsor_id: order_by
  status: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type agency_interviews_min_fields {
  agency_id: uuid
  created_at: timestamptz
  duration_minutes: Int
  id: uuid
  job_id: uuid
  location: String
  maid_id: uuid
  meeting_link: String
  notes: String
  scheduled_date: timestamptz
  sponsor_id: uuid
  status: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "agency_interviews"
"""
input agency_interviews_min_order_by {
  agency_id: order_by
  created_at: order_by
  duration_minutes: order_by
  id: order_by
  job_id: order_by
  location: order_by
  maid_id: order_by
  meeting_link: order_by
  notes: order_by
  scheduled_date: order_by
  sponsor_id: order_by
  status: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "agency_interviews"
"""
type agency_interviews_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [agency_interviews!]!
}

"""
on_conflict condition type for table "agency_interviews"
"""
input agency_interviews_on_conflict {
  constraint: agency_interviews_constraint!
  update_columns: [agency_interviews_update_column!]! = []
  where: agency_interviews_bool_exp
}

"""Ordering options when selecting data from "agency_interviews"."""
input agency_interviews_order_by {
  agency_id: order_by
  agency_job: agency_jobs_order_by
  created_at: order_by
  duration_minutes: order_by
  id: order_by
  job_id: order_by
  location: order_by
  maid_id: order_by
  meeting_link: order_by
  notes: order_by
  scheduled_date: order_by
  sponsor_id: order_by
  status: order_by
  updated_at: order_by
  user: auth_users_order_by
  userByMaidId: auth_users_order_by
  userBySponsorId: auth_users_order_by
}

"""primary key columns input for table: agency_interviews"""
input agency_interviews_pk_columns_input {
  id: uuid!
}

"""
select columns of table "agency_interviews"
"""
enum agency_interviews_select_column {
  """column name"""
  agency_id

  """column name"""
  created_at

  """column name"""
  duration_minutes

  """column name"""
  id

  """column name"""
  job_id

  """column name"""
  location

  """column name"""
  maid_id

  """column name"""
  meeting_link

  """column name"""
  notes

  """column name"""
  scheduled_date

  """column name"""
  sponsor_id

  """column name"""
  status

  """column name"""
  updated_at
}

"""
input type for updating data in table "agency_interviews"
"""
input agency_interviews_set_input {
  agency_id: uuid
  created_at: timestamptz
  duration_minutes: Int
  id: uuid
  job_id: uuid
  location: String
  maid_id: uuid
  meeting_link: String
  notes: String
  scheduled_date: timestamptz
  sponsor_id: uuid
  status: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type agency_interviews_stddev_fields {
  duration_minutes: Float
}

"""
order by stddev() on columns of table "agency_interviews"
"""
input agency_interviews_stddev_order_by {
  duration_minutes: order_by
}

"""aggregate stddev_pop on columns"""
type agency_interviews_stddev_pop_fields {
  duration_minutes: Float
}

"""
order by stddev_pop() on columns of table "agency_interviews"
"""
input agency_interviews_stddev_pop_order_by {
  duration_minutes: order_by
}

"""aggregate stddev_samp on columns"""
type agency_interviews_stddev_samp_fields {
  duration_minutes: Float
}

"""
order by stddev_samp() on columns of table "agency_interviews"
"""
input agency_interviews_stddev_samp_order_by {
  duration_minutes: order_by
}

"""
Streaming cursor of the table "agency_interviews"
"""
input agency_interviews_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: agency_interviews_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input agency_interviews_stream_cursor_value_input {
  agency_id: uuid
  created_at: timestamptz
  duration_minutes: Int
  id: uuid
  job_id: uuid
  location: String
  maid_id: uuid
  meeting_link: String
  notes: String
  scheduled_date: timestamptz
  sponsor_id: uuid
  status: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type agency_interviews_sum_fields {
  duration_minutes: Int
}

"""
order by sum() on columns of table "agency_interviews"
"""
input agency_interviews_sum_order_by {
  duration_minutes: order_by
}

"""
update columns of table "agency_interviews"
"""
enum agency_interviews_update_column {
  """column name"""
  agency_id

  """column name"""
  created_at

  """column name"""
  duration_minutes

  """column name"""
  id

  """column name"""
  job_id

  """column name"""
  location

  """column name"""
  maid_id

  """column name"""
  meeting_link

  """column name"""
  notes

  """column name"""
  scheduled_date

  """column name"""
  sponsor_id

  """column name"""
  status

  """column name"""
  updated_at
}

input agency_interviews_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: agency_interviews_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: agency_interviews_set_input

  """filter the rows which have to be updated"""
  where: agency_interviews_bool_exp!
}

"""aggregate var_pop on columns"""
type agency_interviews_var_pop_fields {
  duration_minutes: Float
}

"""
order by var_pop() on columns of table "agency_interviews"
"""
input agency_interviews_var_pop_order_by {
  duration_minutes: order_by
}

"""aggregate var_samp on columns"""
type agency_interviews_var_samp_fields {
  duration_minutes: Float
}

"""
order by var_samp() on columns of table "agency_interviews"
"""
input agency_interviews_var_samp_order_by {
  duration_minutes: order_by
}

"""aggregate variance on columns"""
type agency_interviews_variance_fields {
  duration_minutes: Float
}

"""
order by variance() on columns of table "agency_interviews"
"""
input agency_interviews_variance_order_by {
  duration_minutes: order_by
}

"""
columns and relationships of "agency_jobs"
"""
type agency_jobs {
  agency_id: uuid!

  """An array relationship"""
  agency_interviews(
    """distinct select on columns"""
    distinct_on: [agency_interviews_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_interviews_order_by!]

    """filter the rows returned"""
    where: agency_interviews_bool_exp
  ): [agency_interviews!]!

  """An aggregate relationship"""
  agency_interviews_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_interviews_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_interviews_order_by!]

    """filter the rows returned"""
    where: agency_interviews_bool_exp
  ): agency_interviews_aggregate!

  """An array relationship"""
  agency_placements(
    """distinct select on columns"""
    distinct_on: [agency_placements_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_placements_order_by!]

    """filter the rows returned"""
    where: agency_placements_bool_exp
  ): [agency_placements!]!

  """An aggregate relationship"""
  agency_placements_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_placements_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_placements_order_by!]

    """filter the rows returned"""
    where: agency_placements_bool_exp
  ): agency_placements_aggregate!

  """Number of applications received"""
  applicant_count: Int
  benefits: String
  benefits_array: [String!]
  children_count: Int
  contract_duration_months: Int
  created_at: timestamptz
  currency: String
  description: String
  expires_at: timestamptz
  family_size: Int
  filled_date: timestamptz
  id: uuid!

  """Whether job should be featured/promoted"""
  is_featured: Boolean
  job_type: String
  live_in_required: Boolean
  location: String

  """Number of matched candidates from AI/algorithm"""
  matched_count: Int
  posted_date: timestamptz

  """Job priority: low, normal, high, urgent"""
  priority: String

  """Array of required languages"""
  required_languages: [String!]

  """Array of required skills"""
  required_skills: [String!]
  requirements: String
  requirements_array: [String!]
  salary_max: numeric
  salary_min: numeric

  """Optional reference to sponsor who posted the job (if applicable)"""
  sponsor_id: uuid
  status: String
  title: String!
  updated_at: timestamptz

  """An object relationship"""
  user: auth_users!

  """Number of times job has been viewed"""
  view_count: Int
  working_hours: String
}

"""
aggregated selection of "agency_jobs"
"""
type agency_jobs_aggregate {
  aggregate: agency_jobs_aggregate_fields
  nodes: [agency_jobs!]!
}

"""
aggregate fields of "agency_jobs"
"""
type agency_jobs_aggregate_fields {
  avg: agency_jobs_avg_fields
  count(columns: [agency_jobs_select_column!], distinct: Boolean): Int!
  max: agency_jobs_max_fields
  min: agency_jobs_min_fields
  stddev: agency_jobs_stddev_fields
  stddev_pop: agency_jobs_stddev_pop_fields
  stddev_samp: agency_jobs_stddev_samp_fields
  sum: agency_jobs_sum_fields
  var_pop: agency_jobs_var_pop_fields
  var_samp: agency_jobs_var_samp_fields
  variance: agency_jobs_variance_fields
}

"""aggregate avg on columns"""
type agency_jobs_avg_fields {
  """Number of applications received"""
  applicant_count: Float
  children_count: Float
  contract_duration_months: Float
  family_size: Float

  """Number of matched candidates from AI/algorithm"""
  matched_count: Float
  salary_max: Float
  salary_min: Float

  """Number of times job has been viewed"""
  view_count: Float
}

"""
Boolean expression to filter rows from the table "agency_jobs". All fields are combined with a logical 'AND'.
"""
input agency_jobs_bool_exp {
  _and: [agency_jobs_bool_exp!]
  _not: agency_jobs_bool_exp
  _or: [agency_jobs_bool_exp!]
  agency_id: uuid_comparison_exp
  agency_interviews: agency_interviews_bool_exp
  agency_interviews_aggregate: agency_interviews_aggregate_bool_exp
  agency_placements: agency_placements_bool_exp
  agency_placements_aggregate: agency_placements_aggregate_bool_exp
  applicant_count: Int_comparison_exp
  benefits: String_comparison_exp
  benefits_array: String_array_comparison_exp
  children_count: Int_comparison_exp
  contract_duration_months: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  currency: String_comparison_exp
  description: String_comparison_exp
  expires_at: timestamptz_comparison_exp
  family_size: Int_comparison_exp
  filled_date: timestamptz_comparison_exp
  id: uuid_comparison_exp
  is_featured: Boolean_comparison_exp
  job_type: String_comparison_exp
  live_in_required: Boolean_comparison_exp
  location: String_comparison_exp
  matched_count: Int_comparison_exp
  posted_date: timestamptz_comparison_exp
  priority: String_comparison_exp
  required_languages: String_array_comparison_exp
  required_skills: String_array_comparison_exp
  requirements: String_comparison_exp
  requirements_array: String_array_comparison_exp
  salary_max: numeric_comparison_exp
  salary_min: numeric_comparison_exp
  sponsor_id: uuid_comparison_exp
  status: String_comparison_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
  view_count: Int_comparison_exp
  working_hours: String_comparison_exp
}

"""
unique or primary key constraints on table "agency_jobs"
"""
enum agency_jobs_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  agency_jobs_pkey
}

"""
input type for incrementing numeric columns in table "agency_jobs"
"""
input agency_jobs_inc_input {
  """Number of applications received"""
  applicant_count: Int
  children_count: Int
  contract_duration_months: Int
  family_size: Int

  """Number of matched candidates from AI/algorithm"""
  matched_count: Int
  salary_max: numeric
  salary_min: numeric

  """Number of times job has been viewed"""
  view_count: Int
}

"""
input type for inserting data into table "agency_jobs"
"""
input agency_jobs_insert_input {
  agency_id: uuid
  agency_interviews: agency_interviews_arr_rel_insert_input
  agency_placements: agency_placements_arr_rel_insert_input

  """Number of applications received"""
  applicant_count: Int
  benefits: String
  benefits_array: [String!]
  children_count: Int
  contract_duration_months: Int
  created_at: timestamptz
  currency: String
  description: String
  expires_at: timestamptz
  family_size: Int
  filled_date: timestamptz
  id: uuid

  """Whether job should be featured/promoted"""
  is_featured: Boolean
  job_type: String
  live_in_required: Boolean
  location: String

  """Number of matched candidates from AI/algorithm"""
  matched_count: Int
  posted_date: timestamptz

  """Job priority: low, normal, high, urgent"""
  priority: String

  """Array of required languages"""
  required_languages: [String!]

  """Array of required skills"""
  required_skills: [String!]
  requirements: String
  requirements_array: [String!]
  salary_max: numeric
  salary_min: numeric

  """Optional reference to sponsor who posted the job (if applicable)"""
  sponsor_id: uuid
  status: String
  title: String
  updated_at: timestamptz
  user: auth_users_obj_rel_insert_input

  """Number of times job has been viewed"""
  view_count: Int
  working_hours: String
}

"""aggregate max on columns"""
type agency_jobs_max_fields {
  agency_id: uuid

  """Number of applications received"""
  applicant_count: Int
  benefits: String
  benefits_array: [String!]
  children_count: Int
  contract_duration_months: Int
  created_at: timestamptz
  currency: String
  description: String
  expires_at: timestamptz
  family_size: Int
  filled_date: timestamptz
  id: uuid
  job_type: String
  location: String

  """Number of matched candidates from AI/algorithm"""
  matched_count: Int
  posted_date: timestamptz

  """Job priority: low, normal, high, urgent"""
  priority: String

  """Array of required languages"""
  required_languages: [String!]

  """Array of required skills"""
  required_skills: [String!]
  requirements: String
  requirements_array: [String!]
  salary_max: numeric
  salary_min: numeric

  """Optional reference to sponsor who posted the job (if applicable)"""
  sponsor_id: uuid
  status: String
  title: String
  updated_at: timestamptz

  """Number of times job has been viewed"""
  view_count: Int
  working_hours: String
}

"""aggregate min on columns"""
type agency_jobs_min_fields {
  agency_id: uuid

  """Number of applications received"""
  applicant_count: Int
  benefits: String
  benefits_array: [String!]
  children_count: Int
  contract_duration_months: Int
  created_at: timestamptz
  currency: String
  description: String
  expires_at: timestamptz
  family_size: Int
  filled_date: timestamptz
  id: uuid
  job_type: String
  location: String

  """Number of matched candidates from AI/algorithm"""
  matched_count: Int
  posted_date: timestamptz

  """Job priority: low, normal, high, urgent"""
  priority: String

  """Array of required languages"""
  required_languages: [String!]

  """Array of required skills"""
  required_skills: [String!]
  requirements: String
  requirements_array: [String!]
  salary_max: numeric
  salary_min: numeric

  """Optional reference to sponsor who posted the job (if applicable)"""
  sponsor_id: uuid
  status: String
  title: String
  updated_at: timestamptz

  """Number of times job has been viewed"""
  view_count: Int
  working_hours: String
}

"""
response of any mutation on the table "agency_jobs"
"""
type agency_jobs_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [agency_jobs!]!
}

"""
input type for inserting object relation for remote table "agency_jobs"
"""
input agency_jobs_obj_rel_insert_input {
  data: agency_jobs_insert_input!

  """upsert condition"""
  on_conflict: agency_jobs_on_conflict
}

"""
on_conflict condition type for table "agency_jobs"
"""
input agency_jobs_on_conflict {
  constraint: agency_jobs_constraint!
  update_columns: [agency_jobs_update_column!]! = []
  where: agency_jobs_bool_exp
}

"""Ordering options when selecting data from "agency_jobs"."""
input agency_jobs_order_by {
  agency_id: order_by
  agency_interviews_aggregate: agency_interviews_aggregate_order_by
  agency_placements_aggregate: agency_placements_aggregate_order_by
  applicant_count: order_by
  benefits: order_by
  benefits_array: order_by
  children_count: order_by
  contract_duration_months: order_by
  created_at: order_by
  currency: order_by
  description: order_by
  expires_at: order_by
  family_size: order_by
  filled_date: order_by
  id: order_by
  is_featured: order_by
  job_type: order_by
  live_in_required: order_by
  location: order_by
  matched_count: order_by
  posted_date: order_by
  priority: order_by
  required_languages: order_by
  required_skills: order_by
  requirements: order_by
  requirements_array: order_by
  salary_max: order_by
  salary_min: order_by
  sponsor_id: order_by
  status: order_by
  title: order_by
  updated_at: order_by
  user: auth_users_order_by
  view_count: order_by
  working_hours: order_by
}

"""primary key columns input for table: agency_jobs"""
input agency_jobs_pk_columns_input {
  id: uuid!
}

"""
select columns of table "agency_jobs"
"""
enum agency_jobs_select_column {
  """column name"""
  agency_id

  """column name"""
  applicant_count

  """column name"""
  benefits

  """column name"""
  benefits_array

  """column name"""
  children_count

  """column name"""
  contract_duration_months

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  description

  """column name"""
  expires_at

  """column name"""
  family_size

  """column name"""
  filled_date

  """column name"""
  id

  """column name"""
  is_featured

  """column name"""
  job_type

  """column name"""
  live_in_required

  """column name"""
  location

  """column name"""
  matched_count

  """column name"""
  posted_date

  """column name"""
  priority

  """column name"""
  required_languages

  """column name"""
  required_skills

  """column name"""
  requirements

  """column name"""
  requirements_array

  """column name"""
  salary_max

  """column name"""
  salary_min

  """column name"""
  sponsor_id

  """column name"""
  status

  """column name"""
  title

  """column name"""
  updated_at

  """column name"""
  view_count

  """column name"""
  working_hours
}

"""
input type for updating data in table "agency_jobs"
"""
input agency_jobs_set_input {
  agency_id: uuid

  """Number of applications received"""
  applicant_count: Int
  benefits: String
  benefits_array: [String!]
  children_count: Int
  contract_duration_months: Int
  created_at: timestamptz
  currency: String
  description: String
  expires_at: timestamptz
  family_size: Int
  filled_date: timestamptz
  id: uuid

  """Whether job should be featured/promoted"""
  is_featured: Boolean
  job_type: String
  live_in_required: Boolean
  location: String

  """Number of matched candidates from AI/algorithm"""
  matched_count: Int
  posted_date: timestamptz

  """Job priority: low, normal, high, urgent"""
  priority: String

  """Array of required languages"""
  required_languages: [String!]

  """Array of required skills"""
  required_skills: [String!]
  requirements: String
  requirements_array: [String!]
  salary_max: numeric
  salary_min: numeric

  """Optional reference to sponsor who posted the job (if applicable)"""
  sponsor_id: uuid
  status: String
  title: String
  updated_at: timestamptz

  """Number of times job has been viewed"""
  view_count: Int
  working_hours: String
}

"""aggregate stddev on columns"""
type agency_jobs_stddev_fields {
  """Number of applications received"""
  applicant_count: Float
  children_count: Float
  contract_duration_months: Float
  family_size: Float

  """Number of matched candidates from AI/algorithm"""
  matched_count: Float
  salary_max: Float
  salary_min: Float

  """Number of times job has been viewed"""
  view_count: Float
}

"""aggregate stddev_pop on columns"""
type agency_jobs_stddev_pop_fields {
  """Number of applications received"""
  applicant_count: Float
  children_count: Float
  contract_duration_months: Float
  family_size: Float

  """Number of matched candidates from AI/algorithm"""
  matched_count: Float
  salary_max: Float
  salary_min: Float

  """Number of times job has been viewed"""
  view_count: Float
}

"""aggregate stddev_samp on columns"""
type agency_jobs_stddev_samp_fields {
  """Number of applications received"""
  applicant_count: Float
  children_count: Float
  contract_duration_months: Float
  family_size: Float

  """Number of matched candidates from AI/algorithm"""
  matched_count: Float
  salary_max: Float
  salary_min: Float

  """Number of times job has been viewed"""
  view_count: Float
}

"""
Streaming cursor of the table "agency_jobs"
"""
input agency_jobs_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: agency_jobs_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input agency_jobs_stream_cursor_value_input {
  agency_id: uuid

  """Number of applications received"""
  applicant_count: Int
  benefits: String
  benefits_array: [String!]
  children_count: Int
  contract_duration_months: Int
  created_at: timestamptz
  currency: String
  description: String
  expires_at: timestamptz
  family_size: Int
  filled_date: timestamptz
  id: uuid

  """Whether job should be featured/promoted"""
  is_featured: Boolean
  job_type: String
  live_in_required: Boolean
  location: String

  """Number of matched candidates from AI/algorithm"""
  matched_count: Int
  posted_date: timestamptz

  """Job priority: low, normal, high, urgent"""
  priority: String

  """Array of required languages"""
  required_languages: [String!]

  """Array of required skills"""
  required_skills: [String!]
  requirements: String
  requirements_array: [String!]
  salary_max: numeric
  salary_min: numeric

  """Optional reference to sponsor who posted the job (if applicable)"""
  sponsor_id: uuid
  status: String
  title: String
  updated_at: timestamptz

  """Number of times job has been viewed"""
  view_count: Int
  working_hours: String
}

"""aggregate sum on columns"""
type agency_jobs_sum_fields {
  """Number of applications received"""
  applicant_count: Int
  children_count: Int
  contract_duration_months: Int
  family_size: Int

  """Number of matched candidates from AI/algorithm"""
  matched_count: Int
  salary_max: numeric
  salary_min: numeric

  """Number of times job has been viewed"""
  view_count: Int
}

"""
update columns of table "agency_jobs"
"""
enum agency_jobs_update_column {
  """column name"""
  agency_id

  """column name"""
  applicant_count

  """column name"""
  benefits

  """column name"""
  benefits_array

  """column name"""
  children_count

  """column name"""
  contract_duration_months

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  description

  """column name"""
  expires_at

  """column name"""
  family_size

  """column name"""
  filled_date

  """column name"""
  id

  """column name"""
  is_featured

  """column name"""
  job_type

  """column name"""
  live_in_required

  """column name"""
  location

  """column name"""
  matched_count

  """column name"""
  posted_date

  """column name"""
  priority

  """column name"""
  required_languages

  """column name"""
  required_skills

  """column name"""
  requirements

  """column name"""
  requirements_array

  """column name"""
  salary_max

  """column name"""
  salary_min

  """column name"""
  sponsor_id

  """column name"""
  status

  """column name"""
  title

  """column name"""
  updated_at

  """column name"""
  view_count

  """column name"""
  working_hours
}

input agency_jobs_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: agency_jobs_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: agency_jobs_set_input

  """filter the rows which have to be updated"""
  where: agency_jobs_bool_exp!
}

"""aggregate var_pop on columns"""
type agency_jobs_var_pop_fields {
  """Number of applications received"""
  applicant_count: Float
  children_count: Float
  contract_duration_months: Float
  family_size: Float

  """Number of matched candidates from AI/algorithm"""
  matched_count: Float
  salary_max: Float
  salary_min: Float

  """Number of times job has been viewed"""
  view_count: Float
}

"""aggregate var_samp on columns"""
type agency_jobs_var_samp_fields {
  """Number of applications received"""
  applicant_count: Float
  children_count: Float
  contract_duration_months: Float
  family_size: Float

  """Number of matched candidates from AI/algorithm"""
  matched_count: Float
  salary_max: Float
  salary_min: Float

  """Number of times job has been viewed"""
  view_count: Float
}

"""aggregate variance on columns"""
type agency_jobs_variance_fields {
  """Number of applications received"""
  applicant_count: Float
  children_count: Float
  contract_duration_months: Float
  family_size: Float

  """Number of matched candidates from AI/algorithm"""
  matched_count: Float
  salary_max: Float
  salary_min: Float

  """Number of times job has been viewed"""
  view_count: Float
}

"""
columns and relationships of "agency_kyb_audit_log"
"""
type agency_kyb_audit_log {
  action: String!
  agency_id: uuid

  """An object relationship"""
  agency_kyb_verification: agency_kyb_verification
  created_at: timestamptz
  id: uuid!
  kyb_verification_id: uuid
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  new_status: String
  notes: String
  performed_by: uuid
  previous_status: String

  """An object relationship"""
  user: auth_users

  """An object relationship"""
  userByPerformedBy: auth_users
}

"""
aggregated selection of "agency_kyb_audit_log"
"""
type agency_kyb_audit_log_aggregate {
  aggregate: agency_kyb_audit_log_aggregate_fields
  nodes: [agency_kyb_audit_log!]!
}

input agency_kyb_audit_log_aggregate_bool_exp {
  count: agency_kyb_audit_log_aggregate_bool_exp_count
}

input agency_kyb_audit_log_aggregate_bool_exp_count {
  arguments: [agency_kyb_audit_log_select_column!]
  distinct: Boolean
  filter: agency_kyb_audit_log_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "agency_kyb_audit_log"
"""
type agency_kyb_audit_log_aggregate_fields {
  count(columns: [agency_kyb_audit_log_select_column!], distinct: Boolean): Int!
  max: agency_kyb_audit_log_max_fields
  min: agency_kyb_audit_log_min_fields
}

"""
order by aggregate values of table "agency_kyb_audit_log"
"""
input agency_kyb_audit_log_aggregate_order_by {
  count: order_by
  max: agency_kyb_audit_log_max_order_by
  min: agency_kyb_audit_log_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input agency_kyb_audit_log_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "agency_kyb_audit_log"
"""
input agency_kyb_audit_log_arr_rel_insert_input {
  data: [agency_kyb_audit_log_insert_input!]!

  """upsert condition"""
  on_conflict: agency_kyb_audit_log_on_conflict
}

"""
Boolean expression to filter rows from the table "agency_kyb_audit_log". All fields are combined with a logical 'AND'.
"""
input agency_kyb_audit_log_bool_exp {
  _and: [agency_kyb_audit_log_bool_exp!]
  _not: agency_kyb_audit_log_bool_exp
  _or: [agency_kyb_audit_log_bool_exp!]
  action: String_comparison_exp
  agency_id: uuid_comparison_exp
  agency_kyb_verification: agency_kyb_verification_bool_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  kyb_verification_id: uuid_comparison_exp
  metadata: jsonb_comparison_exp
  new_status: String_comparison_exp
  notes: String_comparison_exp
  performed_by: uuid_comparison_exp
  previous_status: String_comparison_exp
  user: auth_users_bool_exp
  userByPerformedBy: auth_users_bool_exp
}

"""
unique or primary key constraints on table "agency_kyb_audit_log"
"""
enum agency_kyb_audit_log_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  agency_kyb_audit_log_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input agency_kyb_audit_log_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input agency_kyb_audit_log_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input agency_kyb_audit_log_delete_key_input {
  metadata: String
}

"""
input type for inserting data into table "agency_kyb_audit_log"
"""
input agency_kyb_audit_log_insert_input {
  action: String
  agency_id: uuid
  agency_kyb_verification: agency_kyb_verification_obj_rel_insert_input
  created_at: timestamptz
  id: uuid
  kyb_verification_id: uuid
  metadata: jsonb
  new_status: String
  notes: String
  performed_by: uuid
  previous_status: String
  user: auth_users_obj_rel_insert_input
  userByPerformedBy: auth_users_obj_rel_insert_input
}

"""aggregate max on columns"""
type agency_kyb_audit_log_max_fields {
  action: String
  agency_id: uuid
  created_at: timestamptz
  id: uuid
  kyb_verification_id: uuid
  new_status: String
  notes: String
  performed_by: uuid
  previous_status: String
}

"""
order by max() on columns of table "agency_kyb_audit_log"
"""
input agency_kyb_audit_log_max_order_by {
  action: order_by
  agency_id: order_by
  created_at: order_by
  id: order_by
  kyb_verification_id: order_by
  new_status: order_by
  notes: order_by
  performed_by: order_by
  previous_status: order_by
}

"""aggregate min on columns"""
type agency_kyb_audit_log_min_fields {
  action: String
  agency_id: uuid
  created_at: timestamptz
  id: uuid
  kyb_verification_id: uuid
  new_status: String
  notes: String
  performed_by: uuid
  previous_status: String
}

"""
order by min() on columns of table "agency_kyb_audit_log"
"""
input agency_kyb_audit_log_min_order_by {
  action: order_by
  agency_id: order_by
  created_at: order_by
  id: order_by
  kyb_verification_id: order_by
  new_status: order_by
  notes: order_by
  performed_by: order_by
  previous_status: order_by
}

"""
response of any mutation on the table "agency_kyb_audit_log"
"""
type agency_kyb_audit_log_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [agency_kyb_audit_log!]!
}

"""
on_conflict condition type for table "agency_kyb_audit_log"
"""
input agency_kyb_audit_log_on_conflict {
  constraint: agency_kyb_audit_log_constraint!
  update_columns: [agency_kyb_audit_log_update_column!]! = []
  where: agency_kyb_audit_log_bool_exp
}

"""Ordering options when selecting data from "agency_kyb_audit_log"."""
input agency_kyb_audit_log_order_by {
  action: order_by
  agency_id: order_by
  agency_kyb_verification: agency_kyb_verification_order_by
  created_at: order_by
  id: order_by
  kyb_verification_id: order_by
  metadata: order_by
  new_status: order_by
  notes: order_by
  performed_by: order_by
  previous_status: order_by
  user: auth_users_order_by
  userByPerformedBy: auth_users_order_by
}

"""primary key columns input for table: agency_kyb_audit_log"""
input agency_kyb_audit_log_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input agency_kyb_audit_log_prepend_input {
  metadata: jsonb
}

"""
select columns of table "agency_kyb_audit_log"
"""
enum agency_kyb_audit_log_select_column {
  """column name"""
  action

  """column name"""
  agency_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  kyb_verification_id

  """column name"""
  metadata

  """column name"""
  new_status

  """column name"""
  notes

  """column name"""
  performed_by

  """column name"""
  previous_status
}

"""
input type for updating data in table "agency_kyb_audit_log"
"""
input agency_kyb_audit_log_set_input {
  action: String
  agency_id: uuid
  created_at: timestamptz
  id: uuid
  kyb_verification_id: uuid
  metadata: jsonb
  new_status: String
  notes: String
  performed_by: uuid
  previous_status: String
}

"""
Streaming cursor of the table "agency_kyb_audit_log"
"""
input agency_kyb_audit_log_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: agency_kyb_audit_log_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input agency_kyb_audit_log_stream_cursor_value_input {
  action: String
  agency_id: uuid
  created_at: timestamptz
  id: uuid
  kyb_verification_id: uuid
  metadata: jsonb
  new_status: String
  notes: String
  performed_by: uuid
  previous_status: String
}

"""
update columns of table "agency_kyb_audit_log"
"""
enum agency_kyb_audit_log_update_column {
  """column name"""
  action

  """column name"""
  agency_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  kyb_verification_id

  """column name"""
  metadata

  """column name"""
  new_status

  """column name"""
  notes

  """column name"""
  performed_by

  """column name"""
  previous_status
}

input agency_kyb_audit_log_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: agency_kyb_audit_log_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: agency_kyb_audit_log_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: agency_kyb_audit_log_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: agency_kyb_audit_log_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: agency_kyb_audit_log_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: agency_kyb_audit_log_set_input

  """filter the rows which have to be updated"""
  where: agency_kyb_audit_log_bool_exp!
}

"""
columns and relationships of "agency_kyb_documents"
"""
type agency_kyb_documents {
  agency_id: uuid

  """An object relationship"""
  agency_kyb_verification: agency_kyb_verification
  document_name: String!
  document_type: String!
  file_hash: String
  file_path: String!
  file_size: Int!
  id: uuid!
  kyb_verification_id: uuid
  mime_type: String!
  updated_at: timestamptz
  uploaded_at: timestamptz

  """An object relationship"""
  user: auth_users

  """An object relationship"""
  userByVerifiedBy: auth_users
  verification_notes: String
  verification_status: String
  verified_at: timestamptz
  verified_by: uuid
}

"""
aggregated selection of "agency_kyb_documents"
"""
type agency_kyb_documents_aggregate {
  aggregate: agency_kyb_documents_aggregate_fields
  nodes: [agency_kyb_documents!]!
}

input agency_kyb_documents_aggregate_bool_exp {
  count: agency_kyb_documents_aggregate_bool_exp_count
}

input agency_kyb_documents_aggregate_bool_exp_count {
  arguments: [agency_kyb_documents_select_column!]
  distinct: Boolean
  filter: agency_kyb_documents_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "agency_kyb_documents"
"""
type agency_kyb_documents_aggregate_fields {
  avg: agency_kyb_documents_avg_fields
  count(columns: [agency_kyb_documents_select_column!], distinct: Boolean): Int!
  max: agency_kyb_documents_max_fields
  min: agency_kyb_documents_min_fields
  stddev: agency_kyb_documents_stddev_fields
  stddev_pop: agency_kyb_documents_stddev_pop_fields
  stddev_samp: agency_kyb_documents_stddev_samp_fields
  sum: agency_kyb_documents_sum_fields
  var_pop: agency_kyb_documents_var_pop_fields
  var_samp: agency_kyb_documents_var_samp_fields
  variance: agency_kyb_documents_variance_fields
}

"""
order by aggregate values of table "agency_kyb_documents"
"""
input agency_kyb_documents_aggregate_order_by {
  avg: agency_kyb_documents_avg_order_by
  count: order_by
  max: agency_kyb_documents_max_order_by
  min: agency_kyb_documents_min_order_by
  stddev: agency_kyb_documents_stddev_order_by
  stddev_pop: agency_kyb_documents_stddev_pop_order_by
  stddev_samp: agency_kyb_documents_stddev_samp_order_by
  sum: agency_kyb_documents_sum_order_by
  var_pop: agency_kyb_documents_var_pop_order_by
  var_samp: agency_kyb_documents_var_samp_order_by
  variance: agency_kyb_documents_variance_order_by
}

"""
input type for inserting array relation for remote table "agency_kyb_documents"
"""
input agency_kyb_documents_arr_rel_insert_input {
  data: [agency_kyb_documents_insert_input!]!

  """upsert condition"""
  on_conflict: agency_kyb_documents_on_conflict
}

"""aggregate avg on columns"""
type agency_kyb_documents_avg_fields {
  file_size: Float
}

"""
order by avg() on columns of table "agency_kyb_documents"
"""
input agency_kyb_documents_avg_order_by {
  file_size: order_by
}

"""
Boolean expression to filter rows from the table "agency_kyb_documents". All fields are combined with a logical 'AND'.
"""
input agency_kyb_documents_bool_exp {
  _and: [agency_kyb_documents_bool_exp!]
  _not: agency_kyb_documents_bool_exp
  _or: [agency_kyb_documents_bool_exp!]
  agency_id: uuid_comparison_exp
  agency_kyb_verification: agency_kyb_verification_bool_exp
  document_name: String_comparison_exp
  document_type: String_comparison_exp
  file_hash: String_comparison_exp
  file_path: String_comparison_exp
  file_size: Int_comparison_exp
  id: uuid_comparison_exp
  kyb_verification_id: uuid_comparison_exp
  mime_type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  uploaded_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
  userByVerifiedBy: auth_users_bool_exp
  verification_notes: String_comparison_exp
  verification_status: String_comparison_exp
  verified_at: timestamptz_comparison_exp
  verified_by: uuid_comparison_exp
}

"""
unique or primary key constraints on table "agency_kyb_documents"
"""
enum agency_kyb_documents_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  agency_kyb_documents_pkey
}

"""
input type for incrementing numeric columns in table "agency_kyb_documents"
"""
input agency_kyb_documents_inc_input {
  file_size: Int
}

"""
input type for inserting data into table "agency_kyb_documents"
"""
input agency_kyb_documents_insert_input {
  agency_id: uuid
  agency_kyb_verification: agency_kyb_verification_obj_rel_insert_input
  document_name: String
  document_type: String
  file_hash: String
  file_path: String
  file_size: Int
  id: uuid
  kyb_verification_id: uuid
  mime_type: String
  updated_at: timestamptz
  uploaded_at: timestamptz
  user: auth_users_obj_rel_insert_input
  userByVerifiedBy: auth_users_obj_rel_insert_input
  verification_notes: String
  verification_status: String
  verified_at: timestamptz
  verified_by: uuid
}

"""aggregate max on columns"""
type agency_kyb_documents_max_fields {
  agency_id: uuid
  document_name: String
  document_type: String
  file_hash: String
  file_path: String
  file_size: Int
  id: uuid
  kyb_verification_id: uuid
  mime_type: String
  updated_at: timestamptz
  uploaded_at: timestamptz
  verification_notes: String
  verification_status: String
  verified_at: timestamptz
  verified_by: uuid
}

"""
order by max() on columns of table "agency_kyb_documents"
"""
input agency_kyb_documents_max_order_by {
  agency_id: order_by
  document_name: order_by
  document_type: order_by
  file_hash: order_by
  file_path: order_by
  file_size: order_by
  id: order_by
  kyb_verification_id: order_by
  mime_type: order_by
  updated_at: order_by
  uploaded_at: order_by
  verification_notes: order_by
  verification_status: order_by
  verified_at: order_by
  verified_by: order_by
}

"""aggregate min on columns"""
type agency_kyb_documents_min_fields {
  agency_id: uuid
  document_name: String
  document_type: String
  file_hash: String
  file_path: String
  file_size: Int
  id: uuid
  kyb_verification_id: uuid
  mime_type: String
  updated_at: timestamptz
  uploaded_at: timestamptz
  verification_notes: String
  verification_status: String
  verified_at: timestamptz
  verified_by: uuid
}

"""
order by min() on columns of table "agency_kyb_documents"
"""
input agency_kyb_documents_min_order_by {
  agency_id: order_by
  document_name: order_by
  document_type: order_by
  file_hash: order_by
  file_path: order_by
  file_size: order_by
  id: order_by
  kyb_verification_id: order_by
  mime_type: order_by
  updated_at: order_by
  uploaded_at: order_by
  verification_notes: order_by
  verification_status: order_by
  verified_at: order_by
  verified_by: order_by
}

"""
response of any mutation on the table "agency_kyb_documents"
"""
type agency_kyb_documents_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [agency_kyb_documents!]!
}

"""
on_conflict condition type for table "agency_kyb_documents"
"""
input agency_kyb_documents_on_conflict {
  constraint: agency_kyb_documents_constraint!
  update_columns: [agency_kyb_documents_update_column!]! = []
  where: agency_kyb_documents_bool_exp
}

"""Ordering options when selecting data from "agency_kyb_documents"."""
input agency_kyb_documents_order_by {
  agency_id: order_by
  agency_kyb_verification: agency_kyb_verification_order_by
  document_name: order_by
  document_type: order_by
  file_hash: order_by
  file_path: order_by
  file_size: order_by
  id: order_by
  kyb_verification_id: order_by
  mime_type: order_by
  updated_at: order_by
  uploaded_at: order_by
  user: auth_users_order_by
  userByVerifiedBy: auth_users_order_by
  verification_notes: order_by
  verification_status: order_by
  verified_at: order_by
  verified_by: order_by
}

"""primary key columns input for table: agency_kyb_documents"""
input agency_kyb_documents_pk_columns_input {
  id: uuid!
}

"""
select columns of table "agency_kyb_documents"
"""
enum agency_kyb_documents_select_column {
  """column name"""
  agency_id

  """column name"""
  document_name

  """column name"""
  document_type

  """column name"""
  file_hash

  """column name"""
  file_path

  """column name"""
  file_size

  """column name"""
  id

  """column name"""
  kyb_verification_id

  """column name"""
  mime_type

  """column name"""
  updated_at

  """column name"""
  uploaded_at

  """column name"""
  verification_notes

  """column name"""
  verification_status

  """column name"""
  verified_at

  """column name"""
  verified_by
}

"""
input type for updating data in table "agency_kyb_documents"
"""
input agency_kyb_documents_set_input {
  agency_id: uuid
  document_name: String
  document_type: String
  file_hash: String
  file_path: String
  file_size: Int
  id: uuid
  kyb_verification_id: uuid
  mime_type: String
  updated_at: timestamptz
  uploaded_at: timestamptz
  verification_notes: String
  verification_status: String
  verified_at: timestamptz
  verified_by: uuid
}

"""aggregate stddev on columns"""
type agency_kyb_documents_stddev_fields {
  file_size: Float
}

"""
order by stddev() on columns of table "agency_kyb_documents"
"""
input agency_kyb_documents_stddev_order_by {
  file_size: order_by
}

"""aggregate stddev_pop on columns"""
type agency_kyb_documents_stddev_pop_fields {
  file_size: Float
}

"""
order by stddev_pop() on columns of table "agency_kyb_documents"
"""
input agency_kyb_documents_stddev_pop_order_by {
  file_size: order_by
}

"""aggregate stddev_samp on columns"""
type agency_kyb_documents_stddev_samp_fields {
  file_size: Float
}

"""
order by stddev_samp() on columns of table "agency_kyb_documents"
"""
input agency_kyb_documents_stddev_samp_order_by {
  file_size: order_by
}

"""
Streaming cursor of the table "agency_kyb_documents"
"""
input agency_kyb_documents_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: agency_kyb_documents_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input agency_kyb_documents_stream_cursor_value_input {
  agency_id: uuid
  document_name: String
  document_type: String
  file_hash: String
  file_path: String
  file_size: Int
  id: uuid
  kyb_verification_id: uuid
  mime_type: String
  updated_at: timestamptz
  uploaded_at: timestamptz
  verification_notes: String
  verification_status: String
  verified_at: timestamptz
  verified_by: uuid
}

"""aggregate sum on columns"""
type agency_kyb_documents_sum_fields {
  file_size: Int
}

"""
order by sum() on columns of table "agency_kyb_documents"
"""
input agency_kyb_documents_sum_order_by {
  file_size: order_by
}

"""
update columns of table "agency_kyb_documents"
"""
enum agency_kyb_documents_update_column {
  """column name"""
  agency_id

  """column name"""
  document_name

  """column name"""
  document_type

  """column name"""
  file_hash

  """column name"""
  file_path

  """column name"""
  file_size

  """column name"""
  id

  """column name"""
  kyb_verification_id

  """column name"""
  mime_type

  """column name"""
  updated_at

  """column name"""
  uploaded_at

  """column name"""
  verification_notes

  """column name"""
  verification_status

  """column name"""
  verified_at

  """column name"""
  verified_by
}

input agency_kyb_documents_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: agency_kyb_documents_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: agency_kyb_documents_set_input

  """filter the rows which have to be updated"""
  where: agency_kyb_documents_bool_exp!
}

"""aggregate var_pop on columns"""
type agency_kyb_documents_var_pop_fields {
  file_size: Float
}

"""
order by var_pop() on columns of table "agency_kyb_documents"
"""
input agency_kyb_documents_var_pop_order_by {
  file_size: order_by
}

"""aggregate var_samp on columns"""
type agency_kyb_documents_var_samp_fields {
  file_size: Float
}

"""
order by var_samp() on columns of table "agency_kyb_documents"
"""
input agency_kyb_documents_var_samp_order_by {
  file_size: order_by
}

"""aggregate variance on columns"""
type agency_kyb_documents_variance_fields {
  file_size: Float
}

"""
order by variance() on columns of table "agency_kyb_documents"
"""
input agency_kyb_documents_variance_order_by {
  file_size: order_by
}

"""
columns and relationships of "agency_kyb_verification"
"""
type agency_kyb_verification {
  agency_id: uuid

  """An array relationship"""
  agency_kyb_audit_logs(
    """distinct select on columns"""
    distinct_on: [agency_kyb_audit_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_kyb_audit_log_order_by!]

    """filter the rows returned"""
    where: agency_kyb_audit_log_bool_exp
  ): [agency_kyb_audit_log!]!

  """An aggregate relationship"""
  agency_kyb_audit_logs_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_kyb_audit_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_kyb_audit_log_order_by!]

    """filter the rows returned"""
    where: agency_kyb_audit_log_bool_exp
  ): agency_kyb_audit_log_aggregate!

  """An array relationship"""
  agency_kyb_documents(
    """distinct select on columns"""
    distinct_on: [agency_kyb_documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_kyb_documents_order_by!]

    """filter the rows returned"""
    where: agency_kyb_documents_bool_exp
  ): [agency_kyb_documents!]!

  """An aggregate relationship"""
  agency_kyb_documents_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_kyb_documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_kyb_documents_order_by!]

    """filter the rows returned"""
    where: agency_kyb_documents_bool_exp
  ): agency_kyb_documents_aggregate!
  annual_turnover_etb: Int
  authorized_capital_etb: Int
  business_address: String!
  business_email: String!
  business_phone: String!
  business_registration_date: date
  business_registration_number: String!
  company_type: String
  contact_person_email: String!
  contact_person_id_number: String
  contact_person_name: String!
  contact_person_phone: String!
  contact_person_position: String!
  created_at: timestamptz
  id: uuid!
  legal_business_name: String!
  number_of_employees: Int
  operating_regions: [String!]
  paid_up_capital_etb: Int
  specialization: [String!]
  tax_identification_number: String
  trade_license_expiry: date!
  trade_license_number: String!
  trading_name: String
  updated_at: timestamptz

  """An object relationship"""
  user: auth_users

  """An object relationship"""
  userByVerifiedBy: auth_users
  verification_notes: String
  verification_status: String
  verified_at: timestamptz
  verified_by: uuid
  website_url: String
  year_established: Int
}

"""
aggregated selection of "agency_kyb_verification"
"""
type agency_kyb_verification_aggregate {
  aggregate: agency_kyb_verification_aggregate_fields
  nodes: [agency_kyb_verification!]!
}

"""
aggregate fields of "agency_kyb_verification"
"""
type agency_kyb_verification_aggregate_fields {
  avg: agency_kyb_verification_avg_fields
  count(columns: [agency_kyb_verification_select_column!], distinct: Boolean): Int!
  max: agency_kyb_verification_max_fields
  min: agency_kyb_verification_min_fields
  stddev: agency_kyb_verification_stddev_fields
  stddev_pop: agency_kyb_verification_stddev_pop_fields
  stddev_samp: agency_kyb_verification_stddev_samp_fields
  sum: agency_kyb_verification_sum_fields
  var_pop: agency_kyb_verification_var_pop_fields
  var_samp: agency_kyb_verification_var_samp_fields
  variance: agency_kyb_verification_variance_fields
}

"""aggregate avg on columns"""
type agency_kyb_verification_avg_fields {
  annual_turnover_etb: Float
  authorized_capital_etb: Float
  number_of_employees: Float
  paid_up_capital_etb: Float
  year_established: Float
}

"""
Boolean expression to filter rows from the table "agency_kyb_verification". All fields are combined with a logical 'AND'.
"""
input agency_kyb_verification_bool_exp {
  _and: [agency_kyb_verification_bool_exp!]
  _not: agency_kyb_verification_bool_exp
  _or: [agency_kyb_verification_bool_exp!]
  agency_id: uuid_comparison_exp
  agency_kyb_audit_logs: agency_kyb_audit_log_bool_exp
  agency_kyb_audit_logs_aggregate: agency_kyb_audit_log_aggregate_bool_exp
  agency_kyb_documents: agency_kyb_documents_bool_exp
  agency_kyb_documents_aggregate: agency_kyb_documents_aggregate_bool_exp
  annual_turnover_etb: Int_comparison_exp
  authorized_capital_etb: Int_comparison_exp
  business_address: String_comparison_exp
  business_email: String_comparison_exp
  business_phone: String_comparison_exp
  business_registration_date: date_comparison_exp
  business_registration_number: String_comparison_exp
  company_type: String_comparison_exp
  contact_person_email: String_comparison_exp
  contact_person_id_number: String_comparison_exp
  contact_person_name: String_comparison_exp
  contact_person_phone: String_comparison_exp
  contact_person_position: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  legal_business_name: String_comparison_exp
  number_of_employees: Int_comparison_exp
  operating_regions: String_array_comparison_exp
  paid_up_capital_etb: Int_comparison_exp
  specialization: String_array_comparison_exp
  tax_identification_number: String_comparison_exp
  trade_license_expiry: date_comparison_exp
  trade_license_number: String_comparison_exp
  trading_name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
  userByVerifiedBy: auth_users_bool_exp
  verification_notes: String_comparison_exp
  verification_status: String_comparison_exp
  verified_at: timestamptz_comparison_exp
  verified_by: uuid_comparison_exp
  website_url: String_comparison_exp
  year_established: Int_comparison_exp
}

"""
unique or primary key constraints on table "agency_kyb_verification"
"""
enum agency_kyb_verification_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  agency_kyb_verification_pkey
}

"""
input type for incrementing numeric columns in table "agency_kyb_verification"
"""
input agency_kyb_verification_inc_input {
  annual_turnover_etb: Int
  authorized_capital_etb: Int
  number_of_employees: Int
  paid_up_capital_etb: Int
  year_established: Int
}

"""
input type for inserting data into table "agency_kyb_verification"
"""
input agency_kyb_verification_insert_input {
  agency_id: uuid
  agency_kyb_audit_logs: agency_kyb_audit_log_arr_rel_insert_input
  agency_kyb_documents: agency_kyb_documents_arr_rel_insert_input
  annual_turnover_etb: Int
  authorized_capital_etb: Int
  business_address: String
  business_email: String
  business_phone: String
  business_registration_date: date
  business_registration_number: String
  company_type: String
  contact_person_email: String
  contact_person_id_number: String
  contact_person_name: String
  contact_person_phone: String
  contact_person_position: String
  created_at: timestamptz
  id: uuid
  legal_business_name: String
  number_of_employees: Int
  operating_regions: [String!]
  paid_up_capital_etb: Int
  specialization: [String!]
  tax_identification_number: String
  trade_license_expiry: date
  trade_license_number: String
  trading_name: String
  updated_at: timestamptz
  user: auth_users_obj_rel_insert_input
  userByVerifiedBy: auth_users_obj_rel_insert_input
  verification_notes: String
  verification_status: String
  verified_at: timestamptz
  verified_by: uuid
  website_url: String
  year_established: Int
}

"""aggregate max on columns"""
type agency_kyb_verification_max_fields {
  agency_id: uuid
  annual_turnover_etb: Int
  authorized_capital_etb: Int
  business_address: String
  business_email: String
  business_phone: String
  business_registration_date: date
  business_registration_number: String
  company_type: String
  contact_person_email: String
  contact_person_id_number: String
  contact_person_name: String
  contact_person_phone: String
  contact_person_position: String
  created_at: timestamptz
  id: uuid
  legal_business_name: String
  number_of_employees: Int
  operating_regions: [String!]
  paid_up_capital_etb: Int
  specialization: [String!]
  tax_identification_number: String
  trade_license_expiry: date
  trade_license_number: String
  trading_name: String
  updated_at: timestamptz
  verification_notes: String
  verification_status: String
  verified_at: timestamptz
  verified_by: uuid
  website_url: String
  year_established: Int
}

"""aggregate min on columns"""
type agency_kyb_verification_min_fields {
  agency_id: uuid
  annual_turnover_etb: Int
  authorized_capital_etb: Int
  business_address: String
  business_email: String
  business_phone: String
  business_registration_date: date
  business_registration_number: String
  company_type: String
  contact_person_email: String
  contact_person_id_number: String
  contact_person_name: String
  contact_person_phone: String
  contact_person_position: String
  created_at: timestamptz
  id: uuid
  legal_business_name: String
  number_of_employees: Int
  operating_regions: [String!]
  paid_up_capital_etb: Int
  specialization: [String!]
  tax_identification_number: String
  trade_license_expiry: date
  trade_license_number: String
  trading_name: String
  updated_at: timestamptz
  verification_notes: String
  verification_status: String
  verified_at: timestamptz
  verified_by: uuid
  website_url: String
  year_established: Int
}

"""
response of any mutation on the table "agency_kyb_verification"
"""
type agency_kyb_verification_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [agency_kyb_verification!]!
}

"""
input type for inserting object relation for remote table "agency_kyb_verification"
"""
input agency_kyb_verification_obj_rel_insert_input {
  data: agency_kyb_verification_insert_input!

  """upsert condition"""
  on_conflict: agency_kyb_verification_on_conflict
}

"""
on_conflict condition type for table "agency_kyb_verification"
"""
input agency_kyb_verification_on_conflict {
  constraint: agency_kyb_verification_constraint!
  update_columns: [agency_kyb_verification_update_column!]! = []
  where: agency_kyb_verification_bool_exp
}

"""Ordering options when selecting data from "agency_kyb_verification"."""
input agency_kyb_verification_order_by {
  agency_id: order_by
  agency_kyb_audit_logs_aggregate: agency_kyb_audit_log_aggregate_order_by
  agency_kyb_documents_aggregate: agency_kyb_documents_aggregate_order_by
  annual_turnover_etb: order_by
  authorized_capital_etb: order_by
  business_address: order_by
  business_email: order_by
  business_phone: order_by
  business_registration_date: order_by
  business_registration_number: order_by
  company_type: order_by
  contact_person_email: order_by
  contact_person_id_number: order_by
  contact_person_name: order_by
  contact_person_phone: order_by
  contact_person_position: order_by
  created_at: order_by
  id: order_by
  legal_business_name: order_by
  number_of_employees: order_by
  operating_regions: order_by
  paid_up_capital_etb: order_by
  specialization: order_by
  tax_identification_number: order_by
  trade_license_expiry: order_by
  trade_license_number: order_by
  trading_name: order_by
  updated_at: order_by
  user: auth_users_order_by
  userByVerifiedBy: auth_users_order_by
  verification_notes: order_by
  verification_status: order_by
  verified_at: order_by
  verified_by: order_by
  website_url: order_by
  year_established: order_by
}

"""primary key columns input for table: agency_kyb_verification"""
input agency_kyb_verification_pk_columns_input {
  id: uuid!
}

"""
select columns of table "agency_kyb_verification"
"""
enum agency_kyb_verification_select_column {
  """column name"""
  agency_id

  """column name"""
  annual_turnover_etb

  """column name"""
  authorized_capital_etb

  """column name"""
  business_address

  """column name"""
  business_email

  """column name"""
  business_phone

  """column name"""
  business_registration_date

  """column name"""
  business_registration_number

  """column name"""
  company_type

  """column name"""
  contact_person_email

  """column name"""
  contact_person_id_number

  """column name"""
  contact_person_name

  """column name"""
  contact_person_phone

  """column name"""
  contact_person_position

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  legal_business_name

  """column name"""
  number_of_employees

  """column name"""
  operating_regions

  """column name"""
  paid_up_capital_etb

  """column name"""
  specialization

  """column name"""
  tax_identification_number

  """column name"""
  trade_license_expiry

  """column name"""
  trade_license_number

  """column name"""
  trading_name

  """column name"""
  updated_at

  """column name"""
  verification_notes

  """column name"""
  verification_status

  """column name"""
  verified_at

  """column name"""
  verified_by

  """column name"""
  website_url

  """column name"""
  year_established
}

"""
input type for updating data in table "agency_kyb_verification"
"""
input agency_kyb_verification_set_input {
  agency_id: uuid
  annual_turnover_etb: Int
  authorized_capital_etb: Int
  business_address: String
  business_email: String
  business_phone: String
  business_registration_date: date
  business_registration_number: String
  company_type: String
  contact_person_email: String
  contact_person_id_number: String
  contact_person_name: String
  contact_person_phone: String
  contact_person_position: String
  created_at: timestamptz
  id: uuid
  legal_business_name: String
  number_of_employees: Int
  operating_regions: [String!]
  paid_up_capital_etb: Int
  specialization: [String!]
  tax_identification_number: String
  trade_license_expiry: date
  trade_license_number: String
  trading_name: String
  updated_at: timestamptz
  verification_notes: String
  verification_status: String
  verified_at: timestamptz
  verified_by: uuid
  website_url: String
  year_established: Int
}

"""aggregate stddev on columns"""
type agency_kyb_verification_stddev_fields {
  annual_turnover_etb: Float
  authorized_capital_etb: Float
  number_of_employees: Float
  paid_up_capital_etb: Float
  year_established: Float
}

"""aggregate stddev_pop on columns"""
type agency_kyb_verification_stddev_pop_fields {
  annual_turnover_etb: Float
  authorized_capital_etb: Float
  number_of_employees: Float
  paid_up_capital_etb: Float
  year_established: Float
}

"""aggregate stddev_samp on columns"""
type agency_kyb_verification_stddev_samp_fields {
  annual_turnover_etb: Float
  authorized_capital_etb: Float
  number_of_employees: Float
  paid_up_capital_etb: Float
  year_established: Float
}

"""
Streaming cursor of the table "agency_kyb_verification"
"""
input agency_kyb_verification_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: agency_kyb_verification_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input agency_kyb_verification_stream_cursor_value_input {
  agency_id: uuid
  annual_turnover_etb: Int
  authorized_capital_etb: Int
  business_address: String
  business_email: String
  business_phone: String
  business_registration_date: date
  business_registration_number: String
  company_type: String
  contact_person_email: String
  contact_person_id_number: String
  contact_person_name: String
  contact_person_phone: String
  contact_person_position: String
  created_at: timestamptz
  id: uuid
  legal_business_name: String
  number_of_employees: Int
  operating_regions: [String!]
  paid_up_capital_etb: Int
  specialization: [String!]
  tax_identification_number: String
  trade_license_expiry: date
  trade_license_number: String
  trading_name: String
  updated_at: timestamptz
  verification_notes: String
  verification_status: String
  verified_at: timestamptz
  verified_by: uuid
  website_url: String
  year_established: Int
}

"""aggregate sum on columns"""
type agency_kyb_verification_sum_fields {
  annual_turnover_etb: Int
  authorized_capital_etb: Int
  number_of_employees: Int
  paid_up_capital_etb: Int
  year_established: Int
}

"""
update columns of table "agency_kyb_verification"
"""
enum agency_kyb_verification_update_column {
  """column name"""
  agency_id

  """column name"""
  annual_turnover_etb

  """column name"""
  authorized_capital_etb

  """column name"""
  business_address

  """column name"""
  business_email

  """column name"""
  business_phone

  """column name"""
  business_registration_date

  """column name"""
  business_registration_number

  """column name"""
  company_type

  """column name"""
  contact_person_email

  """column name"""
  contact_person_id_number

  """column name"""
  contact_person_name

  """column name"""
  contact_person_phone

  """column name"""
  contact_person_position

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  legal_business_name

  """column name"""
  number_of_employees

  """column name"""
  operating_regions

  """column name"""
  paid_up_capital_etb

  """column name"""
  specialization

  """column name"""
  tax_identification_number

  """column name"""
  trade_license_expiry

  """column name"""
  trade_license_number

  """column name"""
  trading_name

  """column name"""
  updated_at

  """column name"""
  verification_notes

  """column name"""
  verification_status

  """column name"""
  verified_at

  """column name"""
  verified_by

  """column name"""
  website_url

  """column name"""
  year_established
}

input agency_kyb_verification_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: agency_kyb_verification_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: agency_kyb_verification_set_input

  """filter the rows which have to be updated"""
  where: agency_kyb_verification_bool_exp!
}

"""aggregate var_pop on columns"""
type agency_kyb_verification_var_pop_fields {
  annual_turnover_etb: Float
  authorized_capital_etb: Float
  number_of_employees: Float
  paid_up_capital_etb: Float
  year_established: Float
}

"""aggregate var_samp on columns"""
type agency_kyb_verification_var_samp_fields {
  annual_turnover_etb: Float
  authorized_capital_etb: Float
  number_of_employees: Float
  paid_up_capital_etb: Float
  year_established: Float
}

"""aggregate variance on columns"""
type agency_kyb_verification_variance_fields {
  annual_turnover_etb: Float
  authorized_capital_etb: Float
  number_of_employees: Float
  paid_up_capital_etb: Float
  year_established: Float
}

"""
columns and relationships of "agency_payment_failures"
"""
type agency_payment_failures {
  agency_id: uuid!
  amount: numeric!
  created_at: timestamptz
  currency: String
  failure_reason: String
  id: uuid!
  resolved: Boolean
  resolved_at: timestamptz
  stripe_payment_intent_id: String
  subscription_id: uuid
  updated_at: timestamptz

  """An object relationship"""
  user: auth_users!
}

"""
aggregated selection of "agency_payment_failures"
"""
type agency_payment_failures_aggregate {
  aggregate: agency_payment_failures_aggregate_fields
  nodes: [agency_payment_failures!]!
}

"""
aggregate fields of "agency_payment_failures"
"""
type agency_payment_failures_aggregate_fields {
  avg: agency_payment_failures_avg_fields
  count(columns: [agency_payment_failures_select_column!], distinct: Boolean): Int!
  max: agency_payment_failures_max_fields
  min: agency_payment_failures_min_fields
  stddev: agency_payment_failures_stddev_fields
  stddev_pop: agency_payment_failures_stddev_pop_fields
  stddev_samp: agency_payment_failures_stddev_samp_fields
  sum: agency_payment_failures_sum_fields
  var_pop: agency_payment_failures_var_pop_fields
  var_samp: agency_payment_failures_var_samp_fields
  variance: agency_payment_failures_variance_fields
}

"""aggregate avg on columns"""
type agency_payment_failures_avg_fields {
  amount: Float
}

"""
Boolean expression to filter rows from the table "agency_payment_failures". All fields are combined with a logical 'AND'.
"""
input agency_payment_failures_bool_exp {
  _and: [agency_payment_failures_bool_exp!]
  _not: agency_payment_failures_bool_exp
  _or: [agency_payment_failures_bool_exp!]
  agency_id: uuid_comparison_exp
  amount: numeric_comparison_exp
  created_at: timestamptz_comparison_exp
  currency: String_comparison_exp
  failure_reason: String_comparison_exp
  id: uuid_comparison_exp
  resolved: Boolean_comparison_exp
  resolved_at: timestamptz_comparison_exp
  stripe_payment_intent_id: String_comparison_exp
  subscription_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
}

"""
unique or primary key constraints on table "agency_payment_failures"
"""
enum agency_payment_failures_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  agency_payment_failures_pkey
}

"""
input type for incrementing numeric columns in table "agency_payment_failures"
"""
input agency_payment_failures_inc_input {
  amount: numeric
}

"""
input type for inserting data into table "agency_payment_failures"
"""
input agency_payment_failures_insert_input {
  agency_id: uuid
  amount: numeric
  created_at: timestamptz
  currency: String
  failure_reason: String
  id: uuid
  resolved: Boolean
  resolved_at: timestamptz
  stripe_payment_intent_id: String
  subscription_id: uuid
  updated_at: timestamptz
  user: auth_users_obj_rel_insert_input
}

"""aggregate max on columns"""
type agency_payment_failures_max_fields {
  agency_id: uuid
  amount: numeric
  created_at: timestamptz
  currency: String
  failure_reason: String
  id: uuid
  resolved_at: timestamptz
  stripe_payment_intent_id: String
  subscription_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type agency_payment_failures_min_fields {
  agency_id: uuid
  amount: numeric
  created_at: timestamptz
  currency: String
  failure_reason: String
  id: uuid
  resolved_at: timestamptz
  stripe_payment_intent_id: String
  subscription_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "agency_payment_failures"
"""
type agency_payment_failures_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [agency_payment_failures!]!
}

"""
on_conflict condition type for table "agency_payment_failures"
"""
input agency_payment_failures_on_conflict {
  constraint: agency_payment_failures_constraint!
  update_columns: [agency_payment_failures_update_column!]! = []
  where: agency_payment_failures_bool_exp
}

"""Ordering options when selecting data from "agency_payment_failures"."""
input agency_payment_failures_order_by {
  agency_id: order_by
  amount: order_by
  created_at: order_by
  currency: order_by
  failure_reason: order_by
  id: order_by
  resolved: order_by
  resolved_at: order_by
  stripe_payment_intent_id: order_by
  subscription_id: order_by
  updated_at: order_by
  user: auth_users_order_by
}

"""primary key columns input for table: agency_payment_failures"""
input agency_payment_failures_pk_columns_input {
  id: uuid!
}

"""
select columns of table "agency_payment_failures"
"""
enum agency_payment_failures_select_column {
  """column name"""
  agency_id

  """column name"""
  amount

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  failure_reason

  """column name"""
  id

  """column name"""
  resolved

  """column name"""
  resolved_at

  """column name"""
  stripe_payment_intent_id

  """column name"""
  subscription_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "agency_payment_failures"
"""
input agency_payment_failures_set_input {
  agency_id: uuid
  amount: numeric
  created_at: timestamptz
  currency: String
  failure_reason: String
  id: uuid
  resolved: Boolean
  resolved_at: timestamptz
  stripe_payment_intent_id: String
  subscription_id: uuid
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type agency_payment_failures_stddev_fields {
  amount: Float
}

"""aggregate stddev_pop on columns"""
type agency_payment_failures_stddev_pop_fields {
  amount: Float
}

"""aggregate stddev_samp on columns"""
type agency_payment_failures_stddev_samp_fields {
  amount: Float
}

"""
Streaming cursor of the table "agency_payment_failures"
"""
input agency_payment_failures_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: agency_payment_failures_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input agency_payment_failures_stream_cursor_value_input {
  agency_id: uuid
  amount: numeric
  created_at: timestamptz
  currency: String
  failure_reason: String
  id: uuid
  resolved: Boolean
  resolved_at: timestamptz
  stripe_payment_intent_id: String
  subscription_id: uuid
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type agency_payment_failures_sum_fields {
  amount: numeric
}

"""
update columns of table "agency_payment_failures"
"""
enum agency_payment_failures_update_column {
  """column name"""
  agency_id

  """column name"""
  amount

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  failure_reason

  """column name"""
  id

  """column name"""
  resolved

  """column name"""
  resolved_at

  """column name"""
  stripe_payment_intent_id

  """column name"""
  subscription_id

  """column name"""
  updated_at
}

input agency_payment_failures_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: agency_payment_failures_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: agency_payment_failures_set_input

  """filter the rows which have to be updated"""
  where: agency_payment_failures_bool_exp!
}

"""aggregate var_pop on columns"""
type agency_payment_failures_var_pop_fields {
  amount: Float
}

"""aggregate var_samp on columns"""
type agency_payment_failures_var_samp_fields {
  amount: Float
}

"""aggregate variance on columns"""
type agency_payment_failures_variance_fields {
  amount: Float
}

"""Payout requests and transactions for agency earnings"""
type agency_payouts {
  """An array relationship"""
  agency_earnings(
    """distinct select on columns"""
    distinct_on: [agency_earnings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_earnings_order_by!]

    """filter the rows returned"""
    where: agency_earnings_bool_exp
  ): [agency_earnings!]!

  """An aggregate relationship"""
  agency_earnings_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_earnings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_earnings_order_by!]

    """filter the rows returned"""
    where: agency_earnings_bool_exp
  ): agency_earnings_aggregate!
  agency_id: uuid!
  amount: numeric!
  completed_at: timestamptz
  created_at: timestamptz
  currency: String
  description: String
  failed_at: timestamptz
  failure_code: String
  failure_message: String
  id: uuid!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  net_amount: numeric!
  notes: String
  payout_destination(
    """JSON select path"""
    path: String
  ): jsonb
  payout_method: String!
  payout_number: String!
  platform_fee: numeric
  processing_at: timestamptz
  processing_fee: numeric
  provider_reference: String
  requested_at: timestamptz
  retry_count: Int
  status: String!
  stripe_payout_id: String
  stripe_transfer_id: String
  updated_at: timestamptz

  """An object relationship"""
  user: auth_users!
}

"""
aggregated selection of "agency_payouts"
"""
type agency_payouts_aggregate {
  aggregate: agency_payouts_aggregate_fields
  nodes: [agency_payouts!]!
}

"""
aggregate fields of "agency_payouts"
"""
type agency_payouts_aggregate_fields {
  avg: agency_payouts_avg_fields
  count(columns: [agency_payouts_select_column!], distinct: Boolean): Int!
  max: agency_payouts_max_fields
  min: agency_payouts_min_fields
  stddev: agency_payouts_stddev_fields
  stddev_pop: agency_payouts_stddev_pop_fields
  stddev_samp: agency_payouts_stddev_samp_fields
  sum: agency_payouts_sum_fields
  var_pop: agency_payouts_var_pop_fields
  var_samp: agency_payouts_var_samp_fields
  variance: agency_payouts_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input agency_payouts_append_input {
  metadata: jsonb
  payout_destination: jsonb
}

"""aggregate avg on columns"""
type agency_payouts_avg_fields {
  amount: Float
  net_amount: Float
  platform_fee: Float
  processing_fee: Float
  retry_count: Float
}

"""
Boolean expression to filter rows from the table "agency_payouts". All fields are combined with a logical 'AND'.
"""
input agency_payouts_bool_exp {
  _and: [agency_payouts_bool_exp!]
  _not: agency_payouts_bool_exp
  _or: [agency_payouts_bool_exp!]
  agency_earnings: agency_earnings_bool_exp
  agency_earnings_aggregate: agency_earnings_aggregate_bool_exp
  agency_id: uuid_comparison_exp
  amount: numeric_comparison_exp
  completed_at: timestamptz_comparison_exp
  created_at: timestamptz_comparison_exp
  currency: String_comparison_exp
  description: String_comparison_exp
  failed_at: timestamptz_comparison_exp
  failure_code: String_comparison_exp
  failure_message: String_comparison_exp
  id: uuid_comparison_exp
  metadata: jsonb_comparison_exp
  net_amount: numeric_comparison_exp
  notes: String_comparison_exp
  payout_destination: jsonb_comparison_exp
  payout_method: String_comparison_exp
  payout_number: String_comparison_exp
  platform_fee: numeric_comparison_exp
  processing_at: timestamptz_comparison_exp
  processing_fee: numeric_comparison_exp
  provider_reference: String_comparison_exp
  requested_at: timestamptz_comparison_exp
  retry_count: Int_comparison_exp
  status: String_comparison_exp
  stripe_payout_id: String_comparison_exp
  stripe_transfer_id: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
}

"""
unique or primary key constraints on table "agency_payouts"
"""
enum agency_payouts_constraint {
  """
  unique or primary key constraint on columns "payout_number"
  """
  agency_payouts_payout_number_key

  """
  unique or primary key constraint on columns "id"
  """
  agency_payouts_pkey

  """
  unique or primary key constraint on columns "stripe_payout_id"
  """
  agency_payouts_stripe_payout_id_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input agency_payouts_delete_at_path_input {
  metadata: [String!]
  payout_destination: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input agency_payouts_delete_elem_input {
  metadata: Int
  payout_destination: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input agency_payouts_delete_key_input {
  metadata: String
  payout_destination: String
}

"""
input type for incrementing numeric columns in table "agency_payouts"
"""
input agency_payouts_inc_input {
  amount: numeric
  net_amount: numeric
  platform_fee: numeric
  processing_fee: numeric
  retry_count: Int
}

"""
input type for inserting data into table "agency_payouts"
"""
input agency_payouts_insert_input {
  agency_earnings: agency_earnings_arr_rel_insert_input
  agency_id: uuid
  amount: numeric
  completed_at: timestamptz
  created_at: timestamptz
  currency: String
  description: String
  failed_at: timestamptz
  failure_code: String
  failure_message: String
  id: uuid
  metadata: jsonb
  net_amount: numeric
  notes: String
  payout_destination: jsonb
  payout_method: String
  payout_number: String
  platform_fee: numeric
  processing_at: timestamptz
  processing_fee: numeric
  provider_reference: String
  requested_at: timestamptz
  retry_count: Int
  status: String
  stripe_payout_id: String
  stripe_transfer_id: String
  updated_at: timestamptz
  user: auth_users_obj_rel_insert_input
}

"""aggregate max on columns"""
type agency_payouts_max_fields {
  agency_id: uuid
  amount: numeric
  completed_at: timestamptz
  created_at: timestamptz
  currency: String
  description: String
  failed_at: timestamptz
  failure_code: String
  failure_message: String
  id: uuid
  net_amount: numeric
  notes: String
  payout_method: String
  payout_number: String
  platform_fee: numeric
  processing_at: timestamptz
  processing_fee: numeric
  provider_reference: String
  requested_at: timestamptz
  retry_count: Int
  status: String
  stripe_payout_id: String
  stripe_transfer_id: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type agency_payouts_min_fields {
  agency_id: uuid
  amount: numeric
  completed_at: timestamptz
  created_at: timestamptz
  currency: String
  description: String
  failed_at: timestamptz
  failure_code: String
  failure_message: String
  id: uuid
  net_amount: numeric
  notes: String
  payout_method: String
  payout_number: String
  platform_fee: numeric
  processing_at: timestamptz
  processing_fee: numeric
  provider_reference: String
  requested_at: timestamptz
  retry_count: Int
  status: String
  stripe_payout_id: String
  stripe_transfer_id: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "agency_payouts"
"""
type agency_payouts_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [agency_payouts!]!
}

"""
input type for inserting object relation for remote table "agency_payouts"
"""
input agency_payouts_obj_rel_insert_input {
  data: agency_payouts_insert_input!

  """upsert condition"""
  on_conflict: agency_payouts_on_conflict
}

"""
on_conflict condition type for table "agency_payouts"
"""
input agency_payouts_on_conflict {
  constraint: agency_payouts_constraint!
  update_columns: [agency_payouts_update_column!]! = []
  where: agency_payouts_bool_exp
}

"""Ordering options when selecting data from "agency_payouts"."""
input agency_payouts_order_by {
  agency_earnings_aggregate: agency_earnings_aggregate_order_by
  agency_id: order_by
  amount: order_by
  completed_at: order_by
  created_at: order_by
  currency: order_by
  description: order_by
  failed_at: order_by
  failure_code: order_by
  failure_message: order_by
  id: order_by
  metadata: order_by
  net_amount: order_by
  notes: order_by
  payout_destination: order_by
  payout_method: order_by
  payout_number: order_by
  platform_fee: order_by
  processing_at: order_by
  processing_fee: order_by
  provider_reference: order_by
  requested_at: order_by
  retry_count: order_by
  status: order_by
  stripe_payout_id: order_by
  stripe_transfer_id: order_by
  updated_at: order_by
  user: auth_users_order_by
}

"""primary key columns input for table: agency_payouts"""
input agency_payouts_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input agency_payouts_prepend_input {
  metadata: jsonb
  payout_destination: jsonb
}

"""
select columns of table "agency_payouts"
"""
enum agency_payouts_select_column {
  """column name"""
  agency_id

  """column name"""
  amount

  """column name"""
  completed_at

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  description

  """column name"""
  failed_at

  """column name"""
  failure_code

  """column name"""
  failure_message

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  net_amount

  """column name"""
  notes

  """column name"""
  payout_destination

  """column name"""
  payout_method

  """column name"""
  payout_number

  """column name"""
  platform_fee

  """column name"""
  processing_at

  """column name"""
  processing_fee

  """column name"""
  provider_reference

  """column name"""
  requested_at

  """column name"""
  retry_count

  """column name"""
  status

  """column name"""
  stripe_payout_id

  """column name"""
  stripe_transfer_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "agency_payouts"
"""
input agency_payouts_set_input {
  agency_id: uuid
  amount: numeric
  completed_at: timestamptz
  created_at: timestamptz
  currency: String
  description: String
  failed_at: timestamptz
  failure_code: String
  failure_message: String
  id: uuid
  metadata: jsonb
  net_amount: numeric
  notes: String
  payout_destination: jsonb
  payout_method: String
  payout_number: String
  platform_fee: numeric
  processing_at: timestamptz
  processing_fee: numeric
  provider_reference: String
  requested_at: timestamptz
  retry_count: Int
  status: String
  stripe_payout_id: String
  stripe_transfer_id: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type agency_payouts_stddev_fields {
  amount: Float
  net_amount: Float
  platform_fee: Float
  processing_fee: Float
  retry_count: Float
}

"""aggregate stddev_pop on columns"""
type agency_payouts_stddev_pop_fields {
  amount: Float
  net_amount: Float
  platform_fee: Float
  processing_fee: Float
  retry_count: Float
}

"""aggregate stddev_samp on columns"""
type agency_payouts_stddev_samp_fields {
  amount: Float
  net_amount: Float
  platform_fee: Float
  processing_fee: Float
  retry_count: Float
}

"""
Streaming cursor of the table "agency_payouts"
"""
input agency_payouts_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: agency_payouts_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input agency_payouts_stream_cursor_value_input {
  agency_id: uuid
  amount: numeric
  completed_at: timestamptz
  created_at: timestamptz
  currency: String
  description: String
  failed_at: timestamptz
  failure_code: String
  failure_message: String
  id: uuid
  metadata: jsonb
  net_amount: numeric
  notes: String
  payout_destination: jsonb
  payout_method: String
  payout_number: String
  platform_fee: numeric
  processing_at: timestamptz
  processing_fee: numeric
  provider_reference: String
  requested_at: timestamptz
  retry_count: Int
  status: String
  stripe_payout_id: String
  stripe_transfer_id: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type agency_payouts_sum_fields {
  amount: numeric
  net_amount: numeric
  platform_fee: numeric
  processing_fee: numeric
  retry_count: Int
}

"""
update columns of table "agency_payouts"
"""
enum agency_payouts_update_column {
  """column name"""
  agency_id

  """column name"""
  amount

  """column name"""
  completed_at

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  description

  """column name"""
  failed_at

  """column name"""
  failure_code

  """column name"""
  failure_message

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  net_amount

  """column name"""
  notes

  """column name"""
  payout_destination

  """column name"""
  payout_method

  """column name"""
  payout_number

  """column name"""
  platform_fee

  """column name"""
  processing_at

  """column name"""
  processing_fee

  """column name"""
  provider_reference

  """column name"""
  requested_at

  """column name"""
  retry_count

  """column name"""
  status

  """column name"""
  stripe_payout_id

  """column name"""
  stripe_transfer_id

  """column name"""
  updated_at
}

input agency_payouts_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: agency_payouts_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: agency_payouts_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: agency_payouts_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: agency_payouts_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: agency_payouts_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: agency_payouts_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: agency_payouts_set_input

  """filter the rows which have to be updated"""
  where: agency_payouts_bool_exp!
}

"""aggregate var_pop on columns"""
type agency_payouts_var_pop_fields {
  amount: Float
  net_amount: Float
  platform_fee: Float
  processing_fee: Float
  retry_count: Float
}

"""aggregate var_samp on columns"""
type agency_payouts_var_samp_fields {
  amount: Float
  net_amount: Float
  platform_fee: Float
  processing_fee: Float
  retry_count: Float
}

"""aggregate variance on columns"""
type agency_payouts_variance_fields {
  amount: Float
  net_amount: Float
  platform_fee: Float
  processing_fee: Float
  retry_count: Float
}

"""
columns and relationships of "agency_placements"
"""
type agency_placements {
  agency_id: uuid!

  """An object relationship"""
  agency_job: agency_jobs
  application_date: timestamptz
  created_at: timestamptz

  """An array relationship"""
  disputes(
    """distinct select on columns"""
    distinct_on: [disputes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [disputes_order_by!]

    """filter the rows returned"""
    where: disputes_bool_exp
  ): [disputes!]!

  """An aggregate relationship"""
  disputes_aggregate(
    """distinct select on columns"""
    distinct_on: [disputes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [disputes_order_by!]

    """filter the rows returned"""
    where: disputes_bool_exp
  ): disputes_aggregate!
  id: uuid!
  job_id: uuid
  maid_id: uuid
  notes: String

  """An object relationship"""
  placement_contract: placement_contracts
  placement_date: timestamptz

  """An array relationship"""
  placement_fee_transactions(
    """distinct select on columns"""
    distinct_on: [placement_fee_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [placement_fee_transactions_order_by!]

    """filter the rows returned"""
    where: placement_fee_transactions_bool_exp
  ): [placement_fee_transactions!]!

  """An aggregate relationship"""
  placement_fee_transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [placement_fee_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [placement_fee_transactions_order_by!]

    """filter the rows returned"""
    where: placement_fee_transactions_bool_exp
  ): placement_fee_transactions_aggregate!
  sponsor_id: uuid
  status: String
  updated_at: timestamptz

  """An object relationship"""
  user: auth_users!

  """An object relationship"""
  userByMaidId: auth_users

  """An object relationship"""
  userBySponsorId: auth_users
}

"""
aggregated selection of "agency_placements"
"""
type agency_placements_aggregate {
  aggregate: agency_placements_aggregate_fields
  nodes: [agency_placements!]!
}

input agency_placements_aggregate_bool_exp {
  count: agency_placements_aggregate_bool_exp_count
}

input agency_placements_aggregate_bool_exp_count {
  arguments: [agency_placements_select_column!]
  distinct: Boolean
  filter: agency_placements_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "agency_placements"
"""
type agency_placements_aggregate_fields {
  count(columns: [agency_placements_select_column!], distinct: Boolean): Int!
  max: agency_placements_max_fields
  min: agency_placements_min_fields
}

"""
order by aggregate values of table "agency_placements"
"""
input agency_placements_aggregate_order_by {
  count: order_by
  max: agency_placements_max_order_by
  min: agency_placements_min_order_by
}

"""
input type for inserting array relation for remote table "agency_placements"
"""
input agency_placements_arr_rel_insert_input {
  data: [agency_placements_insert_input!]!

  """upsert condition"""
  on_conflict: agency_placements_on_conflict
}

"""
Boolean expression to filter rows from the table "agency_placements". All fields are combined with a logical 'AND'.
"""
input agency_placements_bool_exp {
  _and: [agency_placements_bool_exp!]
  _not: agency_placements_bool_exp
  _or: [agency_placements_bool_exp!]
  agency_id: uuid_comparison_exp
  agency_job: agency_jobs_bool_exp
  application_date: timestamptz_comparison_exp
  created_at: timestamptz_comparison_exp
  disputes: disputes_bool_exp
  disputes_aggregate: disputes_aggregate_bool_exp
  id: uuid_comparison_exp
  job_id: uuid_comparison_exp
  maid_id: uuid_comparison_exp
  notes: String_comparison_exp
  placement_contract: placement_contracts_bool_exp
  placement_date: timestamptz_comparison_exp
  placement_fee_transactions: placement_fee_transactions_bool_exp
  placement_fee_transactions_aggregate: placement_fee_transactions_aggregate_bool_exp
  sponsor_id: uuid_comparison_exp
  status: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
  userByMaidId: auth_users_bool_exp
  userBySponsorId: auth_users_bool_exp
}

"""
unique or primary key constraints on table "agency_placements"
"""
enum agency_placements_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  agency_placements_pkey
}

"""
input type for inserting data into table "agency_placements"
"""
input agency_placements_insert_input {
  agency_id: uuid
  agency_job: agency_jobs_obj_rel_insert_input
  application_date: timestamptz
  created_at: timestamptz
  disputes: disputes_arr_rel_insert_input
  id: uuid
  job_id: uuid
  maid_id: uuid
  notes: String
  placement_contract: placement_contracts_obj_rel_insert_input
  placement_date: timestamptz
  placement_fee_transactions: placement_fee_transactions_arr_rel_insert_input
  sponsor_id: uuid
  status: String
  updated_at: timestamptz
  user: auth_users_obj_rel_insert_input
  userByMaidId: auth_users_obj_rel_insert_input
  userBySponsorId: auth_users_obj_rel_insert_input
}

"""aggregate max on columns"""
type agency_placements_max_fields {
  agency_id: uuid
  application_date: timestamptz
  created_at: timestamptz
  id: uuid
  job_id: uuid
  maid_id: uuid
  notes: String
  placement_date: timestamptz
  sponsor_id: uuid
  status: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "agency_placements"
"""
input agency_placements_max_order_by {
  agency_id: order_by
  application_date: order_by
  created_at: order_by
  id: order_by
  job_id: order_by
  maid_id: order_by
  notes: order_by
  placement_date: order_by
  sponsor_id: order_by
  status: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type agency_placements_min_fields {
  agency_id: uuid
  application_date: timestamptz
  created_at: timestamptz
  id: uuid
  job_id: uuid
  maid_id: uuid
  notes: String
  placement_date: timestamptz
  sponsor_id: uuid
  status: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "agency_placements"
"""
input agency_placements_min_order_by {
  agency_id: order_by
  application_date: order_by
  created_at: order_by
  id: order_by
  job_id: order_by
  maid_id: order_by
  notes: order_by
  placement_date: order_by
  sponsor_id: order_by
  status: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "agency_placements"
"""
type agency_placements_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [agency_placements!]!
}

"""
input type for inserting object relation for remote table "agency_placements"
"""
input agency_placements_obj_rel_insert_input {
  data: agency_placements_insert_input!

  """upsert condition"""
  on_conflict: agency_placements_on_conflict
}

"""
on_conflict condition type for table "agency_placements"
"""
input agency_placements_on_conflict {
  constraint: agency_placements_constraint!
  update_columns: [agency_placements_update_column!]! = []
  where: agency_placements_bool_exp
}

"""Ordering options when selecting data from "agency_placements"."""
input agency_placements_order_by {
  agency_id: order_by
  agency_job: agency_jobs_order_by
  application_date: order_by
  created_at: order_by
  disputes_aggregate: disputes_aggregate_order_by
  id: order_by
  job_id: order_by
  maid_id: order_by
  notes: order_by
  placement_contract: placement_contracts_order_by
  placement_date: order_by
  placement_fee_transactions_aggregate: placement_fee_transactions_aggregate_order_by
  sponsor_id: order_by
  status: order_by
  updated_at: order_by
  user: auth_users_order_by
  userByMaidId: auth_users_order_by
  userBySponsorId: auth_users_order_by
}

"""primary key columns input for table: agency_placements"""
input agency_placements_pk_columns_input {
  id: uuid!
}

"""
select columns of table "agency_placements"
"""
enum agency_placements_select_column {
  """column name"""
  agency_id

  """column name"""
  application_date

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  job_id

  """column name"""
  maid_id

  """column name"""
  notes

  """column name"""
  placement_date

  """column name"""
  sponsor_id

  """column name"""
  status

  """column name"""
  updated_at
}

"""
input type for updating data in table "agency_placements"
"""
input agency_placements_set_input {
  agency_id: uuid
  application_date: timestamptz
  created_at: timestamptz
  id: uuid
  job_id: uuid
  maid_id: uuid
  notes: String
  placement_date: timestamptz
  sponsor_id: uuid
  status: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "agency_placements"
"""
input agency_placements_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: agency_placements_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input agency_placements_stream_cursor_value_input {
  agency_id: uuid
  application_date: timestamptz
  created_at: timestamptz
  id: uuid
  job_id: uuid
  maid_id: uuid
  notes: String
  placement_date: timestamptz
  sponsor_id: uuid
  status: String
  updated_at: timestamptz
}

"""
update columns of table "agency_placements"
"""
enum agency_placements_update_column {
  """column name"""
  agency_id

  """column name"""
  application_date

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  job_id

  """column name"""
  maid_id

  """column name"""
  notes

  """column name"""
  placement_date

  """column name"""
  sponsor_id

  """column name"""
  status

  """column name"""
  updated_at
}

input agency_placements_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: agency_placements_set_input

  """filter the rows which have to be updated"""
  where: agency_placements_bool_exp!
}

"""
columns and relationships of "agency_profiles"
"""
type agency_profiles {
  accreditation_bodies: [String!]
  active_listings: Int
  active_maids: Int
  address: String
  agency_contract_template: String
  agency_description: String
  full_name: String!
  authorized_person_email: String
  authorized_person_email_verified: Boolean
  authorized_person_id_document: String
  authorized_person_id_number: String
  authorized_person_id_rejection_reason: String
  authorized_person_id_verification_status: String
  authorized_person_id_verified_at: timestamptz
  authorized_person_id_verified_by: uuid
  authorized_person_name: String
  authorized_person_phone: String
  authorized_person_phone_verified: Boolean
  authorized_person_position: String
  average_rating: numeric
  business_address: String
  business_email: String
  business_phone: String
  certifications: [String!]
  city: String
  contact_person_name: String
  contact_person_title: String
  contact_phone_verified: Boolean
  contract_template_verification_status: String
  country: String
  created_at: timestamptz
  email: String
  emergency_contact_phone: String
  established_year: Int
  guarantee_period_months: Int
  head_office_address: String
  id: String!
  license_expiry_date: date
  license_number: String
  license_verified: Boolean
  logo_file_preview: String
  logo_url: String
  official_email_verified: Boolean
  phone: String
  placement_fee_percentage: numeric

  """An object relationship"""
  profile: profiles!
  profile_completed_at: timestamptz
  registration_country: String
  service_countries: [String!]
  specialization: [String!]
  subscription_expires_at: timestamptz
  subscription_tier: String
  successful_placements: Int
  support_hours_end: String
  support_hours_start: String
  total_maids: Int
  total_maids_managed: Int
  trade_license_document: String
  trade_license_rejection_reason: String
  trade_license_verification_status: String
  trade_license_verified_at: timestamptz
  trade_license_verified_by: uuid
  updated_at: timestamptz
  verification_status: String
  verified: Boolean
  website: String
  website_url: String
}

"""
aggregated selection of "agency_profiles"
"""
type agency_profiles_aggregate {
  aggregate: agency_profiles_aggregate_fields
  nodes: [agency_profiles!]!
}

"""
aggregate fields of "agency_profiles"
"""
type agency_profiles_aggregate_fields {
  avg: agency_profiles_avg_fields
  count(columns: [agency_profiles_select_column!], distinct: Boolean): Int!
  max: agency_profiles_max_fields
  min: agency_profiles_min_fields
  stddev: agency_profiles_stddev_fields
  stddev_pop: agency_profiles_stddev_pop_fields
  stddev_samp: agency_profiles_stddev_samp_fields
  sum: agency_profiles_sum_fields
  var_pop: agency_profiles_var_pop_fields
  var_samp: agency_profiles_var_samp_fields
  variance: agency_profiles_variance_fields
}

"""aggregate avg on columns"""
type agency_profiles_avg_fields {
  active_listings: Float
  active_maids: Float
  average_rating: Float
  established_year: Float
  guarantee_period_months: Float
  placement_fee_percentage: Float
  successful_placements: Float
  total_maids: Float
  total_maids_managed: Float
}

"""
Boolean expression to filter rows from the table "agency_profiles". All fields are combined with a logical 'AND'.
"""
input agency_profiles_bool_exp {
  _and: [agency_profiles_bool_exp!]
  _not: agency_profiles_bool_exp
  _or: [agency_profiles_bool_exp!]
  accreditation_bodies: String_array_comparison_exp
  active_listings: Int_comparison_exp
  active_maids: Int_comparison_exp
  address: String_comparison_exp
  agency_contract_template: String_comparison_exp
  agency_description: String_comparison_exp
  full_name: String_comparison_exp
  authorized_person_email: String_comparison_exp
  authorized_person_email_verified: Boolean_comparison_exp
  authorized_person_id_document: String_comparison_exp
  authorized_person_id_number: String_comparison_exp
  authorized_person_id_rejection_reason: String_comparison_exp
  authorized_person_id_verification_status: String_comparison_exp
  authorized_person_id_verified_at: timestamptz_comparison_exp
  authorized_person_id_verified_by: uuid_comparison_exp
  authorized_person_name: String_comparison_exp
  authorized_person_phone: String_comparison_exp
  authorized_person_phone_verified: Boolean_comparison_exp
  authorized_person_position: String_comparison_exp
  average_rating: numeric_comparison_exp
  business_address: String_comparison_exp
  business_email: String_comparison_exp
  business_phone: String_comparison_exp
  certifications: String_array_comparison_exp
  city: String_comparison_exp
  contact_person_name: String_comparison_exp
  contact_person_title: String_comparison_exp
  contact_phone_verified: Boolean_comparison_exp
  contract_template_verification_status: String_comparison_exp
  country: String_comparison_exp
  created_at: timestamptz_comparison_exp
  email: String_comparison_exp
  emergency_contact_phone: String_comparison_exp
  established_year: Int_comparison_exp
  guarantee_period_months: Int_comparison_exp
  head_office_address: String_comparison_exp
  id: String_comparison_exp
  license_expiry_date: date_comparison_exp
  license_number: String_comparison_exp
  license_verified: Boolean_comparison_exp
  logo_file_preview: String_comparison_exp
  logo_url: String_comparison_exp
  official_email_verified: Boolean_comparison_exp
  phone: String_comparison_exp
  placement_fee_percentage: numeric_comparison_exp
  profile: profiles_bool_exp
  profile_completed_at: timestamptz_comparison_exp
  registration_country: String_comparison_exp
  service_countries: String_array_comparison_exp
  specialization: String_array_comparison_exp
  subscription_expires_at: timestamptz_comparison_exp
  subscription_tier: String_comparison_exp
  successful_placements: Int_comparison_exp
  support_hours_end: String_comparison_exp
  support_hours_start: String_comparison_exp
  total_maids: Int_comparison_exp
  total_maids_managed: Int_comparison_exp
  trade_license_document: String_comparison_exp
  trade_license_rejection_reason: String_comparison_exp
  trade_license_verification_status: String_comparison_exp
  trade_license_verified_at: timestamptz_comparison_exp
  trade_license_verified_by: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  verification_status: String_comparison_exp
  verified: Boolean_comparison_exp
  website: String_comparison_exp
  website_url: String_comparison_exp
}

"""
unique or primary key constraints on table "agency_profiles"
"""
enum agency_profiles_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  agency_profiles_pkey
}

"""
input type for incrementing numeric columns in table "agency_profiles"
"""
input agency_profiles_inc_input {
  active_listings: Int
  active_maids: Int
  average_rating: numeric
  established_year: Int
  guarantee_period_months: Int
  placement_fee_percentage: numeric
  successful_placements: Int
  total_maids: Int
  total_maids_managed: Int
}

"""
input type for inserting data into table "agency_profiles"
"""
input agency_profiles_insert_input {
  accreditation_bodies: [String!]
  active_listings: Int
  active_maids: Int
  address: String
  agency_contract_template: String
  agency_description: String
  full_name: String
  authorized_person_email: String
  authorized_person_email_verified: Boolean
  authorized_person_id_document: String
  authorized_person_id_number: String
  authorized_person_id_rejection_reason: String
  authorized_person_id_verification_status: String
  authorized_person_id_verified_at: timestamptz
  authorized_person_id_verified_by: uuid
  authorized_person_name: String
  authorized_person_phone: String
  authorized_person_phone_verified: Boolean
  authorized_person_position: String
  average_rating: numeric
  business_address: String
  business_email: String
  business_phone: String
  certifications: [String!]
  city: String
  contact_person_name: String
  contact_person_title: String
  contact_phone_verified: Boolean
  contract_template_verification_status: String
  country: String
  created_at: timestamptz
  email: String
  emergency_contact_phone: String
  established_year: Int
  guarantee_period_months: Int
  head_office_address: String
  id: String
  license_expiry_date: date
  license_number: String
  license_verified: Boolean
  logo_file_preview: String
  logo_url: String
  official_email_verified: Boolean
  phone: String
  placement_fee_percentage: numeric
  profile: profiles_obj_rel_insert_input
  profile_completed_at: timestamptz
  registration_country: String
  service_countries: [String!]
  specialization: [String!]
  subscription_expires_at: timestamptz
  subscription_tier: String
  successful_placements: Int
  support_hours_end: String
  support_hours_start: String
  total_maids: Int
  total_maids_managed: Int
  trade_license_document: String
  trade_license_rejection_reason: String
  trade_license_verification_status: String
  trade_license_verified_at: timestamptz
  trade_license_verified_by: uuid
  updated_at: timestamptz
  verification_status: String
  verified: Boolean
  website: String
  website_url: String
}

"""aggregate max on columns"""
type agency_profiles_max_fields {
  accreditation_bodies: [String!]
  active_listings: Int
  active_maids: Int
  address: String
  agency_contract_template: String
  agency_description: String
  full_name: String
  authorized_person_email: String
  authorized_person_id_document: String
  authorized_person_id_number: String
  authorized_person_id_rejection_reason: String
  authorized_person_id_verification_status: String
  authorized_person_id_verified_at: timestamptz
  authorized_person_id_verified_by: uuid
  authorized_person_name: String
  authorized_person_phone: String
  authorized_person_position: String
  average_rating: numeric
  business_address: String
  business_email: String
  business_phone: String
  certifications: [String!]
  city: String
  contact_person_name: String
  contact_person_title: String
  contract_template_verification_status: String
  country: String
  created_at: timestamptz
  email: String
  emergency_contact_phone: String
  established_year: Int
  guarantee_period_months: Int
  head_office_address: String
  id: String
  license_expiry_date: date
  license_number: String
  logo_file_preview: String
  logo_url: String
  phone: String
  placement_fee_percentage: numeric
  profile_completed_at: timestamptz
  registration_country: String
  service_countries: [String!]
  specialization: [String!]
  subscription_expires_at: timestamptz
  subscription_tier: String
  successful_placements: Int
  support_hours_end: String
  support_hours_start: String
  total_maids: Int
  total_maids_managed: Int
  trade_license_document: String
  trade_license_rejection_reason: String
  trade_license_verification_status: String
  trade_license_verified_at: timestamptz
  trade_license_verified_by: uuid
  updated_at: timestamptz
  verification_status: String
  website: String
  website_url: String
}

"""aggregate min on columns"""
type agency_profiles_min_fields {
  accreditation_bodies: [String!]
  active_listings: Int
  active_maids: Int
  address: String
  agency_contract_template: String
  agency_description: String
  full_name: String
  authorized_person_email: String
  authorized_person_id_document: String
  authorized_person_id_number: String
  authorized_person_id_rejection_reason: String
  authorized_person_id_verification_status: String
  authorized_person_id_verified_at: timestamptz
  authorized_person_id_verified_by: uuid
  authorized_person_name: String
  authorized_person_phone: String
  authorized_person_position: String
  average_rating: numeric
  business_address: String
  business_email: String
  business_phone: String
  certifications: [String!]
  city: String
  contact_person_name: String
  contact_person_title: String
  contract_template_verification_status: String
  country: String
  created_at: timestamptz
  email: String
  emergency_contact_phone: String
  established_year: Int
  guarantee_period_months: Int
  head_office_address: String
  id: String
  license_expiry_date: date
  license_number: String
  logo_file_preview: String
  logo_url: String
  phone: String
  placement_fee_percentage: numeric
  profile_completed_at: timestamptz
  registration_country: String
  service_countries: [String!]
  specialization: [String!]
  subscription_expires_at: timestamptz
  subscription_tier: String
  successful_placements: Int
  support_hours_end: String
  support_hours_start: String
  total_maids: Int
  total_maids_managed: Int
  trade_license_document: String
  trade_license_rejection_reason: String
  trade_license_verification_status: String
  trade_license_verified_at: timestamptz
  trade_license_verified_by: uuid
  updated_at: timestamptz
  verification_status: String
  website: String
  website_url: String
}

"""
response of any mutation on the table "agency_profiles"
"""
type agency_profiles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [agency_profiles!]!
}

"""
input type for inserting object relation for remote table "agency_profiles"
"""
input agency_profiles_obj_rel_insert_input {
  data: agency_profiles_insert_input!

  """upsert condition"""
  on_conflict: agency_profiles_on_conflict
}

"""
on_conflict condition type for table "agency_profiles"
"""
input agency_profiles_on_conflict {
  constraint: agency_profiles_constraint!
  update_columns: [agency_profiles_update_column!]! = []
  where: agency_profiles_bool_exp
}

"""Ordering options when selecting data from "agency_profiles"."""
input agency_profiles_order_by {
  accreditation_bodies: order_by
  active_listings: order_by
  active_maids: order_by
  address: order_by
  agency_contract_template: order_by
  agency_description: order_by
  full_name: order_by
  authorized_person_email: order_by
  authorized_person_email_verified: order_by
  authorized_person_id_document: order_by
  authorized_person_id_number: order_by
  authorized_person_id_rejection_reason: order_by
  authorized_person_id_verification_status: order_by
  authorized_person_id_verified_at: order_by
  authorized_person_id_verified_by: order_by
  authorized_person_name: order_by
  authorized_person_phone: order_by
  authorized_person_phone_verified: order_by
  authorized_person_position: order_by
  average_rating: order_by
  business_address: order_by
  business_email: order_by
  business_phone: order_by
  certifications: order_by
  city: order_by
  contact_person_name: order_by
  contact_person_title: order_by
  contact_phone_verified: order_by
  contract_template_verification_status: order_by
  country: order_by
  created_at: order_by
  email: order_by
  emergency_contact_phone: order_by
  established_year: order_by
  guarantee_period_months: order_by
  head_office_address: order_by
  id: order_by
  license_expiry_date: order_by
  license_number: order_by
  license_verified: order_by
  logo_file_preview: order_by
  logo_url: order_by
  official_email_verified: order_by
  phone: order_by
  placement_fee_percentage: order_by
  profile: profiles_order_by
  profile_completed_at: order_by
  registration_country: order_by
  service_countries: order_by
  specialization: order_by
  subscription_expires_at: order_by
  subscription_tier: order_by
  successful_placements: order_by
  support_hours_end: order_by
  support_hours_start: order_by
  total_maids: order_by
  total_maids_managed: order_by
  trade_license_document: order_by
  trade_license_rejection_reason: order_by
  trade_license_verification_status: order_by
  trade_license_verified_at: order_by
  trade_license_verified_by: order_by
  updated_at: order_by
  verification_status: order_by
  verified: order_by
  website: order_by
  website_url: order_by
}

"""primary key columns input for table: agency_profiles"""
input agency_profiles_pk_columns_input {
  id: String!
}

"""
select columns of table "agency_profiles"
"""
enum agency_profiles_select_column {
  """column name"""
  accreditation_bodies

  """column name"""
  active_listings

  """column name"""
  active_maids

  """column name"""
  address

  """column name"""
  agency_contract_template

  """column name"""
  agency_description

  """column name"""
  full_name

  """column name"""
  authorized_person_email

  """column name"""
  authorized_person_email_verified

  """column name"""
  authorized_person_id_document

  """column name"""
  authorized_person_id_number

  """column name"""
  authorized_person_id_rejection_reason

  """column name"""
  authorized_person_id_verification_status

  """column name"""
  authorized_person_id_verified_at

  """column name"""
  authorized_person_id_verified_by

  """column name"""
  authorized_person_name

  """column name"""
  authorized_person_phone

  """column name"""
  authorized_person_phone_verified

  """column name"""
  authorized_person_position

  """column name"""
  average_rating

  """column name"""
  business_address

  """column name"""
  business_email

  """column name"""
  business_phone

  """column name"""
  certifications

  """column name"""
  city

  """column name"""
  contact_person_name

  """column name"""
  contact_person_title

  """column name"""
  contact_phone_verified

  """column name"""
  contract_template_verification_status

  """column name"""
  country

  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  emergency_contact_phone

  """column name"""
  established_year

  """column name"""
  guarantee_period_months

  """column name"""
  head_office_address

  """column name"""
  id

  """column name"""
  license_expiry_date

  """column name"""
  license_number

  """column name"""
  license_verified

  """column name"""
  logo_file_preview

  """column name"""
  logo_url

  """column name"""
  official_email_verified

  """column name"""
  phone

  """column name"""
  placement_fee_percentage

  """column name"""
  profile_completed_at

  """column name"""
  registration_country

  """column name"""
  service_countries

  """column name"""
  specialization

  """column name"""
  subscription_expires_at

  """column name"""
  subscription_tier

  """column name"""
  successful_placements

  """column name"""
  support_hours_end

  """column name"""
  support_hours_start

  """column name"""
  total_maids

  """column name"""
  total_maids_managed

  """column name"""
  trade_license_document

  """column name"""
  trade_license_rejection_reason

  """column name"""
  trade_license_verification_status

  """column name"""
  trade_license_verified_at

  """column name"""
  trade_license_verified_by

  """column name"""
  updated_at

  """column name"""
  verification_status

  """column name"""
  verified

  """column name"""
  website

  """column name"""
  website_url
}

"""
input type for updating data in table "agency_profiles"
"""
input agency_profiles_set_input {
  accreditation_bodies: [String!]
  active_listings: Int
  active_maids: Int
  address: String
  agency_contract_template: String
  agency_description: String
  full_name: String
  authorized_person_email: String
  authorized_person_email_verified: Boolean
  authorized_person_id_document: String
  authorized_person_id_number: String
  authorized_person_id_rejection_reason: String
  authorized_person_id_verification_status: String
  authorized_person_id_verified_at: timestamptz
  authorized_person_id_verified_by: uuid
  authorized_person_name: String
  authorized_person_phone: String
  authorized_person_phone_verified: Boolean
  authorized_person_position: String
  average_rating: numeric
  business_address: String
  business_email: String
  business_phone: String
  certifications: [String!]
  city: String
  contact_person_name: String
  contact_person_title: String
  contact_phone_verified: Boolean
  contract_template_verification_status: String
  country: String
  created_at: timestamptz
  email: String
  emergency_contact_phone: String
  established_year: Int
  guarantee_period_months: Int
  head_office_address: String
  id: String
  license_expiry_date: date
  license_number: String
  license_verified: Boolean
  logo_file_preview: String
  logo_url: String
  official_email_verified: Boolean
  phone: String
  placement_fee_percentage: numeric
  profile_completed_at: timestamptz
  registration_country: String
  service_countries: [String!]
  specialization: [String!]
  subscription_expires_at: timestamptz
  subscription_tier: String
  successful_placements: Int
  support_hours_end: String
  support_hours_start: String
  total_maids: Int
  total_maids_managed: Int
  trade_license_document: String
  trade_license_rejection_reason: String
  trade_license_verification_status: String
  trade_license_verified_at: timestamptz
  trade_license_verified_by: uuid
  updated_at: timestamptz
  verification_status: String
  verified: Boolean
  website: String
  website_url: String
}

"""aggregate stddev on columns"""
type agency_profiles_stddev_fields {
  active_listings: Float
  active_maids: Float
  average_rating: Float
  established_year: Float
  guarantee_period_months: Float
  placement_fee_percentage: Float
  successful_placements: Float
  total_maids: Float
  total_maids_managed: Float
}

"""aggregate stddev_pop on columns"""
type agency_profiles_stddev_pop_fields {
  active_listings: Float
  active_maids: Float
  average_rating: Float
  established_year: Float
  guarantee_period_months: Float
  placement_fee_percentage: Float
  successful_placements: Float
  total_maids: Float
  total_maids_managed: Float
}

"""aggregate stddev_samp on columns"""
type agency_profiles_stddev_samp_fields {
  active_listings: Float
  active_maids: Float
  average_rating: Float
  established_year: Float
  guarantee_period_months: Float
  placement_fee_percentage: Float
  successful_placements: Float
  total_maids: Float
  total_maids_managed: Float
}

"""
Streaming cursor of the table "agency_profiles"
"""
input agency_profiles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: agency_profiles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input agency_profiles_stream_cursor_value_input {
  accreditation_bodies: [String!]
  active_listings: Int
  active_maids: Int
  address: String
  agency_contract_template: String
  agency_description: String
  full_name: String
  authorized_person_email: String
  authorized_person_email_verified: Boolean
  authorized_person_id_document: String
  authorized_person_id_number: String
  authorized_person_id_rejection_reason: String
  authorized_person_id_verification_status: String
  authorized_person_id_verified_at: timestamptz
  authorized_person_id_verified_by: uuid
  authorized_person_name: String
  authorized_person_phone: String
  authorized_person_phone_verified: Boolean
  authorized_person_position: String
  average_rating: numeric
  business_address: String
  business_email: String
  business_phone: String
  certifications: [String!]
  city: String
  contact_person_name: String
  contact_person_title: String
  contact_phone_verified: Boolean
  contract_template_verification_status: String
  country: String
  created_at: timestamptz
  email: String
  emergency_contact_phone: String
  established_year: Int
  guarantee_period_months: Int
  head_office_address: String
  id: String
  license_expiry_date: date
  license_number: String
  license_verified: Boolean
  logo_file_preview: String
  logo_url: String
  official_email_verified: Boolean
  phone: String
  placement_fee_percentage: numeric
  profile_completed_at: timestamptz
  registration_country: String
  service_countries: [String!]
  specialization: [String!]
  subscription_expires_at: timestamptz
  subscription_tier: String
  successful_placements: Int
  support_hours_end: String
  support_hours_start: String
  total_maids: Int
  total_maids_managed: Int
  trade_license_document: String
  trade_license_rejection_reason: String
  trade_license_verification_status: String
  trade_license_verified_at: timestamptz
  trade_license_verified_by: uuid
  updated_at: timestamptz
  verification_status: String
  verified: Boolean
  website: String
  website_url: String
}

"""aggregate sum on columns"""
type agency_profiles_sum_fields {
  active_listings: Int
  active_maids: Int
  average_rating: numeric
  established_year: Int
  guarantee_period_months: Int
  placement_fee_percentage: numeric
  successful_placements: Int
  total_maids: Int
  total_maids_managed: Int
}

"""
update columns of table "agency_profiles"
"""
enum agency_profiles_update_column {
  """column name"""
  accreditation_bodies

  """column name"""
  active_listings

  """column name"""
  active_maids

  """column name"""
  address

  """column name"""
  agency_contract_template

  """column name"""
  agency_description

  """column name"""
  full_name

  """column name"""
  authorized_person_email

  """column name"""
  authorized_person_email_verified

  """column name"""
  authorized_person_id_document

  """column name"""
  authorized_person_id_number

  """column name"""
  authorized_person_id_rejection_reason

  """column name"""
  authorized_person_id_verification_status

  """column name"""
  authorized_person_id_verified_at

  """column name"""
  authorized_person_id_verified_by

  """column name"""
  authorized_person_name

  """column name"""
  authorized_person_phone

  """column name"""
  authorized_person_phone_verified

  """column name"""
  authorized_person_position

  """column name"""
  average_rating

  """column name"""
  business_address

  """column name"""
  business_email

  """column name"""
  business_phone

  """column name"""
  certifications

  """column name"""
  city

  """column name"""
  contact_person_name

  """column name"""
  contact_person_title

  """column name"""
  contact_phone_verified

  """column name"""
  contract_template_verification_status

  """column name"""
  country

  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  emergency_contact_phone

  """column name"""
  established_year

  """column name"""
  guarantee_period_months

  """column name"""
  head_office_address

  """column name"""
  id

  """column name"""
  license_expiry_date

  """column name"""
  license_number

  """column name"""
  license_verified

  """column name"""
  logo_file_preview

  """column name"""
  logo_url

  """column name"""
  official_email_verified

  """column name"""
  phone

  """column name"""
  placement_fee_percentage

  """column name"""
  profile_completed_at

  """column name"""
  registration_country

  """column name"""
  service_countries

  """column name"""
  specialization

  """column name"""
  subscription_expires_at

  """column name"""
  subscription_tier

  """column name"""
  successful_placements

  """column name"""
  support_hours_end

  """column name"""
  support_hours_start

  """column name"""
  total_maids

  """column name"""
  total_maids_managed

  """column name"""
  trade_license_document

  """column name"""
  trade_license_rejection_reason

  """column name"""
  trade_license_verification_status

  """column name"""
  trade_license_verified_at

  """column name"""
  trade_license_verified_by

  """column name"""
  updated_at

  """column name"""
  verification_status

  """column name"""
  verified

  """column name"""
  website

  """column name"""
  website_url
}

input agency_profiles_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: agency_profiles_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: agency_profiles_set_input

  """filter the rows which have to be updated"""
  where: agency_profiles_bool_exp!
}

"""aggregate var_pop on columns"""
type agency_profiles_var_pop_fields {
  active_listings: Float
  active_maids: Float
  average_rating: Float
  established_year: Float
  guarantee_period_months: Float
  placement_fee_percentage: Float
  successful_placements: Float
  total_maids: Float
  total_maids_managed: Float
}

"""aggregate var_samp on columns"""
type agency_profiles_var_samp_fields {
  active_listings: Float
  active_maids: Float
  average_rating: Float
  established_year: Float
  guarantee_period_months: Float
  placement_fee_percentage: Float
  successful_placements: Float
  total_maids: Float
  total_maids_managed: Float
}

"""aggregate variance on columns"""
type agency_profiles_variance_fields {
  active_listings: Float
  active_maids: Float
  average_rating: Float
  established_year: Float
  guarantee_period_months: Float
  placement_fee_percentage: Float
  successful_placements: Float
  total_maids: Float
  total_maids_managed: Float
}

"""Task management for agencies"""
type agency_tasks {
  agency_id: uuid!
  assigned_to_id: uuid
  completed_at: timestamptz
  created_at: timestamptz
  created_by: String
  description: String
  due_date: timestamptz
  estimated_hours: numeric
  id: uuid!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  priority: String
  progress: Int
  related_maid_id: uuid
  related_sponsor_id: uuid
  status: String
  tags: [String!]
  task_type: String
  title: String!
  updated_at: timestamptz

  """An object relationship"""
  user: auth_users!
}

"""
aggregated selection of "agency_tasks"
"""
type agency_tasks_aggregate {
  aggregate: agency_tasks_aggregate_fields
  nodes: [agency_tasks!]!
}

"""
aggregate fields of "agency_tasks"
"""
type agency_tasks_aggregate_fields {
  avg: agency_tasks_avg_fields
  count(columns: [agency_tasks_select_column!], distinct: Boolean): Int!
  max: agency_tasks_max_fields
  min: agency_tasks_min_fields
  stddev: agency_tasks_stddev_fields
  stddev_pop: agency_tasks_stddev_pop_fields
  stddev_samp: agency_tasks_stddev_samp_fields
  sum: agency_tasks_sum_fields
  var_pop: agency_tasks_var_pop_fields
  var_samp: agency_tasks_var_samp_fields
  variance: agency_tasks_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input agency_tasks_append_input {
  metadata: jsonb
}

"""aggregate avg on columns"""
type agency_tasks_avg_fields {
  estimated_hours: Float
  progress: Float
}

"""
Boolean expression to filter rows from the table "agency_tasks". All fields are combined with a logical 'AND'.
"""
input agency_tasks_bool_exp {
  _and: [agency_tasks_bool_exp!]
  _not: agency_tasks_bool_exp
  _or: [agency_tasks_bool_exp!]
  agency_id: uuid_comparison_exp
  assigned_to_id: uuid_comparison_exp
  completed_at: timestamptz_comparison_exp
  created_at: timestamptz_comparison_exp
  created_by: String_comparison_exp
  description: String_comparison_exp
  due_date: timestamptz_comparison_exp
  estimated_hours: numeric_comparison_exp
  id: uuid_comparison_exp
  metadata: jsonb_comparison_exp
  priority: String_comparison_exp
  progress: Int_comparison_exp
  related_maid_id: uuid_comparison_exp
  related_sponsor_id: uuid_comparison_exp
  status: String_comparison_exp
  tags: String_array_comparison_exp
  task_type: String_comparison_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
}

"""
unique or primary key constraints on table "agency_tasks"
"""
enum agency_tasks_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  agency_tasks_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input agency_tasks_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input agency_tasks_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input agency_tasks_delete_key_input {
  metadata: String
}

"""
input type for incrementing numeric columns in table "agency_tasks"
"""
input agency_tasks_inc_input {
  estimated_hours: numeric
  progress: Int
}

"""
input type for inserting data into table "agency_tasks"
"""
input agency_tasks_insert_input {
  agency_id: uuid
  assigned_to_id: uuid
  completed_at: timestamptz
  created_at: timestamptz
  created_by: String
  description: String
  due_date: timestamptz
  estimated_hours: numeric
  id: uuid
  metadata: jsonb
  priority: String
  progress: Int
  related_maid_id: uuid
  related_sponsor_id: uuid
  status: String
  tags: [String!]
  task_type: String
  title: String
  updated_at: timestamptz
  user: auth_users_obj_rel_insert_input
}

"""aggregate max on columns"""
type agency_tasks_max_fields {
  agency_id: uuid
  assigned_to_id: uuid
  completed_at: timestamptz
  created_at: timestamptz
  created_by: String
  description: String
  due_date: timestamptz
  estimated_hours: numeric
  id: uuid
  priority: String
  progress: Int
  related_maid_id: uuid
  related_sponsor_id: uuid
  status: String
  tags: [String!]
  task_type: String
  title: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type agency_tasks_min_fields {
  agency_id: uuid
  assigned_to_id: uuid
  completed_at: timestamptz
  created_at: timestamptz
  created_by: String
  description: String
  due_date: timestamptz
  estimated_hours: numeric
  id: uuid
  priority: String
  progress: Int
  related_maid_id: uuid
  related_sponsor_id: uuid
  status: String
  tags: [String!]
  task_type: String
  title: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "agency_tasks"
"""
type agency_tasks_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [agency_tasks!]!
}

"""
on_conflict condition type for table "agency_tasks"
"""
input agency_tasks_on_conflict {
  constraint: agency_tasks_constraint!
  update_columns: [agency_tasks_update_column!]! = []
  where: agency_tasks_bool_exp
}

"""Ordering options when selecting data from "agency_tasks"."""
input agency_tasks_order_by {
  agency_id: order_by
  assigned_to_id: order_by
  completed_at: order_by
  created_at: order_by
  created_by: order_by
  description: order_by
  due_date: order_by
  estimated_hours: order_by
  id: order_by
  metadata: order_by
  priority: order_by
  progress: order_by
  related_maid_id: order_by
  related_sponsor_id: order_by
  status: order_by
  tags: order_by
  task_type: order_by
  title: order_by
  updated_at: order_by
  user: auth_users_order_by
}

"""primary key columns input for table: agency_tasks"""
input agency_tasks_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input agency_tasks_prepend_input {
  metadata: jsonb
}

"""
select columns of table "agency_tasks"
"""
enum agency_tasks_select_column {
  """column name"""
  agency_id

  """column name"""
  assigned_to_id

  """column name"""
  completed_at

  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  description

  """column name"""
  due_date

  """column name"""
  estimated_hours

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  priority

  """column name"""
  progress

  """column name"""
  related_maid_id

  """column name"""
  related_sponsor_id

  """column name"""
  status

  """column name"""
  tags

  """column name"""
  task_type

  """column name"""
  title

  """column name"""
  updated_at
}

"""
input type for updating data in table "agency_tasks"
"""
input agency_tasks_set_input {
  agency_id: uuid
  assigned_to_id: uuid
  completed_at: timestamptz
  created_at: timestamptz
  created_by: String
  description: String
  due_date: timestamptz
  estimated_hours: numeric
  id: uuid
  metadata: jsonb
  priority: String
  progress: Int
  related_maid_id: uuid
  related_sponsor_id: uuid
  status: String
  tags: [String!]
  task_type: String
  title: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type agency_tasks_stddev_fields {
  estimated_hours: Float
  progress: Float
}

"""aggregate stddev_pop on columns"""
type agency_tasks_stddev_pop_fields {
  estimated_hours: Float
  progress: Float
}

"""aggregate stddev_samp on columns"""
type agency_tasks_stddev_samp_fields {
  estimated_hours: Float
  progress: Float
}

"""
Streaming cursor of the table "agency_tasks"
"""
input agency_tasks_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: agency_tasks_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input agency_tasks_stream_cursor_value_input {
  agency_id: uuid
  assigned_to_id: uuid
  completed_at: timestamptz
  created_at: timestamptz
  created_by: String
  description: String
  due_date: timestamptz
  estimated_hours: numeric
  id: uuid
  metadata: jsonb
  priority: String
  progress: Int
  related_maid_id: uuid
  related_sponsor_id: uuid
  status: String
  tags: [String!]
  task_type: String
  title: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type agency_tasks_sum_fields {
  estimated_hours: numeric
  progress: Int
}

"""
update columns of table "agency_tasks"
"""
enum agency_tasks_update_column {
  """column name"""
  agency_id

  """column name"""
  assigned_to_id

  """column name"""
  completed_at

  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  description

  """column name"""
  due_date

  """column name"""
  estimated_hours

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  priority

  """column name"""
  progress

  """column name"""
  related_maid_id

  """column name"""
  related_sponsor_id

  """column name"""
  status

  """column name"""
  tags

  """column name"""
  task_type

  """column name"""
  title

  """column name"""
  updated_at
}

input agency_tasks_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: agency_tasks_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: agency_tasks_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: agency_tasks_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: agency_tasks_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: agency_tasks_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: agency_tasks_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: agency_tasks_set_input

  """filter the rows which have to be updated"""
  where: agency_tasks_bool_exp!
}

"""aggregate var_pop on columns"""
type agency_tasks_var_pop_fields {
  estimated_hours: Float
  progress: Float
}

"""aggregate var_samp on columns"""
type agency_tasks_var_samp_fields {
  estimated_hours: Float
  progress: Float
}

"""aggregate variance on columns"""
type agency_tasks_variance_fields {
  estimated_hours: Float
  progress: Float
}

"""Stores agency team member information for performance tracking"""
type agency_team_members {
  agency_id: uuid!
  created_at: timestamptz
  email: String
  full_name: String!
  hire_date: date
  id: uuid!
  phone: String
  profile_photo_url: String
  role: String!
  status: String

  """An array relationship"""
  team_member_performances(
    """distinct select on columns"""
    distinct_on: [team_member_performance_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_member_performance_order_by!]

    """filter the rows returned"""
    where: team_member_performance_bool_exp
  ): [team_member_performance!]!

  """An aggregate relationship"""
  team_member_performances_aggregate(
    """distinct select on columns"""
    distinct_on: [team_member_performance_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_member_performance_order_by!]

    """filter the rows returned"""
    where: team_member_performance_bool_exp
  ): team_member_performance_aggregate!
  termination_date: date
  updated_at: timestamptz

  """An object relationship"""
  user: auth_users!

  """An object relationship"""
  userByUserId: auth_users
  user_id: uuid
}

"""
aggregated selection of "agency_team_members"
"""
type agency_team_members_aggregate {
  aggregate: agency_team_members_aggregate_fields
  nodes: [agency_team_members!]!
}

"""
aggregate fields of "agency_team_members"
"""
type agency_team_members_aggregate_fields {
  count(columns: [agency_team_members_select_column!], distinct: Boolean): Int!
  max: agency_team_members_max_fields
  min: agency_team_members_min_fields
}

"""
Boolean expression to filter rows from the table "agency_team_members". All fields are combined with a logical 'AND'.
"""
input agency_team_members_bool_exp {
  _and: [agency_team_members_bool_exp!]
  _not: agency_team_members_bool_exp
  _or: [agency_team_members_bool_exp!]
  agency_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  email: String_comparison_exp
  full_name: String_comparison_exp
  hire_date: date_comparison_exp
  id: uuid_comparison_exp
  phone: String_comparison_exp
  profile_photo_url: String_comparison_exp
  role: String_comparison_exp
  status: String_comparison_exp
  team_member_performances: team_member_performance_bool_exp
  team_member_performances_aggregate: team_member_performance_aggregate_bool_exp
  termination_date: date_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
  userByUserId: auth_users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "agency_team_members"
"""
enum agency_team_members_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  agency_team_members_pkey
}

"""
input type for inserting data into table "agency_team_members"
"""
input agency_team_members_insert_input {
  agency_id: uuid
  created_at: timestamptz
  email: String
  full_name: String
  hire_date: date
  id: uuid
  phone: String
  profile_photo_url: String
  role: String
  status: String
  team_member_performances: team_member_performance_arr_rel_insert_input
  termination_date: date
  updated_at: timestamptz
  user: auth_users_obj_rel_insert_input
  userByUserId: auth_users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type agency_team_members_max_fields {
  agency_id: uuid
  created_at: timestamptz
  email: String
  full_name: String
  hire_date: date
  id: uuid
  phone: String
  profile_photo_url: String
  role: String
  status: String
  termination_date: date
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate min on columns"""
type agency_team_members_min_fields {
  agency_id: uuid
  created_at: timestamptz
  email: String
  full_name: String
  hire_date: date
  id: uuid
  phone: String
  profile_photo_url: String
  role: String
  status: String
  termination_date: date
  updated_at: timestamptz
  user_id: uuid
}

"""
response of any mutation on the table "agency_team_members"
"""
type agency_team_members_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [agency_team_members!]!
}

"""
input type for inserting object relation for remote table "agency_team_members"
"""
input agency_team_members_obj_rel_insert_input {
  data: agency_team_members_insert_input!

  """upsert condition"""
  on_conflict: agency_team_members_on_conflict
}

"""
on_conflict condition type for table "agency_team_members"
"""
input agency_team_members_on_conflict {
  constraint: agency_team_members_constraint!
  update_columns: [agency_team_members_update_column!]! = []
  where: agency_team_members_bool_exp
}

"""Ordering options when selecting data from "agency_team_members"."""
input agency_team_members_order_by {
  agency_id: order_by
  created_at: order_by
  email: order_by
  full_name: order_by
  hire_date: order_by
  id: order_by
  phone: order_by
  profile_photo_url: order_by
  role: order_by
  status: order_by
  team_member_performances_aggregate: team_member_performance_aggregate_order_by
  termination_date: order_by
  updated_at: order_by
  user: auth_users_order_by
  userByUserId: auth_users_order_by
  user_id: order_by
}

"""primary key columns input for table: agency_team_members"""
input agency_team_members_pk_columns_input {
  id: uuid!
}

"""
select columns of table "agency_team_members"
"""
enum agency_team_members_select_column {
  """column name"""
  agency_id

  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  full_name

  """column name"""
  hire_date

  """column name"""
  id

  """column name"""
  phone

  """column name"""
  profile_photo_url

  """column name"""
  role

  """column name"""
  status

  """column name"""
  termination_date

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "agency_team_members"
"""
input agency_team_members_set_input {
  agency_id: uuid
  created_at: timestamptz
  email: String
  full_name: String
  hire_date: date
  id: uuid
  phone: String
  profile_photo_url: String
  role: String
  status: String
  termination_date: date
  updated_at: timestamptz
  user_id: uuid
}

"""
Streaming cursor of the table "agency_team_members"
"""
input agency_team_members_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: agency_team_members_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input agency_team_members_stream_cursor_value_input {
  agency_id: uuid
  created_at: timestamptz
  email: String
  full_name: String
  hire_date: date
  id: uuid
  phone: String
  profile_photo_url: String
  role: String
  status: String
  termination_date: date
  updated_at: timestamptz
  user_id: uuid
}

"""
update columns of table "agency_team_members"
"""
enum agency_team_members_update_column {
  """column name"""
  agency_id

  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  full_name

  """column name"""
  hire_date

  """column name"""
  id

  """column name"""
  phone

  """column name"""
  profile_photo_url

  """column name"""
  role

  """column name"""
  status

  """column name"""
  termination_date

  """column name"""
  updated_at

  """column name"""
  user_id
}

input agency_team_members_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: agency_team_members_set_input

  """filter the rows which have to be updated"""
  where: agency_team_members_bool_exp!
}

"""Caches analytics data to improve performance"""
type analytics_cache {
  agency_id: uuid
  cache_key: String!
  created_at: timestamptz
  data(
    """JSON select path"""
    path: String
  ): jsonb!
  expires_at: timestamptz!
  hit_count: Int
  id: uuid!
  time_range: String

  """An object relationship"""
  user: auth_users
}

"""
aggregated selection of "analytics_cache"
"""
type analytics_cache_aggregate {
  aggregate: analytics_cache_aggregate_fields
  nodes: [analytics_cache!]!
}

"""
aggregate fields of "analytics_cache"
"""
type analytics_cache_aggregate_fields {
  avg: analytics_cache_avg_fields
  count(columns: [analytics_cache_select_column!], distinct: Boolean): Int!
  max: analytics_cache_max_fields
  min: analytics_cache_min_fields
  stddev: analytics_cache_stddev_fields
  stddev_pop: analytics_cache_stddev_pop_fields
  stddev_samp: analytics_cache_stddev_samp_fields
  sum: analytics_cache_sum_fields
  var_pop: analytics_cache_var_pop_fields
  var_samp: analytics_cache_var_samp_fields
  variance: analytics_cache_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input analytics_cache_append_input {
  data: jsonb
}

"""aggregate avg on columns"""
type analytics_cache_avg_fields {
  hit_count: Float
}

"""
Boolean expression to filter rows from the table "analytics_cache". All fields are combined with a logical 'AND'.
"""
input analytics_cache_bool_exp {
  _and: [analytics_cache_bool_exp!]
  _not: analytics_cache_bool_exp
  _or: [analytics_cache_bool_exp!]
  agency_id: uuid_comparison_exp
  cache_key: String_comparison_exp
  created_at: timestamptz_comparison_exp
  data: jsonb_comparison_exp
  expires_at: timestamptz_comparison_exp
  hit_count: Int_comparison_exp
  id: uuid_comparison_exp
  time_range: String_comparison_exp
  user: auth_users_bool_exp
}

"""
unique or primary key constraints on table "analytics_cache"
"""
enum analytics_cache_constraint {
  """
  unique or primary key constraint on columns "cache_key"
  """
  analytics_cache_cache_key_key

  """
  unique or primary key constraint on columns "id"
  """
  analytics_cache_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input analytics_cache_delete_at_path_input {
  data: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input analytics_cache_delete_elem_input {
  data: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input analytics_cache_delete_key_input {
  data: String
}

"""
input type for incrementing numeric columns in table "analytics_cache"
"""
input analytics_cache_inc_input {
  hit_count: Int
}

"""
input type for inserting data into table "analytics_cache"
"""
input analytics_cache_insert_input {
  agency_id: uuid
  cache_key: String
  created_at: timestamptz
  data: jsonb
  expires_at: timestamptz
  hit_count: Int
  id: uuid
  time_range: String
  user: auth_users_obj_rel_insert_input
}

"""aggregate max on columns"""
type analytics_cache_max_fields {
  agency_id: uuid
  cache_key: String
  created_at: timestamptz
  expires_at: timestamptz
  hit_count: Int
  id: uuid
  time_range: String
}

"""aggregate min on columns"""
type analytics_cache_min_fields {
  agency_id: uuid
  cache_key: String
  created_at: timestamptz
  expires_at: timestamptz
  hit_count: Int
  id: uuid
  time_range: String
}

"""
response of any mutation on the table "analytics_cache"
"""
type analytics_cache_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [analytics_cache!]!
}

"""
on_conflict condition type for table "analytics_cache"
"""
input analytics_cache_on_conflict {
  constraint: analytics_cache_constraint!
  update_columns: [analytics_cache_update_column!]! = []
  where: analytics_cache_bool_exp
}

"""Ordering options when selecting data from "analytics_cache"."""
input analytics_cache_order_by {
  agency_id: order_by
  cache_key: order_by
  created_at: order_by
  data: order_by
  expires_at: order_by
  hit_count: order_by
  id: order_by
  time_range: order_by
  user: auth_users_order_by
}

"""primary key columns input for table: analytics_cache"""
input analytics_cache_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input analytics_cache_prepend_input {
  data: jsonb
}

"""
select columns of table "analytics_cache"
"""
enum analytics_cache_select_column {
  """column name"""
  agency_id

  """column name"""
  cache_key

  """column name"""
  created_at

  """column name"""
  data

  """column name"""
  expires_at

  """column name"""
  hit_count

  """column name"""
  id

  """column name"""
  time_range
}

"""
input type for updating data in table "analytics_cache"
"""
input analytics_cache_set_input {
  agency_id: uuid
  cache_key: String
  created_at: timestamptz
  data: jsonb
  expires_at: timestamptz
  hit_count: Int
  id: uuid
  time_range: String
}

"""aggregate stddev on columns"""
type analytics_cache_stddev_fields {
  hit_count: Float
}

"""aggregate stddev_pop on columns"""
type analytics_cache_stddev_pop_fields {
  hit_count: Float
}

"""aggregate stddev_samp on columns"""
type analytics_cache_stddev_samp_fields {
  hit_count: Float
}

"""
Streaming cursor of the table "analytics_cache"
"""
input analytics_cache_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: analytics_cache_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input analytics_cache_stream_cursor_value_input {
  agency_id: uuid
  cache_key: String
  created_at: timestamptz
  data: jsonb
  expires_at: timestamptz
  hit_count: Int
  id: uuid
  time_range: String
}

"""aggregate sum on columns"""
type analytics_cache_sum_fields {
  hit_count: Int
}

"""
update columns of table "analytics_cache"
"""
enum analytics_cache_update_column {
  """column name"""
  agency_id

  """column name"""
  cache_key

  """column name"""
  created_at

  """column name"""
  data

  """column name"""
  expires_at

  """column name"""
  hit_count

  """column name"""
  id

  """column name"""
  time_range
}

input analytics_cache_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: analytics_cache_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: analytics_cache_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: analytics_cache_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: analytics_cache_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: analytics_cache_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: analytics_cache_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: analytics_cache_set_input

  """filter the rows which have to be updated"""
  where: analytics_cache_bool_exp!
}

"""aggregate var_pop on columns"""
type analytics_cache_var_pop_fields {
  hit_count: Float
}

"""aggregate var_samp on columns"""
type analytics_cache_var_samp_fields {
  hit_count: Float
}

"""aggregate variance on columns"""
type analytics_cache_variance_fields {
  hit_count: Float
}

"""Track which users have seen which announcements"""
type announcement_views {
  announcement_id: uuid!
  announcement_type: String!
  id: uuid!

  """An object relationship"""
  user: auth_users
  user_id: uuid
  viewed_at: timestamptz
}

"""
aggregated selection of "announcement_views"
"""
type announcement_views_aggregate {
  aggregate: announcement_views_aggregate_fields
  nodes: [announcement_views!]!
}

"""
aggregate fields of "announcement_views"
"""
type announcement_views_aggregate_fields {
  count(columns: [announcement_views_select_column!], distinct: Boolean): Int!
  max: announcement_views_max_fields
  min: announcement_views_min_fields
}

"""
Boolean expression to filter rows from the table "announcement_views". All fields are combined with a logical 'AND'.
"""
input announcement_views_bool_exp {
  _and: [announcement_views_bool_exp!]
  _not: announcement_views_bool_exp
  _or: [announcement_views_bool_exp!]
  announcement_id: uuid_comparison_exp
  announcement_type: String_comparison_exp
  id: uuid_comparison_exp
  user: auth_users_bool_exp
  user_id: uuid_comparison_exp
  viewed_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "announcement_views"
"""
enum announcement_views_constraint {
  """
  unique or primary key constraint on columns "user_id", "announcement_type", "announcement_id"
  """
  announcement_views_announcement_id_announcement_type_user_i_key

  """
  unique or primary key constraint on columns "id"
  """
  announcement_views_pkey
}

"""
input type for inserting data into table "announcement_views"
"""
input announcement_views_insert_input {
  announcement_id: uuid
  announcement_type: String
  id: uuid
  user: auth_users_obj_rel_insert_input
  user_id: uuid
  viewed_at: timestamptz
}

"""aggregate max on columns"""
type announcement_views_max_fields {
  announcement_id: uuid
  announcement_type: String
  id: uuid
  user_id: uuid
  viewed_at: timestamptz
}

"""aggregate min on columns"""
type announcement_views_min_fields {
  announcement_id: uuid
  announcement_type: String
  id: uuid
  user_id: uuid
  viewed_at: timestamptz
}

"""
response of any mutation on the table "announcement_views"
"""
type announcement_views_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [announcement_views!]!
}

"""
on_conflict condition type for table "announcement_views"
"""
input announcement_views_on_conflict {
  constraint: announcement_views_constraint!
  update_columns: [announcement_views_update_column!]! = []
  where: announcement_views_bool_exp
}

"""Ordering options when selecting data from "announcement_views"."""
input announcement_views_order_by {
  announcement_id: order_by
  announcement_type: order_by
  id: order_by
  user: auth_users_order_by
  user_id: order_by
  viewed_at: order_by
}

"""primary key columns input for table: announcement_views"""
input announcement_views_pk_columns_input {
  id: uuid!
}

"""
select columns of table "announcement_views"
"""
enum announcement_views_select_column {
  """column name"""
  announcement_id

  """column name"""
  announcement_type

  """column name"""
  id

  """column name"""
  user_id

  """column name"""
  viewed_at
}

"""
input type for updating data in table "announcement_views"
"""
input announcement_views_set_input {
  announcement_id: uuid
  announcement_type: String
  id: uuid
  user_id: uuid
  viewed_at: timestamptz
}

"""
Streaming cursor of the table "announcement_views"
"""
input announcement_views_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: announcement_views_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input announcement_views_stream_cursor_value_input {
  announcement_id: uuid
  announcement_type: String
  id: uuid
  user_id: uuid
  viewed_at: timestamptz
}

"""
update columns of table "announcement_views"
"""
enum announcement_views_update_column {
  """column name"""
  announcement_id

  """column name"""
  announcement_type

  """column name"""
  id

  """column name"""
  user_id

  """column name"""
  viewed_at
}

input announcement_views_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: announcement_views_set_input

  """filter the rows which have to be updated"""
  where: announcement_views_bool_exp!
}

"""Stores maid applications to sponsor jobs"""
type applications {
  """Agency managing this application (if applicable)"""
  agency_id: uuid

  """Current status of the application workflow"""
  application_status: String
  background_check_status: String
  cover_letter: String
  created_at: timestamptz
  documents_submitted: Boolean
  hired_date: timestamptz
  id: uuid!
  interview_date: timestamptz
  interview_notes: String

  """An object relationship"""
  job: jobs
  job_id: uuid
  maid_id: String

  """An object relationship"""
  maid_profile: maid_profiles

  """Calculated match score (0-100) based on requirements"""
  match_score: Int
  message: String
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  notes: String
  offer_amount: Int
  offer_currency: String
  offer_date: timestamptz

  """Priority level for processing this application"""
  priority: String
  rejection_reason: String
  response_deadline: timestamptz
  status: String
  updated_at: timestamptz
  viewed_at: timestamptz
  viewed_by_agency: Boolean
}

"""
aggregated selection of "applications"
"""
type applications_aggregate {
  aggregate: applications_aggregate_fields
  nodes: [applications!]!
}

input applications_aggregate_bool_exp {
  bool_and: applications_aggregate_bool_exp_bool_and
  bool_or: applications_aggregate_bool_exp_bool_or
  count: applications_aggregate_bool_exp_count
}

input applications_aggregate_bool_exp_bool_and {
  arguments: applications_select_column_applications_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: applications_bool_exp
  predicate: Boolean_comparison_exp!
}

input applications_aggregate_bool_exp_bool_or {
  arguments: applications_select_column_applications_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: applications_bool_exp
  predicate: Boolean_comparison_exp!
}

input applications_aggregate_bool_exp_count {
  arguments: [applications_select_column!]
  distinct: Boolean
  filter: applications_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "applications"
"""
type applications_aggregate_fields {
  avg: applications_avg_fields
  count(columns: [applications_select_column!], distinct: Boolean): Int!
  max: applications_max_fields
  min: applications_min_fields
  stddev: applications_stddev_fields
  stddev_pop: applications_stddev_pop_fields
  stddev_samp: applications_stddev_samp_fields
  sum: applications_sum_fields
  var_pop: applications_var_pop_fields
  var_samp: applications_var_samp_fields
  variance: applications_variance_fields
}

"""
order by aggregate values of table "applications"
"""
input applications_aggregate_order_by {
  avg: applications_avg_order_by
  count: order_by
  max: applications_max_order_by
  min: applications_min_order_by
  stddev: applications_stddev_order_by
  stddev_pop: applications_stddev_pop_order_by
  stddev_samp: applications_stddev_samp_order_by
  sum: applications_sum_order_by
  var_pop: applications_var_pop_order_by
  var_samp: applications_var_samp_order_by
  variance: applications_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input applications_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "applications"
"""
input applications_arr_rel_insert_input {
  data: [applications_insert_input!]!

  """upsert condition"""
  on_conflict: applications_on_conflict
}

"""aggregate avg on columns"""
type applications_avg_fields {
  """Calculated match score (0-100) based on requirements"""
  match_score: Float
  offer_amount: Float
}

"""
order by avg() on columns of table "applications"
"""
input applications_avg_order_by {
  """Calculated match score (0-100) based on requirements"""
  match_score: order_by
  offer_amount: order_by
}

"""
Boolean expression to filter rows from the table "applications". All fields are combined with a logical 'AND'.
"""
input applications_bool_exp {
  _and: [applications_bool_exp!]
  _not: applications_bool_exp
  _or: [applications_bool_exp!]
  agency_id: uuid_comparison_exp
  application_status: String_comparison_exp
  background_check_status: String_comparison_exp
  cover_letter: String_comparison_exp
  created_at: timestamptz_comparison_exp
  documents_submitted: Boolean_comparison_exp
  hired_date: timestamptz_comparison_exp
  id: uuid_comparison_exp
  interview_date: timestamptz_comparison_exp
  interview_notes: String_comparison_exp
  job: jobs_bool_exp
  job_id: uuid_comparison_exp
  maid_id: String_comparison_exp
  maid_profile: maid_profiles_bool_exp
  match_score: Int_comparison_exp
  message: String_comparison_exp
  metadata: jsonb_comparison_exp
  notes: String_comparison_exp
  offer_amount: Int_comparison_exp
  offer_currency: String_comparison_exp
  offer_date: timestamptz_comparison_exp
  priority: String_comparison_exp
  rejection_reason: String_comparison_exp
  response_deadline: timestamptz_comparison_exp
  status: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  viewed_at: timestamptz_comparison_exp
  viewed_by_agency: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "applications"
"""
enum applications_constraint {
  """
  unique or primary key constraint on columns "job_id", "maid_id"
  """
  applications_job_id_maid_id_key

  """
  unique or primary key constraint on columns "id"
  """
  applications_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input applications_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input applications_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input applications_delete_key_input {
  metadata: String
}

"""
input type for incrementing numeric columns in table "applications"
"""
input applications_inc_input {
  """Calculated match score (0-100) based on requirements"""
  match_score: Int
  offer_amount: Int
}

"""
input type for inserting data into table "applications"
"""
input applications_insert_input {
  """Agency managing this application (if applicable)"""
  agency_id: uuid

  """Current status of the application workflow"""
  application_status: String
  background_check_status: String
  cover_letter: String
  created_at: timestamptz
  documents_submitted: Boolean
  hired_date: timestamptz
  id: uuid
  interview_date: timestamptz
  interview_notes: String
  job: jobs_obj_rel_insert_input
  job_id: uuid
  maid_id: String
  maid_profile: maid_profiles_obj_rel_insert_input

  """Calculated match score (0-100) based on requirements"""
  match_score: Int
  message: String
  metadata: jsonb
  notes: String
  offer_amount: Int
  offer_currency: String
  offer_date: timestamptz

  """Priority level for processing this application"""
  priority: String
  rejection_reason: String
  response_deadline: timestamptz
  status: String
  updated_at: timestamptz
  viewed_at: timestamptz
  viewed_by_agency: Boolean
}

"""aggregate max on columns"""
type applications_max_fields {
  """Agency managing this application (if applicable)"""
  agency_id: uuid

  """Current status of the application workflow"""
  application_status: String
  background_check_status: String
  cover_letter: String
  created_at: timestamptz
  hired_date: timestamptz
  id: uuid
  interview_date: timestamptz
  interview_notes: String
  job_id: uuid
  maid_id: String

  """Calculated match score (0-100) based on requirements"""
  match_score: Int
  message: String
  notes: String
  offer_amount: Int
  offer_currency: String
  offer_date: timestamptz

  """Priority level for processing this application"""
  priority: String
  rejection_reason: String
  response_deadline: timestamptz
  status: String
  updated_at: timestamptz
  viewed_at: timestamptz
}

"""
order by max() on columns of table "applications"
"""
input applications_max_order_by {
  """Agency managing this application (if applicable)"""
  agency_id: order_by

  """Current status of the application workflow"""
  application_status: order_by
  background_check_status: order_by
  cover_letter: order_by
  created_at: order_by
  hired_date: order_by
  id: order_by
  interview_date: order_by
  interview_notes: order_by
  job_id: order_by
  maid_id: order_by

  """Calculated match score (0-100) based on requirements"""
  match_score: order_by
  message: order_by
  notes: order_by
  offer_amount: order_by
  offer_currency: order_by
  offer_date: order_by

  """Priority level for processing this application"""
  priority: order_by
  rejection_reason: order_by
  response_deadline: order_by
  status: order_by
  updated_at: order_by
  viewed_at: order_by
}

"""aggregate min on columns"""
type applications_min_fields {
  """Agency managing this application (if applicable)"""
  agency_id: uuid

  """Current status of the application workflow"""
  application_status: String
  background_check_status: String
  cover_letter: String
  created_at: timestamptz
  hired_date: timestamptz
  id: uuid
  interview_date: timestamptz
  interview_notes: String
  job_id: uuid
  maid_id: String

  """Calculated match score (0-100) based on requirements"""
  match_score: Int
  message: String
  notes: String
  offer_amount: Int
  offer_currency: String
  offer_date: timestamptz

  """Priority level for processing this application"""
  priority: String
  rejection_reason: String
  response_deadline: timestamptz
  status: String
  updated_at: timestamptz
  viewed_at: timestamptz
}

"""
order by min() on columns of table "applications"
"""
input applications_min_order_by {
  """Agency managing this application (if applicable)"""
  agency_id: order_by

  """Current status of the application workflow"""
  application_status: order_by
  background_check_status: order_by
  cover_letter: order_by
  created_at: order_by
  hired_date: order_by
  id: order_by
  interview_date: order_by
  interview_notes: order_by
  job_id: order_by
  maid_id: order_by

  """Calculated match score (0-100) based on requirements"""
  match_score: order_by
  message: order_by
  notes: order_by
  offer_amount: order_by
  offer_currency: order_by
  offer_date: order_by

  """Priority level for processing this application"""
  priority: order_by
  rejection_reason: order_by
  response_deadline: order_by
  status: order_by
  updated_at: order_by
  viewed_at: order_by
}

"""
response of any mutation on the table "applications"
"""
type applications_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [applications!]!
}

"""
on_conflict condition type for table "applications"
"""
input applications_on_conflict {
  constraint: applications_constraint!
  update_columns: [applications_update_column!]! = []
  where: applications_bool_exp
}

"""Ordering options when selecting data from "applications"."""
input applications_order_by {
  agency_id: order_by
  application_status: order_by
  background_check_status: order_by
  cover_letter: order_by
  created_at: order_by
  documents_submitted: order_by
  hired_date: order_by
  id: order_by
  interview_date: order_by
  interview_notes: order_by
  job: jobs_order_by
  job_id: order_by
  maid_id: order_by
  maid_profile: maid_profiles_order_by
  match_score: order_by
  message: order_by
  metadata: order_by
  notes: order_by
  offer_amount: order_by
  offer_currency: order_by
  offer_date: order_by
  priority: order_by
  rejection_reason: order_by
  response_deadline: order_by
  status: order_by
  updated_at: order_by
  viewed_at: order_by
  viewed_by_agency: order_by
}

"""primary key columns input for table: applications"""
input applications_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input applications_prepend_input {
  metadata: jsonb
}

"""
select columns of table "applications"
"""
enum applications_select_column {
  """column name"""
  agency_id

  """column name"""
  application_status

  """column name"""
  background_check_status

  """column name"""
  cover_letter

  """column name"""
  created_at

  """column name"""
  documents_submitted

  """column name"""
  hired_date

  """column name"""
  id

  """column name"""
  interview_date

  """column name"""
  interview_notes

  """column name"""
  job_id

  """column name"""
  maid_id

  """column name"""
  match_score

  """column name"""
  message

  """column name"""
  metadata

  """column name"""
  notes

  """column name"""
  offer_amount

  """column name"""
  offer_currency

  """column name"""
  offer_date

  """column name"""
  priority

  """column name"""
  rejection_reason

  """column name"""
  response_deadline

  """column name"""
  status

  """column name"""
  updated_at

  """column name"""
  viewed_at

  """column name"""
  viewed_by_agency
}

"""
select "applications_aggregate_bool_exp_bool_and_arguments_columns" columns of table "applications"
"""
enum applications_select_column_applications_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  documents_submitted

  """column name"""
  viewed_by_agency
}

"""
select "applications_aggregate_bool_exp_bool_or_arguments_columns" columns of table "applications"
"""
enum applications_select_column_applications_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  documents_submitted

  """column name"""
  viewed_by_agency
}

"""
input type for updating data in table "applications"
"""
input applications_set_input {
  """Agency managing this application (if applicable)"""
  agency_id: uuid

  """Current status of the application workflow"""
  application_status: String
  background_check_status: String
  cover_letter: String
  created_at: timestamptz
  documents_submitted: Boolean
  hired_date: timestamptz
  id: uuid
  interview_date: timestamptz
  interview_notes: String
  job_id: uuid
  maid_id: String

  """Calculated match score (0-100) based on requirements"""
  match_score: Int
  message: String
  metadata: jsonb
  notes: String
  offer_amount: Int
  offer_currency: String
  offer_date: timestamptz

  """Priority level for processing this application"""
  priority: String
  rejection_reason: String
  response_deadline: timestamptz
  status: String
  updated_at: timestamptz
  viewed_at: timestamptz
  viewed_by_agency: Boolean
}

"""aggregate stddev on columns"""
type applications_stddev_fields {
  """Calculated match score (0-100) based on requirements"""
  match_score: Float
  offer_amount: Float
}

"""
order by stddev() on columns of table "applications"
"""
input applications_stddev_order_by {
  """Calculated match score (0-100) based on requirements"""
  match_score: order_by
  offer_amount: order_by
}

"""aggregate stddev_pop on columns"""
type applications_stddev_pop_fields {
  """Calculated match score (0-100) based on requirements"""
  match_score: Float
  offer_amount: Float
}

"""
order by stddev_pop() on columns of table "applications"
"""
input applications_stddev_pop_order_by {
  """Calculated match score (0-100) based on requirements"""
  match_score: order_by
  offer_amount: order_by
}

"""aggregate stddev_samp on columns"""
type applications_stddev_samp_fields {
  """Calculated match score (0-100) based on requirements"""
  match_score: Float
  offer_amount: Float
}

"""
order by stddev_samp() on columns of table "applications"
"""
input applications_stddev_samp_order_by {
  """Calculated match score (0-100) based on requirements"""
  match_score: order_by
  offer_amount: order_by
}

"""
Streaming cursor of the table "applications"
"""
input applications_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: applications_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input applications_stream_cursor_value_input {
  """Agency managing this application (if applicable)"""
  agency_id: uuid

  """Current status of the application workflow"""
  application_status: String
  background_check_status: String
  cover_letter: String
  created_at: timestamptz
  documents_submitted: Boolean
  hired_date: timestamptz
  id: uuid
  interview_date: timestamptz
  interview_notes: String
  job_id: uuid
  maid_id: String

  """Calculated match score (0-100) based on requirements"""
  match_score: Int
  message: String
  metadata: jsonb
  notes: String
  offer_amount: Int
  offer_currency: String
  offer_date: timestamptz

  """Priority level for processing this application"""
  priority: String
  rejection_reason: String
  response_deadline: timestamptz
  status: String
  updated_at: timestamptz
  viewed_at: timestamptz
  viewed_by_agency: Boolean
}

"""aggregate sum on columns"""
type applications_sum_fields {
  """Calculated match score (0-100) based on requirements"""
  match_score: Int
  offer_amount: Int
}

"""
order by sum() on columns of table "applications"
"""
input applications_sum_order_by {
  """Calculated match score (0-100) based on requirements"""
  match_score: order_by
  offer_amount: order_by
}

"""
update columns of table "applications"
"""
enum applications_update_column {
  """column name"""
  agency_id

  """column name"""
  application_status

  """column name"""
  background_check_status

  """column name"""
  cover_letter

  """column name"""
  created_at

  """column name"""
  documents_submitted

  """column name"""
  hired_date

  """column name"""
  id

  """column name"""
  interview_date

  """column name"""
  interview_notes

  """column name"""
  job_id

  """column name"""
  maid_id

  """column name"""
  match_score

  """column name"""
  message

  """column name"""
  metadata

  """column name"""
  notes

  """column name"""
  offer_amount

  """column name"""
  offer_currency

  """column name"""
  offer_date

  """column name"""
  priority

  """column name"""
  rejection_reason

  """column name"""
  response_deadline

  """column name"""
  status

  """column name"""
  updated_at

  """column name"""
  viewed_at

  """column name"""
  viewed_by_agency
}

input applications_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: applications_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: applications_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: applications_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: applications_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: applications_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: applications_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: applications_set_input

  """filter the rows which have to be updated"""
  where: applications_bool_exp!
}

"""aggregate var_pop on columns"""
type applications_var_pop_fields {
  """Calculated match score (0-100) based on requirements"""
  match_score: Float
  offer_amount: Float
}

"""
order by var_pop() on columns of table "applications"
"""
input applications_var_pop_order_by {
  """Calculated match score (0-100) based on requirements"""
  match_score: order_by
  offer_amount: order_by
}

"""aggregate var_samp on columns"""
type applications_var_samp_fields {
  """Calculated match score (0-100) based on requirements"""
  match_score: Float
  offer_amount: Float
}

"""
order by var_samp() on columns of table "applications"
"""
input applications_var_samp_order_by {
  """Calculated match score (0-100) based on requirements"""
  match_score: order_by
  offer_amount: order_by
}

"""aggregate variance on columns"""
type applications_variance_fields {
  """Calculated match score (0-100) based on requirements"""
  match_score: Float
  offer_amount: Float
}

"""
order by variance() on columns of table "applications"
"""
input applications_variance_order_by {
  """Calculated match score (0-100) based on requirements"""
  match_score: order_by
  offer_amount: order_by
}

"""
columns and relationships of "audit_logs"
"""
type audit_logs {
  action: String!
  action_category: String
  actor_email: String
  actor_id: uuid
  actor_ip: String
  actor_type: String
  actor_user_agent: String
  category: String
  created_at: timestamptz
  details(
    """JSON select path"""
    path: String
  ): jsonb
  error_message: String
  id: uuid!
  ip_address: String
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  new_values(
    """JSON select path"""
    path: String
  ): jsonb
  old_values(
    """JSON select path"""
    path: String
  ): jsonb
  resource_id: uuid
  resource_type: String
  severity: String
  success: Boolean
  target_id: uuid
  target_table: String
  target_type: String
  timestamp: timestamptz

  """An object relationship"""
  user: auth_users
  user_agent: String
  user_email: String
  user_id: uuid
}

"""
aggregated selection of "audit_logs"
"""
type audit_logs_aggregate {
  aggregate: audit_logs_aggregate_fields
  nodes: [audit_logs!]!
}

"""
aggregate fields of "audit_logs"
"""
type audit_logs_aggregate_fields {
  count(columns: [audit_logs_select_column!], distinct: Boolean): Int!
  max: audit_logs_max_fields
  min: audit_logs_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input audit_logs_append_input {
  details: jsonb
  metadata: jsonb
  new_values: jsonb
  old_values: jsonb
}

"""
Boolean expression to filter rows from the table "audit_logs". All fields are combined with a logical 'AND'.
"""
input audit_logs_bool_exp {
  _and: [audit_logs_bool_exp!]
  _not: audit_logs_bool_exp
  _or: [audit_logs_bool_exp!]
  action: String_comparison_exp
  action_category: String_comparison_exp
  actor_email: String_comparison_exp
  actor_id: uuid_comparison_exp
  actor_ip: String_comparison_exp
  actor_type: String_comparison_exp
  actor_user_agent: String_comparison_exp
  category: String_comparison_exp
  created_at: timestamptz_comparison_exp
  details: jsonb_comparison_exp
  error_message: String_comparison_exp
  id: uuid_comparison_exp
  ip_address: String_comparison_exp
  metadata: jsonb_comparison_exp
  new_values: jsonb_comparison_exp
  old_values: jsonb_comparison_exp
  resource_id: uuid_comparison_exp
  resource_type: String_comparison_exp
  severity: String_comparison_exp
  success: Boolean_comparison_exp
  target_id: uuid_comparison_exp
  target_table: String_comparison_exp
  target_type: String_comparison_exp
  timestamp: timestamptz_comparison_exp
  user: auth_users_bool_exp
  user_agent: String_comparison_exp
  user_email: String_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "audit_logs"
"""
enum audit_logs_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  audit_logs_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input audit_logs_delete_at_path_input {
  details: [String!]
  metadata: [String!]
  new_values: [String!]
  old_values: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input audit_logs_delete_elem_input {
  details: Int
  metadata: Int
  new_values: Int
  old_values: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input audit_logs_delete_key_input {
  details: String
  metadata: String
  new_values: String
  old_values: String
}

"""
input type for inserting data into table "audit_logs"
"""
input audit_logs_insert_input {
  action: String
  action_category: String
  actor_email: String
  actor_id: uuid
  actor_ip: String
  actor_type: String
  actor_user_agent: String
  category: String
  created_at: timestamptz
  details: jsonb
  error_message: String
  id: uuid
  ip_address: String
  metadata: jsonb
  new_values: jsonb
  old_values: jsonb
  resource_id: uuid
  resource_type: String
  severity: String
  success: Boolean
  target_id: uuid
  target_table: String
  target_type: String
  timestamp: timestamptz
  user: auth_users_obj_rel_insert_input
  user_agent: String
  user_email: String
  user_id: uuid
}

"""aggregate max on columns"""
type audit_logs_max_fields {
  action: String
  action_category: String
  actor_email: String
  actor_id: uuid
  actor_ip: String
  actor_type: String
  actor_user_agent: String
  category: String
  created_at: timestamptz
  error_message: String
  id: uuid
  ip_address: String
  resource_id: uuid
  resource_type: String
  severity: String
  target_id: uuid
  target_table: String
  target_type: String
  timestamp: timestamptz
  user_agent: String
  user_email: String
  user_id: uuid
}

"""aggregate min on columns"""
type audit_logs_min_fields {
  action: String
  action_category: String
  actor_email: String
  actor_id: uuid
  actor_ip: String
  actor_type: String
  actor_user_agent: String
  category: String
  created_at: timestamptz
  error_message: String
  id: uuid
  ip_address: String
  resource_id: uuid
  resource_type: String
  severity: String
  target_id: uuid
  target_table: String
  target_type: String
  timestamp: timestamptz
  user_agent: String
  user_email: String
  user_id: uuid
}

"""
response of any mutation on the table "audit_logs"
"""
type audit_logs_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [audit_logs!]!
}

"""
on_conflict condition type for table "audit_logs"
"""
input audit_logs_on_conflict {
  constraint: audit_logs_constraint!
  update_columns: [audit_logs_update_column!]! = []
  where: audit_logs_bool_exp
}

"""Ordering options when selecting data from "audit_logs"."""
input audit_logs_order_by {
  action: order_by
  action_category: order_by
  actor_email: order_by
  actor_id: order_by
  actor_ip: order_by
  actor_type: order_by
  actor_user_agent: order_by
  category: order_by
  created_at: order_by
  details: order_by
  error_message: order_by
  id: order_by
  ip_address: order_by
  metadata: order_by
  new_values: order_by
  old_values: order_by
  resource_id: order_by
  resource_type: order_by
  severity: order_by
  success: order_by
  target_id: order_by
  target_table: order_by
  target_type: order_by
  timestamp: order_by
  user: auth_users_order_by
  user_agent: order_by
  user_email: order_by
  user_id: order_by
}

"""primary key columns input for table: audit_logs"""
input audit_logs_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input audit_logs_prepend_input {
  details: jsonb
  metadata: jsonb
  new_values: jsonb
  old_values: jsonb
}

"""
select columns of table "audit_logs"
"""
enum audit_logs_select_column {
  """column name"""
  action

  """column name"""
  action_category

  """column name"""
  actor_email

  """column name"""
  actor_id

  """column name"""
  actor_ip

  """column name"""
  actor_type

  """column name"""
  actor_user_agent

  """column name"""
  category

  """column name"""
  created_at

  """column name"""
  details

  """column name"""
  error_message

  """column name"""
  id

  """column name"""
  ip_address

  """column name"""
  metadata

  """column name"""
  new_values

  """column name"""
  old_values

  """column name"""
  resource_id

  """column name"""
  resource_type

  """column name"""
  severity

  """column name"""
  success

  """column name"""
  target_id

  """column name"""
  target_table

  """column name"""
  target_type

  """column name"""
  timestamp

  """column name"""
  user_agent

  """column name"""
  user_email

  """column name"""
  user_id
}

"""
input type for updating data in table "audit_logs"
"""
input audit_logs_set_input {
  action: String
  action_category: String
  actor_email: String
  actor_id: uuid
  actor_ip: String
  actor_type: String
  actor_user_agent: String
  category: String
  created_at: timestamptz
  details: jsonb
  error_message: String
  id: uuid
  ip_address: String
  metadata: jsonb
  new_values: jsonb
  old_values: jsonb
  resource_id: uuid
  resource_type: String
  severity: String
  success: Boolean
  target_id: uuid
  target_table: String
  target_type: String
  timestamp: timestamptz
  user_agent: String
  user_email: String
  user_id: uuid
}

"""
Streaming cursor of the table "audit_logs"
"""
input audit_logs_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: audit_logs_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input audit_logs_stream_cursor_value_input {
  action: String
  action_category: String
  actor_email: String
  actor_id: uuid
  actor_ip: String
  actor_type: String
  actor_user_agent: String
  category: String
  created_at: timestamptz
  details: jsonb
  error_message: String
  id: uuid
  ip_address: String
  metadata: jsonb
  new_values: jsonb
  old_values: jsonb
  resource_id: uuid
  resource_type: String
  severity: String
  success: Boolean
  target_id: uuid
  target_table: String
  target_type: String
  timestamp: timestamptz
  user_agent: String
  user_email: String
  user_id: uuid
}

"""
update columns of table "audit_logs"
"""
enum audit_logs_update_column {
  """column name"""
  action

  """column name"""
  action_category

  """column name"""
  actor_email

  """column name"""
  actor_id

  """column name"""
  actor_ip

  """column name"""
  actor_type

  """column name"""
  actor_user_agent

  """column name"""
  category

  """column name"""
  created_at

  """column name"""
  details

  """column name"""
  error_message

  """column name"""
  id

  """column name"""
  ip_address

  """column name"""
  metadata

  """column name"""
  new_values

  """column name"""
  old_values

  """column name"""
  resource_id

  """column name"""
  resource_type

  """column name"""
  severity

  """column name"""
  success

  """column name"""
  target_id

  """column name"""
  target_table

  """column name"""
  target_type

  """column name"""
  timestamp

  """column name"""
  user_agent

  """column name"""
  user_email

  """column name"""
  user_id
}

input audit_logs_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: audit_logs_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: audit_logs_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: audit_logs_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: audit_logs_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: audit_logs_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: audit_logs_set_input

  """filter the rows which have to be updated"""
  where: audit_logs_bool_exp!
}

"""Auth: Audit trail for user actions."""
type auth_audit_log_entries {
  created_at: timestamptz
  id: uuid!
  instance_id: uuid
  ip_address: String!
  payload(
    """JSON select path"""
    path: String
  ): json
}

"""
aggregated selection of "auth.audit_log_entries"
"""
type auth_audit_log_entries_aggregate {
  aggregate: auth_audit_log_entries_aggregate_fields
  nodes: [auth_audit_log_entries!]!
}

"""
aggregate fields of "auth.audit_log_entries"
"""
type auth_audit_log_entries_aggregate_fields {
  count(columns: [auth_audit_log_entries_select_column!], distinct: Boolean): Int!
  max: auth_audit_log_entries_max_fields
  min: auth_audit_log_entries_min_fields
}

"""
Boolean expression to filter rows from the table "auth.audit_log_entries". All fields are combined with a logical 'AND'.
"""
input auth_audit_log_entries_bool_exp {
  _and: [auth_audit_log_entries_bool_exp!]
  _not: auth_audit_log_entries_bool_exp
  _or: [auth_audit_log_entries_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  instance_id: uuid_comparison_exp
  ip_address: String_comparison_exp
  payload: json_comparison_exp
}

"""
unique or primary key constraints on table "auth.audit_log_entries"
"""
enum auth_audit_log_entries_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  audit_log_entries_pkey
}

"""
input type for inserting data into table "auth.audit_log_entries"
"""
input auth_audit_log_entries_insert_input {
  created_at: timestamptz
  id: uuid
  instance_id: uuid
  ip_address: String
  payload: json
}

"""aggregate max on columns"""
type auth_audit_log_entries_max_fields {
  created_at: timestamptz
  id: uuid
  instance_id: uuid
  ip_address: String
}

"""aggregate min on columns"""
type auth_audit_log_entries_min_fields {
  created_at: timestamptz
  id: uuid
  instance_id: uuid
  ip_address: String
}

"""
response of any mutation on the table "auth.audit_log_entries"
"""
type auth_audit_log_entries_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [auth_audit_log_entries!]!
}

"""
on_conflict condition type for table "auth.audit_log_entries"
"""
input auth_audit_log_entries_on_conflict {
  constraint: auth_audit_log_entries_constraint!
  update_columns: [auth_audit_log_entries_update_column!]! = []
  where: auth_audit_log_entries_bool_exp
}

"""Ordering options when selecting data from "auth.audit_log_entries"."""
input auth_audit_log_entries_order_by {
  created_at: order_by
  id: order_by
  instance_id: order_by
  ip_address: order_by
  payload: order_by
}

"""primary key columns input for table: auth.audit_log_entries"""
input auth_audit_log_entries_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.audit_log_entries"
"""
enum auth_audit_log_entries_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  instance_id

  """column name"""
  ip_address

  """column name"""
  payload
}

"""
input type for updating data in table "auth.audit_log_entries"
"""
input auth_audit_log_entries_set_input {
  created_at: timestamptz
  id: uuid
  instance_id: uuid
  ip_address: String
  payload: json
}

"""
Streaming cursor of the table "auth_audit_log_entries"
"""
input auth_audit_log_entries_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: auth_audit_log_entries_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input auth_audit_log_entries_stream_cursor_value_input {
  created_at: timestamptz
  id: uuid
  instance_id: uuid
  ip_address: String
  payload: json
}

"""
update columns of table "auth.audit_log_entries"
"""
enum auth_audit_log_entries_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  instance_id

  """column name"""
  ip_address

  """column name"""
  payload
}

input auth_audit_log_entries_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: auth_audit_log_entries_set_input

  """filter the rows which have to be updated"""
  where: auth_audit_log_entries_bool_exp!
}

"""stores metadata for pkce logins"""
type auth_flow_state {
  auth_code: String!
  auth_code_issued_at: timestamptz
  authentication_method: String!
  code_challenge: String!
  code_challenge_method: code_challenge_method!
  created_at: timestamptz
  id: uuid!
  provider_access_token: String
  provider_refresh_token: String
  provider_type: String!
  updated_at: timestamptz
  user_id: uuid
}

"""
aggregated selection of "auth.flow_state"
"""
type auth_flow_state_aggregate {
  aggregate: auth_flow_state_aggregate_fields
  nodes: [auth_flow_state!]!
}

"""
aggregate fields of "auth.flow_state"
"""
type auth_flow_state_aggregate_fields {
  count(columns: [auth_flow_state_select_column!], distinct: Boolean): Int!
  max: auth_flow_state_max_fields
  min: auth_flow_state_min_fields
}

"""
Boolean expression to filter rows from the table "auth.flow_state". All fields are combined with a logical 'AND'.
"""
input auth_flow_state_bool_exp {
  _and: [auth_flow_state_bool_exp!]
  _not: auth_flow_state_bool_exp
  _or: [auth_flow_state_bool_exp!]
  auth_code: String_comparison_exp
  auth_code_issued_at: timestamptz_comparison_exp
  authentication_method: String_comparison_exp
  code_challenge: String_comparison_exp
  code_challenge_method: code_challenge_method_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  provider_access_token: String_comparison_exp
  provider_refresh_token: String_comparison_exp
  provider_type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.flow_state"
"""
enum auth_flow_state_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  flow_state_pkey
}

"""
input type for inserting data into table "auth.flow_state"
"""
input auth_flow_state_insert_input {
  auth_code: String
  auth_code_issued_at: timestamptz
  authentication_method: String
  code_challenge: String
  code_challenge_method: code_challenge_method
  created_at: timestamptz
  id: uuid
  provider_access_token: String
  provider_refresh_token: String
  provider_type: String
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate max on columns"""
type auth_flow_state_max_fields {
  auth_code: String
  auth_code_issued_at: timestamptz
  authentication_method: String
  code_challenge: String
  code_challenge_method: code_challenge_method
  created_at: timestamptz
  id: uuid
  provider_access_token: String
  provider_refresh_token: String
  provider_type: String
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate min on columns"""
type auth_flow_state_min_fields {
  auth_code: String
  auth_code_issued_at: timestamptz
  authentication_method: String
  code_challenge: String
  code_challenge_method: code_challenge_method
  created_at: timestamptz
  id: uuid
  provider_access_token: String
  provider_refresh_token: String
  provider_type: String
  updated_at: timestamptz
  user_id: uuid
}

"""
response of any mutation on the table "auth.flow_state"
"""
type auth_flow_state_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [auth_flow_state!]!
}

"""
on_conflict condition type for table "auth.flow_state"
"""
input auth_flow_state_on_conflict {
  constraint: auth_flow_state_constraint!
  update_columns: [auth_flow_state_update_column!]! = []
  where: auth_flow_state_bool_exp
}

"""Ordering options when selecting data from "auth.flow_state"."""
input auth_flow_state_order_by {
  auth_code: order_by
  auth_code_issued_at: order_by
  authentication_method: order_by
  code_challenge: order_by
  code_challenge_method: order_by
  created_at: order_by
  id: order_by
  provider_access_token: order_by
  provider_refresh_token: order_by
  provider_type: order_by
  updated_at: order_by
  user_id: order_by
}

"""primary key columns input for table: auth.flow_state"""
input auth_flow_state_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.flow_state"
"""
enum auth_flow_state_select_column {
  """column name"""
  auth_code

  """column name"""
  auth_code_issued_at

  """column name"""
  authentication_method

  """column name"""
  code_challenge

  """column name"""
  code_challenge_method

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  provider_access_token

  """column name"""
  provider_refresh_token

  """column name"""
  provider_type

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "auth.flow_state"
"""
input auth_flow_state_set_input {
  auth_code: String
  auth_code_issued_at: timestamptz
  authentication_method: String
  code_challenge: String
  code_challenge_method: code_challenge_method
  created_at: timestamptz
  id: uuid
  provider_access_token: String
  provider_refresh_token: String
  provider_type: String
  updated_at: timestamptz
  user_id: uuid
}

"""
Streaming cursor of the table "auth_flow_state"
"""
input auth_flow_state_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: auth_flow_state_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input auth_flow_state_stream_cursor_value_input {
  auth_code: String
  auth_code_issued_at: timestamptz
  authentication_method: String
  code_challenge: String
  code_challenge_method: code_challenge_method
  created_at: timestamptz
  id: uuid
  provider_access_token: String
  provider_refresh_token: String
  provider_type: String
  updated_at: timestamptz
  user_id: uuid
}

"""
update columns of table "auth.flow_state"
"""
enum auth_flow_state_update_column {
  """column name"""
  auth_code

  """column name"""
  auth_code_issued_at

  """column name"""
  authentication_method

  """column name"""
  code_challenge

  """column name"""
  code_challenge_method

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  provider_access_token

  """column name"""
  provider_refresh_token

  """column name"""
  provider_type

  """column name"""
  updated_at

  """column name"""
  user_id
}

input auth_flow_state_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: auth_flow_state_set_input

  """filter the rows which have to be updated"""
  where: auth_flow_state_bool_exp!
}

"""Auth: Stores identities associated to a user."""
type auth_identities {
  created_at: timestamptz

  """
  Auth: Email is a generated column that references the optional email property in the identity_data
  """
  email: String
  id: uuid!
  identity_data(
    """JSON select path"""
    path: String
  ): jsonb!
  last_sign_in_at: timestamptz
  provider: String!
  provider_id: String!
  updated_at: timestamptz
  user_id: uuid!
}

"""
aggregated selection of "auth.identities"
"""
type auth_identities_aggregate {
  aggregate: auth_identities_aggregate_fields
  nodes: [auth_identities!]!
}

"""
aggregate fields of "auth.identities"
"""
type auth_identities_aggregate_fields {
  count(columns: [auth_identities_select_column!], distinct: Boolean): Int!
  max: auth_identities_max_fields
  min: auth_identities_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input auth_identities_append_input {
  identity_data: jsonb
}

"""
Boolean expression to filter rows from the table "auth.identities". All fields are combined with a logical 'AND'.
"""
input auth_identities_bool_exp {
  _and: [auth_identities_bool_exp!]
  _not: auth_identities_bool_exp
  _or: [auth_identities_bool_exp!]
  created_at: timestamptz_comparison_exp
  email: String_comparison_exp
  id: uuid_comparison_exp
  identity_data: jsonb_comparison_exp
  last_sign_in_at: timestamptz_comparison_exp
  provider: String_comparison_exp
  provider_id: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.identities"
"""
enum auth_identities_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  identities_pkey

  """
  unique or primary key constraint on columns "provider", "provider_id"
  """
  identities_provider_id_provider_unique
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input auth_identities_delete_at_path_input {
  identity_data: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input auth_identities_delete_elem_input {
  identity_data: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input auth_identities_delete_key_input {
  identity_data: String
}

"""
input type for inserting data into table "auth.identities"
"""
input auth_identities_insert_input {
  created_at: timestamptz
  id: uuid
  identity_data: jsonb
  last_sign_in_at: timestamptz
  provider: String
  provider_id: String
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate max on columns"""
type auth_identities_max_fields {
  created_at: timestamptz

  """
  Auth: Email is a generated column that references the optional email property in the identity_data
  """
  email: String
  id: uuid
  last_sign_in_at: timestamptz
  provider: String
  provider_id: String
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate min on columns"""
type auth_identities_min_fields {
  created_at: timestamptz

  """
  Auth: Email is a generated column that references the optional email property in the identity_data
  """
  email: String
  id: uuid
  last_sign_in_at: timestamptz
  provider: String
  provider_id: String
  updated_at: timestamptz
  user_id: uuid
}

"""
response of any mutation on the table "auth.identities"
"""
type auth_identities_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [auth_identities!]!
}

"""
on_conflict condition type for table "auth.identities"
"""
input auth_identities_on_conflict {
  constraint: auth_identities_constraint!
  update_columns: [auth_identities_update_column!]! = []
  where: auth_identities_bool_exp
}

"""Ordering options when selecting data from "auth.identities"."""
input auth_identities_order_by {
  created_at: order_by
  email: order_by
  id: order_by
  identity_data: order_by
  last_sign_in_at: order_by
  provider: order_by
  provider_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""primary key columns input for table: auth.identities"""
input auth_identities_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input auth_identities_prepend_input {
  identity_data: jsonb
}

"""
select columns of table "auth.identities"
"""
enum auth_identities_select_column {
  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  id

  """column name"""
  identity_data

  """column name"""
  last_sign_in_at

  """column name"""
  provider

  """column name"""
  provider_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "auth.identities"
"""
input auth_identities_set_input {
  created_at: timestamptz
  id: uuid
  identity_data: jsonb
  last_sign_in_at: timestamptz
  provider: String
  provider_id: String
  updated_at: timestamptz
  user_id: uuid
}

"""
Streaming cursor of the table "auth_identities"
"""
input auth_identities_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: auth_identities_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input auth_identities_stream_cursor_value_input {
  created_at: timestamptz

  """
  Auth: Email is a generated column that references the optional email property in the identity_data
  """
  email: String
  id: uuid
  identity_data: jsonb
  last_sign_in_at: timestamptz
  provider: String
  provider_id: String
  updated_at: timestamptz
  user_id: uuid
}

"""
update columns of table "auth.identities"
"""
enum auth_identities_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  identity_data

  """column name"""
  last_sign_in_at

  """column name"""
  provider

  """column name"""
  provider_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

input auth_identities_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: auth_identities_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: auth_identities_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: auth_identities_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: auth_identities_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: auth_identities_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: auth_identities_set_input

  """filter the rows which have to be updated"""
  where: auth_identities_bool_exp!
}

"""Auth: Manages users across multiple sites."""
type auth_instances {
  created_at: timestamptz
  id: uuid!
  raw_base_config: String
  updated_at: timestamptz
  uuid: uuid
}

"""
aggregated selection of "auth.instances"
"""
type auth_instances_aggregate {
  aggregate: auth_instances_aggregate_fields
  nodes: [auth_instances!]!
}

"""
aggregate fields of "auth.instances"
"""
type auth_instances_aggregate_fields {
  count(columns: [auth_instances_select_column!], distinct: Boolean): Int!
  max: auth_instances_max_fields
  min: auth_instances_min_fields
}

"""
Boolean expression to filter rows from the table "auth.instances". All fields are combined with a logical 'AND'.
"""
input auth_instances_bool_exp {
  _and: [auth_instances_bool_exp!]
  _not: auth_instances_bool_exp
  _or: [auth_instances_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  raw_base_config: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  uuid: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.instances"
"""
enum auth_instances_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  instances_pkey
}

"""
input type for inserting data into table "auth.instances"
"""
input auth_instances_insert_input {
  created_at: timestamptz
  id: uuid
  raw_base_config: String
  updated_at: timestamptz
  uuid: uuid
}

"""aggregate max on columns"""
type auth_instances_max_fields {
  created_at: timestamptz
  id: uuid
  raw_base_config: String
  updated_at: timestamptz
  uuid: uuid
}

"""aggregate min on columns"""
type auth_instances_min_fields {
  created_at: timestamptz
  id: uuid
  raw_base_config: String
  updated_at: timestamptz
  uuid: uuid
}

"""
response of any mutation on the table "auth.instances"
"""
type auth_instances_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [auth_instances!]!
}

"""
on_conflict condition type for table "auth.instances"
"""
input auth_instances_on_conflict {
  constraint: auth_instances_constraint!
  update_columns: [auth_instances_update_column!]! = []
  where: auth_instances_bool_exp
}

"""Ordering options when selecting data from "auth.instances"."""
input auth_instances_order_by {
  created_at: order_by
  id: order_by
  raw_base_config: order_by
  updated_at: order_by
  uuid: order_by
}

"""primary key columns input for table: auth.instances"""
input auth_instances_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.instances"
"""
enum auth_instances_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  raw_base_config

  """column name"""
  updated_at

  """column name"""
  uuid
}

"""
input type for updating data in table "auth.instances"
"""
input auth_instances_set_input {
  created_at: timestamptz
  id: uuid
  raw_base_config: String
  updated_at: timestamptz
  uuid: uuid
}

"""
Streaming cursor of the table "auth_instances"
"""
input auth_instances_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: auth_instances_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input auth_instances_stream_cursor_value_input {
  created_at: timestamptz
  id: uuid
  raw_base_config: String
  updated_at: timestamptz
  uuid: uuid
}

"""
update columns of table "auth.instances"
"""
enum auth_instances_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  raw_base_config

  """column name"""
  updated_at

  """column name"""
  uuid
}

input auth_instances_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: auth_instances_set_input

  """filter the rows which have to be updated"""
  where: auth_instances_bool_exp!
}

"""
auth: stores authenticator method reference claims for multi factor authentication
"""
type auth_mfa_amr_claims {
  authentication_method: String!
  created_at: timestamptz!
  id: uuid!
  session_id: uuid!
  updated_at: timestamptz!
}

"""
aggregated selection of "auth.mfa_amr_claims"
"""
type auth_mfa_amr_claims_aggregate {
  aggregate: auth_mfa_amr_claims_aggregate_fields
  nodes: [auth_mfa_amr_claims!]!
}

"""
aggregate fields of "auth.mfa_amr_claims"
"""
type auth_mfa_amr_claims_aggregate_fields {
  count(columns: [auth_mfa_amr_claims_select_column!], distinct: Boolean): Int!
  max: auth_mfa_amr_claims_max_fields
  min: auth_mfa_amr_claims_min_fields
}

"""
Boolean expression to filter rows from the table "auth.mfa_amr_claims". All fields are combined with a logical 'AND'.
"""
input auth_mfa_amr_claims_bool_exp {
  _and: [auth_mfa_amr_claims_bool_exp!]
  _not: auth_mfa_amr_claims_bool_exp
  _or: [auth_mfa_amr_claims_bool_exp!]
  authentication_method: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  session_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "auth.mfa_amr_claims"
"""
enum auth_mfa_amr_claims_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  amr_id_pk

  """
  unique or primary key constraint on columns "authentication_method", "session_id"
  """
  mfa_amr_claims_session_id_authentication_method_pkey
}

"""
input type for inserting data into table "auth.mfa_amr_claims"
"""
input auth_mfa_amr_claims_insert_input {
  authentication_method: String
  created_at: timestamptz
  id: uuid
  session_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type auth_mfa_amr_claims_max_fields {
  authentication_method: String
  created_at: timestamptz
  id: uuid
  session_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type auth_mfa_amr_claims_min_fields {
  authentication_method: String
  created_at: timestamptz
  id: uuid
  session_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "auth.mfa_amr_claims"
"""
type auth_mfa_amr_claims_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [auth_mfa_amr_claims!]!
}

"""
on_conflict condition type for table "auth.mfa_amr_claims"
"""
input auth_mfa_amr_claims_on_conflict {
  constraint: auth_mfa_amr_claims_constraint!
  update_columns: [auth_mfa_amr_claims_update_column!]! = []
  where: auth_mfa_amr_claims_bool_exp
}

"""Ordering options when selecting data from "auth.mfa_amr_claims"."""
input auth_mfa_amr_claims_order_by {
  authentication_method: order_by
  created_at: order_by
  id: order_by
  session_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: auth.mfa_amr_claims"""
input auth_mfa_amr_claims_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.mfa_amr_claims"
"""
enum auth_mfa_amr_claims_select_column {
  """column name"""
  authentication_method

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  session_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "auth.mfa_amr_claims"
"""
input auth_mfa_amr_claims_set_input {
  authentication_method: String
  created_at: timestamptz
  id: uuid
  session_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "auth_mfa_amr_claims"
"""
input auth_mfa_amr_claims_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: auth_mfa_amr_claims_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input auth_mfa_amr_claims_stream_cursor_value_input {
  authentication_method: String
  created_at: timestamptz
  id: uuid
  session_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "auth.mfa_amr_claims"
"""
enum auth_mfa_amr_claims_update_column {
  """column name"""
  authentication_method

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  session_id

  """column name"""
  updated_at
}

input auth_mfa_amr_claims_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: auth_mfa_amr_claims_set_input

  """filter the rows which have to be updated"""
  where: auth_mfa_amr_claims_bool_exp!
}

"""auth: stores metadata about challenge requests made"""
type auth_mfa_challenges {
  created_at: timestamptz!
  factor_id: uuid!
  id: uuid!
  ip_address: inet!
  otp_code: String
  verified_at: timestamptz
  web_authn_session_data(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
aggregated selection of "auth.mfa_challenges"
"""
type auth_mfa_challenges_aggregate {
  aggregate: auth_mfa_challenges_aggregate_fields
  nodes: [auth_mfa_challenges!]!
}

"""
aggregate fields of "auth.mfa_challenges"
"""
type auth_mfa_challenges_aggregate_fields {
  count(columns: [auth_mfa_challenges_select_column!], distinct: Boolean): Int!
  max: auth_mfa_challenges_max_fields
  min: auth_mfa_challenges_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input auth_mfa_challenges_append_input {
  web_authn_session_data: jsonb
}

"""
Boolean expression to filter rows from the table "auth.mfa_challenges". All fields are combined with a logical 'AND'.
"""
input auth_mfa_challenges_bool_exp {
  _and: [auth_mfa_challenges_bool_exp!]
  _not: auth_mfa_challenges_bool_exp
  _or: [auth_mfa_challenges_bool_exp!]
  created_at: timestamptz_comparison_exp
  factor_id: uuid_comparison_exp
  id: uuid_comparison_exp
  ip_address: inet_comparison_exp
  otp_code: String_comparison_exp
  verified_at: timestamptz_comparison_exp
  web_authn_session_data: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "auth.mfa_challenges"
"""
enum auth_mfa_challenges_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  mfa_challenges_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input auth_mfa_challenges_delete_at_path_input {
  web_authn_session_data: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input auth_mfa_challenges_delete_elem_input {
  web_authn_session_data: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input auth_mfa_challenges_delete_key_input {
  web_authn_session_data: String
}

"""
input type for inserting data into table "auth.mfa_challenges"
"""
input auth_mfa_challenges_insert_input {
  created_at: timestamptz
  factor_id: uuid
  id: uuid
  ip_address: inet
  otp_code: String
  verified_at: timestamptz
  web_authn_session_data: jsonb
}

"""aggregate max on columns"""
type auth_mfa_challenges_max_fields {
  created_at: timestamptz
  factor_id: uuid
  id: uuid
  otp_code: String
  verified_at: timestamptz
}

"""aggregate min on columns"""
type auth_mfa_challenges_min_fields {
  created_at: timestamptz
  factor_id: uuid
  id: uuid
  otp_code: String
  verified_at: timestamptz
}

"""
response of any mutation on the table "auth.mfa_challenges"
"""
type auth_mfa_challenges_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [auth_mfa_challenges!]!
}

"""
on_conflict condition type for table "auth.mfa_challenges"
"""
input auth_mfa_challenges_on_conflict {
  constraint: auth_mfa_challenges_constraint!
  update_columns: [auth_mfa_challenges_update_column!]! = []
  where: auth_mfa_challenges_bool_exp
}

"""Ordering options when selecting data from "auth.mfa_challenges"."""
input auth_mfa_challenges_order_by {
  created_at: order_by
  factor_id: order_by
  id: order_by
  ip_address: order_by
  otp_code: order_by
  verified_at: order_by
  web_authn_session_data: order_by
}

"""primary key columns input for table: auth.mfa_challenges"""
input auth_mfa_challenges_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input auth_mfa_challenges_prepend_input {
  web_authn_session_data: jsonb
}

"""
select columns of table "auth.mfa_challenges"
"""
enum auth_mfa_challenges_select_column {
  """column name"""
  created_at

  """column name"""
  factor_id

  """column name"""
  id

  """column name"""
  ip_address

  """column name"""
  otp_code

  """column name"""
  verified_at

  """column name"""
  web_authn_session_data
}

"""
input type for updating data in table "auth.mfa_challenges"
"""
input auth_mfa_challenges_set_input {
  created_at: timestamptz
  factor_id: uuid
  id: uuid
  ip_address: inet
  otp_code: String
  verified_at: timestamptz
  web_authn_session_data: jsonb
}

"""
Streaming cursor of the table "auth_mfa_challenges"
"""
input auth_mfa_challenges_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: auth_mfa_challenges_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input auth_mfa_challenges_stream_cursor_value_input {
  created_at: timestamptz
  factor_id: uuid
  id: uuid
  ip_address: inet
  otp_code: String
  verified_at: timestamptz
  web_authn_session_data: jsonb
}

"""
update columns of table "auth.mfa_challenges"
"""
enum auth_mfa_challenges_update_column {
  """column name"""
  created_at

  """column name"""
  factor_id

  """column name"""
  id

  """column name"""
  ip_address

  """column name"""
  otp_code

  """column name"""
  verified_at

  """column name"""
  web_authn_session_data
}

input auth_mfa_challenges_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: auth_mfa_challenges_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: auth_mfa_challenges_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: auth_mfa_challenges_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: auth_mfa_challenges_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: auth_mfa_challenges_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: auth_mfa_challenges_set_input

  """filter the rows which have to be updated"""
  where: auth_mfa_challenges_bool_exp!
}

"""auth: stores metadata about factors"""
type auth_mfa_factors {
  created_at: timestamptz!
  factor_type: factor_type!
  friendly_name: String
  id: uuid!
  last_challenged_at: timestamptz

  """
  Stores the latest WebAuthn challenge data including attestation/assertion for customer verification
  """
  last_webauthn_challenge_data(
    """JSON select path"""
    path: String
  ): jsonb
  phone: String
  secret: String
  status: factor_status!
  updated_at: timestamptz!
  user_id: uuid!
  web_authn_aaguid: uuid
  web_authn_credential(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
aggregated selection of "auth.mfa_factors"
"""
type auth_mfa_factors_aggregate {
  aggregate: auth_mfa_factors_aggregate_fields
  nodes: [auth_mfa_factors!]!
}

"""
aggregate fields of "auth.mfa_factors"
"""
type auth_mfa_factors_aggregate_fields {
  count(columns: [auth_mfa_factors_select_column!], distinct: Boolean): Int!
  max: auth_mfa_factors_max_fields
  min: auth_mfa_factors_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input auth_mfa_factors_append_input {
  """
  Stores the latest WebAuthn challenge data including attestation/assertion for customer verification
  """
  last_webauthn_challenge_data: jsonb
  web_authn_credential: jsonb
}

"""
Boolean expression to filter rows from the table "auth.mfa_factors". All fields are combined with a logical 'AND'.
"""
input auth_mfa_factors_bool_exp {
  _and: [auth_mfa_factors_bool_exp!]
  _not: auth_mfa_factors_bool_exp
  _or: [auth_mfa_factors_bool_exp!]
  created_at: timestamptz_comparison_exp
  factor_type: factor_type_comparison_exp
  friendly_name: String_comparison_exp
  id: uuid_comparison_exp
  last_challenged_at: timestamptz_comparison_exp
  last_webauthn_challenge_data: jsonb_comparison_exp
  phone: String_comparison_exp
  secret: String_comparison_exp
  status: factor_status_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: uuid_comparison_exp
  web_authn_aaguid: uuid_comparison_exp
  web_authn_credential: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "auth.mfa_factors"
"""
enum auth_mfa_factors_constraint {
  """
  unique or primary key constraint on columns "last_challenged_at"
  """
  mfa_factors_last_challenged_at_key

  """
  unique or primary key constraint on columns "id"
  """
  mfa_factors_pkey

  """
  unique or primary key constraint on columns "user_id", "friendly_name"
  """
  mfa_factors_user_friendly_name_unique

  """
  unique or primary key constraint on columns "user_id", "phone"
  """
  unique_phone_factor_per_user
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input auth_mfa_factors_delete_at_path_input {
  """
  Stores the latest WebAuthn challenge data including attestation/assertion for customer verification
  """
  last_webauthn_challenge_data: [String!]
  web_authn_credential: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input auth_mfa_factors_delete_elem_input {
  """
  Stores the latest WebAuthn challenge data including attestation/assertion for customer verification
  """
  last_webauthn_challenge_data: Int
  web_authn_credential: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input auth_mfa_factors_delete_key_input {
  """
  Stores the latest WebAuthn challenge data including attestation/assertion for customer verification
  """
  last_webauthn_challenge_data: String
  web_authn_credential: String
}

"""
input type for inserting data into table "auth.mfa_factors"
"""
input auth_mfa_factors_insert_input {
  created_at: timestamptz
  factor_type: factor_type
  friendly_name: String
  id: uuid
  last_challenged_at: timestamptz

  """
  Stores the latest WebAuthn challenge data including attestation/assertion for customer verification
  """
  last_webauthn_challenge_data: jsonb
  phone: String
  secret: String
  status: factor_status
  updated_at: timestamptz
  user_id: uuid
  web_authn_aaguid: uuid
  web_authn_credential: jsonb
}

"""aggregate max on columns"""
type auth_mfa_factors_max_fields {
  created_at: timestamptz
  factor_type: factor_type
  friendly_name: String
  id: uuid
  last_challenged_at: timestamptz
  phone: String
  secret: String
  status: factor_status
  updated_at: timestamptz
  user_id: uuid
  web_authn_aaguid: uuid
}

"""aggregate min on columns"""
type auth_mfa_factors_min_fields {
  created_at: timestamptz
  factor_type: factor_type
  friendly_name: String
  id: uuid
  last_challenged_at: timestamptz
  phone: String
  secret: String
  status: factor_status
  updated_at: timestamptz
  user_id: uuid
  web_authn_aaguid: uuid
}

"""
response of any mutation on the table "auth.mfa_factors"
"""
type auth_mfa_factors_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [auth_mfa_factors!]!
}

"""
on_conflict condition type for table "auth.mfa_factors"
"""
input auth_mfa_factors_on_conflict {
  constraint: auth_mfa_factors_constraint!
  update_columns: [auth_mfa_factors_update_column!]! = []
  where: auth_mfa_factors_bool_exp
}

"""Ordering options when selecting data from "auth.mfa_factors"."""
input auth_mfa_factors_order_by {
  created_at: order_by
  factor_type: order_by
  friendly_name: order_by
  id: order_by
  last_challenged_at: order_by
  last_webauthn_challenge_data: order_by
  phone: order_by
  secret: order_by
  status: order_by
  updated_at: order_by
  user_id: order_by
  web_authn_aaguid: order_by
  web_authn_credential: order_by
}

"""primary key columns input for table: auth.mfa_factors"""
input auth_mfa_factors_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input auth_mfa_factors_prepend_input {
  """
  Stores the latest WebAuthn challenge data including attestation/assertion for customer verification
  """
  last_webauthn_challenge_data: jsonb
  web_authn_credential: jsonb
}

"""
select columns of table "auth.mfa_factors"
"""
enum auth_mfa_factors_select_column {
  """column name"""
  created_at

  """column name"""
  factor_type

  """column name"""
  friendly_name

  """column name"""
  id

  """column name"""
  last_challenged_at

  """column name"""
  last_webauthn_challenge_data

  """column name"""
  phone

  """column name"""
  secret

  """column name"""
  status

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  web_authn_aaguid

  """column name"""
  web_authn_credential
}

"""
input type for updating data in table "auth.mfa_factors"
"""
input auth_mfa_factors_set_input {
  created_at: timestamptz
  factor_type: factor_type
  friendly_name: String
  id: uuid
  last_challenged_at: timestamptz

  """
  Stores the latest WebAuthn challenge data including attestation/assertion for customer verification
  """
  last_webauthn_challenge_data: jsonb
  phone: String
  secret: String
  status: factor_status
  updated_at: timestamptz
  user_id: uuid
  web_authn_aaguid: uuid
  web_authn_credential: jsonb
}

"""
Streaming cursor of the table "auth_mfa_factors"
"""
input auth_mfa_factors_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: auth_mfa_factors_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input auth_mfa_factors_stream_cursor_value_input {
  created_at: timestamptz
  factor_type: factor_type
  friendly_name: String
  id: uuid
  last_challenged_at: timestamptz

  """
  Stores the latest WebAuthn challenge data including attestation/assertion for customer verification
  """
  last_webauthn_challenge_data: jsonb
  phone: String
  secret: String
  status: factor_status
  updated_at: timestamptz
  user_id: uuid
  web_authn_aaguid: uuid
  web_authn_credential: jsonb
}

"""
update columns of table "auth.mfa_factors"
"""
enum auth_mfa_factors_update_column {
  """column name"""
  created_at

  """column name"""
  factor_type

  """column name"""
  friendly_name

  """column name"""
  id

  """column name"""
  last_challenged_at

  """column name"""
  last_webauthn_challenge_data

  """column name"""
  phone

  """column name"""
  secret

  """column name"""
  status

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  web_authn_aaguid

  """column name"""
  web_authn_credential
}

input auth_mfa_factors_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: auth_mfa_factors_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: auth_mfa_factors_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: auth_mfa_factors_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: auth_mfa_factors_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: auth_mfa_factors_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: auth_mfa_factors_set_input

  """filter the rows which have to be updated"""
  where: auth_mfa_factors_bool_exp!
}

"""
columns and relationships of "auth.oauth_authorizations"
"""
type auth_oauth_authorizations {
  approved_at: timestamptz
  authorization_code: String
  authorization_id: String!
  client_id: uuid!
  code_challenge: String
  code_challenge_method: code_challenge_method
  created_at: timestamptz!
  expires_at: timestamptz!
  id: uuid!
  nonce: String
  redirect_uri: String!
  resource: String
  response_type: oauth_response_type!
  scope: String!
  state: String
  status: oauth_authorization_status!
  user_id: uuid
}

"""
aggregated selection of "auth.oauth_authorizations"
"""
type auth_oauth_authorizations_aggregate {
  aggregate: auth_oauth_authorizations_aggregate_fields
  nodes: [auth_oauth_authorizations!]!
}

"""
aggregate fields of "auth.oauth_authorizations"
"""
type auth_oauth_authorizations_aggregate_fields {
  count(columns: [auth_oauth_authorizations_select_column!], distinct: Boolean): Int!
  max: auth_oauth_authorizations_max_fields
  min: auth_oauth_authorizations_min_fields
}

"""
Boolean expression to filter rows from the table "auth.oauth_authorizations". All fields are combined with a logical 'AND'.
"""
input auth_oauth_authorizations_bool_exp {
  _and: [auth_oauth_authorizations_bool_exp!]
  _not: auth_oauth_authorizations_bool_exp
  _or: [auth_oauth_authorizations_bool_exp!]
  approved_at: timestamptz_comparison_exp
  authorization_code: String_comparison_exp
  authorization_id: String_comparison_exp
  client_id: uuid_comparison_exp
  code_challenge: String_comparison_exp
  code_challenge_method: code_challenge_method_comparison_exp
  created_at: timestamptz_comparison_exp
  expires_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  nonce: String_comparison_exp
  redirect_uri: String_comparison_exp
  resource: String_comparison_exp
  response_type: oauth_response_type_comparison_exp
  scope: String_comparison_exp
  state: String_comparison_exp
  status: oauth_authorization_status_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.oauth_authorizations"
"""
enum auth_oauth_authorizations_constraint {
  """
  unique or primary key constraint on columns "authorization_code"
  """
  oauth_authorizations_authorization_code_key

  """
  unique or primary key constraint on columns "authorization_id"
  """
  oauth_authorizations_authorization_id_key

  """
  unique or primary key constraint on columns "id"
  """
  oauth_authorizations_pkey
}

"""
input type for inserting data into table "auth.oauth_authorizations"
"""
input auth_oauth_authorizations_insert_input {
  approved_at: timestamptz
  authorization_code: String
  authorization_id: String
  client_id: uuid
  code_challenge: String
  code_challenge_method: code_challenge_method
  created_at: timestamptz
  expires_at: timestamptz
  id: uuid
  nonce: String
  redirect_uri: String
  resource: String
  response_type: oauth_response_type
  scope: String
  state: String
  status: oauth_authorization_status
  user_id: uuid
}

"""aggregate max on columns"""
type auth_oauth_authorizations_max_fields {
  approved_at: timestamptz
  authorization_code: String
  authorization_id: String
  client_id: uuid
  code_challenge: String
  code_challenge_method: code_challenge_method
  created_at: timestamptz
  expires_at: timestamptz
  id: uuid
  nonce: String
  redirect_uri: String
  resource: String
  response_type: oauth_response_type
  scope: String
  state: String
  status: oauth_authorization_status
  user_id: uuid
}

"""aggregate min on columns"""
type auth_oauth_authorizations_min_fields {
  approved_at: timestamptz
  authorization_code: String
  authorization_id: String
  client_id: uuid
  code_challenge: String
  code_challenge_method: code_challenge_method
  created_at: timestamptz
  expires_at: timestamptz
  id: uuid
  nonce: String
  redirect_uri: String
  resource: String
  response_type: oauth_response_type
  scope: String
  state: String
  status: oauth_authorization_status
  user_id: uuid
}

"""
response of any mutation on the table "auth.oauth_authorizations"
"""
type auth_oauth_authorizations_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [auth_oauth_authorizations!]!
}

"""
on_conflict condition type for table "auth.oauth_authorizations"
"""
input auth_oauth_authorizations_on_conflict {
  constraint: auth_oauth_authorizations_constraint!
  update_columns: [auth_oauth_authorizations_update_column!]! = []
  where: auth_oauth_authorizations_bool_exp
}

"""Ordering options when selecting data from "auth.oauth_authorizations"."""
input auth_oauth_authorizations_order_by {
  approved_at: order_by
  authorization_code: order_by
  authorization_id: order_by
  client_id: order_by
  code_challenge: order_by
  code_challenge_method: order_by
  created_at: order_by
  expires_at: order_by
  id: order_by
  nonce: order_by
  redirect_uri: order_by
  resource: order_by
  response_type: order_by
  scope: order_by
  state: order_by
  status: order_by
  user_id: order_by
}

"""primary key columns input for table: auth.oauth_authorizations"""
input auth_oauth_authorizations_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.oauth_authorizations"
"""
enum auth_oauth_authorizations_select_column {
  """column name"""
  approved_at

  """column name"""
  authorization_code

  """column name"""
  authorization_id

  """column name"""
  client_id

  """column name"""
  code_challenge

  """column name"""
  code_challenge_method

  """column name"""
  created_at

  """column name"""
  expires_at

  """column name"""
  id

  """column name"""
  nonce

  """column name"""
  redirect_uri

  """column name"""
  resource

  """column name"""
  response_type

  """column name"""
  scope

  """column name"""
  state

  """column name"""
  status

  """column name"""
  user_id
}

"""
input type for updating data in table "auth.oauth_authorizations"
"""
input auth_oauth_authorizations_set_input {
  approved_at: timestamptz
  authorization_code: String
  authorization_id: String
  client_id: uuid
  code_challenge: String
  code_challenge_method: code_challenge_method
  created_at: timestamptz
  expires_at: timestamptz
  id: uuid
  nonce: String
  redirect_uri: String
  resource: String
  response_type: oauth_response_type
  scope: String
  state: String
  status: oauth_authorization_status
  user_id: uuid
}

"""
Streaming cursor of the table "auth_oauth_authorizations"
"""
input auth_oauth_authorizations_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: auth_oauth_authorizations_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input auth_oauth_authorizations_stream_cursor_value_input {
  approved_at: timestamptz
  authorization_code: String
  authorization_id: String
  client_id: uuid
  code_challenge: String
  code_challenge_method: code_challenge_method
  created_at: timestamptz
  expires_at: timestamptz
  id: uuid
  nonce: String
  redirect_uri: String
  resource: String
  response_type: oauth_response_type
  scope: String
  state: String
  status: oauth_authorization_status
  user_id: uuid
}

"""
update columns of table "auth.oauth_authorizations"
"""
enum auth_oauth_authorizations_update_column {
  """column name"""
  approved_at

  """column name"""
  authorization_code

  """column name"""
  authorization_id

  """column name"""
  client_id

  """column name"""
  code_challenge

  """column name"""
  code_challenge_method

  """column name"""
  created_at

  """column name"""
  expires_at

  """column name"""
  id

  """column name"""
  nonce

  """column name"""
  redirect_uri

  """column name"""
  resource

  """column name"""
  response_type

  """column name"""
  scope

  """column name"""
  state

  """column name"""
  status

  """column name"""
  user_id
}

input auth_oauth_authorizations_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: auth_oauth_authorizations_set_input

  """filter the rows which have to be updated"""
  where: auth_oauth_authorizations_bool_exp!
}

"""
columns and relationships of "auth.oauth_clients"
"""
type auth_oauth_clients {
  client_name: String
  client_secret_hash: String
  client_type: oauth_client_type!
  client_uri: String
  created_at: timestamptz!
  deleted_at: timestamptz
  grant_types: String!
  id: uuid!
  logo_uri: String
  redirect_uris: String!
  registration_type: oauth_registration_type!
  updated_at: timestamptz!
}

"""
aggregated selection of "auth.oauth_clients"
"""
type auth_oauth_clients_aggregate {
  aggregate: auth_oauth_clients_aggregate_fields
  nodes: [auth_oauth_clients!]!
}

"""
aggregate fields of "auth.oauth_clients"
"""
type auth_oauth_clients_aggregate_fields {
  count(columns: [auth_oauth_clients_select_column!], distinct: Boolean): Int!
  max: auth_oauth_clients_max_fields
  min: auth_oauth_clients_min_fields
}

"""
Boolean expression to filter rows from the table "auth.oauth_clients". All fields are combined with a logical 'AND'.
"""
input auth_oauth_clients_bool_exp {
  _and: [auth_oauth_clients_bool_exp!]
  _not: auth_oauth_clients_bool_exp
  _or: [auth_oauth_clients_bool_exp!]
  client_name: String_comparison_exp
  client_secret_hash: String_comparison_exp
  client_type: oauth_client_type_comparison_exp
  client_uri: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  grant_types: String_comparison_exp
  id: uuid_comparison_exp
  logo_uri: String_comparison_exp
  redirect_uris: String_comparison_exp
  registration_type: oauth_registration_type_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "auth.oauth_clients"
"""
enum auth_oauth_clients_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  oauth_clients_pkey
}

"""
input type for inserting data into table "auth.oauth_clients"
"""
input auth_oauth_clients_insert_input {
  client_name: String
  client_secret_hash: String
  client_type: oauth_client_type
  client_uri: String
  created_at: timestamptz
  deleted_at: timestamptz
  grant_types: String
  id: uuid
  logo_uri: String
  redirect_uris: String
  registration_type: oauth_registration_type
  updated_at: timestamptz
}

"""aggregate max on columns"""
type auth_oauth_clients_max_fields {
  client_name: String
  client_secret_hash: String
  client_type: oauth_client_type
  client_uri: String
  created_at: timestamptz
  deleted_at: timestamptz
  grant_types: String
  id: uuid
  logo_uri: String
  redirect_uris: String
  registration_type: oauth_registration_type
  updated_at: timestamptz
}

"""aggregate min on columns"""
type auth_oauth_clients_min_fields {
  client_name: String
  client_secret_hash: String
  client_type: oauth_client_type
  client_uri: String
  created_at: timestamptz
  deleted_at: timestamptz
  grant_types: String
  id: uuid
  logo_uri: String
  redirect_uris: String
  registration_type: oauth_registration_type
  updated_at: timestamptz
}

"""
response of any mutation on the table "auth.oauth_clients"
"""
type auth_oauth_clients_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [auth_oauth_clients!]!
}

"""
on_conflict condition type for table "auth.oauth_clients"
"""
input auth_oauth_clients_on_conflict {
  constraint: auth_oauth_clients_constraint!
  update_columns: [auth_oauth_clients_update_column!]! = []
  where: auth_oauth_clients_bool_exp
}

"""Ordering options when selecting data from "auth.oauth_clients"."""
input auth_oauth_clients_order_by {
  client_name: order_by
  client_secret_hash: order_by
  client_type: order_by
  client_uri: order_by
  created_at: order_by
  deleted_at: order_by
  grant_types: order_by
  id: order_by
  logo_uri: order_by
  redirect_uris: order_by
  registration_type: order_by
  updated_at: order_by
}

"""primary key columns input for table: auth.oauth_clients"""
input auth_oauth_clients_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.oauth_clients"
"""
enum auth_oauth_clients_select_column {
  """column name"""
  client_name

  """column name"""
  client_secret_hash

  """column name"""
  client_type

  """column name"""
  client_uri

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  grant_types

  """column name"""
  id

  """column name"""
  logo_uri

  """column name"""
  redirect_uris

  """column name"""
  registration_type

  """column name"""
  updated_at
}

"""
input type for updating data in table "auth.oauth_clients"
"""
input auth_oauth_clients_set_input {
  client_name: String
  client_secret_hash: String
  client_type: oauth_client_type
  client_uri: String
  created_at: timestamptz
  deleted_at: timestamptz
  grant_types: String
  id: uuid
  logo_uri: String
  redirect_uris: String
  registration_type: oauth_registration_type
  updated_at: timestamptz
}

"""
Streaming cursor of the table "auth_oauth_clients"
"""
input auth_oauth_clients_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: auth_oauth_clients_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input auth_oauth_clients_stream_cursor_value_input {
  client_name: String
  client_secret_hash: String
  client_type: oauth_client_type
  client_uri: String
  created_at: timestamptz
  deleted_at: timestamptz
  grant_types: String
  id: uuid
  logo_uri: String
  redirect_uris: String
  registration_type: oauth_registration_type
  updated_at: timestamptz
}

"""
update columns of table "auth.oauth_clients"
"""
enum auth_oauth_clients_update_column {
  """column name"""
  client_name

  """column name"""
  client_secret_hash

  """column name"""
  client_type

  """column name"""
  client_uri

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  grant_types

  """column name"""
  id

  """column name"""
  logo_uri

  """column name"""
  redirect_uris

  """column name"""
  registration_type

  """column name"""
  updated_at
}

input auth_oauth_clients_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: auth_oauth_clients_set_input

  """filter the rows which have to be updated"""
  where: auth_oauth_clients_bool_exp!
}

"""
columns and relationships of "auth.oauth_consents"
"""
type auth_oauth_consents {
  client_id: uuid!
  granted_at: timestamptz!
  id: uuid!
  revoked_at: timestamptz
  scopes: String!
  user_id: uuid!
}

"""
aggregated selection of "auth.oauth_consents"
"""
type auth_oauth_consents_aggregate {
  aggregate: auth_oauth_consents_aggregate_fields
  nodes: [auth_oauth_consents!]!
}

"""
aggregate fields of "auth.oauth_consents"
"""
type auth_oauth_consents_aggregate_fields {
  count(columns: [auth_oauth_consents_select_column!], distinct: Boolean): Int!
  max: auth_oauth_consents_max_fields
  min: auth_oauth_consents_min_fields
}

"""
Boolean expression to filter rows from the table "auth.oauth_consents". All fields are combined with a logical 'AND'.
"""
input auth_oauth_consents_bool_exp {
  _and: [auth_oauth_consents_bool_exp!]
  _not: auth_oauth_consents_bool_exp
  _or: [auth_oauth_consents_bool_exp!]
  client_id: uuid_comparison_exp
  granted_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  revoked_at: timestamptz_comparison_exp
  scopes: String_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.oauth_consents"
"""
enum auth_oauth_consents_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  oauth_consents_pkey

  """
  unique or primary key constraint on columns "user_id", "client_id"
  """
  oauth_consents_user_client_unique
}

"""
input type for inserting data into table "auth.oauth_consents"
"""
input auth_oauth_consents_insert_input {
  client_id: uuid
  granted_at: timestamptz
  id: uuid
  revoked_at: timestamptz
  scopes: String
  user_id: uuid
}

"""aggregate max on columns"""
type auth_oauth_consents_max_fields {
  client_id: uuid
  granted_at: timestamptz
  id: uuid
  revoked_at: timestamptz
  scopes: String
  user_id: uuid
}

"""aggregate min on columns"""
type auth_oauth_consents_min_fields {
  client_id: uuid
  granted_at: timestamptz
  id: uuid
  revoked_at: timestamptz
  scopes: String
  user_id: uuid
}

"""
response of any mutation on the table "auth.oauth_consents"
"""
type auth_oauth_consents_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [auth_oauth_consents!]!
}

"""
on_conflict condition type for table "auth.oauth_consents"
"""
input auth_oauth_consents_on_conflict {
  constraint: auth_oauth_consents_constraint!
  update_columns: [auth_oauth_consents_update_column!]! = []
  where: auth_oauth_consents_bool_exp
}

"""Ordering options when selecting data from "auth.oauth_consents"."""
input auth_oauth_consents_order_by {
  client_id: order_by
  granted_at: order_by
  id: order_by
  revoked_at: order_by
  scopes: order_by
  user_id: order_by
}

"""primary key columns input for table: auth.oauth_consents"""
input auth_oauth_consents_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.oauth_consents"
"""
enum auth_oauth_consents_select_column {
  """column name"""
  client_id

  """column name"""
  granted_at

  """column name"""
  id

  """column name"""
  revoked_at

  """column name"""
  scopes

  """column name"""
  user_id
}

"""
input type for updating data in table "auth.oauth_consents"
"""
input auth_oauth_consents_set_input {
  client_id: uuid
  granted_at: timestamptz
  id: uuid
  revoked_at: timestamptz
  scopes: String
  user_id: uuid
}

"""
Streaming cursor of the table "auth_oauth_consents"
"""
input auth_oauth_consents_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: auth_oauth_consents_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input auth_oauth_consents_stream_cursor_value_input {
  client_id: uuid
  granted_at: timestamptz
  id: uuid
  revoked_at: timestamptz
  scopes: String
  user_id: uuid
}

"""
update columns of table "auth.oauth_consents"
"""
enum auth_oauth_consents_update_column {
  """column name"""
  client_id

  """column name"""
  granted_at

  """column name"""
  id

  """column name"""
  revoked_at

  """column name"""
  scopes

  """column name"""
  user_id
}

input auth_oauth_consents_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: auth_oauth_consents_set_input

  """filter the rows which have to be updated"""
  where: auth_oauth_consents_bool_exp!
}

"""
columns and relationships of "auth.one_time_tokens"
"""
type auth_one_time_tokens {
  created_at: timestamp!
  id: uuid!
  relates_to: String!
  token_hash: String!
  token_type: one_time_token_type!
  updated_at: timestamp!
  user_id: uuid!
}

"""
aggregated selection of "auth.one_time_tokens"
"""
type auth_one_time_tokens_aggregate {
  aggregate: auth_one_time_tokens_aggregate_fields
  nodes: [auth_one_time_tokens!]!
}

"""
aggregate fields of "auth.one_time_tokens"
"""
type auth_one_time_tokens_aggregate_fields {
  count(columns: [auth_one_time_tokens_select_column!], distinct: Boolean): Int!
  max: auth_one_time_tokens_max_fields
  min: auth_one_time_tokens_min_fields
}

"""
Boolean expression to filter rows from the table "auth.one_time_tokens". All fields are combined with a logical 'AND'.
"""
input auth_one_time_tokens_bool_exp {
  _and: [auth_one_time_tokens_bool_exp!]
  _not: auth_one_time_tokens_bool_exp
  _or: [auth_one_time_tokens_bool_exp!]
  created_at: timestamp_comparison_exp
  id: uuid_comparison_exp
  relates_to: String_comparison_exp
  token_hash: String_comparison_exp
  token_type: one_time_token_type_comparison_exp
  updated_at: timestamp_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.one_time_tokens"
"""
enum auth_one_time_tokens_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  one_time_tokens_pkey

  """
  unique or primary key constraint on columns "user_id", "token_type"
  """
  one_time_tokens_user_id_token_type_key
}

"""
input type for inserting data into table "auth.one_time_tokens"
"""
input auth_one_time_tokens_insert_input {
  created_at: timestamp
  id: uuid
  relates_to: String
  token_hash: String
  token_type: one_time_token_type
  updated_at: timestamp
  user_id: uuid
}

"""aggregate max on columns"""
type auth_one_time_tokens_max_fields {
  created_at: timestamp
  id: uuid
  relates_to: String
  token_hash: String
  token_type: one_time_token_type
  updated_at: timestamp
  user_id: uuid
}

"""aggregate min on columns"""
type auth_one_time_tokens_min_fields {
  created_at: timestamp
  id: uuid
  relates_to: String
  token_hash: String
  token_type: one_time_token_type
  updated_at: timestamp
  user_id: uuid
}

"""
response of any mutation on the table "auth.one_time_tokens"
"""
type auth_one_time_tokens_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [auth_one_time_tokens!]!
}

"""
on_conflict condition type for table "auth.one_time_tokens"
"""
input auth_one_time_tokens_on_conflict {
  constraint: auth_one_time_tokens_constraint!
  update_columns: [auth_one_time_tokens_update_column!]! = []
  where: auth_one_time_tokens_bool_exp
}

"""Ordering options when selecting data from "auth.one_time_tokens"."""
input auth_one_time_tokens_order_by {
  created_at: order_by
  id: order_by
  relates_to: order_by
  token_hash: order_by
  token_type: order_by
  updated_at: order_by
  user_id: order_by
}

"""primary key columns input for table: auth.one_time_tokens"""
input auth_one_time_tokens_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.one_time_tokens"
"""
enum auth_one_time_tokens_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  relates_to

  """column name"""
  token_hash

  """column name"""
  token_type

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "auth.one_time_tokens"
"""
input auth_one_time_tokens_set_input {
  created_at: timestamp
  id: uuid
  relates_to: String
  token_hash: String
  token_type: one_time_token_type
  updated_at: timestamp
  user_id: uuid
}

"""
Streaming cursor of the table "auth_one_time_tokens"
"""
input auth_one_time_tokens_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: auth_one_time_tokens_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input auth_one_time_tokens_stream_cursor_value_input {
  created_at: timestamp
  id: uuid
  relates_to: String
  token_hash: String
  token_type: one_time_token_type
  updated_at: timestamp
  user_id: uuid
}

"""
update columns of table "auth.one_time_tokens"
"""
enum auth_one_time_tokens_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  relates_to

  """column name"""
  token_hash

  """column name"""
  token_type

  """column name"""
  updated_at

  """column name"""
  user_id
}

input auth_one_time_tokens_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: auth_one_time_tokens_set_input

  """filter the rows which have to be updated"""
  where: auth_one_time_tokens_bool_exp!
}

"""Auth: Store of tokens used to refresh JWT tokens once they expire."""
type auth_refresh_tokens {
  created_at: timestamptz
  id: bigint!
  instance_id: uuid
  parent: String
  revoked: Boolean
  session_id: uuid
  token: String
  updated_at: timestamptz
  user_id: String
}

"""
aggregated selection of "auth.refresh_tokens"
"""
type auth_refresh_tokens_aggregate {
  aggregate: auth_refresh_tokens_aggregate_fields
  nodes: [auth_refresh_tokens!]!
}

"""
aggregate fields of "auth.refresh_tokens"
"""
type auth_refresh_tokens_aggregate_fields {
  avg: auth_refresh_tokens_avg_fields
  count(columns: [auth_refresh_tokens_select_column!], distinct: Boolean): Int!
  max: auth_refresh_tokens_max_fields
  min: auth_refresh_tokens_min_fields
  stddev: auth_refresh_tokens_stddev_fields
  stddev_pop: auth_refresh_tokens_stddev_pop_fields
  stddev_samp: auth_refresh_tokens_stddev_samp_fields
  sum: auth_refresh_tokens_sum_fields
  var_pop: auth_refresh_tokens_var_pop_fields
  var_samp: auth_refresh_tokens_var_samp_fields
  variance: auth_refresh_tokens_variance_fields
}

"""aggregate avg on columns"""
type auth_refresh_tokens_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "auth.refresh_tokens". All fields are combined with a logical 'AND'.
"""
input auth_refresh_tokens_bool_exp {
  _and: [auth_refresh_tokens_bool_exp!]
  _not: auth_refresh_tokens_bool_exp
  _or: [auth_refresh_tokens_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: bigint_comparison_exp
  instance_id: uuid_comparison_exp
  parent: String_comparison_exp
  revoked: Boolean_comparison_exp
  session_id: uuid_comparison_exp
  token: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "auth.refresh_tokens"
"""
enum auth_refresh_tokens_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  refresh_tokens_pkey

  """
  unique or primary key constraint on columns "token"
  """
  refresh_tokens_token_unique
}

"""
input type for incrementing numeric columns in table "auth.refresh_tokens"
"""
input auth_refresh_tokens_inc_input {
  id: bigint
}

"""
input type for inserting data into table "auth.refresh_tokens"
"""
input auth_refresh_tokens_insert_input {
  created_at: timestamptz
  id: bigint
  instance_id: uuid
  parent: String
  revoked: Boolean
  session_id: uuid
  token: String
  updated_at: timestamptz
  user_id: String
}

"""aggregate max on columns"""
type auth_refresh_tokens_max_fields {
  created_at: timestamptz
  id: bigint
  instance_id: uuid
  parent: String
  session_id: uuid
  token: String
  updated_at: timestamptz
  user_id: String
}

"""aggregate min on columns"""
type auth_refresh_tokens_min_fields {
  created_at: timestamptz
  id: bigint
  instance_id: uuid
  parent: String
  session_id: uuid
  token: String
  updated_at: timestamptz
  user_id: String
}

"""
response of any mutation on the table "auth.refresh_tokens"
"""
type auth_refresh_tokens_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [auth_refresh_tokens!]!
}

"""
on_conflict condition type for table "auth.refresh_tokens"
"""
input auth_refresh_tokens_on_conflict {
  constraint: auth_refresh_tokens_constraint!
  update_columns: [auth_refresh_tokens_update_column!]! = []
  where: auth_refresh_tokens_bool_exp
}

"""Ordering options when selecting data from "auth.refresh_tokens"."""
input auth_refresh_tokens_order_by {
  created_at: order_by
  id: order_by
  instance_id: order_by
  parent: order_by
  revoked: order_by
  session_id: order_by
  token: order_by
  updated_at: order_by
  user_id: order_by
}

"""primary key columns input for table: auth.refresh_tokens"""
input auth_refresh_tokens_pk_columns_input {
  id: bigint!
}

"""
select columns of table "auth.refresh_tokens"
"""
enum auth_refresh_tokens_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  instance_id

  """column name"""
  parent

  """column name"""
  revoked

  """column name"""
  session_id

  """column name"""
  token

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "auth.refresh_tokens"
"""
input auth_refresh_tokens_set_input {
  created_at: timestamptz
  id: bigint
  instance_id: uuid
  parent: String
  revoked: Boolean
  session_id: uuid
  token: String
  updated_at: timestamptz
  user_id: String
}

"""aggregate stddev on columns"""
type auth_refresh_tokens_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type auth_refresh_tokens_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type auth_refresh_tokens_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "auth_refresh_tokens"
"""
input auth_refresh_tokens_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: auth_refresh_tokens_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input auth_refresh_tokens_stream_cursor_value_input {
  created_at: timestamptz
  id: bigint
  instance_id: uuid
  parent: String
  revoked: Boolean
  session_id: uuid
  token: String
  updated_at: timestamptz
  user_id: String
}

"""aggregate sum on columns"""
type auth_refresh_tokens_sum_fields {
  id: bigint
}

"""
update columns of table "auth.refresh_tokens"
"""
enum auth_refresh_tokens_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  instance_id

  """column name"""
  parent

  """column name"""
  revoked

  """column name"""
  session_id

  """column name"""
  token

  """column name"""
  updated_at

  """column name"""
  user_id
}

input auth_refresh_tokens_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: auth_refresh_tokens_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: auth_refresh_tokens_set_input

  """filter the rows which have to be updated"""
  where: auth_refresh_tokens_bool_exp!
}

"""aggregate var_pop on columns"""
type auth_refresh_tokens_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type auth_refresh_tokens_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type auth_refresh_tokens_variance_fields {
  id: Float
}

"""Auth: Manages SAML Identity Provider connections."""
type auth_saml_providers {
  attribute_mapping(
    """JSON select path"""
    path: String
  ): jsonb
  created_at: timestamptz
  entity_id: String!
  id: uuid!
  metadata_url: String
  metadata_xml: String!
  name_id_format: String
  sso_provider_id: uuid!
  updated_at: timestamptz
}

"""
aggregated selection of "auth.saml_providers"
"""
type auth_saml_providers_aggregate {
  aggregate: auth_saml_providers_aggregate_fields
  nodes: [auth_saml_providers!]!
}

"""
aggregate fields of "auth.saml_providers"
"""
type auth_saml_providers_aggregate_fields {
  count(columns: [auth_saml_providers_select_column!], distinct: Boolean): Int!
  max: auth_saml_providers_max_fields
  min: auth_saml_providers_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input auth_saml_providers_append_input {
  attribute_mapping: jsonb
}

"""
Boolean expression to filter rows from the table "auth.saml_providers". All fields are combined with a logical 'AND'.
"""
input auth_saml_providers_bool_exp {
  _and: [auth_saml_providers_bool_exp!]
  _not: auth_saml_providers_bool_exp
  _or: [auth_saml_providers_bool_exp!]
  attribute_mapping: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  entity_id: String_comparison_exp
  id: uuid_comparison_exp
  metadata_url: String_comparison_exp
  metadata_xml: String_comparison_exp
  name_id_format: String_comparison_exp
  sso_provider_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "auth.saml_providers"
"""
enum auth_saml_providers_constraint {
  """
  unique or primary key constraint on columns "entity_id"
  """
  saml_providers_entity_id_key

  """
  unique or primary key constraint on columns "id"
  """
  saml_providers_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input auth_saml_providers_delete_at_path_input {
  attribute_mapping: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input auth_saml_providers_delete_elem_input {
  attribute_mapping: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input auth_saml_providers_delete_key_input {
  attribute_mapping: String
}

"""
input type for inserting data into table "auth.saml_providers"
"""
input auth_saml_providers_insert_input {
  attribute_mapping: jsonb
  created_at: timestamptz
  entity_id: String
  id: uuid
  metadata_url: String
  metadata_xml: String
  name_id_format: String
  sso_provider_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type auth_saml_providers_max_fields {
  created_at: timestamptz
  entity_id: String
  id: uuid
  metadata_url: String
  metadata_xml: String
  name_id_format: String
  sso_provider_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type auth_saml_providers_min_fields {
  created_at: timestamptz
  entity_id: String
  id: uuid
  metadata_url: String
  metadata_xml: String
  name_id_format: String
  sso_provider_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "auth.saml_providers"
"""
type auth_saml_providers_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [auth_saml_providers!]!
}

"""
on_conflict condition type for table "auth.saml_providers"
"""
input auth_saml_providers_on_conflict {
  constraint: auth_saml_providers_constraint!
  update_columns: [auth_saml_providers_update_column!]! = []
  where: auth_saml_providers_bool_exp
}

"""Ordering options when selecting data from "auth.saml_providers"."""
input auth_saml_providers_order_by {
  attribute_mapping: order_by
  created_at: order_by
  entity_id: order_by
  id: order_by
  metadata_url: order_by
  metadata_xml: order_by
  name_id_format: order_by
  sso_provider_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: auth.saml_providers"""
input auth_saml_providers_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input auth_saml_providers_prepend_input {
  attribute_mapping: jsonb
}

"""
select columns of table "auth.saml_providers"
"""
enum auth_saml_providers_select_column {
  """column name"""
  attribute_mapping

  """column name"""
  created_at

  """column name"""
  entity_id

  """column name"""
  id

  """column name"""
  metadata_url

  """column name"""
  metadata_xml

  """column name"""
  name_id_format

  """column name"""
  sso_provider_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "auth.saml_providers"
"""
input auth_saml_providers_set_input {
  attribute_mapping: jsonb
  created_at: timestamptz
  entity_id: String
  id: uuid
  metadata_url: String
  metadata_xml: String
  name_id_format: String
  sso_provider_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "auth_saml_providers"
"""
input auth_saml_providers_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: auth_saml_providers_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input auth_saml_providers_stream_cursor_value_input {
  attribute_mapping: jsonb
  created_at: timestamptz
  entity_id: String
  id: uuid
  metadata_url: String
  metadata_xml: String
  name_id_format: String
  sso_provider_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "auth.saml_providers"
"""
enum auth_saml_providers_update_column {
  """column name"""
  attribute_mapping

  """column name"""
  created_at

  """column name"""
  entity_id

  """column name"""
  id

  """column name"""
  metadata_url

  """column name"""
  metadata_xml

  """column name"""
  name_id_format

  """column name"""
  sso_provider_id

  """column name"""
  updated_at
}

input auth_saml_providers_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: auth_saml_providers_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: auth_saml_providers_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: auth_saml_providers_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: auth_saml_providers_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: auth_saml_providers_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: auth_saml_providers_set_input

  """filter the rows which have to be updated"""
  where: auth_saml_providers_bool_exp!
}

"""
Auth: Contains SAML Relay State information for each Service Provider initiated login.
"""
type auth_saml_relay_states {
  created_at: timestamptz
  flow_state_id: uuid
  for_email: String
  id: uuid!
  redirect_to: String
  request_id: String!
  sso_provider_id: uuid!
  updated_at: timestamptz
}

"""
aggregated selection of "auth.saml_relay_states"
"""
type auth_saml_relay_states_aggregate {
  aggregate: auth_saml_relay_states_aggregate_fields
  nodes: [auth_saml_relay_states!]!
}

"""
aggregate fields of "auth.saml_relay_states"
"""
type auth_saml_relay_states_aggregate_fields {
  count(columns: [auth_saml_relay_states_select_column!], distinct: Boolean): Int!
  max: auth_saml_relay_states_max_fields
  min: auth_saml_relay_states_min_fields
}

"""
Boolean expression to filter rows from the table "auth.saml_relay_states". All fields are combined with a logical 'AND'.
"""
input auth_saml_relay_states_bool_exp {
  _and: [auth_saml_relay_states_bool_exp!]
  _not: auth_saml_relay_states_bool_exp
  _or: [auth_saml_relay_states_bool_exp!]
  created_at: timestamptz_comparison_exp
  flow_state_id: uuid_comparison_exp
  for_email: String_comparison_exp
  id: uuid_comparison_exp
  redirect_to: String_comparison_exp
  request_id: String_comparison_exp
  sso_provider_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "auth.saml_relay_states"
"""
enum auth_saml_relay_states_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  saml_relay_states_pkey
}

"""
input type for inserting data into table "auth.saml_relay_states"
"""
input auth_saml_relay_states_insert_input {
  created_at: timestamptz
  flow_state_id: uuid
  for_email: String
  id: uuid
  redirect_to: String
  request_id: String
  sso_provider_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type auth_saml_relay_states_max_fields {
  created_at: timestamptz
  flow_state_id: uuid
  for_email: String
  id: uuid
  redirect_to: String
  request_id: String
  sso_provider_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type auth_saml_relay_states_min_fields {
  created_at: timestamptz
  flow_state_id: uuid
  for_email: String
  id: uuid
  redirect_to: String
  request_id: String
  sso_provider_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "auth.saml_relay_states"
"""
type auth_saml_relay_states_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [auth_saml_relay_states!]!
}

"""
on_conflict condition type for table "auth.saml_relay_states"
"""
input auth_saml_relay_states_on_conflict {
  constraint: auth_saml_relay_states_constraint!
  update_columns: [auth_saml_relay_states_update_column!]! = []
  where: auth_saml_relay_states_bool_exp
}

"""Ordering options when selecting data from "auth.saml_relay_states"."""
input auth_saml_relay_states_order_by {
  created_at: order_by
  flow_state_id: order_by
  for_email: order_by
  id: order_by
  redirect_to: order_by
  request_id: order_by
  sso_provider_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: auth.saml_relay_states"""
input auth_saml_relay_states_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.saml_relay_states"
"""
enum auth_saml_relay_states_select_column {
  """column name"""
  created_at

  """column name"""
  flow_state_id

  """column name"""
  for_email

  """column name"""
  id

  """column name"""
  redirect_to

  """column name"""
  request_id

  """column name"""
  sso_provider_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "auth.saml_relay_states"
"""
input auth_saml_relay_states_set_input {
  created_at: timestamptz
  flow_state_id: uuid
  for_email: String
  id: uuid
  redirect_to: String
  request_id: String
  sso_provider_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "auth_saml_relay_states"
"""
input auth_saml_relay_states_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: auth_saml_relay_states_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input auth_saml_relay_states_stream_cursor_value_input {
  created_at: timestamptz
  flow_state_id: uuid
  for_email: String
  id: uuid
  redirect_to: String
  request_id: String
  sso_provider_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "auth.saml_relay_states"
"""
enum auth_saml_relay_states_update_column {
  """column name"""
  created_at

  """column name"""
  flow_state_id

  """column name"""
  for_email

  """column name"""
  id

  """column name"""
  redirect_to

  """column name"""
  request_id

  """column name"""
  sso_provider_id

  """column name"""
  updated_at
}

input auth_saml_relay_states_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: auth_saml_relay_states_set_input

  """filter the rows which have to be updated"""
  where: auth_saml_relay_states_bool_exp!
}

"""Auth: Stores session data associated to a user."""
type auth_sessions {
  aal: aal_level
  created_at: timestamptz
  factor_id: uuid
  id: uuid!
  ip: inet

  """
  Auth: Not after is a nullable column that contains a timestamp after which the session should be regarded as expired.
  """
  not_after: timestamptz
  oauth_client_id: uuid

  """Holds the ID (counter) of the last issued refresh token."""
  refresh_token_counter: bigint

  """Holds a HMAC-SHA256 key used to sign refresh tokens for this session."""
  refresh_token_hmac_key: String
  refreshed_at: timestamp
  scopes: String
  tag: String
  updated_at: timestamptz
  user_agent: String
  user_id: uuid!
}

"""
aggregated selection of "auth.sessions"
"""
type auth_sessions_aggregate {
  aggregate: auth_sessions_aggregate_fields
  nodes: [auth_sessions!]!
}

"""
aggregate fields of "auth.sessions"
"""
type auth_sessions_aggregate_fields {
  avg: auth_sessions_avg_fields
  count(columns: [auth_sessions_select_column!], distinct: Boolean): Int!
  max: auth_sessions_max_fields
  min: auth_sessions_min_fields
  stddev: auth_sessions_stddev_fields
  stddev_pop: auth_sessions_stddev_pop_fields
  stddev_samp: auth_sessions_stddev_samp_fields
  sum: auth_sessions_sum_fields
  var_pop: auth_sessions_var_pop_fields
  var_samp: auth_sessions_var_samp_fields
  variance: auth_sessions_variance_fields
}

"""aggregate avg on columns"""
type auth_sessions_avg_fields {
  """Holds the ID (counter) of the last issued refresh token."""
  refresh_token_counter: Float
}

"""
Boolean expression to filter rows from the table "auth.sessions". All fields are combined with a logical 'AND'.
"""
input auth_sessions_bool_exp {
  _and: [auth_sessions_bool_exp!]
  _not: auth_sessions_bool_exp
  _or: [auth_sessions_bool_exp!]
  aal: aal_level_comparison_exp
  created_at: timestamptz_comparison_exp
  factor_id: uuid_comparison_exp
  id: uuid_comparison_exp
  ip: inet_comparison_exp
  not_after: timestamptz_comparison_exp
  oauth_client_id: uuid_comparison_exp
  refresh_token_counter: bigint_comparison_exp
  refresh_token_hmac_key: String_comparison_exp
  refreshed_at: timestamp_comparison_exp
  scopes: String_comparison_exp
  tag: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_agent: String_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.sessions"
"""
enum auth_sessions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  sessions_pkey
}

"""
input type for incrementing numeric columns in table "auth.sessions"
"""
input auth_sessions_inc_input {
  """Holds the ID (counter) of the last issued refresh token."""
  refresh_token_counter: bigint
}

"""
input type for inserting data into table "auth.sessions"
"""
input auth_sessions_insert_input {
  aal: aal_level
  created_at: timestamptz
  factor_id: uuid
  id: uuid
  ip: inet

  """
  Auth: Not after is a nullable column that contains a timestamp after which the session should be regarded as expired.
  """
  not_after: timestamptz
  oauth_client_id: uuid

  """Holds the ID (counter) of the last issued refresh token."""
  refresh_token_counter: bigint

  """Holds a HMAC-SHA256 key used to sign refresh tokens for this session."""
  refresh_token_hmac_key: String
  refreshed_at: timestamp
  scopes: String
  tag: String
  updated_at: timestamptz
  user_agent: String
  user_id: uuid
}

"""aggregate max on columns"""
type auth_sessions_max_fields {
  aal: aal_level
  created_at: timestamptz
  factor_id: uuid
  id: uuid

  """
  Auth: Not after is a nullable column that contains a timestamp after which the session should be regarded as expired.
  """
  not_after: timestamptz
  oauth_client_id: uuid

  """Holds the ID (counter) of the last issued refresh token."""
  refresh_token_counter: bigint

  """Holds a HMAC-SHA256 key used to sign refresh tokens for this session."""
  refresh_token_hmac_key: String
  refreshed_at: timestamp
  scopes: String
  tag: String
  updated_at: timestamptz
  user_agent: String
  user_id: uuid
}

"""aggregate min on columns"""
type auth_sessions_min_fields {
  aal: aal_level
  created_at: timestamptz
  factor_id: uuid
  id: uuid

  """
  Auth: Not after is a nullable column that contains a timestamp after which the session should be regarded as expired.
  """
  not_after: timestamptz
  oauth_client_id: uuid

  """Holds the ID (counter) of the last issued refresh token."""
  refresh_token_counter: bigint

  """Holds a HMAC-SHA256 key used to sign refresh tokens for this session."""
  refresh_token_hmac_key: String
  refreshed_at: timestamp
  scopes: String
  tag: String
  updated_at: timestamptz
  user_agent: String
  user_id: uuid
}

"""
response of any mutation on the table "auth.sessions"
"""
type auth_sessions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [auth_sessions!]!
}

"""
on_conflict condition type for table "auth.sessions"
"""
input auth_sessions_on_conflict {
  constraint: auth_sessions_constraint!
  update_columns: [auth_sessions_update_column!]! = []
  where: auth_sessions_bool_exp
}

"""Ordering options when selecting data from "auth.sessions"."""
input auth_sessions_order_by {
  aal: order_by
  created_at: order_by
  factor_id: order_by
  id: order_by
  ip: order_by
  not_after: order_by
  oauth_client_id: order_by
  refresh_token_counter: order_by
  refresh_token_hmac_key: order_by
  refreshed_at: order_by
  scopes: order_by
  tag: order_by
  updated_at: order_by
  user_agent: order_by
  user_id: order_by
}

"""primary key columns input for table: auth.sessions"""
input auth_sessions_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.sessions"
"""
enum auth_sessions_select_column {
  """column name"""
  aal

  """column name"""
  created_at

  """column name"""
  factor_id

  """column name"""
  id

  """column name"""
  ip

  """column name"""
  not_after

  """column name"""
  oauth_client_id

  """column name"""
  refresh_token_counter

  """column name"""
  refresh_token_hmac_key

  """column name"""
  refreshed_at

  """column name"""
  scopes

  """column name"""
  tag

  """column name"""
  updated_at

  """column name"""
  user_agent

  """column name"""
  user_id
}

"""
input type for updating data in table "auth.sessions"
"""
input auth_sessions_set_input {
  aal: aal_level
  created_at: timestamptz
  factor_id: uuid
  id: uuid
  ip: inet

  """
  Auth: Not after is a nullable column that contains a timestamp after which the session should be regarded as expired.
  """
  not_after: timestamptz
  oauth_client_id: uuid

  """Holds the ID (counter) of the last issued refresh token."""
  refresh_token_counter: bigint

  """Holds a HMAC-SHA256 key used to sign refresh tokens for this session."""
  refresh_token_hmac_key: String
  refreshed_at: timestamp
  scopes: String
  tag: String
  updated_at: timestamptz
  user_agent: String
  user_id: uuid
}

"""aggregate stddev on columns"""
type auth_sessions_stddev_fields {
  """Holds the ID (counter) of the last issued refresh token."""
  refresh_token_counter: Float
}

"""aggregate stddev_pop on columns"""
type auth_sessions_stddev_pop_fields {
  """Holds the ID (counter) of the last issued refresh token."""
  refresh_token_counter: Float
}

"""aggregate stddev_samp on columns"""
type auth_sessions_stddev_samp_fields {
  """Holds the ID (counter) of the last issued refresh token."""
  refresh_token_counter: Float
}

"""
Streaming cursor of the table "auth_sessions"
"""
input auth_sessions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: auth_sessions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input auth_sessions_stream_cursor_value_input {
  aal: aal_level
  created_at: timestamptz
  factor_id: uuid
  id: uuid
  ip: inet

  """
  Auth: Not after is a nullable column that contains a timestamp after which the session should be regarded as expired.
  """
  not_after: timestamptz
  oauth_client_id: uuid

  """Holds the ID (counter) of the last issued refresh token."""
  refresh_token_counter: bigint

  """Holds a HMAC-SHA256 key used to sign refresh tokens for this session."""
  refresh_token_hmac_key: String
  refreshed_at: timestamp
  scopes: String
  tag: String
  updated_at: timestamptz
  user_agent: String
  user_id: uuid
}

"""aggregate sum on columns"""
type auth_sessions_sum_fields {
  """Holds the ID (counter) of the last issued refresh token."""
  refresh_token_counter: bigint
}

"""
update columns of table "auth.sessions"
"""
enum auth_sessions_update_column {
  """column name"""
  aal

  """column name"""
  created_at

  """column name"""
  factor_id

  """column name"""
  id

  """column name"""
  ip

  """column name"""
  not_after

  """column name"""
  oauth_client_id

  """column name"""
  refresh_token_counter

  """column name"""
  refresh_token_hmac_key

  """column name"""
  refreshed_at

  """column name"""
  scopes

  """column name"""
  tag

  """column name"""
  updated_at

  """column name"""
  user_agent

  """column name"""
  user_id
}

input auth_sessions_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: auth_sessions_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: auth_sessions_set_input

  """filter the rows which have to be updated"""
  where: auth_sessions_bool_exp!
}

"""aggregate var_pop on columns"""
type auth_sessions_var_pop_fields {
  """Holds the ID (counter) of the last issued refresh token."""
  refresh_token_counter: Float
}

"""aggregate var_samp on columns"""
type auth_sessions_var_samp_fields {
  """Holds the ID (counter) of the last issued refresh token."""
  refresh_token_counter: Float
}

"""aggregate variance on columns"""
type auth_sessions_variance_fields {
  """Holds the ID (counter) of the last issued refresh token."""
  refresh_token_counter: Float
}

"""
Auth: Manages SSO email address domain mapping to an SSO Identity Provider.
"""
type auth_sso_domains {
  created_at: timestamptz
  domain: String!
  id: uuid!
  sso_provider_id: uuid!
  updated_at: timestamptz
}

"""
aggregated selection of "auth.sso_domains"
"""
type auth_sso_domains_aggregate {
  aggregate: auth_sso_domains_aggregate_fields
  nodes: [auth_sso_domains!]!
}

"""
aggregate fields of "auth.sso_domains"
"""
type auth_sso_domains_aggregate_fields {
  count(columns: [auth_sso_domains_select_column!], distinct: Boolean): Int!
  max: auth_sso_domains_max_fields
  min: auth_sso_domains_min_fields
}

"""
Boolean expression to filter rows from the table "auth.sso_domains". All fields are combined with a logical 'AND'.
"""
input auth_sso_domains_bool_exp {
  _and: [auth_sso_domains_bool_exp!]
  _not: auth_sso_domains_bool_exp
  _or: [auth_sso_domains_bool_exp!]
  created_at: timestamptz_comparison_exp
  domain: String_comparison_exp
  id: uuid_comparison_exp
  sso_provider_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "auth.sso_domains"
"""
enum auth_sso_domains_constraint {
  """unique or primary key constraint on columns """
  sso_domains_domain_idx

  """
  unique or primary key constraint on columns "id"
  """
  sso_domains_pkey
}

"""
input type for inserting data into table "auth.sso_domains"
"""
input auth_sso_domains_insert_input {
  created_at: timestamptz
  domain: String
  id: uuid
  sso_provider_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type auth_sso_domains_max_fields {
  created_at: timestamptz
  domain: String
  id: uuid
  sso_provider_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type auth_sso_domains_min_fields {
  created_at: timestamptz
  domain: String
  id: uuid
  sso_provider_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "auth.sso_domains"
"""
type auth_sso_domains_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [auth_sso_domains!]!
}

"""
on_conflict condition type for table "auth.sso_domains"
"""
input auth_sso_domains_on_conflict {
  constraint: auth_sso_domains_constraint!
  update_columns: [auth_sso_domains_update_column!]! = []
  where: auth_sso_domains_bool_exp
}

"""Ordering options when selecting data from "auth.sso_domains"."""
input auth_sso_domains_order_by {
  created_at: order_by
  domain: order_by
  id: order_by
  sso_provider_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: auth.sso_domains"""
input auth_sso_domains_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.sso_domains"
"""
enum auth_sso_domains_select_column {
  """column name"""
  created_at

  """column name"""
  domain

  """column name"""
  id

  """column name"""
  sso_provider_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "auth.sso_domains"
"""
input auth_sso_domains_set_input {
  created_at: timestamptz
  domain: String
  id: uuid
  sso_provider_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "auth_sso_domains"
"""
input auth_sso_domains_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: auth_sso_domains_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input auth_sso_domains_stream_cursor_value_input {
  created_at: timestamptz
  domain: String
  id: uuid
  sso_provider_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "auth.sso_domains"
"""
enum auth_sso_domains_update_column {
  """column name"""
  created_at

  """column name"""
  domain

  """column name"""
  id

  """column name"""
  sso_provider_id

  """column name"""
  updated_at
}

input auth_sso_domains_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: auth_sso_domains_set_input

  """filter the rows which have to be updated"""
  where: auth_sso_domains_bool_exp!
}

"""
Auth: Manages SSO identity provider information; see saml_providers for SAML.
"""
type auth_sso_providers {
  created_at: timestamptz
  disabled: Boolean
  id: uuid!

  """
  Auth: Uniquely identifies a SSO provider according to a user-chosen resource ID (case insensitive), useful in infrastructure as code.
  """
  resource_id: String
  updated_at: timestamptz
}

"""
aggregated selection of "auth.sso_providers"
"""
type auth_sso_providers_aggregate {
  aggregate: auth_sso_providers_aggregate_fields
  nodes: [auth_sso_providers!]!
}

"""
aggregate fields of "auth.sso_providers"
"""
type auth_sso_providers_aggregate_fields {
  count(columns: [auth_sso_providers_select_column!], distinct: Boolean): Int!
  max: auth_sso_providers_max_fields
  min: auth_sso_providers_min_fields
}

"""
Boolean expression to filter rows from the table "auth.sso_providers". All fields are combined with a logical 'AND'.
"""
input auth_sso_providers_bool_exp {
  _and: [auth_sso_providers_bool_exp!]
  _not: auth_sso_providers_bool_exp
  _or: [auth_sso_providers_bool_exp!]
  created_at: timestamptz_comparison_exp
  disabled: Boolean_comparison_exp
  id: uuid_comparison_exp
  resource_id: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "auth.sso_providers"
"""
enum auth_sso_providers_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  sso_providers_pkey

  """unique or primary key constraint on columns """
  sso_providers_resource_id_idx
}

"""
input type for inserting data into table "auth.sso_providers"
"""
input auth_sso_providers_insert_input {
  created_at: timestamptz
  disabled: Boolean
  id: uuid

  """
  Auth: Uniquely identifies a SSO provider according to a user-chosen resource ID (case insensitive), useful in infrastructure as code.
  """
  resource_id: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type auth_sso_providers_max_fields {
  created_at: timestamptz
  id: uuid

  """
  Auth: Uniquely identifies a SSO provider according to a user-chosen resource ID (case insensitive), useful in infrastructure as code.
  """
  resource_id: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type auth_sso_providers_min_fields {
  created_at: timestamptz
  id: uuid

  """
  Auth: Uniquely identifies a SSO provider according to a user-chosen resource ID (case insensitive), useful in infrastructure as code.
  """
  resource_id: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "auth.sso_providers"
"""
type auth_sso_providers_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [auth_sso_providers!]!
}

"""
on_conflict condition type for table "auth.sso_providers"
"""
input auth_sso_providers_on_conflict {
  constraint: auth_sso_providers_constraint!
  update_columns: [auth_sso_providers_update_column!]! = []
  where: auth_sso_providers_bool_exp
}

"""Ordering options when selecting data from "auth.sso_providers"."""
input auth_sso_providers_order_by {
  created_at: order_by
  disabled: order_by
  id: order_by
  resource_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: auth.sso_providers"""
input auth_sso_providers_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.sso_providers"
"""
enum auth_sso_providers_select_column {
  """column name"""
  created_at

  """column name"""
  disabled

  """column name"""
  id

  """column name"""
  resource_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "auth.sso_providers"
"""
input auth_sso_providers_set_input {
  created_at: timestamptz
  disabled: Boolean
  id: uuid

  """
  Auth: Uniquely identifies a SSO provider according to a user-chosen resource ID (case insensitive), useful in infrastructure as code.
  """
  resource_id: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "auth_sso_providers"
"""
input auth_sso_providers_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: auth_sso_providers_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input auth_sso_providers_stream_cursor_value_input {
  created_at: timestamptz
  disabled: Boolean
  id: uuid

  """
  Auth: Uniquely identifies a SSO provider according to a user-chosen resource ID (case insensitive), useful in infrastructure as code.
  """
  resource_id: String
  updated_at: timestamptz
}

"""
update columns of table "auth.sso_providers"
"""
enum auth_sso_providers_update_column {
  """column name"""
  created_at

  """column name"""
  disabled

  """column name"""
  id

  """column name"""
  resource_id

  """column name"""
  updated_at
}

input auth_sso_providers_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: auth_sso_providers_set_input

  """filter the rows which have to be updated"""
  where: auth_sso_providers_bool_exp!
}

"""Auth: Stores user login data within a secure schema."""
type auth_users {
  aud: String
  banned_until: timestamptz
  confirmation_sent_at: timestamptz
  confirmation_token: String
  confirmed_at: timestamptz
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  email_change: String
  email_change_confirm_status: smallint
  email_change_sent_at: timestamptz
  email_change_token_current: String
  email_change_token_new: String
  email_confirmed_at: timestamptz
  encrypted_password: String
  id: uuid!
  instance_id: uuid
  invited_at: timestamptz
  is_anonymous: Boolean!

  """
  Auth: Set this column to true when the account comes from SSO. These accounts can have duplicate emails.
  """
  is_sso_user: Boolean!
  is_super_admin: Boolean
  last_sign_in_at: timestamptz
  phone: String
  phone_change: String
  phone_change_sent_at: timestamptz
  phone_change_token: String
  phone_confirmed_at: timestamptz
  raw_app_meta_data(
    """JSON select path"""
    path: String
  ): jsonb
  raw_user_meta_data(
    """JSON select path"""
    path: String
  ): jsonb
  reauthentication_sent_at: timestamptz
  reauthentication_token: String
  recovery_sent_at: timestamptz
  recovery_token: String
  role: String
  updated_at: timestamptz
}

"""
aggregated selection of "auth.users"
"""
type auth_users_aggregate {
  aggregate: auth_users_aggregate_fields
  nodes: [auth_users!]!
}

"""
aggregate fields of "auth.users"
"""
type auth_users_aggregate_fields {
  avg: auth_users_avg_fields
  count(columns: [auth_users_select_column!], distinct: Boolean): Int!
  max: auth_users_max_fields
  min: auth_users_min_fields
  stddev: auth_users_stddev_fields
  stddev_pop: auth_users_stddev_pop_fields
  stddev_samp: auth_users_stddev_samp_fields
  sum: auth_users_sum_fields
  var_pop: auth_users_var_pop_fields
  var_samp: auth_users_var_samp_fields
  variance: auth_users_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input auth_users_append_input {
  raw_app_meta_data: jsonb
  raw_user_meta_data: jsonb
}

"""aggregate avg on columns"""
type auth_users_avg_fields {
  email_change_confirm_status: Float
}

"""
Boolean expression to filter rows from the table "auth.users". All fields are combined with a logical 'AND'.
"""
input auth_users_bool_exp {
  _and: [auth_users_bool_exp!]
  _not: auth_users_bool_exp
  _or: [auth_users_bool_exp!]
  aud: String_comparison_exp
  banned_until: timestamptz_comparison_exp
  confirmation_sent_at: timestamptz_comparison_exp
  confirmation_token: String_comparison_exp
  confirmed_at: timestamptz_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  email: String_comparison_exp
  email_change: String_comparison_exp
  email_change_confirm_status: smallint_comparison_exp
  email_change_sent_at: timestamptz_comparison_exp
  email_change_token_current: String_comparison_exp
  email_change_token_new: String_comparison_exp
  email_confirmed_at: timestamptz_comparison_exp
  encrypted_password: String_comparison_exp
  id: uuid_comparison_exp
  instance_id: uuid_comparison_exp
  invited_at: timestamptz_comparison_exp
  is_anonymous: Boolean_comparison_exp
  is_sso_user: Boolean_comparison_exp
  is_super_admin: Boolean_comparison_exp
  last_sign_in_at: timestamptz_comparison_exp
  phone: String_comparison_exp
  phone_change: String_comparison_exp
  phone_change_sent_at: timestamptz_comparison_exp
  phone_change_token: String_comparison_exp
  phone_confirmed_at: timestamptz_comparison_exp
  raw_app_meta_data: jsonb_comparison_exp
  raw_user_meta_data: jsonb_comparison_exp
  reauthentication_sent_at: timestamptz_comparison_exp
  reauthentication_token: String_comparison_exp
  recovery_sent_at: timestamptz_comparison_exp
  recovery_token: String_comparison_exp
  role: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "auth.users"
"""
enum auth_users_constraint {
  """
  unique or primary key constraint on columns "confirmation_token"
  """
  confirmation_token_idx

  """
  unique or primary key constraint on columns "email_change_token_current"
  """
  email_change_token_current_idx

  """
  unique or primary key constraint on columns "email_change_token_new"
  """
  email_change_token_new_idx

  """
  unique or primary key constraint on columns "reauthentication_token"
  """
  reauthentication_token_idx

  """
  unique or primary key constraint on columns "recovery_token"
  """
  recovery_token_idx

  """
  unique or primary key constraint on columns "email"
  """
  users_email_partial_key

  """
  unique or primary key constraint on columns "phone"
  """
  users_phone_key

  """
  unique or primary key constraint on columns "id"
  """
  users_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input auth_users_delete_at_path_input {
  raw_app_meta_data: [String!]
  raw_user_meta_data: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input auth_users_delete_elem_input {
  raw_app_meta_data: Int
  raw_user_meta_data: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input auth_users_delete_key_input {
  raw_app_meta_data: String
  raw_user_meta_data: String
}

"""
input type for incrementing numeric columns in table "auth.users"
"""
input auth_users_inc_input {
  email_change_confirm_status: smallint
}

"""
input type for inserting data into table "auth.users"
"""
input auth_users_insert_input {
  aud: String
  banned_until: timestamptz
  confirmation_sent_at: timestamptz
  confirmation_token: String
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  email_change: String
  email_change_confirm_status: smallint
  email_change_sent_at: timestamptz
  email_change_token_current: String
  email_change_token_new: String
  email_confirmed_at: timestamptz
  encrypted_password: String
  id: uuid
  instance_id: uuid
  invited_at: timestamptz
  is_anonymous: Boolean

  """
  Auth: Set this column to true when the account comes from SSO. These accounts can have duplicate emails.
  """
  is_sso_user: Boolean
  is_super_admin: Boolean
  last_sign_in_at: timestamptz
  phone: String
  phone_change: String
  phone_change_sent_at: timestamptz
  phone_change_token: String
  phone_confirmed_at: timestamptz
  raw_app_meta_data: jsonb
  raw_user_meta_data: jsonb
  reauthentication_sent_at: timestamptz
  reauthentication_token: String
  recovery_sent_at: timestamptz
  recovery_token: String
  role: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type auth_users_max_fields {
  aud: String
  banned_until: timestamptz
  confirmation_sent_at: timestamptz
  confirmation_token: String
  confirmed_at: timestamptz
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  email_change: String
  email_change_confirm_status: smallint
  email_change_sent_at: timestamptz
  email_change_token_current: String
  email_change_token_new: String
  email_confirmed_at: timestamptz
  encrypted_password: String
  id: uuid
  instance_id: uuid
  invited_at: timestamptz
  last_sign_in_at: timestamptz
  phone: String
  phone_change: String
  phone_change_sent_at: timestamptz
  phone_change_token: String
  phone_confirmed_at: timestamptz
  reauthentication_sent_at: timestamptz
  reauthentication_token: String
  recovery_sent_at: timestamptz
  recovery_token: String
  role: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type auth_users_min_fields {
  aud: String
  banned_until: timestamptz
  confirmation_sent_at: timestamptz
  confirmation_token: String
  confirmed_at: timestamptz
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  email_change: String
  email_change_confirm_status: smallint
  email_change_sent_at: timestamptz
  email_change_token_current: String
  email_change_token_new: String
  email_confirmed_at: timestamptz
  encrypted_password: String
  id: uuid
  instance_id: uuid
  invited_at: timestamptz
  last_sign_in_at: timestamptz
  phone: String
  phone_change: String
  phone_change_sent_at: timestamptz
  phone_change_token: String
  phone_confirmed_at: timestamptz
  reauthentication_sent_at: timestamptz
  reauthentication_token: String
  recovery_sent_at: timestamptz
  recovery_token: String
  role: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "auth.users"
"""
type auth_users_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [auth_users!]!
}

"""
input type for inserting object relation for remote table "auth.users"
"""
input auth_users_obj_rel_insert_input {
  data: auth_users_insert_input!

  """upsert condition"""
  on_conflict: auth_users_on_conflict
}

"""
on_conflict condition type for table "auth.users"
"""
input auth_users_on_conflict {
  constraint: auth_users_constraint!
  update_columns: [auth_users_update_column!]! = []
  where: auth_users_bool_exp
}

"""Ordering options when selecting data from "auth.users"."""
input auth_users_order_by {
  aud: order_by
  banned_until: order_by
  confirmation_sent_at: order_by
  confirmation_token: order_by
  confirmed_at: order_by
  created_at: order_by
  deleted_at: order_by
  email: order_by
  email_change: order_by
  email_change_confirm_status: order_by
  email_change_sent_at: order_by
  email_change_token_current: order_by
  email_change_token_new: order_by
  email_confirmed_at: order_by
  encrypted_password: order_by
  id: order_by
  instance_id: order_by
  invited_at: order_by
  is_anonymous: order_by
  is_sso_user: order_by
  is_super_admin: order_by
  last_sign_in_at: order_by
  phone: order_by
  phone_change: order_by
  phone_change_sent_at: order_by
  phone_change_token: order_by
  phone_confirmed_at: order_by
  raw_app_meta_data: order_by
  raw_user_meta_data: order_by
  reauthentication_sent_at: order_by
  reauthentication_token: order_by
  recovery_sent_at: order_by
  recovery_token: order_by
  role: order_by
  updated_at: order_by
}

"""primary key columns input for table: auth.users"""
input auth_users_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input auth_users_prepend_input {
  raw_app_meta_data: jsonb
  raw_user_meta_data: jsonb
}

"""
select columns of table "auth.users"
"""
enum auth_users_select_column {
  """column name"""
  aud

  """column name"""
  banned_until

  """column name"""
  confirmation_sent_at

  """column name"""
  confirmation_token

  """column name"""
  confirmed_at

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  email

  """column name"""
  email_change

  """column name"""
  email_change_confirm_status

  """column name"""
  email_change_sent_at

  """column name"""
  email_change_token_current

  """column name"""
  email_change_token_new

  """column name"""
  email_confirmed_at

  """column name"""
  encrypted_password

  """column name"""
  id

  """column name"""
  instance_id

  """column name"""
  invited_at

  """column name"""
  is_anonymous

  """column name"""
  is_sso_user

  """column name"""
  is_super_admin

  """column name"""
  last_sign_in_at

  """column name"""
  phone

  """column name"""
  phone_change

  """column name"""
  phone_change_sent_at

  """column name"""
  phone_change_token

  """column name"""
  phone_confirmed_at

  """column name"""
  raw_app_meta_data

  """column name"""
  raw_user_meta_data

  """column name"""
  reauthentication_sent_at

  """column name"""
  reauthentication_token

  """column name"""
  recovery_sent_at

  """column name"""
  recovery_token

  """column name"""
  role

  """column name"""
  updated_at
}

"""
input type for updating data in table "auth.users"
"""
input auth_users_set_input {
  aud: String
  banned_until: timestamptz
  confirmation_sent_at: timestamptz
  confirmation_token: String
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  email_change: String
  email_change_confirm_status: smallint
  email_change_sent_at: timestamptz
  email_change_token_current: String
  email_change_token_new: String
  email_confirmed_at: timestamptz
  encrypted_password: String
  id: uuid
  instance_id: uuid
  invited_at: timestamptz
  is_anonymous: Boolean

  """
  Auth: Set this column to true when the account comes from SSO. These accounts can have duplicate emails.
  """
  is_sso_user: Boolean
  is_super_admin: Boolean
  last_sign_in_at: timestamptz
  phone: String
  phone_change: String
  phone_change_sent_at: timestamptz
  phone_change_token: String
  phone_confirmed_at: timestamptz
  raw_app_meta_data: jsonb
  raw_user_meta_data: jsonb
  reauthentication_sent_at: timestamptz
  reauthentication_token: String
  recovery_sent_at: timestamptz
  recovery_token: String
  role: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type auth_users_stddev_fields {
  email_change_confirm_status: Float
}

"""aggregate stddev_pop on columns"""
type auth_users_stddev_pop_fields {
  email_change_confirm_status: Float
}

"""aggregate stddev_samp on columns"""
type auth_users_stddev_samp_fields {
  email_change_confirm_status: Float
}

"""
Streaming cursor of the table "auth_users"
"""
input auth_users_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: auth_users_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input auth_users_stream_cursor_value_input {
  aud: String
  banned_until: timestamptz
  confirmation_sent_at: timestamptz
  confirmation_token: String
  confirmed_at: timestamptz
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  email_change: String
  email_change_confirm_status: smallint
  email_change_sent_at: timestamptz
  email_change_token_current: String
  email_change_token_new: String
  email_confirmed_at: timestamptz
  encrypted_password: String
  id: uuid
  instance_id: uuid
  invited_at: timestamptz
  is_anonymous: Boolean

  """
  Auth: Set this column to true when the account comes from SSO. These accounts can have duplicate emails.
  """
  is_sso_user: Boolean
  is_super_admin: Boolean
  last_sign_in_at: timestamptz
  phone: String
  phone_change: String
  phone_change_sent_at: timestamptz
  phone_change_token: String
  phone_confirmed_at: timestamptz
  raw_app_meta_data: jsonb
  raw_user_meta_data: jsonb
  reauthentication_sent_at: timestamptz
  reauthentication_token: String
  recovery_sent_at: timestamptz
  recovery_token: String
  role: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type auth_users_sum_fields {
  email_change_confirm_status: smallint
}

"""
update columns of table "auth.users"
"""
enum auth_users_update_column {
  """column name"""
  aud

  """column name"""
  banned_until

  """column name"""
  confirmation_sent_at

  """column name"""
  confirmation_token

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  email

  """column name"""
  email_change

  """column name"""
  email_change_confirm_status

  """column name"""
  email_change_sent_at

  """column name"""
  email_change_token_current

  """column name"""
  email_change_token_new

  """column name"""
  email_confirmed_at

  """column name"""
  encrypted_password

  """column name"""
  id

  """column name"""
  instance_id

  """column name"""
  invited_at

  """column name"""
  is_anonymous

  """column name"""
  is_sso_user

  """column name"""
  is_super_admin

  """column name"""
  last_sign_in_at

  """column name"""
  phone

  """column name"""
  phone_change

  """column name"""
  phone_change_sent_at

  """column name"""
  phone_change_token

  """column name"""
  phone_confirmed_at

  """column name"""
  raw_app_meta_data

  """column name"""
  raw_user_meta_data

  """column name"""
  reauthentication_sent_at

  """column name"""
  reauthentication_token

  """column name"""
  recovery_sent_at

  """column name"""
  recovery_token

  """column name"""
  role

  """column name"""
  updated_at
}

input auth_users_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: auth_users_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: auth_users_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: auth_users_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: auth_users_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: auth_users_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: auth_users_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: auth_users_set_input

  """filter the rows which have to be updated"""
  where: auth_users_bool_exp!
}

"""aggregate var_pop on columns"""
type auth_users_var_pop_fields {
  email_change_confirm_status: Float
}

"""aggregate var_samp on columns"""
type auth_users_var_samp_fields {
  email_change_confirm_status: Float
}

"""aggregate variance on columns"""
type auth_users_variance_fields {
  email_change_confirm_status: Float
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
columns and relationships of "booking_requests"
"""
type booking_requests {
  agency_id: uuid

  """Payment amount for the booking"""
  amount: numeric
  created_at: timestamptz

  """Currency code (ISO 4217)"""
  currency: String
  end_date: date
  id: uuid!
  maid_id: String
  message: String
  offered_salary: numeric
  payment_date: timestamptz
  payment_method: String

  """Payment gateway transaction reference"""
  payment_reference: String

  """Current payment status"""
  payment_status: String
  rejection_reason: String
  requested_duration_months: Int
  requested_start_date: date
  responded_at: timestamptz
  special_requirements: String
  sponsor_id: String
  start_date: date
  status: String!
  updated_at: timestamptz
}

"""
aggregated selection of "booking_requests"
"""
type booking_requests_aggregate {
  aggregate: booking_requests_aggregate_fields
  nodes: [booking_requests!]!
}

"""
aggregate fields of "booking_requests"
"""
type booking_requests_aggregate_fields {
  avg: booking_requests_avg_fields
  count(columns: [booking_requests_select_column!], distinct: Boolean): Int!
  max: booking_requests_max_fields
  min: booking_requests_min_fields
  stddev: booking_requests_stddev_fields
  stddev_pop: booking_requests_stddev_pop_fields
  stddev_samp: booking_requests_stddev_samp_fields
  sum: booking_requests_sum_fields
  var_pop: booking_requests_var_pop_fields
  var_samp: booking_requests_var_samp_fields
  variance: booking_requests_variance_fields
}

"""aggregate avg on columns"""
type booking_requests_avg_fields {
  """Payment amount for the booking"""
  amount: Float
  offered_salary: Float
  requested_duration_months: Float
}

"""
Boolean expression to filter rows from the table "booking_requests". All fields are combined with a logical 'AND'.
"""
input booking_requests_bool_exp {
  _and: [booking_requests_bool_exp!]
  _not: booking_requests_bool_exp
  _or: [booking_requests_bool_exp!]
  agency_id: uuid_comparison_exp
  amount: numeric_comparison_exp
  created_at: timestamptz_comparison_exp
  currency: String_comparison_exp
  end_date: date_comparison_exp
  id: uuid_comparison_exp
  maid_id: String_comparison_exp
  message: String_comparison_exp
  offered_salary: numeric_comparison_exp
  payment_date: timestamptz_comparison_exp
  payment_method: String_comparison_exp
  payment_reference: String_comparison_exp
  payment_status: String_comparison_exp
  rejection_reason: String_comparison_exp
  requested_duration_months: Int_comparison_exp
  requested_start_date: date_comparison_exp
  responded_at: timestamptz_comparison_exp
  special_requirements: String_comparison_exp
  sponsor_id: String_comparison_exp
  start_date: date_comparison_exp
  status: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "booking_requests"
"""
enum booking_requests_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  booking_requests_pkey
}

"""
input type for incrementing numeric columns in table "booking_requests"
"""
input booking_requests_inc_input {
  """Payment amount for the booking"""
  amount: numeric
  offered_salary: numeric
  requested_duration_months: Int
}

"""
input type for inserting data into table "booking_requests"
"""
input booking_requests_insert_input {
  agency_id: uuid

  """Payment amount for the booking"""
  amount: numeric
  created_at: timestamptz

  """Currency code (ISO 4217)"""
  currency: String
  end_date: date
  id: uuid
  maid_id: String
  message: String
  offered_salary: numeric
  payment_date: timestamptz
  payment_method: String

  """Payment gateway transaction reference"""
  payment_reference: String

  """Current payment status"""
  payment_status: String
  rejection_reason: String
  requested_duration_months: Int
  requested_start_date: date
  responded_at: timestamptz
  special_requirements: String
  sponsor_id: String
  start_date: date
  status: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type booking_requests_max_fields {
  agency_id: uuid

  """Payment amount for the booking"""
  amount: numeric
  created_at: timestamptz

  """Currency code (ISO 4217)"""
  currency: String
  end_date: date
  id: uuid
  maid_id: String
  message: String
  offered_salary: numeric
  payment_date: timestamptz
  payment_method: String

  """Payment gateway transaction reference"""
  payment_reference: String

  """Current payment status"""
  payment_status: String
  rejection_reason: String
  requested_duration_months: Int
  requested_start_date: date
  responded_at: timestamptz
  special_requirements: String
  sponsor_id: String
  start_date: date
  status: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type booking_requests_min_fields {
  agency_id: uuid

  """Payment amount for the booking"""
  amount: numeric
  created_at: timestamptz

  """Currency code (ISO 4217)"""
  currency: String
  end_date: date
  id: uuid
  maid_id: String
  message: String
  offered_salary: numeric
  payment_date: timestamptz
  payment_method: String

  """Payment gateway transaction reference"""
  payment_reference: String

  """Current payment status"""
  payment_status: String
  rejection_reason: String
  requested_duration_months: Int
  requested_start_date: date
  responded_at: timestamptz
  special_requirements: String
  sponsor_id: String
  start_date: date
  status: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "booking_requests"
"""
type booking_requests_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [booking_requests!]!
}

"""
on_conflict condition type for table "booking_requests"
"""
input booking_requests_on_conflict {
  constraint: booking_requests_constraint!
  update_columns: [booking_requests_update_column!]! = []
  where: booking_requests_bool_exp
}

"""Ordering options when selecting data from "booking_requests"."""
input booking_requests_order_by {
  agency_id: order_by
  amount: order_by
  created_at: order_by
  currency: order_by
  end_date: order_by
  id: order_by
  maid_id: order_by
  message: order_by
  offered_salary: order_by
  payment_date: order_by
  payment_method: order_by
  payment_reference: order_by
  payment_status: order_by
  rejection_reason: order_by
  requested_duration_months: order_by
  requested_start_date: order_by
  responded_at: order_by
  special_requirements: order_by
  sponsor_id: order_by
  start_date: order_by
  status: order_by
  updated_at: order_by
}

"""primary key columns input for table: booking_requests"""
input booking_requests_pk_columns_input {
  id: uuid!
}

"""
select columns of table "booking_requests"
"""
enum booking_requests_select_column {
  """column name"""
  agency_id

  """column name"""
  amount

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  end_date

  """column name"""
  id

  """column name"""
  maid_id

  """column name"""
  message

  """column name"""
  offered_salary

  """column name"""
  payment_date

  """column name"""
  payment_method

  """column name"""
  payment_reference

  """column name"""
  payment_status

  """column name"""
  rejection_reason

  """column name"""
  requested_duration_months

  """column name"""
  requested_start_date

  """column name"""
  responded_at

  """column name"""
  special_requirements

  """column name"""
  sponsor_id

  """column name"""
  start_date

  """column name"""
  status

  """column name"""
  updated_at
}

"""
input type for updating data in table "booking_requests"
"""
input booking_requests_set_input {
  agency_id: uuid

  """Payment amount for the booking"""
  amount: numeric
  created_at: timestamptz

  """Currency code (ISO 4217)"""
  currency: String
  end_date: date
  id: uuid
  maid_id: String
  message: String
  offered_salary: numeric
  payment_date: timestamptz
  payment_method: String

  """Payment gateway transaction reference"""
  payment_reference: String

  """Current payment status"""
  payment_status: String
  rejection_reason: String
  requested_duration_months: Int
  requested_start_date: date
  responded_at: timestamptz
  special_requirements: String
  sponsor_id: String
  start_date: date
  status: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type booking_requests_stddev_fields {
  """Payment amount for the booking"""
  amount: Float
  offered_salary: Float
  requested_duration_months: Float
}

"""aggregate stddev_pop on columns"""
type booking_requests_stddev_pop_fields {
  """Payment amount for the booking"""
  amount: Float
  offered_salary: Float
  requested_duration_months: Float
}

"""aggregate stddev_samp on columns"""
type booking_requests_stddev_samp_fields {
  """Payment amount for the booking"""
  amount: Float
  offered_salary: Float
  requested_duration_months: Float
}

"""
Streaming cursor of the table "booking_requests"
"""
input booking_requests_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: booking_requests_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input booking_requests_stream_cursor_value_input {
  agency_id: uuid

  """Payment amount for the booking"""
  amount: numeric
  created_at: timestamptz

  """Currency code (ISO 4217)"""
  currency: String
  end_date: date
  id: uuid
  maid_id: String
  message: String
  offered_salary: numeric
  payment_date: timestamptz
  payment_method: String

  """Payment gateway transaction reference"""
  payment_reference: String

  """Current payment status"""
  payment_status: String
  rejection_reason: String
  requested_duration_months: Int
  requested_start_date: date
  responded_at: timestamptz
  special_requirements: String
  sponsor_id: String
  start_date: date
  status: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type booking_requests_sum_fields {
  """Payment amount for the booking"""
  amount: numeric
  offered_salary: numeric
  requested_duration_months: Int
}

"""
update columns of table "booking_requests"
"""
enum booking_requests_update_column {
  """column name"""
  agency_id

  """column name"""
  amount

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  end_date

  """column name"""
  id

  """column name"""
  maid_id

  """column name"""
  message

  """column name"""
  offered_salary

  """column name"""
  payment_date

  """column name"""
  payment_method

  """column name"""
  payment_reference

  """column name"""
  payment_status

  """column name"""
  rejection_reason

  """column name"""
  requested_duration_months

  """column name"""
  requested_start_date

  """column name"""
  responded_at

  """column name"""
  special_requirements

  """column name"""
  sponsor_id

  """column name"""
  start_date

  """column name"""
  status

  """column name"""
  updated_at
}

input booking_requests_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: booking_requests_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: booking_requests_set_input

  """filter the rows which have to be updated"""
  where: booking_requests_bool_exp!
}

"""aggregate var_pop on columns"""
type booking_requests_var_pop_fields {
  """Payment amount for the booking"""
  amount: Float
  offered_salary: Float
  requested_duration_months: Float
}

"""aggregate var_samp on columns"""
type booking_requests_var_samp_fields {
  """Payment amount for the booking"""
  amount: Float
  offered_salary: Float
  requested_duration_months: Float
}

"""aggregate variance on columns"""
type booking_requests_variance_fields {
  """Payment amount for the booking"""
  amount: Float
  offered_salary: Float
  requested_duration_months: Float
}

"""
columns and relationships of "bookings"
"""
type bookings {
  accommodation_provided: Boolean
  agency_id: String
  booking_type: String!
  cancellation_reason: String
  cancelled_at: timestamptz
  cancelled_by: uuid
  completion_notes: String
  completion_rating: Int
  contract_type: String
  created_at: timestamptz
  duration_months: Int
  duties: [String!]
  end_date: date
  food_provided: Boolean
  id: uuid!
  interview_date: timestamptz
  interview_type: String

  """An object relationship"""
  job: jobs
  job_id: uuid
  maid_id: String

  """An object relationship"""
  maid_profile: maid_profiles
  medical_insurance_provided: Boolean
  notes: String
  payment_frequency: String

  """An array relationship"""
  payments(
    """distinct select on columns"""
    distinct_on: [payments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_order_by!]

    """filter the rows returned"""
    where: payments_bool_exp
  ): [payments!]!

  """An aggregate relationship"""
  payments_aggregate(
    """distinct select on columns"""
    distinct_on: [payments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_order_by!]

    """filter the rows returned"""
    where: payments_bool_exp
  ): payments_aggregate!
  salary_amount: numeric
  salary_currency: String
  sponsor_id: String

  """An object relationship"""
  sponsor_profile: sponsor_profiles
  start_date: date!
  status: String!
  updated_at: timestamptz
  working_hours(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
aggregated selection of "bookings"
"""
type bookings_aggregate {
  aggregate: bookings_aggregate_fields
  nodes: [bookings!]!
}

input bookings_aggregate_bool_exp {
  bool_and: bookings_aggregate_bool_exp_bool_and
  bool_or: bookings_aggregate_bool_exp_bool_or
  count: bookings_aggregate_bool_exp_count
}

input bookings_aggregate_bool_exp_bool_and {
  arguments: bookings_select_column_bookings_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: bookings_bool_exp
  predicate: Boolean_comparison_exp!
}

input bookings_aggregate_bool_exp_bool_or {
  arguments: bookings_select_column_bookings_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: bookings_bool_exp
  predicate: Boolean_comparison_exp!
}

input bookings_aggregate_bool_exp_count {
  arguments: [bookings_select_column!]
  distinct: Boolean
  filter: bookings_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "bookings"
"""
type bookings_aggregate_fields {
  avg: bookings_avg_fields
  count(columns: [bookings_select_column!], distinct: Boolean): Int!
  max: bookings_max_fields
  min: bookings_min_fields
  stddev: bookings_stddev_fields
  stddev_pop: bookings_stddev_pop_fields
  stddev_samp: bookings_stddev_samp_fields
  sum: bookings_sum_fields
  var_pop: bookings_var_pop_fields
  var_samp: bookings_var_samp_fields
  variance: bookings_variance_fields
}

"""
order by aggregate values of table "bookings"
"""
input bookings_aggregate_order_by {
  avg: bookings_avg_order_by
  count: order_by
  max: bookings_max_order_by
  min: bookings_min_order_by
  stddev: bookings_stddev_order_by
  stddev_pop: bookings_stddev_pop_order_by
  stddev_samp: bookings_stddev_samp_order_by
  sum: bookings_sum_order_by
  var_pop: bookings_var_pop_order_by
  var_samp: bookings_var_samp_order_by
  variance: bookings_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input bookings_append_input {
  working_hours: jsonb
}

"""
input type for inserting array relation for remote table "bookings"
"""
input bookings_arr_rel_insert_input {
  data: [bookings_insert_input!]!

  """upsert condition"""
  on_conflict: bookings_on_conflict
}

"""aggregate avg on columns"""
type bookings_avg_fields {
  completion_rating: Float
  duration_months: Float
  salary_amount: Float
}

"""
order by avg() on columns of table "bookings"
"""
input bookings_avg_order_by {
  completion_rating: order_by
  duration_months: order_by
  salary_amount: order_by
}

"""
Boolean expression to filter rows from the table "bookings". All fields are combined with a logical 'AND'.
"""
input bookings_bool_exp {
  _and: [bookings_bool_exp!]
  _not: bookings_bool_exp
  _or: [bookings_bool_exp!]
  accommodation_provided: Boolean_comparison_exp
  agency_id: String_comparison_exp
  booking_type: String_comparison_exp
  cancellation_reason: String_comparison_exp
  cancelled_at: timestamptz_comparison_exp
  cancelled_by: uuid_comparison_exp
  completion_notes: String_comparison_exp
  completion_rating: Int_comparison_exp
  contract_type: String_comparison_exp
  created_at: timestamptz_comparison_exp
  duration_months: Int_comparison_exp
  duties: String_array_comparison_exp
  end_date: date_comparison_exp
  food_provided: Boolean_comparison_exp
  id: uuid_comparison_exp
  interview_date: timestamptz_comparison_exp
  interview_type: String_comparison_exp
  job: jobs_bool_exp
  job_id: uuid_comparison_exp
  maid_id: String_comparison_exp
  maid_profile: maid_profiles_bool_exp
  medical_insurance_provided: Boolean_comparison_exp
  notes: String_comparison_exp
  payment_frequency: String_comparison_exp
  payments: payments_bool_exp
  payments_aggregate: payments_aggregate_bool_exp
  salary_amount: numeric_comparison_exp
  salary_currency: String_comparison_exp
  sponsor_id: String_comparison_exp
  sponsor_profile: sponsor_profiles_bool_exp
  start_date: date_comparison_exp
  status: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  working_hours: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "bookings"
"""
enum bookings_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  bookings_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input bookings_delete_at_path_input {
  working_hours: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input bookings_delete_elem_input {
  working_hours: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input bookings_delete_key_input {
  working_hours: String
}

"""
input type for incrementing numeric columns in table "bookings"
"""
input bookings_inc_input {
  completion_rating: Int
  duration_months: Int
  salary_amount: numeric
}

"""
input type for inserting data into table "bookings"
"""
input bookings_insert_input {
  accommodation_provided: Boolean
  agency_id: String
  booking_type: String
  cancellation_reason: String
  cancelled_at: timestamptz
  cancelled_by: uuid
  completion_notes: String
  completion_rating: Int
  contract_type: String
  created_at: timestamptz
  duration_months: Int
  duties: [String!]
  end_date: date
  food_provided: Boolean
  id: uuid
  interview_date: timestamptz
  interview_type: String
  job: jobs_obj_rel_insert_input
  job_id: uuid
  maid_id: String
  maid_profile: maid_profiles_obj_rel_insert_input
  medical_insurance_provided: Boolean
  notes: String
  payment_frequency: String
  payments: payments_arr_rel_insert_input
  salary_amount: numeric
  salary_currency: String
  sponsor_id: String
  sponsor_profile: sponsor_profiles_obj_rel_insert_input
  start_date: date
  status: String
  updated_at: timestamptz
  working_hours: jsonb
}

"""aggregate max on columns"""
type bookings_max_fields {
  agency_id: String
  booking_type: String
  cancellation_reason: String
  cancelled_at: timestamptz
  cancelled_by: uuid
  completion_notes: String
  completion_rating: Int
  contract_type: String
  created_at: timestamptz
  duration_months: Int
  duties: [String!]
  end_date: date
  id: uuid
  interview_date: timestamptz
  interview_type: String
  job_id: uuid
  maid_id: String
  notes: String
  payment_frequency: String
  salary_amount: numeric
  salary_currency: String
  sponsor_id: String
  start_date: date
  status: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "bookings"
"""
input bookings_max_order_by {
  agency_id: order_by
  booking_type: order_by
  cancellation_reason: order_by
  cancelled_at: order_by
  cancelled_by: order_by
  completion_notes: order_by
  completion_rating: order_by
  contract_type: order_by
  created_at: order_by
  duration_months: order_by
  duties: order_by
  end_date: order_by
  id: order_by
  interview_date: order_by
  interview_type: order_by
  job_id: order_by
  maid_id: order_by
  notes: order_by
  payment_frequency: order_by
  salary_amount: order_by
  salary_currency: order_by
  sponsor_id: order_by
  start_date: order_by
  status: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type bookings_min_fields {
  agency_id: String
  booking_type: String
  cancellation_reason: String
  cancelled_at: timestamptz
  cancelled_by: uuid
  completion_notes: String
  completion_rating: Int
  contract_type: String
  created_at: timestamptz
  duration_months: Int
  duties: [String!]
  end_date: date
  id: uuid
  interview_date: timestamptz
  interview_type: String
  job_id: uuid
  maid_id: String
  notes: String
  payment_frequency: String
  salary_amount: numeric
  salary_currency: String
  sponsor_id: String
  start_date: date
  status: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "bookings"
"""
input bookings_min_order_by {
  agency_id: order_by
  booking_type: order_by
  cancellation_reason: order_by
  cancelled_at: order_by
  cancelled_by: order_by
  completion_notes: order_by
  completion_rating: order_by
  contract_type: order_by
  created_at: order_by
  duration_months: order_by
  duties: order_by
  end_date: order_by
  id: order_by
  interview_date: order_by
  interview_type: order_by
  job_id: order_by
  maid_id: order_by
  notes: order_by
  payment_frequency: order_by
  salary_amount: order_by
  salary_currency: order_by
  sponsor_id: order_by
  start_date: order_by
  status: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "bookings"
"""
type bookings_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [bookings!]!
}

"""
input type for inserting object relation for remote table "bookings"
"""
input bookings_obj_rel_insert_input {
  data: bookings_insert_input!

  """upsert condition"""
  on_conflict: bookings_on_conflict
}

"""
on_conflict condition type for table "bookings"
"""
input bookings_on_conflict {
  constraint: bookings_constraint!
  update_columns: [bookings_update_column!]! = []
  where: bookings_bool_exp
}

"""Ordering options when selecting data from "bookings"."""
input bookings_order_by {
  accommodation_provided: order_by
  agency_id: order_by
  booking_type: order_by
  cancellation_reason: order_by
  cancelled_at: order_by
  cancelled_by: order_by
  completion_notes: order_by
  completion_rating: order_by
  contract_type: order_by
  created_at: order_by
  duration_months: order_by
  duties: order_by
  end_date: order_by
  food_provided: order_by
  id: order_by
  interview_date: order_by
  interview_type: order_by
  job: jobs_order_by
  job_id: order_by
  maid_id: order_by
  maid_profile: maid_profiles_order_by
  medical_insurance_provided: order_by
  notes: order_by
  payment_frequency: order_by
  payments_aggregate: payments_aggregate_order_by
  salary_amount: order_by
  salary_currency: order_by
  sponsor_id: order_by
  sponsor_profile: sponsor_profiles_order_by
  start_date: order_by
  status: order_by
  updated_at: order_by
  working_hours: order_by
}

"""primary key columns input for table: bookings"""
input bookings_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input bookings_prepend_input {
  working_hours: jsonb
}

"""
select columns of table "bookings"
"""
enum bookings_select_column {
  """column name"""
  accommodation_provided

  """column name"""
  agency_id

  """column name"""
  booking_type

  """column name"""
  cancellation_reason

  """column name"""
  cancelled_at

  """column name"""
  cancelled_by

  """column name"""
  completion_notes

  """column name"""
  completion_rating

  """column name"""
  contract_type

  """column name"""
  created_at

  """column name"""
  duration_months

  """column name"""
  duties

  """column name"""
  end_date

  """column name"""
  food_provided

  """column name"""
  id

  """column name"""
  interview_date

  """column name"""
  interview_type

  """column name"""
  job_id

  """column name"""
  maid_id

  """column name"""
  medical_insurance_provided

  """column name"""
  notes

  """column name"""
  payment_frequency

  """column name"""
  salary_amount

  """column name"""
  salary_currency

  """column name"""
  sponsor_id

  """column name"""
  start_date

  """column name"""
  status

  """column name"""
  updated_at

  """column name"""
  working_hours
}

"""
select "bookings_aggregate_bool_exp_bool_and_arguments_columns" columns of table "bookings"
"""
enum bookings_select_column_bookings_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  accommodation_provided

  """column name"""
  food_provided

  """column name"""
  medical_insurance_provided
}

"""
select "bookings_aggregate_bool_exp_bool_or_arguments_columns" columns of table "bookings"
"""
enum bookings_select_column_bookings_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  accommodation_provided

  """column name"""
  food_provided

  """column name"""
  medical_insurance_provided
}

"""
input type for updating data in table "bookings"
"""
input bookings_set_input {
  accommodation_provided: Boolean
  agency_id: String
  booking_type: String
  cancellation_reason: String
  cancelled_at: timestamptz
  cancelled_by: uuid
  completion_notes: String
  completion_rating: Int
  contract_type: String
  created_at: timestamptz
  duration_months: Int
  duties: [String!]
  end_date: date
  food_provided: Boolean
  id: uuid
  interview_date: timestamptz
  interview_type: String
  job_id: uuid
  maid_id: String
  medical_insurance_provided: Boolean
  notes: String
  payment_frequency: String
  salary_amount: numeric
  salary_currency: String
  sponsor_id: String
  start_date: date
  status: String
  updated_at: timestamptz
  working_hours: jsonb
}

"""aggregate stddev on columns"""
type bookings_stddev_fields {
  completion_rating: Float
  duration_months: Float
  salary_amount: Float
}

"""
order by stddev() on columns of table "bookings"
"""
input bookings_stddev_order_by {
  completion_rating: order_by
  duration_months: order_by
  salary_amount: order_by
}

"""aggregate stddev_pop on columns"""
type bookings_stddev_pop_fields {
  completion_rating: Float
  duration_months: Float
  salary_amount: Float
}

"""
order by stddev_pop() on columns of table "bookings"
"""
input bookings_stddev_pop_order_by {
  completion_rating: order_by
  duration_months: order_by
  salary_amount: order_by
}

"""aggregate stddev_samp on columns"""
type bookings_stddev_samp_fields {
  completion_rating: Float
  duration_months: Float
  salary_amount: Float
}

"""
order by stddev_samp() on columns of table "bookings"
"""
input bookings_stddev_samp_order_by {
  completion_rating: order_by
  duration_months: order_by
  salary_amount: order_by
}

"""
Streaming cursor of the table "bookings"
"""
input bookings_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: bookings_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input bookings_stream_cursor_value_input {
  accommodation_provided: Boolean
  agency_id: String
  booking_type: String
  cancellation_reason: String
  cancelled_at: timestamptz
  cancelled_by: uuid
  completion_notes: String
  completion_rating: Int
  contract_type: String
  created_at: timestamptz
  duration_months: Int
  duties: [String!]
  end_date: date
  food_provided: Boolean
  id: uuid
  interview_date: timestamptz
  interview_type: String
  job_id: uuid
  maid_id: String
  medical_insurance_provided: Boolean
  notes: String
  payment_frequency: String
  salary_amount: numeric
  salary_currency: String
  sponsor_id: String
  start_date: date
  status: String
  updated_at: timestamptz
  working_hours: jsonb
}

"""aggregate sum on columns"""
type bookings_sum_fields {
  completion_rating: Int
  duration_months: Int
  salary_amount: numeric
}

"""
order by sum() on columns of table "bookings"
"""
input bookings_sum_order_by {
  completion_rating: order_by
  duration_months: order_by
  salary_amount: order_by
}

"""
update columns of table "bookings"
"""
enum bookings_update_column {
  """column name"""
  accommodation_provided

  """column name"""
  agency_id

  """column name"""
  booking_type

  """column name"""
  cancellation_reason

  """column name"""
  cancelled_at

  """column name"""
  cancelled_by

  """column name"""
  completion_notes

  """column name"""
  completion_rating

  """column name"""
  contract_type

  """column name"""
  created_at

  """column name"""
  duration_months

  """column name"""
  duties

  """column name"""
  end_date

  """column name"""
  food_provided

  """column name"""
  id

  """column name"""
  interview_date

  """column name"""
  interview_type

  """column name"""
  job_id

  """column name"""
  maid_id

  """column name"""
  medical_insurance_provided

  """column name"""
  notes

  """column name"""
  payment_frequency

  """column name"""
  salary_amount

  """column name"""
  salary_currency

  """column name"""
  sponsor_id

  """column name"""
  start_date

  """column name"""
  status

  """column name"""
  updated_at

  """column name"""
  working_hours
}

input bookings_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: bookings_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: bookings_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: bookings_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: bookings_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: bookings_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: bookings_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: bookings_set_input

  """filter the rows which have to be updated"""
  where: bookings_bool_exp!
}

"""aggregate var_pop on columns"""
type bookings_var_pop_fields {
  completion_rating: Float
  duration_months: Float
  salary_amount: Float
}

"""
order by var_pop() on columns of table "bookings"
"""
input bookings_var_pop_order_by {
  completion_rating: order_by
  duration_months: order_by
  salary_amount: order_by
}

"""aggregate var_samp on columns"""
type bookings_var_samp_fields {
  completion_rating: Float
  duration_months: Float
  salary_amount: Float
}

"""
order by var_samp() on columns of table "bookings"
"""
input bookings_var_samp_order_by {
  completion_rating: order_by
  duration_months: order_by
  salary_amount: order_by
}

"""aggregate variance on columns"""
type bookings_variance_fields {
  completion_rating: Float
  duration_months: Float
  salary_amount: Float
}

"""
order by variance() on columns of table "bookings"
"""
input bookings_variance_order_by {
  completion_rating: order_by
  duration_months: order_by
  salary_amount: order_by
}

scalar buckettype

"""
Boolean expression to compare columns of type "buckettype". All fields are combined with logical 'AND'.
"""
input buckettype_comparison_exp {
  _eq: buckettype
  _gt: buckettype
  _gte: buckettype
  _in: [buckettype!]
  _is_null: Boolean
  _lt: buckettype
  _lte: buckettype
  _neq: buckettype
  _nin: [buckettype!]
}

"""Calendar events for agency scheduling"""
type calendar_events {
  agency_id: uuid!
  all_day: Boolean
  created_at: timestamptz
  created_by: String
  description: String
  end_date: date
  end_time: time
  event_type: String
  id: uuid!
  location: String
  location_type: String
  maid_id: uuid
  meeting_link: String
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  notes: String
  outcome: String
  priority: String
  sponsor_id: uuid
  start_date: date!
  start_time: time
  status: String
  tags: [String!]
  title: String!
  updated_at: timestamptz
}

"""
aggregated selection of "calendar_events"
"""
type calendar_events_aggregate {
  aggregate: calendar_events_aggregate_fields
  nodes: [calendar_events!]!
}

"""
aggregate fields of "calendar_events"
"""
type calendar_events_aggregate_fields {
  count(columns: [calendar_events_select_column!], distinct: Boolean): Int!
  max: calendar_events_max_fields
  min: calendar_events_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input calendar_events_append_input {
  metadata: jsonb
}

"""
Boolean expression to filter rows from the table "calendar_events". All fields are combined with a logical 'AND'.
"""
input calendar_events_bool_exp {
  _and: [calendar_events_bool_exp!]
  _not: calendar_events_bool_exp
  _or: [calendar_events_bool_exp!]
  agency_id: uuid_comparison_exp
  all_day: Boolean_comparison_exp
  created_at: timestamptz_comparison_exp
  created_by: String_comparison_exp
  description: String_comparison_exp
  end_date: date_comparison_exp
  end_time: time_comparison_exp
  event_type: String_comparison_exp
  id: uuid_comparison_exp
  location: String_comparison_exp
  location_type: String_comparison_exp
  maid_id: uuid_comparison_exp
  meeting_link: String_comparison_exp
  metadata: jsonb_comparison_exp
  notes: String_comparison_exp
  outcome: String_comparison_exp
  priority: String_comparison_exp
  sponsor_id: uuid_comparison_exp
  start_date: date_comparison_exp
  start_time: time_comparison_exp
  status: String_comparison_exp
  tags: String_array_comparison_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "calendar_events"
"""
enum calendar_events_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  calendar_events_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input calendar_events_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input calendar_events_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input calendar_events_delete_key_input {
  metadata: String
}

"""
input type for inserting data into table "calendar_events"
"""
input calendar_events_insert_input {
  agency_id: uuid
  all_day: Boolean
  created_at: timestamptz
  created_by: String
  description: String
  end_date: date
  end_time: time
  event_type: String
  id: uuid
  location: String
  location_type: String
  maid_id: uuid
  meeting_link: String
  metadata: jsonb
  notes: String
  outcome: String
  priority: String
  sponsor_id: uuid
  start_date: date
  start_time: time
  status: String
  tags: [String!]
  title: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type calendar_events_max_fields {
  agency_id: uuid
  created_at: timestamptz
  created_by: String
  description: String
  end_date: date
  event_type: String
  id: uuid
  location: String
  location_type: String
  maid_id: uuid
  meeting_link: String
  notes: String
  outcome: String
  priority: String
  sponsor_id: uuid
  start_date: date
  status: String
  tags: [String!]
  title: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type calendar_events_min_fields {
  agency_id: uuid
  created_at: timestamptz
  created_by: String
  description: String
  end_date: date
  event_type: String
  id: uuid
  location: String
  location_type: String
  maid_id: uuid
  meeting_link: String
  notes: String
  outcome: String
  priority: String
  sponsor_id: uuid
  start_date: date
  status: String
  tags: [String!]
  title: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "calendar_events"
"""
type calendar_events_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [calendar_events!]!
}

"""
on_conflict condition type for table "calendar_events"
"""
input calendar_events_on_conflict {
  constraint: calendar_events_constraint!
  update_columns: [calendar_events_update_column!]! = []
  where: calendar_events_bool_exp
}

"""Ordering options when selecting data from "calendar_events"."""
input calendar_events_order_by {
  agency_id: order_by
  all_day: order_by
  created_at: order_by
  created_by: order_by
  description: order_by
  end_date: order_by
  end_time: order_by
  event_type: order_by
  id: order_by
  location: order_by
  location_type: order_by
  maid_id: order_by
  meeting_link: order_by
  metadata: order_by
  notes: order_by
  outcome: order_by
  priority: order_by
  sponsor_id: order_by
  start_date: order_by
  start_time: order_by
  status: order_by
  tags: order_by
  title: order_by
  updated_at: order_by
}

"""primary key columns input for table: calendar_events"""
input calendar_events_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input calendar_events_prepend_input {
  metadata: jsonb
}

"""
select columns of table "calendar_events"
"""
enum calendar_events_select_column {
  """column name"""
  agency_id

  """column name"""
  all_day

  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  description

  """column name"""
  end_date

  """column name"""
  end_time

  """column name"""
  event_type

  """column name"""
  id

  """column name"""
  location

  """column name"""
  location_type

  """column name"""
  maid_id

  """column name"""
  meeting_link

  """column name"""
  metadata

  """column name"""
  notes

  """column name"""
  outcome

  """column name"""
  priority

  """column name"""
  sponsor_id

  """column name"""
  start_date

  """column name"""
  start_time

  """column name"""
  status

  """column name"""
  tags

  """column name"""
  title

  """column name"""
  updated_at
}

"""
input type for updating data in table "calendar_events"
"""
input calendar_events_set_input {
  agency_id: uuid
  all_day: Boolean
  created_at: timestamptz
  created_by: String
  description: String
  end_date: date
  end_time: time
  event_type: String
  id: uuid
  location: String
  location_type: String
  maid_id: uuid
  meeting_link: String
  metadata: jsonb
  notes: String
  outcome: String
  priority: String
  sponsor_id: uuid
  start_date: date
  start_time: time
  status: String
  tags: [String!]
  title: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "calendar_events"
"""
input calendar_events_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: calendar_events_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input calendar_events_stream_cursor_value_input {
  agency_id: uuid
  all_day: Boolean
  created_at: timestamptz
  created_by: String
  description: String
  end_date: date
  end_time: time
  event_type: String
  id: uuid
  location: String
  location_type: String
  maid_id: uuid
  meeting_link: String
  metadata: jsonb
  notes: String
  outcome: String
  priority: String
  sponsor_id: uuid
  start_date: date
  start_time: time
  status: String
  tags: [String!]
  title: String
  updated_at: timestamptz
}

"""
update columns of table "calendar_events"
"""
enum calendar_events_update_column {
  """column name"""
  agency_id

  """column name"""
  all_day

  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  description

  """column name"""
  end_date

  """column name"""
  end_time

  """column name"""
  event_type

  """column name"""
  id

  """column name"""
  location

  """column name"""
  location_type

  """column name"""
  maid_id

  """column name"""
  meeting_link

  """column name"""
  metadata

  """column name"""
  notes

  """column name"""
  outcome

  """column name"""
  priority

  """column name"""
  sponsor_id

  """column name"""
  start_date

  """column name"""
  start_time

  """column name"""
  status

  """column name"""
  tags

  """column name"""
  title

  """column name"""
  updated_at
}

input calendar_events_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: calendar_events_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: calendar_events_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: calendar_events_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: calendar_events_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: calendar_events_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: calendar_events_set_input

  """filter the rows which have to be updated"""
  where: calendar_events_bool_exp!
}

"""Stores client satisfaction ratings by category"""
type client_satisfaction_ratings {
  agency_id: uuid!
  communication_rating: numeric
  created_at: timestamptz
  documentation_rating: numeric
  feedback_text: String
  id: uuid!
  maid_id: uuid
  overall_rating: numeric

  """An object relationship"""
  placement_contract: placement_contracts
  placement_id: uuid
  quality_rating: numeric
  rating_date: timestamptz
  sponsor_id: uuid!
  timeliness_rating: numeric
  updated_at: timestamptz

  """An object relationship"""
  user: auth_users!

  """An object relationship"""
  userByMaidId: auth_users

  """An object relationship"""
  userBySponsorId: auth_users!
  would_recommend: Boolean
}

"""
aggregated selection of "client_satisfaction_ratings"
"""
type client_satisfaction_ratings_aggregate {
  aggregate: client_satisfaction_ratings_aggregate_fields
  nodes: [client_satisfaction_ratings!]!
}

input client_satisfaction_ratings_aggregate_bool_exp {
  bool_and: client_satisfaction_ratings_aggregate_bool_exp_bool_and
  bool_or: client_satisfaction_ratings_aggregate_bool_exp_bool_or
  count: client_satisfaction_ratings_aggregate_bool_exp_count
}

input client_satisfaction_ratings_aggregate_bool_exp_bool_and {
  arguments: client_satisfaction_ratings_select_column_client_satisfaction_ratings_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: client_satisfaction_ratings_bool_exp
  predicate: Boolean_comparison_exp!
}

input client_satisfaction_ratings_aggregate_bool_exp_bool_or {
  arguments: client_satisfaction_ratings_select_column_client_satisfaction_ratings_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: client_satisfaction_ratings_bool_exp
  predicate: Boolean_comparison_exp!
}

input client_satisfaction_ratings_aggregate_bool_exp_count {
  arguments: [client_satisfaction_ratings_select_column!]
  distinct: Boolean
  filter: client_satisfaction_ratings_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "client_satisfaction_ratings"
"""
type client_satisfaction_ratings_aggregate_fields {
  avg: client_satisfaction_ratings_avg_fields
  count(columns: [client_satisfaction_ratings_select_column!], distinct: Boolean): Int!
  max: client_satisfaction_ratings_max_fields
  min: client_satisfaction_ratings_min_fields
  stddev: client_satisfaction_ratings_stddev_fields
  stddev_pop: client_satisfaction_ratings_stddev_pop_fields
  stddev_samp: client_satisfaction_ratings_stddev_samp_fields
  sum: client_satisfaction_ratings_sum_fields
  var_pop: client_satisfaction_ratings_var_pop_fields
  var_samp: client_satisfaction_ratings_var_samp_fields
  variance: client_satisfaction_ratings_variance_fields
}

"""
order by aggregate values of table "client_satisfaction_ratings"
"""
input client_satisfaction_ratings_aggregate_order_by {
  avg: client_satisfaction_ratings_avg_order_by
  count: order_by
  max: client_satisfaction_ratings_max_order_by
  min: client_satisfaction_ratings_min_order_by
  stddev: client_satisfaction_ratings_stddev_order_by
  stddev_pop: client_satisfaction_ratings_stddev_pop_order_by
  stddev_samp: client_satisfaction_ratings_stddev_samp_order_by
  sum: client_satisfaction_ratings_sum_order_by
  var_pop: client_satisfaction_ratings_var_pop_order_by
  var_samp: client_satisfaction_ratings_var_samp_order_by
  variance: client_satisfaction_ratings_variance_order_by
}

"""
input type for inserting array relation for remote table "client_satisfaction_ratings"
"""
input client_satisfaction_ratings_arr_rel_insert_input {
  data: [client_satisfaction_ratings_insert_input!]!

  """upsert condition"""
  on_conflict: client_satisfaction_ratings_on_conflict
}

"""aggregate avg on columns"""
type client_satisfaction_ratings_avg_fields {
  communication_rating: Float
  documentation_rating: Float
  overall_rating: Float
  quality_rating: Float
  timeliness_rating: Float
}

"""
order by avg() on columns of table "client_satisfaction_ratings"
"""
input client_satisfaction_ratings_avg_order_by {
  communication_rating: order_by
  documentation_rating: order_by
  overall_rating: order_by
  quality_rating: order_by
  timeliness_rating: order_by
}

"""
Boolean expression to filter rows from the table "client_satisfaction_ratings". All fields are combined with a logical 'AND'.
"""
input client_satisfaction_ratings_bool_exp {
  _and: [client_satisfaction_ratings_bool_exp!]
  _not: client_satisfaction_ratings_bool_exp
  _or: [client_satisfaction_ratings_bool_exp!]
  agency_id: uuid_comparison_exp
  communication_rating: numeric_comparison_exp
  created_at: timestamptz_comparison_exp
  documentation_rating: numeric_comparison_exp
  feedback_text: String_comparison_exp
  id: uuid_comparison_exp
  maid_id: uuid_comparison_exp
  overall_rating: numeric_comparison_exp
  placement_contract: placement_contracts_bool_exp
  placement_id: uuid_comparison_exp
  quality_rating: numeric_comparison_exp
  rating_date: timestamptz_comparison_exp
  sponsor_id: uuid_comparison_exp
  timeliness_rating: numeric_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
  userByMaidId: auth_users_bool_exp
  userBySponsorId: auth_users_bool_exp
  would_recommend: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "client_satisfaction_ratings"
"""
enum client_satisfaction_ratings_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  client_satisfaction_ratings_pkey
}

"""
input type for incrementing numeric columns in table "client_satisfaction_ratings"
"""
input client_satisfaction_ratings_inc_input {
  communication_rating: numeric
  documentation_rating: numeric
  overall_rating: numeric
  quality_rating: numeric
  timeliness_rating: numeric
}

"""
input type for inserting data into table "client_satisfaction_ratings"
"""
input client_satisfaction_ratings_insert_input {
  agency_id: uuid
  communication_rating: numeric
  created_at: timestamptz
  documentation_rating: numeric
  feedback_text: String
  id: uuid
  maid_id: uuid
  overall_rating: numeric
  placement_contract: placement_contracts_obj_rel_insert_input
  placement_id: uuid
  quality_rating: numeric
  rating_date: timestamptz
  sponsor_id: uuid
  timeliness_rating: numeric
  updated_at: timestamptz
  user: auth_users_obj_rel_insert_input
  userByMaidId: auth_users_obj_rel_insert_input
  userBySponsorId: auth_users_obj_rel_insert_input
  would_recommend: Boolean
}

"""aggregate max on columns"""
type client_satisfaction_ratings_max_fields {
  agency_id: uuid
  communication_rating: numeric
  created_at: timestamptz
  documentation_rating: numeric
  feedback_text: String
  id: uuid
  maid_id: uuid
  overall_rating: numeric
  placement_id: uuid
  quality_rating: numeric
  rating_date: timestamptz
  sponsor_id: uuid
  timeliness_rating: numeric
  updated_at: timestamptz
}

"""
order by max() on columns of table "client_satisfaction_ratings"
"""
input client_satisfaction_ratings_max_order_by {
  agency_id: order_by
  communication_rating: order_by
  created_at: order_by
  documentation_rating: order_by
  feedback_text: order_by
  id: order_by
  maid_id: order_by
  overall_rating: order_by
  placement_id: order_by
  quality_rating: order_by
  rating_date: order_by
  sponsor_id: order_by
  timeliness_rating: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type client_satisfaction_ratings_min_fields {
  agency_id: uuid
  communication_rating: numeric
  created_at: timestamptz
  documentation_rating: numeric
  feedback_text: String
  id: uuid
  maid_id: uuid
  overall_rating: numeric
  placement_id: uuid
  quality_rating: numeric
  rating_date: timestamptz
  sponsor_id: uuid
  timeliness_rating: numeric
  updated_at: timestamptz
}

"""
order by min() on columns of table "client_satisfaction_ratings"
"""
input client_satisfaction_ratings_min_order_by {
  agency_id: order_by
  communication_rating: order_by
  created_at: order_by
  documentation_rating: order_by
  feedback_text: order_by
  id: order_by
  maid_id: order_by
  overall_rating: order_by
  placement_id: order_by
  quality_rating: order_by
  rating_date: order_by
  sponsor_id: order_by
  timeliness_rating: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "client_satisfaction_ratings"
"""
type client_satisfaction_ratings_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [client_satisfaction_ratings!]!
}

"""
on_conflict condition type for table "client_satisfaction_ratings"
"""
input client_satisfaction_ratings_on_conflict {
  constraint: client_satisfaction_ratings_constraint!
  update_columns: [client_satisfaction_ratings_update_column!]! = []
  where: client_satisfaction_ratings_bool_exp
}

"""
Ordering options when selecting data from "client_satisfaction_ratings".
"""
input client_satisfaction_ratings_order_by {
  agency_id: order_by
  communication_rating: order_by
  created_at: order_by
  documentation_rating: order_by
  feedback_text: order_by
  id: order_by
  maid_id: order_by
  overall_rating: order_by
  placement_contract: placement_contracts_order_by
  placement_id: order_by
  quality_rating: order_by
  rating_date: order_by
  sponsor_id: order_by
  timeliness_rating: order_by
  updated_at: order_by
  user: auth_users_order_by
  userByMaidId: auth_users_order_by
  userBySponsorId: auth_users_order_by
  would_recommend: order_by
}

"""primary key columns input for table: client_satisfaction_ratings"""
input client_satisfaction_ratings_pk_columns_input {
  id: uuid!
}

"""
select columns of table "client_satisfaction_ratings"
"""
enum client_satisfaction_ratings_select_column {
  """column name"""
  agency_id

  """column name"""
  communication_rating

  """column name"""
  created_at

  """column name"""
  documentation_rating

  """column name"""
  feedback_text

  """column name"""
  id

  """column name"""
  maid_id

  """column name"""
  overall_rating

  """column name"""
  placement_id

  """column name"""
  quality_rating

  """column name"""
  rating_date

  """column name"""
  sponsor_id

  """column name"""
  timeliness_rating

  """column name"""
  updated_at

  """column name"""
  would_recommend
}

"""
select "client_satisfaction_ratings_aggregate_bool_exp_bool_and_arguments_columns" columns of table "client_satisfaction_ratings"
"""
enum client_satisfaction_ratings_select_column_client_satisfaction_ratings_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  would_recommend
}

"""
select "client_satisfaction_ratings_aggregate_bool_exp_bool_or_arguments_columns" columns of table "client_satisfaction_ratings"
"""
enum client_satisfaction_ratings_select_column_client_satisfaction_ratings_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  would_recommend
}

"""
input type for updating data in table "client_satisfaction_ratings"
"""
input client_satisfaction_ratings_set_input {
  agency_id: uuid
  communication_rating: numeric
  created_at: timestamptz
  documentation_rating: numeric
  feedback_text: String
  id: uuid
  maid_id: uuid
  overall_rating: numeric
  placement_id: uuid
  quality_rating: numeric
  rating_date: timestamptz
  sponsor_id: uuid
  timeliness_rating: numeric
  updated_at: timestamptz
  would_recommend: Boolean
}

"""aggregate stddev on columns"""
type client_satisfaction_ratings_stddev_fields {
  communication_rating: Float
  documentation_rating: Float
  overall_rating: Float
  quality_rating: Float
  timeliness_rating: Float
}

"""
order by stddev() on columns of table "client_satisfaction_ratings"
"""
input client_satisfaction_ratings_stddev_order_by {
  communication_rating: order_by
  documentation_rating: order_by
  overall_rating: order_by
  quality_rating: order_by
  timeliness_rating: order_by
}

"""aggregate stddev_pop on columns"""
type client_satisfaction_ratings_stddev_pop_fields {
  communication_rating: Float
  documentation_rating: Float
  overall_rating: Float
  quality_rating: Float
  timeliness_rating: Float
}

"""
order by stddev_pop() on columns of table "client_satisfaction_ratings"
"""
input client_satisfaction_ratings_stddev_pop_order_by {
  communication_rating: order_by
  documentation_rating: order_by
  overall_rating: order_by
  quality_rating: order_by
  timeliness_rating: order_by
}

"""aggregate stddev_samp on columns"""
type client_satisfaction_ratings_stddev_samp_fields {
  communication_rating: Float
  documentation_rating: Float
  overall_rating: Float
  quality_rating: Float
  timeliness_rating: Float
}

"""
order by stddev_samp() on columns of table "client_satisfaction_ratings"
"""
input client_satisfaction_ratings_stddev_samp_order_by {
  communication_rating: order_by
  documentation_rating: order_by
  overall_rating: order_by
  quality_rating: order_by
  timeliness_rating: order_by
}

"""
Streaming cursor of the table "client_satisfaction_ratings"
"""
input client_satisfaction_ratings_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: client_satisfaction_ratings_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input client_satisfaction_ratings_stream_cursor_value_input {
  agency_id: uuid
  communication_rating: numeric
  created_at: timestamptz
  documentation_rating: numeric
  feedback_text: String
  id: uuid
  maid_id: uuid
  overall_rating: numeric
  placement_id: uuid
  quality_rating: numeric
  rating_date: timestamptz
  sponsor_id: uuid
  timeliness_rating: numeric
  updated_at: timestamptz
  would_recommend: Boolean
}

"""aggregate sum on columns"""
type client_satisfaction_ratings_sum_fields {
  communication_rating: numeric
  documentation_rating: numeric
  overall_rating: numeric
  quality_rating: numeric
  timeliness_rating: numeric
}

"""
order by sum() on columns of table "client_satisfaction_ratings"
"""
input client_satisfaction_ratings_sum_order_by {
  communication_rating: order_by
  documentation_rating: order_by
  overall_rating: order_by
  quality_rating: order_by
  timeliness_rating: order_by
}

"""
update columns of table "client_satisfaction_ratings"
"""
enum client_satisfaction_ratings_update_column {
  """column name"""
  agency_id

  """column name"""
  communication_rating

  """column name"""
  created_at

  """column name"""
  documentation_rating

  """column name"""
  feedback_text

  """column name"""
  id

  """column name"""
  maid_id

  """column name"""
  overall_rating

  """column name"""
  placement_id

  """column name"""
  quality_rating

  """column name"""
  rating_date

  """column name"""
  sponsor_id

  """column name"""
  timeliness_rating

  """column name"""
  updated_at

  """column name"""
  would_recommend
}

input client_satisfaction_ratings_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: client_satisfaction_ratings_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: client_satisfaction_ratings_set_input

  """filter the rows which have to be updated"""
  where: client_satisfaction_ratings_bool_exp!
}

"""aggregate var_pop on columns"""
type client_satisfaction_ratings_var_pop_fields {
  communication_rating: Float
  documentation_rating: Float
  overall_rating: Float
  quality_rating: Float
  timeliness_rating: Float
}

"""
order by var_pop() on columns of table "client_satisfaction_ratings"
"""
input client_satisfaction_ratings_var_pop_order_by {
  communication_rating: order_by
  documentation_rating: order_by
  overall_rating: order_by
  quality_rating: order_by
  timeliness_rating: order_by
}

"""aggregate var_samp on columns"""
type client_satisfaction_ratings_var_samp_fields {
  communication_rating: Float
  documentation_rating: Float
  overall_rating: Float
  quality_rating: Float
  timeliness_rating: Float
}

"""
order by var_samp() on columns of table "client_satisfaction_ratings"
"""
input client_satisfaction_ratings_var_samp_order_by {
  communication_rating: order_by
  documentation_rating: order_by
  overall_rating: order_by
  quality_rating: order_by
  timeliness_rating: order_by
}

"""aggregate variance on columns"""
type client_satisfaction_ratings_variance_fields {
  communication_rating: Float
  documentation_rating: Float
  overall_rating: Float
  quality_rating: Float
  timeliness_rating: Float
}

"""
order by variance() on columns of table "client_satisfaction_ratings"
"""
input client_satisfaction_ratings_variance_order_by {
  communication_rating: order_by
  documentation_rating: order_by
  overall_rating: order_by
  quality_rating: order_by
  timeliness_rating: order_by
}

scalar code_challenge_method

"""
Boolean expression to compare columns of type "code_challenge_method". All fields are combined with logical 'AND'.
"""
input code_challenge_method_comparison_exp {
  _eq: code_challenge_method
  _gt: code_challenge_method
  _gte: code_challenge_method
  _in: [code_challenge_method!]
  _is_null: Boolean
  _lt: code_challenge_method
  _lte: code_challenge_method
  _neq: code_challenge_method
  _nin: [code_challenge_method!]
}

"""
columns and relationships of "compliance_categories"
"""
type compliance_categories {
  agency_id: uuid!
  category: String!
  completed_items: Int

  """An array relationship"""
  compliance_items(
    """distinct select on columns"""
    distinct_on: [compliance_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [compliance_items_order_by!]

    """filter the rows returned"""
    where: compliance_items_bool_exp
  ): [compliance_items!]!

  """An aggregate relationship"""
  compliance_items_aggregate(
    """distinct select on columns"""
    distinct_on: [compliance_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [compliance_items_order_by!]

    """filter the rows returned"""
    where: compliance_items_bool_exp
  ): compliance_items_aggregate!
  compliance_percentage: Int
  created_at: timestamptz
  description: String
  id: uuid!
  priority: String
  title: String!
  total_items: Int
  updated_at: timestamptz

  """An object relationship"""
  user: auth_users!
}

"""
aggregated selection of "compliance_categories"
"""
type compliance_categories_aggregate {
  aggregate: compliance_categories_aggregate_fields
  nodes: [compliance_categories!]!
}

"""
aggregate fields of "compliance_categories"
"""
type compliance_categories_aggregate_fields {
  avg: compliance_categories_avg_fields
  count(columns: [compliance_categories_select_column!], distinct: Boolean): Int!
  max: compliance_categories_max_fields
  min: compliance_categories_min_fields
  stddev: compliance_categories_stddev_fields
  stddev_pop: compliance_categories_stddev_pop_fields
  stddev_samp: compliance_categories_stddev_samp_fields
  sum: compliance_categories_sum_fields
  var_pop: compliance_categories_var_pop_fields
  var_samp: compliance_categories_var_samp_fields
  variance: compliance_categories_variance_fields
}

"""aggregate avg on columns"""
type compliance_categories_avg_fields {
  completed_items: Float
  compliance_percentage: Float
  total_items: Float
}

"""
Boolean expression to filter rows from the table "compliance_categories". All fields are combined with a logical 'AND'.
"""
input compliance_categories_bool_exp {
  _and: [compliance_categories_bool_exp!]
  _not: compliance_categories_bool_exp
  _or: [compliance_categories_bool_exp!]
  agency_id: uuid_comparison_exp
  category: String_comparison_exp
  completed_items: Int_comparison_exp
  compliance_items: compliance_items_bool_exp
  compliance_items_aggregate: compliance_items_aggregate_bool_exp
  compliance_percentage: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  priority: String_comparison_exp
  title: String_comparison_exp
  total_items: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
}

"""
unique or primary key constraints on table "compliance_categories"
"""
enum compliance_categories_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  compliance_categories_pkey
}

"""
input type for incrementing numeric columns in table "compliance_categories"
"""
input compliance_categories_inc_input {
  completed_items: Int
  compliance_percentage: Int
  total_items: Int
}

"""
input type for inserting data into table "compliance_categories"
"""
input compliance_categories_insert_input {
  agency_id: uuid
  category: String
  completed_items: Int
  compliance_items: compliance_items_arr_rel_insert_input
  compliance_percentage: Int
  created_at: timestamptz
  description: String
  id: uuid
  priority: String
  title: String
  total_items: Int
  updated_at: timestamptz
  user: auth_users_obj_rel_insert_input
}

"""aggregate max on columns"""
type compliance_categories_max_fields {
  agency_id: uuid
  category: String
  completed_items: Int
  compliance_percentage: Int
  created_at: timestamptz
  description: String
  id: uuid
  priority: String
  title: String
  total_items: Int
  updated_at: timestamptz
}

"""aggregate min on columns"""
type compliance_categories_min_fields {
  agency_id: uuid
  category: String
  completed_items: Int
  compliance_percentage: Int
  created_at: timestamptz
  description: String
  id: uuid
  priority: String
  title: String
  total_items: Int
  updated_at: timestamptz
}

"""
response of any mutation on the table "compliance_categories"
"""
type compliance_categories_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [compliance_categories!]!
}

"""
input type for inserting object relation for remote table "compliance_categories"
"""
input compliance_categories_obj_rel_insert_input {
  data: compliance_categories_insert_input!

  """upsert condition"""
  on_conflict: compliance_categories_on_conflict
}

"""
on_conflict condition type for table "compliance_categories"
"""
input compliance_categories_on_conflict {
  constraint: compliance_categories_constraint!
  update_columns: [compliance_categories_update_column!]! = []
  where: compliance_categories_bool_exp
}

"""Ordering options when selecting data from "compliance_categories"."""
input compliance_categories_order_by {
  agency_id: order_by
  category: order_by
  completed_items: order_by
  compliance_items_aggregate: compliance_items_aggregate_order_by
  compliance_percentage: order_by
  created_at: order_by
  description: order_by
  id: order_by
  priority: order_by
  title: order_by
  total_items: order_by
  updated_at: order_by
  user: auth_users_order_by
}

"""primary key columns input for table: compliance_categories"""
input compliance_categories_pk_columns_input {
  id: uuid!
}

"""
select columns of table "compliance_categories"
"""
enum compliance_categories_select_column {
  """column name"""
  agency_id

  """column name"""
  category

  """column name"""
  completed_items

  """column name"""
  compliance_percentage

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  priority

  """column name"""
  title

  """column name"""
  total_items

  """column name"""
  updated_at
}

"""
input type for updating data in table "compliance_categories"
"""
input compliance_categories_set_input {
  agency_id: uuid
  category: String
  completed_items: Int
  compliance_percentage: Int
  created_at: timestamptz
  description: String
  id: uuid
  priority: String
  title: String
  total_items: Int
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type compliance_categories_stddev_fields {
  completed_items: Float
  compliance_percentage: Float
  total_items: Float
}

"""aggregate stddev_pop on columns"""
type compliance_categories_stddev_pop_fields {
  completed_items: Float
  compliance_percentage: Float
  total_items: Float
}

"""aggregate stddev_samp on columns"""
type compliance_categories_stddev_samp_fields {
  completed_items: Float
  compliance_percentage: Float
  total_items: Float
}

"""
Streaming cursor of the table "compliance_categories"
"""
input compliance_categories_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: compliance_categories_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input compliance_categories_stream_cursor_value_input {
  agency_id: uuid
  category: String
  completed_items: Int
  compliance_percentage: Int
  created_at: timestamptz
  description: String
  id: uuid
  priority: String
  title: String
  total_items: Int
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type compliance_categories_sum_fields {
  completed_items: Int
  compliance_percentage: Int
  total_items: Int
}

"""
update columns of table "compliance_categories"
"""
enum compliance_categories_update_column {
  """column name"""
  agency_id

  """column name"""
  category

  """column name"""
  completed_items

  """column name"""
  compliance_percentage

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  priority

  """column name"""
  title

  """column name"""
  total_items

  """column name"""
  updated_at
}

input compliance_categories_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: compliance_categories_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: compliance_categories_set_input

  """filter the rows which have to be updated"""
  where: compliance_categories_bool_exp!
}

"""aggregate var_pop on columns"""
type compliance_categories_var_pop_fields {
  completed_items: Float
  compliance_percentage: Float
  total_items: Float
}

"""aggregate var_samp on columns"""
type compliance_categories_var_samp_fields {
  completed_items: Float
  compliance_percentage: Float
  total_items: Float
}

"""aggregate variance on columns"""
type compliance_categories_variance_fields {
  completed_items: Float
  compliance_percentage: Float
  total_items: Float
}

"""
columns and relationships of "compliance_items"
"""
type compliance_items {
  """An object relationship"""
  agency_document: agency_documents
  agency_id: uuid!
  category_id: uuid!
  completed_at: timestamptz

  """An object relationship"""
  compliance_category: compliance_categories!
  created_at: timestamptz
  description: String
  document_id: uuid
  due_date: timestamptz
  id: uuid!
  notes: String
  requirement: String!
  responsible: String
  status: String
  updated_at: timestamptz

  """An object relationship"""
  user: auth_users!
}

"""
aggregated selection of "compliance_items"
"""
type compliance_items_aggregate {
  aggregate: compliance_items_aggregate_fields
  nodes: [compliance_items!]!
}

input compliance_items_aggregate_bool_exp {
  count: compliance_items_aggregate_bool_exp_count
}

input compliance_items_aggregate_bool_exp_count {
  arguments: [compliance_items_select_column!]
  distinct: Boolean
  filter: compliance_items_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "compliance_items"
"""
type compliance_items_aggregate_fields {
  count(columns: [compliance_items_select_column!], distinct: Boolean): Int!
  max: compliance_items_max_fields
  min: compliance_items_min_fields
}

"""
order by aggregate values of table "compliance_items"
"""
input compliance_items_aggregate_order_by {
  count: order_by
  max: compliance_items_max_order_by
  min: compliance_items_min_order_by
}

"""
input type for inserting array relation for remote table "compliance_items"
"""
input compliance_items_arr_rel_insert_input {
  data: [compliance_items_insert_input!]!

  """upsert condition"""
  on_conflict: compliance_items_on_conflict
}

"""
Boolean expression to filter rows from the table "compliance_items". All fields are combined with a logical 'AND'.
"""
input compliance_items_bool_exp {
  _and: [compliance_items_bool_exp!]
  _not: compliance_items_bool_exp
  _or: [compliance_items_bool_exp!]
  agency_document: agency_documents_bool_exp
  agency_id: uuid_comparison_exp
  category_id: uuid_comparison_exp
  completed_at: timestamptz_comparison_exp
  compliance_category: compliance_categories_bool_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  document_id: uuid_comparison_exp
  due_date: timestamptz_comparison_exp
  id: uuid_comparison_exp
  notes: String_comparison_exp
  requirement: String_comparison_exp
  responsible: String_comparison_exp
  status: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
}

"""
unique or primary key constraints on table "compliance_items"
"""
enum compliance_items_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  compliance_items_pkey
}

"""
input type for inserting data into table "compliance_items"
"""
input compliance_items_insert_input {
  agency_document: agency_documents_obj_rel_insert_input
  agency_id: uuid
  category_id: uuid
  completed_at: timestamptz
  compliance_category: compliance_categories_obj_rel_insert_input
  created_at: timestamptz
  description: String
  document_id: uuid
  due_date: timestamptz
  id: uuid
  notes: String
  requirement: String
  responsible: String
  status: String
  updated_at: timestamptz
  user: auth_users_obj_rel_insert_input
}

"""aggregate max on columns"""
type compliance_items_max_fields {
  agency_id: uuid
  category_id: uuid
  completed_at: timestamptz
  created_at: timestamptz
  description: String
  document_id: uuid
  due_date: timestamptz
  id: uuid
  notes: String
  requirement: String
  responsible: String
  status: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "compliance_items"
"""
input compliance_items_max_order_by {
  agency_id: order_by
  category_id: order_by
  completed_at: order_by
  created_at: order_by
  description: order_by
  document_id: order_by
  due_date: order_by
  id: order_by
  notes: order_by
  requirement: order_by
  responsible: order_by
  status: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type compliance_items_min_fields {
  agency_id: uuid
  category_id: uuid
  completed_at: timestamptz
  created_at: timestamptz
  description: String
  document_id: uuid
  due_date: timestamptz
  id: uuid
  notes: String
  requirement: String
  responsible: String
  status: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "compliance_items"
"""
input compliance_items_min_order_by {
  agency_id: order_by
  category_id: order_by
  completed_at: order_by
  created_at: order_by
  description: order_by
  document_id: order_by
  due_date: order_by
  id: order_by
  notes: order_by
  requirement: order_by
  responsible: order_by
  status: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "compliance_items"
"""
type compliance_items_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [compliance_items!]!
}

"""
on_conflict condition type for table "compliance_items"
"""
input compliance_items_on_conflict {
  constraint: compliance_items_constraint!
  update_columns: [compliance_items_update_column!]! = []
  where: compliance_items_bool_exp
}

"""Ordering options when selecting data from "compliance_items"."""
input compliance_items_order_by {
  agency_document: agency_documents_order_by
  agency_id: order_by
  category_id: order_by
  completed_at: order_by
  compliance_category: compliance_categories_order_by
  created_at: order_by
  description: order_by
  document_id: order_by
  due_date: order_by
  id: order_by
  notes: order_by
  requirement: order_by
  responsible: order_by
  status: order_by
  updated_at: order_by
  user: auth_users_order_by
}

"""primary key columns input for table: compliance_items"""
input compliance_items_pk_columns_input {
  id: uuid!
}

"""
select columns of table "compliance_items"
"""
enum compliance_items_select_column {
  """column name"""
  agency_id

  """column name"""
  category_id

  """column name"""
  completed_at

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  document_id

  """column name"""
  due_date

  """column name"""
  id

  """column name"""
  notes

  """column name"""
  requirement

  """column name"""
  responsible

  """column name"""
  status

  """column name"""
  updated_at
}

"""
input type for updating data in table "compliance_items"
"""
input compliance_items_set_input {
  agency_id: uuid
  category_id: uuid
  completed_at: timestamptz
  created_at: timestamptz
  description: String
  document_id: uuid
  due_date: timestamptz
  id: uuid
  notes: String
  requirement: String
  responsible: String
  status: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "compliance_items"
"""
input compliance_items_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: compliance_items_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input compliance_items_stream_cursor_value_input {
  agency_id: uuid
  category_id: uuid
  completed_at: timestamptz
  created_at: timestamptz
  description: String
  document_id: uuid
  due_date: timestamptz
  id: uuid
  notes: String
  requirement: String
  responsible: String
  status: String
  updated_at: timestamptz
}

"""
update columns of table "compliance_items"
"""
enum compliance_items_update_column {
  """column name"""
  agency_id

  """column name"""
  category_id

  """column name"""
  completed_at

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  document_id

  """column name"""
  due_date

  """column name"""
  id

  """column name"""
  notes

  """column name"""
  requirement

  """column name"""
  responsible

  """column name"""
  status

  """column name"""
  updated_at
}

input compliance_items_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: compliance_items_set_input

  """filter the rows which have to be updated"""
  where: compliance_items_bool_exp!
}

"""
columns and relationships of "contact_fees"
"""
type contact_fees {
  contact_message: String
  created_at: timestamptz
  credits_charged: Int!
  id: uuid!
  idempotency_key: String
  maid_id: uuid

  """An object relationship"""
  payment_idempotency: payment_idempotency
  sponsor_id: uuid

  """An object relationship"""
  user: auth_users

  """An object relationship"""
  userBySponsorId: auth_users
}

"""
aggregated selection of "contact_fees"
"""
type contact_fees_aggregate {
  aggregate: contact_fees_aggregate_fields
  nodes: [contact_fees!]!
}

input contact_fees_aggregate_bool_exp {
  count: contact_fees_aggregate_bool_exp_count
}

input contact_fees_aggregate_bool_exp_count {
  arguments: [contact_fees_select_column!]
  distinct: Boolean
  filter: contact_fees_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "contact_fees"
"""
type contact_fees_aggregate_fields {
  avg: contact_fees_avg_fields
  count(columns: [contact_fees_select_column!], distinct: Boolean): Int!
  max: contact_fees_max_fields
  min: contact_fees_min_fields
  stddev: contact_fees_stddev_fields
  stddev_pop: contact_fees_stddev_pop_fields
  stddev_samp: contact_fees_stddev_samp_fields
  sum: contact_fees_sum_fields
  var_pop: contact_fees_var_pop_fields
  var_samp: contact_fees_var_samp_fields
  variance: contact_fees_variance_fields
}

"""
order by aggregate values of table "contact_fees"
"""
input contact_fees_aggregate_order_by {
  avg: contact_fees_avg_order_by
  count: order_by
  max: contact_fees_max_order_by
  min: contact_fees_min_order_by
  stddev: contact_fees_stddev_order_by
  stddev_pop: contact_fees_stddev_pop_order_by
  stddev_samp: contact_fees_stddev_samp_order_by
  sum: contact_fees_sum_order_by
  var_pop: contact_fees_var_pop_order_by
  var_samp: contact_fees_var_samp_order_by
  variance: contact_fees_variance_order_by
}

"""
input type for inserting array relation for remote table "contact_fees"
"""
input contact_fees_arr_rel_insert_input {
  data: [contact_fees_insert_input!]!

  """upsert condition"""
  on_conflict: contact_fees_on_conflict
}

"""aggregate avg on columns"""
type contact_fees_avg_fields {
  credits_charged: Float
}

"""
order by avg() on columns of table "contact_fees"
"""
input contact_fees_avg_order_by {
  credits_charged: order_by
}

"""
Boolean expression to filter rows from the table "contact_fees". All fields are combined with a logical 'AND'.
"""
input contact_fees_bool_exp {
  _and: [contact_fees_bool_exp!]
  _not: contact_fees_bool_exp
  _or: [contact_fees_bool_exp!]
  contact_message: String_comparison_exp
  created_at: timestamptz_comparison_exp
  credits_charged: Int_comparison_exp
  id: uuid_comparison_exp
  idempotency_key: String_comparison_exp
  maid_id: uuid_comparison_exp
  payment_idempotency: payment_idempotency_bool_exp
  sponsor_id: uuid_comparison_exp
  user: auth_users_bool_exp
  userBySponsorId: auth_users_bool_exp
}

"""
unique or primary key constraints on table "contact_fees"
"""
enum contact_fees_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  contact_fees_pkey

  """
  unique or primary key constraint on columns "maid_id", "sponsor_id"
  """
  contact_fees_sponsor_id_maid_id_key
}

"""
input type for incrementing numeric columns in table "contact_fees"
"""
input contact_fees_inc_input {
  credits_charged: Int
}

"""
input type for inserting data into table "contact_fees"
"""
input contact_fees_insert_input {
  contact_message: String
  created_at: timestamptz
  credits_charged: Int
  id: uuid
  idempotency_key: String
  maid_id: uuid
  payment_idempotency: payment_idempotency_obj_rel_insert_input
  sponsor_id: uuid
  user: auth_users_obj_rel_insert_input
  userBySponsorId: auth_users_obj_rel_insert_input
}

"""aggregate max on columns"""
type contact_fees_max_fields {
  contact_message: String
  created_at: timestamptz
  credits_charged: Int
  id: uuid
  idempotency_key: String
  maid_id: uuid
  sponsor_id: uuid
}

"""
order by max() on columns of table "contact_fees"
"""
input contact_fees_max_order_by {
  contact_message: order_by
  created_at: order_by
  credits_charged: order_by
  id: order_by
  idempotency_key: order_by
  maid_id: order_by
  sponsor_id: order_by
}

"""aggregate min on columns"""
type contact_fees_min_fields {
  contact_message: String
  created_at: timestamptz
  credits_charged: Int
  id: uuid
  idempotency_key: String
  maid_id: uuid
  sponsor_id: uuid
}

"""
order by min() on columns of table "contact_fees"
"""
input contact_fees_min_order_by {
  contact_message: order_by
  created_at: order_by
  credits_charged: order_by
  id: order_by
  idempotency_key: order_by
  maid_id: order_by
  sponsor_id: order_by
}

"""
response of any mutation on the table "contact_fees"
"""
type contact_fees_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [contact_fees!]!
}

"""
on_conflict condition type for table "contact_fees"
"""
input contact_fees_on_conflict {
  constraint: contact_fees_constraint!
  update_columns: [contact_fees_update_column!]! = []
  where: contact_fees_bool_exp
}

"""Ordering options when selecting data from "contact_fees"."""
input contact_fees_order_by {
  contact_message: order_by
  created_at: order_by
  credits_charged: order_by
  id: order_by
  idempotency_key: order_by
  maid_id: order_by
  payment_idempotency: payment_idempotency_order_by
  sponsor_id: order_by
  user: auth_users_order_by
  userBySponsorId: auth_users_order_by
}

"""primary key columns input for table: contact_fees"""
input contact_fees_pk_columns_input {
  id: uuid!
}

"""
select columns of table "contact_fees"
"""
enum contact_fees_select_column {
  """column name"""
  contact_message

  """column name"""
  created_at

  """column name"""
  credits_charged

  """column name"""
  id

  """column name"""
  idempotency_key

  """column name"""
  maid_id

  """column name"""
  sponsor_id
}

"""
input type for updating data in table "contact_fees"
"""
input contact_fees_set_input {
  contact_message: String
  created_at: timestamptz
  credits_charged: Int
  id: uuid
  idempotency_key: String
  maid_id: uuid
  sponsor_id: uuid
}

"""aggregate stddev on columns"""
type contact_fees_stddev_fields {
  credits_charged: Float
}

"""
order by stddev() on columns of table "contact_fees"
"""
input contact_fees_stddev_order_by {
  credits_charged: order_by
}

"""aggregate stddev_pop on columns"""
type contact_fees_stddev_pop_fields {
  credits_charged: Float
}

"""
order by stddev_pop() on columns of table "contact_fees"
"""
input contact_fees_stddev_pop_order_by {
  credits_charged: order_by
}

"""aggregate stddev_samp on columns"""
type contact_fees_stddev_samp_fields {
  credits_charged: Float
}

"""
order by stddev_samp() on columns of table "contact_fees"
"""
input contact_fees_stddev_samp_order_by {
  credits_charged: order_by
}

"""
Streaming cursor of the table "contact_fees"
"""
input contact_fees_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: contact_fees_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input contact_fees_stream_cursor_value_input {
  contact_message: String
  created_at: timestamptz
  credits_charged: Int
  id: uuid
  idempotency_key: String
  maid_id: uuid
  sponsor_id: uuid
}

"""aggregate sum on columns"""
type contact_fees_sum_fields {
  credits_charged: Int
}

"""
order by sum() on columns of table "contact_fees"
"""
input contact_fees_sum_order_by {
  credits_charged: order_by
}

"""
update columns of table "contact_fees"
"""
enum contact_fees_update_column {
  """column name"""
  contact_message

  """column name"""
  created_at

  """column name"""
  credits_charged

  """column name"""
  id

  """column name"""
  idempotency_key

  """column name"""
  maid_id

  """column name"""
  sponsor_id
}

input contact_fees_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: contact_fees_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: contact_fees_set_input

  """filter the rows which have to be updated"""
  where: contact_fees_bool_exp!
}

"""aggregate var_pop on columns"""
type contact_fees_var_pop_fields {
  credits_charged: Float
}

"""
order by var_pop() on columns of table "contact_fees"
"""
input contact_fees_var_pop_order_by {
  credits_charged: order_by
}

"""aggregate var_samp on columns"""
type contact_fees_var_samp_fields {
  credits_charged: Float
}

"""
order by var_samp() on columns of table "contact_fees"
"""
input contact_fees_var_samp_order_by {
  credits_charged: order_by
}

"""aggregate variance on columns"""
type contact_fees_variance_fields {
  credits_charged: Float
}

"""
order by variance() on columns of table "contact_fees"
"""
input contact_fees_variance_order_by {
  credits_charged: order_by
}

"""
columns and relationships of "content_moderation_flags"
"""
type content_moderation_flags {
  """An object relationship"""
  admin_user: admin_users
  content_id: uuid!
  content_type: String!
  created_at: timestamptz
  flagged_by: String!
  flags(
    """JSON select path"""
    path: String
  ): jsonb!
  id: uuid!
  requires_human_review: Boolean
  reviewed_at: timestamptz
  reviewed_by: uuid
  severity: String!
  status: String
  updated_at: timestamptz
}

"""
aggregated selection of "content_moderation_flags"
"""
type content_moderation_flags_aggregate {
  aggregate: content_moderation_flags_aggregate_fields
  nodes: [content_moderation_flags!]!
}

input content_moderation_flags_aggregate_bool_exp {
  bool_and: content_moderation_flags_aggregate_bool_exp_bool_and
  bool_or: content_moderation_flags_aggregate_bool_exp_bool_or
  count: content_moderation_flags_aggregate_bool_exp_count
}

input content_moderation_flags_aggregate_bool_exp_bool_and {
  arguments: content_moderation_flags_select_column_content_moderation_flags_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: content_moderation_flags_bool_exp
  predicate: Boolean_comparison_exp!
}

input content_moderation_flags_aggregate_bool_exp_bool_or {
  arguments: content_moderation_flags_select_column_content_moderation_flags_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: content_moderation_flags_bool_exp
  predicate: Boolean_comparison_exp!
}

input content_moderation_flags_aggregate_bool_exp_count {
  arguments: [content_moderation_flags_select_column!]
  distinct: Boolean
  filter: content_moderation_flags_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "content_moderation_flags"
"""
type content_moderation_flags_aggregate_fields {
  count(columns: [content_moderation_flags_select_column!], distinct: Boolean): Int!
  max: content_moderation_flags_max_fields
  min: content_moderation_flags_min_fields
}

"""
order by aggregate values of table "content_moderation_flags"
"""
input content_moderation_flags_aggregate_order_by {
  count: order_by
  max: content_moderation_flags_max_order_by
  min: content_moderation_flags_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input content_moderation_flags_append_input {
  flags: jsonb
}

"""
input type for inserting array relation for remote table "content_moderation_flags"
"""
input content_moderation_flags_arr_rel_insert_input {
  data: [content_moderation_flags_insert_input!]!

  """upsert condition"""
  on_conflict: content_moderation_flags_on_conflict
}

"""
Boolean expression to filter rows from the table "content_moderation_flags". All fields are combined with a logical 'AND'.
"""
input content_moderation_flags_bool_exp {
  _and: [content_moderation_flags_bool_exp!]
  _not: content_moderation_flags_bool_exp
  _or: [content_moderation_flags_bool_exp!]
  admin_user: admin_users_bool_exp
  content_id: uuid_comparison_exp
  content_type: String_comparison_exp
  created_at: timestamptz_comparison_exp
  flagged_by: String_comparison_exp
  flags: jsonb_comparison_exp
  id: uuid_comparison_exp
  requires_human_review: Boolean_comparison_exp
  reviewed_at: timestamptz_comparison_exp
  reviewed_by: uuid_comparison_exp
  severity: String_comparison_exp
  status: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "content_moderation_flags"
"""
enum content_moderation_flags_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  content_moderation_flags_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input content_moderation_flags_delete_at_path_input {
  flags: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input content_moderation_flags_delete_elem_input {
  flags: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input content_moderation_flags_delete_key_input {
  flags: String
}

"""
input type for inserting data into table "content_moderation_flags"
"""
input content_moderation_flags_insert_input {
  admin_user: admin_users_obj_rel_insert_input
  content_id: uuid
  content_type: String
  created_at: timestamptz
  flagged_by: String
  flags: jsonb
  id: uuid
  requires_human_review: Boolean
  reviewed_at: timestamptz
  reviewed_by: uuid
  severity: String
  status: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type content_moderation_flags_max_fields {
  content_id: uuid
  content_type: String
  created_at: timestamptz
  flagged_by: String
  id: uuid
  reviewed_at: timestamptz
  reviewed_by: uuid
  severity: String
  status: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "content_moderation_flags"
"""
input content_moderation_flags_max_order_by {
  content_id: order_by
  content_type: order_by
  created_at: order_by
  flagged_by: order_by
  id: order_by
  reviewed_at: order_by
  reviewed_by: order_by
  severity: order_by
  status: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type content_moderation_flags_min_fields {
  content_id: uuid
  content_type: String
  created_at: timestamptz
  flagged_by: String
  id: uuid
  reviewed_at: timestamptz
  reviewed_by: uuid
  severity: String
  status: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "content_moderation_flags"
"""
input content_moderation_flags_min_order_by {
  content_id: order_by
  content_type: order_by
  created_at: order_by
  flagged_by: order_by
  id: order_by
  reviewed_at: order_by
  reviewed_by: order_by
  severity: order_by
  status: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "content_moderation_flags"
"""
type content_moderation_flags_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [content_moderation_flags!]!
}

"""
on_conflict condition type for table "content_moderation_flags"
"""
input content_moderation_flags_on_conflict {
  constraint: content_moderation_flags_constraint!
  update_columns: [content_moderation_flags_update_column!]! = []
  where: content_moderation_flags_bool_exp
}

"""Ordering options when selecting data from "content_moderation_flags"."""
input content_moderation_flags_order_by {
  admin_user: admin_users_order_by
  content_id: order_by
  content_type: order_by
  created_at: order_by
  flagged_by: order_by
  flags: order_by
  id: order_by
  requires_human_review: order_by
  reviewed_at: order_by
  reviewed_by: order_by
  severity: order_by
  status: order_by
  updated_at: order_by
}

"""primary key columns input for table: content_moderation_flags"""
input content_moderation_flags_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input content_moderation_flags_prepend_input {
  flags: jsonb
}

"""
select columns of table "content_moderation_flags"
"""
enum content_moderation_flags_select_column {
  """column name"""
  content_id

  """column name"""
  content_type

  """column name"""
  created_at

  """column name"""
  flagged_by

  """column name"""
  flags

  """column name"""
  id

  """column name"""
  requires_human_review

  """column name"""
  reviewed_at

  """column name"""
  reviewed_by

  """column name"""
  severity

  """column name"""
  status

  """column name"""
  updated_at
}

"""
select "content_moderation_flags_aggregate_bool_exp_bool_and_arguments_columns" columns of table "content_moderation_flags"
"""
enum content_moderation_flags_select_column_content_moderation_flags_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  requires_human_review
}

"""
select "content_moderation_flags_aggregate_bool_exp_bool_or_arguments_columns" columns of table "content_moderation_flags"
"""
enum content_moderation_flags_select_column_content_moderation_flags_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  requires_human_review
}

"""
input type for updating data in table "content_moderation_flags"
"""
input content_moderation_flags_set_input {
  content_id: uuid
  content_type: String
  created_at: timestamptz
  flagged_by: String
  flags: jsonb
  id: uuid
  requires_human_review: Boolean
  reviewed_at: timestamptz
  reviewed_by: uuid
  severity: String
  status: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "content_moderation_flags"
"""
input content_moderation_flags_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: content_moderation_flags_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input content_moderation_flags_stream_cursor_value_input {
  content_id: uuid
  content_type: String
  created_at: timestamptz
  flagged_by: String
  flags: jsonb
  id: uuid
  requires_human_review: Boolean
  reviewed_at: timestamptz
  reviewed_by: uuid
  severity: String
  status: String
  updated_at: timestamptz
}

"""
update columns of table "content_moderation_flags"
"""
enum content_moderation_flags_update_column {
  """column name"""
  content_id

  """column name"""
  content_type

  """column name"""
  created_at

  """column name"""
  flagged_by

  """column name"""
  flags

  """column name"""
  id

  """column name"""
  requires_human_review

  """column name"""
  reviewed_at

  """column name"""
  reviewed_by

  """column name"""
  severity

  """column name"""
  status

  """column name"""
  updated_at
}

input content_moderation_flags_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: content_moderation_flags_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: content_moderation_flags_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: content_moderation_flags_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: content_moderation_flags_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: content_moderation_flags_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: content_moderation_flags_set_input

  """filter the rows which have to be updated"""
  where: content_moderation_flags_bool_exp!
}

"""
columns and relationships of "conversations"
"""
type conversations {
  """The agency involved in this conversation"""
  agency_id: uuid
  created_at: timestamptz
  id: uuid!
  last_message_at: timestamptz
  last_message_preview: String

  """An array relationship"""
  messages(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): [messages!]!

  """An aggregate relationship"""
  messages_aggregate(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): messages_aggregate!
  participant1_id: String
  participant1_type: String!
  participant1_unread_count: Int
  participant2_id: String
  participant2_type: String!
  participant2_unread_count: Int
  status: String
  updated_at: timestamptz
}

"""
aggregated selection of "conversations"
"""
type conversations_aggregate {
  aggregate: conversations_aggregate_fields
  nodes: [conversations!]!
}

"""
aggregate fields of "conversations"
"""
type conversations_aggregate_fields {
  avg: conversations_avg_fields
  count(columns: [conversations_select_column!], distinct: Boolean): Int!
  max: conversations_max_fields
  min: conversations_min_fields
  stddev: conversations_stddev_fields
  stddev_pop: conversations_stddev_pop_fields
  stddev_samp: conversations_stddev_samp_fields
  sum: conversations_sum_fields
  var_pop: conversations_var_pop_fields
  var_samp: conversations_var_samp_fields
  variance: conversations_variance_fields
}

"""aggregate avg on columns"""
type conversations_avg_fields {
  participant1_unread_count: Float
  participant2_unread_count: Float
}

"""
Boolean expression to filter rows from the table "conversations". All fields are combined with a logical 'AND'.
"""
input conversations_bool_exp {
  _and: [conversations_bool_exp!]
  _not: conversations_bool_exp
  _or: [conversations_bool_exp!]
  agency_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  last_message_at: timestamptz_comparison_exp
  last_message_preview: String_comparison_exp
  messages: messages_bool_exp
  messages_aggregate: messages_aggregate_bool_exp
  participant1_id: String_comparison_exp
  participant1_type: String_comparison_exp
  participant1_unread_count: Int_comparison_exp
  participant2_id: String_comparison_exp
  participant2_type: String_comparison_exp
  participant2_unread_count: Int_comparison_exp
  status: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "conversations"
"""
enum conversations_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  conversations_pkey

  """
  unique or primary key constraint on columns "participant1_id", "participant2_id"
  """
  unique_conversation
}

"""
input type for incrementing numeric columns in table "conversations"
"""
input conversations_inc_input {
  participant1_unread_count: Int
  participant2_unread_count: Int
}

"""
input type for inserting data into table "conversations"
"""
input conversations_insert_input {
  """The agency involved in this conversation"""
  agency_id: uuid
  created_at: timestamptz
  id: uuid
  last_message_at: timestamptz
  last_message_preview: String
  messages: messages_arr_rel_insert_input
  participant1_id: String
  participant1_type: String
  participant1_unread_count: Int
  participant2_id: String
  participant2_type: String
  participant2_unread_count: Int
  status: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type conversations_max_fields {
  """The agency involved in this conversation"""
  agency_id: uuid
  created_at: timestamptz
  id: uuid
  last_message_at: timestamptz
  last_message_preview: String
  participant1_id: String
  participant1_type: String
  participant1_unread_count: Int
  participant2_id: String
  participant2_type: String
  participant2_unread_count: Int
  status: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type conversations_min_fields {
  """The agency involved in this conversation"""
  agency_id: uuid
  created_at: timestamptz
  id: uuid
  last_message_at: timestamptz
  last_message_preview: String
  participant1_id: String
  participant1_type: String
  participant1_unread_count: Int
  participant2_id: String
  participant2_type: String
  participant2_unread_count: Int
  status: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "conversations"
"""
type conversations_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [conversations!]!
}

"""
input type for inserting object relation for remote table "conversations"
"""
input conversations_obj_rel_insert_input {
  data: conversations_insert_input!

  """upsert condition"""
  on_conflict: conversations_on_conflict
}

"""
on_conflict condition type for table "conversations"
"""
input conversations_on_conflict {
  constraint: conversations_constraint!
  update_columns: [conversations_update_column!]! = []
  where: conversations_bool_exp
}

"""Ordering options when selecting data from "conversations"."""
input conversations_order_by {
  agency_id: order_by
  created_at: order_by
  id: order_by
  last_message_at: order_by
  last_message_preview: order_by
  messages_aggregate: messages_aggregate_order_by
  participant1_id: order_by
  participant1_type: order_by
  participant1_unread_count: order_by
  participant2_id: order_by
  participant2_type: order_by
  participant2_unread_count: order_by
  status: order_by
  updated_at: order_by
}

"""primary key columns input for table: conversations"""
input conversations_pk_columns_input {
  id: uuid!
}

"""
select columns of table "conversations"
"""
enum conversations_select_column {
  """column name"""
  agency_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  last_message_at

  """column name"""
  last_message_preview

  """column name"""
  participant1_id

  """column name"""
  participant1_type

  """column name"""
  participant1_unread_count

  """column name"""
  participant2_id

  """column name"""
  participant2_type

  """column name"""
  participant2_unread_count

  """column name"""
  status

  """column name"""
  updated_at
}

"""
input type for updating data in table "conversations"
"""
input conversations_set_input {
  """The agency involved in this conversation"""
  agency_id: uuid
  created_at: timestamptz
  id: uuid
  last_message_at: timestamptz
  last_message_preview: String
  participant1_id: String
  participant1_type: String
  participant1_unread_count: Int
  participant2_id: String
  participant2_type: String
  participant2_unread_count: Int
  status: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type conversations_stddev_fields {
  participant1_unread_count: Float
  participant2_unread_count: Float
}

"""aggregate stddev_pop on columns"""
type conversations_stddev_pop_fields {
  participant1_unread_count: Float
  participant2_unread_count: Float
}

"""aggregate stddev_samp on columns"""
type conversations_stddev_samp_fields {
  participant1_unread_count: Float
  participant2_unread_count: Float
}

"""
Streaming cursor of the table "conversations"
"""
input conversations_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: conversations_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input conversations_stream_cursor_value_input {
  """The agency involved in this conversation"""
  agency_id: uuid
  created_at: timestamptz
  id: uuid
  last_message_at: timestamptz
  last_message_preview: String
  participant1_id: String
  participant1_type: String
  participant1_unread_count: Int
  participant2_id: String
  participant2_type: String
  participant2_unread_count: Int
  status: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type conversations_sum_fields {
  participant1_unread_count: Int
  participant2_unread_count: Int
}

"""
update columns of table "conversations"
"""
enum conversations_update_column {
  """column name"""
  agency_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  last_message_at

  """column name"""
  last_message_preview

  """column name"""
  participant1_id

  """column name"""
  participant1_type

  """column name"""
  participant1_unread_count

  """column name"""
  participant2_id

  """column name"""
  participant2_type

  """column name"""
  participant2_unread_count

  """column name"""
  status

  """column name"""
  updated_at
}

input conversations_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: conversations_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: conversations_set_input

  """filter the rows which have to be updated"""
  where: conversations_bool_exp!
}

"""aggregate var_pop on columns"""
type conversations_var_pop_fields {
  participant1_unread_count: Float
  participant2_unread_count: Float
}

"""aggregate var_samp on columns"""
type conversations_var_samp_fields {
  participant1_unread_count: Float
  participant2_unread_count: Float
}

"""aggregate variance on columns"""
type conversations_variance_fields {
  participant1_unread_count: Float
  participant2_unread_count: Float
}

"""Tracks important conversion events"""
type conversion_events {
  conversion_type: String!
  conversion_value: numeric
  converted_at: timestamptz
  created_at: timestamptz
  currency: String
  id: uuid!
  properties(
    """JSON select path"""
    path: String
  ): jsonb
  related_id: uuid
  related_type: String
  session_id: uuid
  user_id: uuid

  """An object relationship"""
  user_session: user_sessions
}

"""
aggregated selection of "conversion_events"
"""
type conversion_events_aggregate {
  aggregate: conversion_events_aggregate_fields
  nodes: [conversion_events!]!
}

input conversion_events_aggregate_bool_exp {
  count: conversion_events_aggregate_bool_exp_count
}

input conversion_events_aggregate_bool_exp_count {
  arguments: [conversion_events_select_column!]
  distinct: Boolean
  filter: conversion_events_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "conversion_events"
"""
type conversion_events_aggregate_fields {
  avg: conversion_events_avg_fields
  count(columns: [conversion_events_select_column!], distinct: Boolean): Int!
  max: conversion_events_max_fields
  min: conversion_events_min_fields
  stddev: conversion_events_stddev_fields
  stddev_pop: conversion_events_stddev_pop_fields
  stddev_samp: conversion_events_stddev_samp_fields
  sum: conversion_events_sum_fields
  var_pop: conversion_events_var_pop_fields
  var_samp: conversion_events_var_samp_fields
  variance: conversion_events_variance_fields
}

"""
order by aggregate values of table "conversion_events"
"""
input conversion_events_aggregate_order_by {
  avg: conversion_events_avg_order_by
  count: order_by
  max: conversion_events_max_order_by
  min: conversion_events_min_order_by
  stddev: conversion_events_stddev_order_by
  stddev_pop: conversion_events_stddev_pop_order_by
  stddev_samp: conversion_events_stddev_samp_order_by
  sum: conversion_events_sum_order_by
  var_pop: conversion_events_var_pop_order_by
  var_samp: conversion_events_var_samp_order_by
  variance: conversion_events_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input conversion_events_append_input {
  properties: jsonb
}

"""
input type for inserting array relation for remote table "conversion_events"
"""
input conversion_events_arr_rel_insert_input {
  data: [conversion_events_insert_input!]!

  """upsert condition"""
  on_conflict: conversion_events_on_conflict
}

"""aggregate avg on columns"""
type conversion_events_avg_fields {
  conversion_value: Float
}

"""
order by avg() on columns of table "conversion_events"
"""
input conversion_events_avg_order_by {
  conversion_value: order_by
}

"""
Boolean expression to filter rows from the table "conversion_events". All fields are combined with a logical 'AND'.
"""
input conversion_events_bool_exp {
  _and: [conversion_events_bool_exp!]
  _not: conversion_events_bool_exp
  _or: [conversion_events_bool_exp!]
  conversion_type: String_comparison_exp
  conversion_value: numeric_comparison_exp
  converted_at: timestamptz_comparison_exp
  created_at: timestamptz_comparison_exp
  currency: String_comparison_exp
  id: uuid_comparison_exp
  properties: jsonb_comparison_exp
  related_id: uuid_comparison_exp
  related_type: String_comparison_exp
  session_id: uuid_comparison_exp
  user_id: uuid_comparison_exp
  user_session: user_sessions_bool_exp
}

"""
unique or primary key constraints on table "conversion_events"
"""
enum conversion_events_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  conversion_events_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input conversion_events_delete_at_path_input {
  properties: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input conversion_events_delete_elem_input {
  properties: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input conversion_events_delete_key_input {
  properties: String
}

"""
input type for incrementing numeric columns in table "conversion_events"
"""
input conversion_events_inc_input {
  conversion_value: numeric
}

"""
input type for inserting data into table "conversion_events"
"""
input conversion_events_insert_input {
  conversion_type: String
  conversion_value: numeric
  converted_at: timestamptz
  created_at: timestamptz
  currency: String
  id: uuid
  properties: jsonb
  related_id: uuid
  related_type: String
  session_id: uuid
  user_id: uuid
  user_session: user_sessions_obj_rel_insert_input
}

"""aggregate max on columns"""
type conversion_events_max_fields {
  conversion_type: String
  conversion_value: numeric
  converted_at: timestamptz
  created_at: timestamptz
  currency: String
  id: uuid
  related_id: uuid
  related_type: String
  session_id: uuid
  user_id: uuid
}

"""
order by max() on columns of table "conversion_events"
"""
input conversion_events_max_order_by {
  conversion_type: order_by
  conversion_value: order_by
  converted_at: order_by
  created_at: order_by
  currency: order_by
  id: order_by
  related_id: order_by
  related_type: order_by
  session_id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type conversion_events_min_fields {
  conversion_type: String
  conversion_value: numeric
  converted_at: timestamptz
  created_at: timestamptz
  currency: String
  id: uuid
  related_id: uuid
  related_type: String
  session_id: uuid
  user_id: uuid
}

"""
order by min() on columns of table "conversion_events"
"""
input conversion_events_min_order_by {
  conversion_type: order_by
  conversion_value: order_by
  converted_at: order_by
  created_at: order_by
  currency: order_by
  id: order_by
  related_id: order_by
  related_type: order_by
  session_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "conversion_events"
"""
type conversion_events_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [conversion_events!]!
}

"""
on_conflict condition type for table "conversion_events"
"""
input conversion_events_on_conflict {
  constraint: conversion_events_constraint!
  update_columns: [conversion_events_update_column!]! = []
  where: conversion_events_bool_exp
}

"""Ordering options when selecting data from "conversion_events"."""
input conversion_events_order_by {
  conversion_type: order_by
  conversion_value: order_by
  converted_at: order_by
  created_at: order_by
  currency: order_by
  id: order_by
  properties: order_by
  related_id: order_by
  related_type: order_by
  session_id: order_by
  user_id: order_by
  user_session: user_sessions_order_by
}

"""primary key columns input for table: conversion_events"""
input conversion_events_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input conversion_events_prepend_input {
  properties: jsonb
}

"""
select columns of table "conversion_events"
"""
enum conversion_events_select_column {
  """column name"""
  conversion_type

  """column name"""
  conversion_value

  """column name"""
  converted_at

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  id

  """column name"""
  properties

  """column name"""
  related_id

  """column name"""
  related_type

  """column name"""
  session_id

  """column name"""
  user_id
}

"""
input type for updating data in table "conversion_events"
"""
input conversion_events_set_input {
  conversion_type: String
  conversion_value: numeric
  converted_at: timestamptz
  created_at: timestamptz
  currency: String
  id: uuid
  properties: jsonb
  related_id: uuid
  related_type: String
  session_id: uuid
  user_id: uuid
}

"""aggregate stddev on columns"""
type conversion_events_stddev_fields {
  conversion_value: Float
}

"""
order by stddev() on columns of table "conversion_events"
"""
input conversion_events_stddev_order_by {
  conversion_value: order_by
}

"""aggregate stddev_pop on columns"""
type conversion_events_stddev_pop_fields {
  conversion_value: Float
}

"""
order by stddev_pop() on columns of table "conversion_events"
"""
input conversion_events_stddev_pop_order_by {
  conversion_value: order_by
}

"""aggregate stddev_samp on columns"""
type conversion_events_stddev_samp_fields {
  conversion_value: Float
}

"""
order by stddev_samp() on columns of table "conversion_events"
"""
input conversion_events_stddev_samp_order_by {
  conversion_value: order_by
}

"""
Streaming cursor of the table "conversion_events"
"""
input conversion_events_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: conversion_events_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input conversion_events_stream_cursor_value_input {
  conversion_type: String
  conversion_value: numeric
  converted_at: timestamptz
  created_at: timestamptz
  currency: String
  id: uuid
  properties: jsonb
  related_id: uuid
  related_type: String
  session_id: uuid
  user_id: uuid
}

"""aggregate sum on columns"""
type conversion_events_sum_fields {
  conversion_value: numeric
}

"""
order by sum() on columns of table "conversion_events"
"""
input conversion_events_sum_order_by {
  conversion_value: order_by
}

"""
update columns of table "conversion_events"
"""
enum conversion_events_update_column {
  """column name"""
  conversion_type

  """column name"""
  conversion_value

  """column name"""
  converted_at

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  id

  """column name"""
  properties

  """column name"""
  related_id

  """column name"""
  related_type

  """column name"""
  session_id

  """column name"""
  user_id
}

input conversion_events_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: conversion_events_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: conversion_events_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: conversion_events_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: conversion_events_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: conversion_events_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: conversion_events_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: conversion_events_set_input

  """filter the rows which have to be updated"""
  where: conversion_events_bool_exp!
}

"""aggregate var_pop on columns"""
type conversion_events_var_pop_fields {
  conversion_value: Float
}

"""
order by var_pop() on columns of table "conversion_events"
"""
input conversion_events_var_pop_order_by {
  conversion_value: order_by
}

"""aggregate var_samp on columns"""
type conversion_events_var_samp_fields {
  conversion_value: Float
}

"""
order by var_samp() on columns of table "conversion_events"
"""
input conversion_events_var_samp_order_by {
  conversion_value: order_by
}

"""aggregate variance on columns"""
type conversion_events_variance_fields {
  conversion_value: Float
}

"""
order by variance() on columns of table "conversion_events"
"""
input conversion_events_variance_order_by {
  conversion_value: order_by
}

"""
columns and relationships of "countries"
"""
type countries {
  code: String!
  created_at: timestamptz
  currency_code: String
  id: Int!
  is_gcc: Boolean
  is_source_country: Boolean
  name: String!
  updated_at: timestamptz
}

"""
aggregated selection of "countries"
"""
type countries_aggregate {
  aggregate: countries_aggregate_fields
  nodes: [countries!]!
}

"""
aggregate fields of "countries"
"""
type countries_aggregate_fields {
  avg: countries_avg_fields
  count(columns: [countries_select_column!], distinct: Boolean): Int!
  max: countries_max_fields
  min: countries_min_fields
  stddev: countries_stddev_fields
  stddev_pop: countries_stddev_pop_fields
  stddev_samp: countries_stddev_samp_fields
  sum: countries_sum_fields
  var_pop: countries_var_pop_fields
  var_samp: countries_var_samp_fields
  variance: countries_variance_fields
}

"""aggregate avg on columns"""
type countries_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "countries". All fields are combined with a logical 'AND'.
"""
input countries_bool_exp {
  _and: [countries_bool_exp!]
  _not: countries_bool_exp
  _or: [countries_bool_exp!]
  code: String_comparison_exp
  created_at: timestamptz_comparison_exp
  currency_code: String_comparison_exp
  id: Int_comparison_exp
  is_gcc: Boolean_comparison_exp
  is_source_country: Boolean_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "countries"
"""
enum countries_constraint {
  """
  unique or primary key constraint on columns "code"
  """
  countries_code_key

  """
  unique or primary key constraint on columns "name"
  """
  countries_name_key

  """
  unique or primary key constraint on columns "id"
  """
  countries_pkey
}

"""
input type for incrementing numeric columns in table "countries"
"""
input countries_inc_input {
  id: Int
}

"""
input type for inserting data into table "countries"
"""
input countries_insert_input {
  code: String
  created_at: timestamptz
  currency_code: String
  id: Int
  is_gcc: Boolean
  is_source_country: Boolean
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type countries_max_fields {
  code: String
  created_at: timestamptz
  currency_code: String
  id: Int
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type countries_min_fields {
  code: String
  created_at: timestamptz
  currency_code: String
  id: Int
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "countries"
"""
type countries_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [countries!]!
}

"""
on_conflict condition type for table "countries"
"""
input countries_on_conflict {
  constraint: countries_constraint!
  update_columns: [countries_update_column!]! = []
  where: countries_bool_exp
}

"""Ordering options when selecting data from "countries"."""
input countries_order_by {
  code: order_by
  created_at: order_by
  currency_code: order_by
  id: order_by
  is_gcc: order_by
  is_source_country: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: countries"""
input countries_pk_columns_input {
  id: Int!
}

"""
select columns of table "countries"
"""
enum countries_select_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  currency_code

  """column name"""
  id

  """column name"""
  is_gcc

  """column name"""
  is_source_country

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "countries"
"""
input countries_set_input {
  code: String
  created_at: timestamptz
  currency_code: String
  id: Int
  is_gcc: Boolean
  is_source_country: Boolean
  name: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type countries_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type countries_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type countries_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "countries"
"""
input countries_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: countries_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input countries_stream_cursor_value_input {
  code: String
  created_at: timestamptz
  currency_code: String
  id: Int
  is_gcc: Boolean
  is_source_country: Boolean
  name: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type countries_sum_fields {
  id: Int
}

"""
update columns of table "countries"
"""
enum countries_update_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  currency_code

  """column name"""
  id

  """column name"""
  is_gcc

  """column name"""
  is_source_country

  """column name"""
  name

  """column name"""
  updated_at
}

input countries_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: countries_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: countries_set_input

  """filter the rows which have to be updated"""
  where: countries_bool_exp!
}

"""aggregate var_pop on columns"""
type countries_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type countries_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type countries_variance_fields {
  id: Float
}

"""Reference table for country calling codes"""
type country_codes {
  country_code: String!
  country_name: String!
  created_at: timestamptz
  dial_code: String!
  flag_emoji: String
  id: Int!
}

"""
aggregated selection of "country_codes"
"""
type country_codes_aggregate {
  aggregate: country_codes_aggregate_fields
  nodes: [country_codes!]!
}

"""
aggregate fields of "country_codes"
"""
type country_codes_aggregate_fields {
  avg: country_codes_avg_fields
  count(columns: [country_codes_select_column!], distinct: Boolean): Int!
  max: country_codes_max_fields
  min: country_codes_min_fields
  stddev: country_codes_stddev_fields
  stddev_pop: country_codes_stddev_pop_fields
  stddev_samp: country_codes_stddev_samp_fields
  sum: country_codes_sum_fields
  var_pop: country_codes_var_pop_fields
  var_samp: country_codes_var_samp_fields
  variance: country_codes_variance_fields
}

"""aggregate avg on columns"""
type country_codes_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "country_codes". All fields are combined with a logical 'AND'.
"""
input country_codes_bool_exp {
  _and: [country_codes_bool_exp!]
  _not: country_codes_bool_exp
  _or: [country_codes_bool_exp!]
  country_code: String_comparison_exp
  country_name: String_comparison_exp
  created_at: timestamptz_comparison_exp
  dial_code: String_comparison_exp
  flag_emoji: String_comparison_exp
  id: Int_comparison_exp
}

"""
unique or primary key constraints on table "country_codes"
"""
enum country_codes_constraint {
  """
  unique or primary key constraint on columns "country_code"
  """
  country_codes_country_code_key

  """
  unique or primary key constraint on columns "id"
  """
  country_codes_pkey
}

"""
input type for incrementing numeric columns in table "country_codes"
"""
input country_codes_inc_input {
  id: Int
}

"""
input type for inserting data into table "country_codes"
"""
input country_codes_insert_input {
  country_code: String
  country_name: String
  created_at: timestamptz
  dial_code: String
  flag_emoji: String
  id: Int
}

"""aggregate max on columns"""
type country_codes_max_fields {
  country_code: String
  country_name: String
  created_at: timestamptz
  dial_code: String
  flag_emoji: String
  id: Int
}

"""aggregate min on columns"""
type country_codes_min_fields {
  country_code: String
  country_name: String
  created_at: timestamptz
  dial_code: String
  flag_emoji: String
  id: Int
}

"""
response of any mutation on the table "country_codes"
"""
type country_codes_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [country_codes!]!
}

"""
on_conflict condition type for table "country_codes"
"""
input country_codes_on_conflict {
  constraint: country_codes_constraint!
  update_columns: [country_codes_update_column!]! = []
  where: country_codes_bool_exp
}

"""Ordering options when selecting data from "country_codes"."""
input country_codes_order_by {
  country_code: order_by
  country_name: order_by
  created_at: order_by
  dial_code: order_by
  flag_emoji: order_by
  id: order_by
}

"""primary key columns input for table: country_codes"""
input country_codes_pk_columns_input {
  id: Int!
}

"""
select columns of table "country_codes"
"""
enum country_codes_select_column {
  """column name"""
  country_code

  """column name"""
  country_name

  """column name"""
  created_at

  """column name"""
  dial_code

  """column name"""
  flag_emoji

  """column name"""
  id
}

"""
input type for updating data in table "country_codes"
"""
input country_codes_set_input {
  country_code: String
  country_name: String
  created_at: timestamptz
  dial_code: String
  flag_emoji: String
  id: Int
}

"""aggregate stddev on columns"""
type country_codes_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type country_codes_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type country_codes_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "country_codes"
"""
input country_codes_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: country_codes_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input country_codes_stream_cursor_value_input {
  country_code: String
  country_name: String
  created_at: timestamptz
  dial_code: String
  flag_emoji: String
  id: Int
}

"""aggregate sum on columns"""
type country_codes_sum_fields {
  id: Int
}

"""
update columns of table "country_codes"
"""
enum country_codes_update_column {
  """column name"""
  country_code

  """column name"""
  country_name

  """column name"""
  created_at

  """column name"""
  dial_code

  """column name"""
  flag_emoji

  """column name"""
  id
}

input country_codes_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: country_codes_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: country_codes_set_input

  """filter the rows which have to be updated"""
  where: country_codes_bool_exp!
}

"""aggregate var_pop on columns"""
type country_codes_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type country_codes_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type country_codes_variance_fields {
  id: Float
}

"""
columns and relationships of "credit_transactions"
"""
type credit_transactions {
  balance_after: Int!
  cost_usd_cents: Int
  created_at: timestamptz
  credits_amount: Int!
  description: String
  id: uuid!
  idempotency_key: String
  metadata(
    """JSON select path"""
    path: String
  ): jsonb

  """An object relationship"""
  payment_idempotency: payment_idempotency
  stripe_payment_intent_id: String
  transaction_type: String!

  """An object relationship"""
  user: auth_users
  user_id: uuid
}

"""
aggregated selection of "credit_transactions"
"""
type credit_transactions_aggregate {
  aggregate: credit_transactions_aggregate_fields
  nodes: [credit_transactions!]!
}

input credit_transactions_aggregate_bool_exp {
  count: credit_transactions_aggregate_bool_exp_count
}

input credit_transactions_aggregate_bool_exp_count {
  arguments: [credit_transactions_select_column!]
  distinct: Boolean
  filter: credit_transactions_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "credit_transactions"
"""
type credit_transactions_aggregate_fields {
  avg: credit_transactions_avg_fields
  count(columns: [credit_transactions_select_column!], distinct: Boolean): Int!
  max: credit_transactions_max_fields
  min: credit_transactions_min_fields
  stddev: credit_transactions_stddev_fields
  stddev_pop: credit_transactions_stddev_pop_fields
  stddev_samp: credit_transactions_stddev_samp_fields
  sum: credit_transactions_sum_fields
  var_pop: credit_transactions_var_pop_fields
  var_samp: credit_transactions_var_samp_fields
  variance: credit_transactions_variance_fields
}

"""
order by aggregate values of table "credit_transactions"
"""
input credit_transactions_aggregate_order_by {
  avg: credit_transactions_avg_order_by
  count: order_by
  max: credit_transactions_max_order_by
  min: credit_transactions_min_order_by
  stddev: credit_transactions_stddev_order_by
  stddev_pop: credit_transactions_stddev_pop_order_by
  stddev_samp: credit_transactions_stddev_samp_order_by
  sum: credit_transactions_sum_order_by
  var_pop: credit_transactions_var_pop_order_by
  var_samp: credit_transactions_var_samp_order_by
  variance: credit_transactions_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input credit_transactions_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "credit_transactions"
"""
input credit_transactions_arr_rel_insert_input {
  data: [credit_transactions_insert_input!]!

  """upsert condition"""
  on_conflict: credit_transactions_on_conflict
}

"""aggregate avg on columns"""
type credit_transactions_avg_fields {
  balance_after: Float
  cost_usd_cents: Float
  credits_amount: Float
}

"""
order by avg() on columns of table "credit_transactions"
"""
input credit_transactions_avg_order_by {
  balance_after: order_by
  cost_usd_cents: order_by
  credits_amount: order_by
}

"""
Boolean expression to filter rows from the table "credit_transactions". All fields are combined with a logical 'AND'.
"""
input credit_transactions_bool_exp {
  _and: [credit_transactions_bool_exp!]
  _not: credit_transactions_bool_exp
  _or: [credit_transactions_bool_exp!]
  balance_after: Int_comparison_exp
  cost_usd_cents: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  credits_amount: Int_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  idempotency_key: String_comparison_exp
  metadata: jsonb_comparison_exp
  payment_idempotency: payment_idempotency_bool_exp
  stripe_payment_intent_id: String_comparison_exp
  transaction_type: String_comparison_exp
  user: auth_users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "credit_transactions"
"""
enum credit_transactions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  credit_transactions_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input credit_transactions_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input credit_transactions_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input credit_transactions_delete_key_input {
  metadata: String
}

"""
input type for incrementing numeric columns in table "credit_transactions"
"""
input credit_transactions_inc_input {
  balance_after: Int
  cost_usd_cents: Int
  credits_amount: Int
}

"""
input type for inserting data into table "credit_transactions"
"""
input credit_transactions_insert_input {
  balance_after: Int
  cost_usd_cents: Int
  created_at: timestamptz
  credits_amount: Int
  description: String
  id: uuid
  idempotency_key: String
  metadata: jsonb
  payment_idempotency: payment_idempotency_obj_rel_insert_input
  stripe_payment_intent_id: String
  transaction_type: String
  user: auth_users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type credit_transactions_max_fields {
  balance_after: Int
  cost_usd_cents: Int
  created_at: timestamptz
  credits_amount: Int
  description: String
  id: uuid
  idempotency_key: String
  stripe_payment_intent_id: String
  transaction_type: String
  user_id: uuid
}

"""
order by max() on columns of table "credit_transactions"
"""
input credit_transactions_max_order_by {
  balance_after: order_by
  cost_usd_cents: order_by
  created_at: order_by
  credits_amount: order_by
  description: order_by
  id: order_by
  idempotency_key: order_by
  stripe_payment_intent_id: order_by
  transaction_type: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type credit_transactions_min_fields {
  balance_after: Int
  cost_usd_cents: Int
  created_at: timestamptz
  credits_amount: Int
  description: String
  id: uuid
  idempotency_key: String
  stripe_payment_intent_id: String
  transaction_type: String
  user_id: uuid
}

"""
order by min() on columns of table "credit_transactions"
"""
input credit_transactions_min_order_by {
  balance_after: order_by
  cost_usd_cents: order_by
  created_at: order_by
  credits_amount: order_by
  description: order_by
  id: order_by
  idempotency_key: order_by
  stripe_payment_intent_id: order_by
  transaction_type: order_by
  user_id: order_by
}

"""
response of any mutation on the table "credit_transactions"
"""
type credit_transactions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [credit_transactions!]!
}

"""
on_conflict condition type for table "credit_transactions"
"""
input credit_transactions_on_conflict {
  constraint: credit_transactions_constraint!
  update_columns: [credit_transactions_update_column!]! = []
  where: credit_transactions_bool_exp
}

"""Ordering options when selecting data from "credit_transactions"."""
input credit_transactions_order_by {
  balance_after: order_by
  cost_usd_cents: order_by
  created_at: order_by
  credits_amount: order_by
  description: order_by
  id: order_by
  idempotency_key: order_by
  metadata: order_by
  payment_idempotency: payment_idempotency_order_by
  stripe_payment_intent_id: order_by
  transaction_type: order_by
  user: auth_users_order_by
  user_id: order_by
}

"""primary key columns input for table: credit_transactions"""
input credit_transactions_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input credit_transactions_prepend_input {
  metadata: jsonb
}

"""
select columns of table "credit_transactions"
"""
enum credit_transactions_select_column {
  """column name"""
  balance_after

  """column name"""
  cost_usd_cents

  """column name"""
  created_at

  """column name"""
  credits_amount

  """column name"""
  description

  """column name"""
  id

  """column name"""
  idempotency_key

  """column name"""
  metadata

  """column name"""
  stripe_payment_intent_id

  """column name"""
  transaction_type

  """column name"""
  user_id
}

"""
input type for updating data in table "credit_transactions"
"""
input credit_transactions_set_input {
  balance_after: Int
  cost_usd_cents: Int
  created_at: timestamptz
  credits_amount: Int
  description: String
  id: uuid
  idempotency_key: String
  metadata: jsonb
  stripe_payment_intent_id: String
  transaction_type: String
  user_id: uuid
}

"""aggregate stddev on columns"""
type credit_transactions_stddev_fields {
  balance_after: Float
  cost_usd_cents: Float
  credits_amount: Float
}

"""
order by stddev() on columns of table "credit_transactions"
"""
input credit_transactions_stddev_order_by {
  balance_after: order_by
  cost_usd_cents: order_by
  credits_amount: order_by
}

"""aggregate stddev_pop on columns"""
type credit_transactions_stddev_pop_fields {
  balance_after: Float
  cost_usd_cents: Float
  credits_amount: Float
}

"""
order by stddev_pop() on columns of table "credit_transactions"
"""
input credit_transactions_stddev_pop_order_by {
  balance_after: order_by
  cost_usd_cents: order_by
  credits_amount: order_by
}

"""aggregate stddev_samp on columns"""
type credit_transactions_stddev_samp_fields {
  balance_after: Float
  cost_usd_cents: Float
  credits_amount: Float
}

"""
order by stddev_samp() on columns of table "credit_transactions"
"""
input credit_transactions_stddev_samp_order_by {
  balance_after: order_by
  cost_usd_cents: order_by
  credits_amount: order_by
}

"""
Streaming cursor of the table "credit_transactions"
"""
input credit_transactions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: credit_transactions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input credit_transactions_stream_cursor_value_input {
  balance_after: Int
  cost_usd_cents: Int
  created_at: timestamptz
  credits_amount: Int
  description: String
  id: uuid
  idempotency_key: String
  metadata: jsonb
  stripe_payment_intent_id: String
  transaction_type: String
  user_id: uuid
}

"""aggregate sum on columns"""
type credit_transactions_sum_fields {
  balance_after: Int
  cost_usd_cents: Int
  credits_amount: Int
}

"""
order by sum() on columns of table "credit_transactions"
"""
input credit_transactions_sum_order_by {
  balance_after: order_by
  cost_usd_cents: order_by
  credits_amount: order_by
}

"""
update columns of table "credit_transactions"
"""
enum credit_transactions_update_column {
  """column name"""
  balance_after

  """column name"""
  cost_usd_cents

  """column name"""
  created_at

  """column name"""
  credits_amount

  """column name"""
  description

  """column name"""
  id

  """column name"""
  idempotency_key

  """column name"""
  metadata

  """column name"""
  stripe_payment_intent_id

  """column name"""
  transaction_type

  """column name"""
  user_id
}

input credit_transactions_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: credit_transactions_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: credit_transactions_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: credit_transactions_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: credit_transactions_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: credit_transactions_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: credit_transactions_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: credit_transactions_set_input

  """filter the rows which have to be updated"""
  where: credit_transactions_bool_exp!
}

"""aggregate var_pop on columns"""
type credit_transactions_var_pop_fields {
  balance_after: Float
  cost_usd_cents: Float
  credits_amount: Float
}

"""
order by var_pop() on columns of table "credit_transactions"
"""
input credit_transactions_var_pop_order_by {
  balance_after: order_by
  cost_usd_cents: order_by
  credits_amount: order_by
}

"""aggregate var_samp on columns"""
type credit_transactions_var_samp_fields {
  balance_after: Float
  cost_usd_cents: Float
  credits_amount: Float
}

"""
order by var_samp() on columns of table "credit_transactions"
"""
input credit_transactions_var_samp_order_by {
  balance_after: order_by
  cost_usd_cents: order_by
  credits_amount: order_by
}

"""aggregate variance on columns"""
type credit_transactions_variance_fields {
  balance_after: Float
  cost_usd_cents: Float
  credits_amount: Float
}

"""
order by variance() on columns of table "credit_transactions"
"""
input credit_transactions_variance_order_by {
  balance_after: order_by
  cost_usd_cents: order_by
  credits_amount: order_by
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

scalar date

"""
Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'.
"""
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

"""Evidence and supporting documents for disputes"""
type dispute_evidence {
  created_at: timestamptz
  description: String

  """An object relationship"""
  dispute: disputes!
  dispute_id: uuid!
  evidence_type: String!
  file_name: String
  file_size: Int
  file_type: String
  file_url: String
  id: uuid!
  is_verified: Boolean
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  submitted_by_id: uuid!
  submitted_by_name: String
  submitted_by_type: String!
  title: String!
  updated_at: timestamptz

  """An object relationship"""
  user: auth_users!

  """An object relationship"""
  userByVerifiedById: auth_users
  verification_notes: String
  verified_at: timestamptz
  verified_by_id: uuid
}

"""
aggregated selection of "dispute_evidence"
"""
type dispute_evidence_aggregate {
  aggregate: dispute_evidence_aggregate_fields
  nodes: [dispute_evidence!]!
}

input dispute_evidence_aggregate_bool_exp {
  bool_and: dispute_evidence_aggregate_bool_exp_bool_and
  bool_or: dispute_evidence_aggregate_bool_exp_bool_or
  count: dispute_evidence_aggregate_bool_exp_count
}

input dispute_evidence_aggregate_bool_exp_bool_and {
  arguments: dispute_evidence_select_column_dispute_evidence_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: dispute_evidence_bool_exp
  predicate: Boolean_comparison_exp!
}

input dispute_evidence_aggregate_bool_exp_bool_or {
  arguments: dispute_evidence_select_column_dispute_evidence_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: dispute_evidence_bool_exp
  predicate: Boolean_comparison_exp!
}

input dispute_evidence_aggregate_bool_exp_count {
  arguments: [dispute_evidence_select_column!]
  distinct: Boolean
  filter: dispute_evidence_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "dispute_evidence"
"""
type dispute_evidence_aggregate_fields {
  avg: dispute_evidence_avg_fields
  count(columns: [dispute_evidence_select_column!], distinct: Boolean): Int!
  max: dispute_evidence_max_fields
  min: dispute_evidence_min_fields
  stddev: dispute_evidence_stddev_fields
  stddev_pop: dispute_evidence_stddev_pop_fields
  stddev_samp: dispute_evidence_stddev_samp_fields
  sum: dispute_evidence_sum_fields
  var_pop: dispute_evidence_var_pop_fields
  var_samp: dispute_evidence_var_samp_fields
  variance: dispute_evidence_variance_fields
}

"""
order by aggregate values of table "dispute_evidence"
"""
input dispute_evidence_aggregate_order_by {
  avg: dispute_evidence_avg_order_by
  count: order_by
  max: dispute_evidence_max_order_by
  min: dispute_evidence_min_order_by
  stddev: dispute_evidence_stddev_order_by
  stddev_pop: dispute_evidence_stddev_pop_order_by
  stddev_samp: dispute_evidence_stddev_samp_order_by
  sum: dispute_evidence_sum_order_by
  var_pop: dispute_evidence_var_pop_order_by
  var_samp: dispute_evidence_var_samp_order_by
  variance: dispute_evidence_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input dispute_evidence_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "dispute_evidence"
"""
input dispute_evidence_arr_rel_insert_input {
  data: [dispute_evidence_insert_input!]!

  """upsert condition"""
  on_conflict: dispute_evidence_on_conflict
}

"""aggregate avg on columns"""
type dispute_evidence_avg_fields {
  file_size: Float
}

"""
order by avg() on columns of table "dispute_evidence"
"""
input dispute_evidence_avg_order_by {
  file_size: order_by
}

"""
Boolean expression to filter rows from the table "dispute_evidence". All fields are combined with a logical 'AND'.
"""
input dispute_evidence_bool_exp {
  _and: [dispute_evidence_bool_exp!]
  _not: dispute_evidence_bool_exp
  _or: [dispute_evidence_bool_exp!]
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  dispute: disputes_bool_exp
  dispute_id: uuid_comparison_exp
  evidence_type: String_comparison_exp
  file_name: String_comparison_exp
  file_size: Int_comparison_exp
  file_type: String_comparison_exp
  file_url: String_comparison_exp
  id: uuid_comparison_exp
  is_verified: Boolean_comparison_exp
  metadata: jsonb_comparison_exp
  submitted_by_id: uuid_comparison_exp
  submitted_by_name: String_comparison_exp
  submitted_by_type: String_comparison_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
  userByVerifiedById: auth_users_bool_exp
  verification_notes: String_comparison_exp
  verified_at: timestamptz_comparison_exp
  verified_by_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "dispute_evidence"
"""
enum dispute_evidence_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  dispute_evidence_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input dispute_evidence_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input dispute_evidence_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input dispute_evidence_delete_key_input {
  metadata: String
}

"""
input type for incrementing numeric columns in table "dispute_evidence"
"""
input dispute_evidence_inc_input {
  file_size: Int
}

"""
input type for inserting data into table "dispute_evidence"
"""
input dispute_evidence_insert_input {
  created_at: timestamptz
  description: String
  dispute: disputes_obj_rel_insert_input
  dispute_id: uuid
  evidence_type: String
  file_name: String
  file_size: Int
  file_type: String
  file_url: String
  id: uuid
  is_verified: Boolean
  metadata: jsonb
  submitted_by_id: uuid
  submitted_by_name: String
  submitted_by_type: String
  title: String
  updated_at: timestamptz
  user: auth_users_obj_rel_insert_input
  userByVerifiedById: auth_users_obj_rel_insert_input
  verification_notes: String
  verified_at: timestamptz
  verified_by_id: uuid
}

"""aggregate max on columns"""
type dispute_evidence_max_fields {
  created_at: timestamptz
  description: String
  dispute_id: uuid
  evidence_type: String
  file_name: String
  file_size: Int
  file_type: String
  file_url: String
  id: uuid
  submitted_by_id: uuid
  submitted_by_name: String
  submitted_by_type: String
  title: String
  updated_at: timestamptz
  verification_notes: String
  verified_at: timestamptz
  verified_by_id: uuid
}

"""
order by max() on columns of table "dispute_evidence"
"""
input dispute_evidence_max_order_by {
  created_at: order_by
  description: order_by
  dispute_id: order_by
  evidence_type: order_by
  file_name: order_by
  file_size: order_by
  file_type: order_by
  file_url: order_by
  id: order_by
  submitted_by_id: order_by
  submitted_by_name: order_by
  submitted_by_type: order_by
  title: order_by
  updated_at: order_by
  verification_notes: order_by
  verified_at: order_by
  verified_by_id: order_by
}

"""aggregate min on columns"""
type dispute_evidence_min_fields {
  created_at: timestamptz
  description: String
  dispute_id: uuid
  evidence_type: String
  file_name: String
  file_size: Int
  file_type: String
  file_url: String
  id: uuid
  submitted_by_id: uuid
  submitted_by_name: String
  submitted_by_type: String
  title: String
  updated_at: timestamptz
  verification_notes: String
  verified_at: timestamptz
  verified_by_id: uuid
}

"""
order by min() on columns of table "dispute_evidence"
"""
input dispute_evidence_min_order_by {
  created_at: order_by
  description: order_by
  dispute_id: order_by
  evidence_type: order_by
  file_name: order_by
  file_size: order_by
  file_type: order_by
  file_url: order_by
  id: order_by
  submitted_by_id: order_by
  submitted_by_name: order_by
  submitted_by_type: order_by
  title: order_by
  updated_at: order_by
  verification_notes: order_by
  verified_at: order_by
  verified_by_id: order_by
}

"""
response of any mutation on the table "dispute_evidence"
"""
type dispute_evidence_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [dispute_evidence!]!
}

"""
on_conflict condition type for table "dispute_evidence"
"""
input dispute_evidence_on_conflict {
  constraint: dispute_evidence_constraint!
  update_columns: [dispute_evidence_update_column!]! = []
  where: dispute_evidence_bool_exp
}

"""Ordering options when selecting data from "dispute_evidence"."""
input dispute_evidence_order_by {
  created_at: order_by
  description: order_by
  dispute: disputes_order_by
  dispute_id: order_by
  evidence_type: order_by
  file_name: order_by
  file_size: order_by
  file_type: order_by
  file_url: order_by
  id: order_by
  is_verified: order_by
  metadata: order_by
  submitted_by_id: order_by
  submitted_by_name: order_by
  submitted_by_type: order_by
  title: order_by
  updated_at: order_by
  user: auth_users_order_by
  userByVerifiedById: auth_users_order_by
  verification_notes: order_by
  verified_at: order_by
  verified_by_id: order_by
}

"""primary key columns input for table: dispute_evidence"""
input dispute_evidence_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input dispute_evidence_prepend_input {
  metadata: jsonb
}

"""
select columns of table "dispute_evidence"
"""
enum dispute_evidence_select_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  dispute_id

  """column name"""
  evidence_type

  """column name"""
  file_name

  """column name"""
  file_size

  """column name"""
  file_type

  """column name"""
  file_url

  """column name"""
  id

  """column name"""
  is_verified

  """column name"""
  metadata

  """column name"""
  submitted_by_id

  """column name"""
  submitted_by_name

  """column name"""
  submitted_by_type

  """column name"""
  title

  """column name"""
  updated_at

  """column name"""
  verification_notes

  """column name"""
  verified_at

  """column name"""
  verified_by_id
}

"""
select "dispute_evidence_aggregate_bool_exp_bool_and_arguments_columns" columns of table "dispute_evidence"
"""
enum dispute_evidence_select_column_dispute_evidence_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_verified
}

"""
select "dispute_evidence_aggregate_bool_exp_bool_or_arguments_columns" columns of table "dispute_evidence"
"""
enum dispute_evidence_select_column_dispute_evidence_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_verified
}

"""
input type for updating data in table "dispute_evidence"
"""
input dispute_evidence_set_input {
  created_at: timestamptz
  description: String
  dispute_id: uuid
  evidence_type: String
  file_name: String
  file_size: Int
  file_type: String
  file_url: String
  id: uuid
  is_verified: Boolean
  metadata: jsonb
  submitted_by_id: uuid
  submitted_by_name: String
  submitted_by_type: String
  title: String
  updated_at: timestamptz
  verification_notes: String
  verified_at: timestamptz
  verified_by_id: uuid
}

"""aggregate stddev on columns"""
type dispute_evidence_stddev_fields {
  file_size: Float
}

"""
order by stddev() on columns of table "dispute_evidence"
"""
input dispute_evidence_stddev_order_by {
  file_size: order_by
}

"""aggregate stddev_pop on columns"""
type dispute_evidence_stddev_pop_fields {
  file_size: Float
}

"""
order by stddev_pop() on columns of table "dispute_evidence"
"""
input dispute_evidence_stddev_pop_order_by {
  file_size: order_by
}

"""aggregate stddev_samp on columns"""
type dispute_evidence_stddev_samp_fields {
  file_size: Float
}

"""
order by stddev_samp() on columns of table "dispute_evidence"
"""
input dispute_evidence_stddev_samp_order_by {
  file_size: order_by
}

"""
Streaming cursor of the table "dispute_evidence"
"""
input dispute_evidence_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: dispute_evidence_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input dispute_evidence_stream_cursor_value_input {
  created_at: timestamptz
  description: String
  dispute_id: uuid
  evidence_type: String
  file_name: String
  file_size: Int
  file_type: String
  file_url: String
  id: uuid
  is_verified: Boolean
  metadata: jsonb
  submitted_by_id: uuid
  submitted_by_name: String
  submitted_by_type: String
  title: String
  updated_at: timestamptz
  verification_notes: String
  verified_at: timestamptz
  verified_by_id: uuid
}

"""aggregate sum on columns"""
type dispute_evidence_sum_fields {
  file_size: Int
}

"""
order by sum() on columns of table "dispute_evidence"
"""
input dispute_evidence_sum_order_by {
  file_size: order_by
}

"""
update columns of table "dispute_evidence"
"""
enum dispute_evidence_update_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  dispute_id

  """column name"""
  evidence_type

  """column name"""
  file_name

  """column name"""
  file_size

  """column name"""
  file_type

  """column name"""
  file_url

  """column name"""
  id

  """column name"""
  is_verified

  """column name"""
  metadata

  """column name"""
  submitted_by_id

  """column name"""
  submitted_by_name

  """column name"""
  submitted_by_type

  """column name"""
  title

  """column name"""
  updated_at

  """column name"""
  verification_notes

  """column name"""
  verified_at

  """column name"""
  verified_by_id
}

input dispute_evidence_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: dispute_evidence_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: dispute_evidence_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: dispute_evidence_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: dispute_evidence_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: dispute_evidence_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: dispute_evidence_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: dispute_evidence_set_input

  """filter the rows which have to be updated"""
  where: dispute_evidence_bool_exp!
}

"""aggregate var_pop on columns"""
type dispute_evidence_var_pop_fields {
  file_size: Float
}

"""
order by var_pop() on columns of table "dispute_evidence"
"""
input dispute_evidence_var_pop_order_by {
  file_size: order_by
}

"""aggregate var_samp on columns"""
type dispute_evidence_var_samp_fields {
  file_size: Float
}

"""
order by var_samp() on columns of table "dispute_evidence"
"""
input dispute_evidence_var_samp_order_by {
  file_size: order_by
}

"""aggregate variance on columns"""
type dispute_evidence_variance_fields {
  file_size: Float
}

"""
order by variance() on columns of table "dispute_evidence"
"""
input dispute_evidence_variance_order_by {
  file_size: order_by
}

"""Communication thread for disputes"""
type dispute_messages {
  attachments(
    """JSON select path"""
    path: String
  ): jsonb
  created_at: timestamptz

  """An object relationship"""
  dispute: disputes!
  dispute_id: uuid!
  id: uuid!
  is_internal: Boolean
  is_read: Boolean
  message: String!
  message_type: String
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  read_at: timestamptz
  sender_id: uuid!
  sender_name: String!
  sender_type: String!
  updated_at: timestamptz

  """An object relationship"""
  user: auth_users!
}

"""
aggregated selection of "dispute_messages"
"""
type dispute_messages_aggregate {
  aggregate: dispute_messages_aggregate_fields
  nodes: [dispute_messages!]!
}

input dispute_messages_aggregate_bool_exp {
  bool_and: dispute_messages_aggregate_bool_exp_bool_and
  bool_or: dispute_messages_aggregate_bool_exp_bool_or
  count: dispute_messages_aggregate_bool_exp_count
}

input dispute_messages_aggregate_bool_exp_bool_and {
  arguments: dispute_messages_select_column_dispute_messages_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: dispute_messages_bool_exp
  predicate: Boolean_comparison_exp!
}

input dispute_messages_aggregate_bool_exp_bool_or {
  arguments: dispute_messages_select_column_dispute_messages_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: dispute_messages_bool_exp
  predicate: Boolean_comparison_exp!
}

input dispute_messages_aggregate_bool_exp_count {
  arguments: [dispute_messages_select_column!]
  distinct: Boolean
  filter: dispute_messages_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "dispute_messages"
"""
type dispute_messages_aggregate_fields {
  count(columns: [dispute_messages_select_column!], distinct: Boolean): Int!
  max: dispute_messages_max_fields
  min: dispute_messages_min_fields
}

"""
order by aggregate values of table "dispute_messages"
"""
input dispute_messages_aggregate_order_by {
  count: order_by
  max: dispute_messages_max_order_by
  min: dispute_messages_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input dispute_messages_append_input {
  attachments: jsonb
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "dispute_messages"
"""
input dispute_messages_arr_rel_insert_input {
  data: [dispute_messages_insert_input!]!

  """upsert condition"""
  on_conflict: dispute_messages_on_conflict
}

"""
Boolean expression to filter rows from the table "dispute_messages". All fields are combined with a logical 'AND'.
"""
input dispute_messages_bool_exp {
  _and: [dispute_messages_bool_exp!]
  _not: dispute_messages_bool_exp
  _or: [dispute_messages_bool_exp!]
  attachments: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  dispute: disputes_bool_exp
  dispute_id: uuid_comparison_exp
  id: uuid_comparison_exp
  is_internal: Boolean_comparison_exp
  is_read: Boolean_comparison_exp
  message: String_comparison_exp
  message_type: String_comparison_exp
  metadata: jsonb_comparison_exp
  read_at: timestamptz_comparison_exp
  sender_id: uuid_comparison_exp
  sender_name: String_comparison_exp
  sender_type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
}

"""
unique or primary key constraints on table "dispute_messages"
"""
enum dispute_messages_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  dispute_messages_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input dispute_messages_delete_at_path_input {
  attachments: [String!]
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input dispute_messages_delete_elem_input {
  attachments: Int
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input dispute_messages_delete_key_input {
  attachments: String
  metadata: String
}

"""
input type for inserting data into table "dispute_messages"
"""
input dispute_messages_insert_input {
  attachments: jsonb
  created_at: timestamptz
  dispute: disputes_obj_rel_insert_input
  dispute_id: uuid
  id: uuid
  is_internal: Boolean
  is_read: Boolean
  message: String
  message_type: String
  metadata: jsonb
  read_at: timestamptz
  sender_id: uuid
  sender_name: String
  sender_type: String
  updated_at: timestamptz
  user: auth_users_obj_rel_insert_input
}

"""aggregate max on columns"""
type dispute_messages_max_fields {
  created_at: timestamptz
  dispute_id: uuid
  id: uuid
  message: String
  message_type: String
  read_at: timestamptz
  sender_id: uuid
  sender_name: String
  sender_type: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "dispute_messages"
"""
input dispute_messages_max_order_by {
  created_at: order_by
  dispute_id: order_by
  id: order_by
  message: order_by
  message_type: order_by
  read_at: order_by
  sender_id: order_by
  sender_name: order_by
  sender_type: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type dispute_messages_min_fields {
  created_at: timestamptz
  dispute_id: uuid
  id: uuid
  message: String
  message_type: String
  read_at: timestamptz
  sender_id: uuid
  sender_name: String
  sender_type: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "dispute_messages"
"""
input dispute_messages_min_order_by {
  created_at: order_by
  dispute_id: order_by
  id: order_by
  message: order_by
  message_type: order_by
  read_at: order_by
  sender_id: order_by
  sender_name: order_by
  sender_type: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "dispute_messages"
"""
type dispute_messages_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [dispute_messages!]!
}

"""
on_conflict condition type for table "dispute_messages"
"""
input dispute_messages_on_conflict {
  constraint: dispute_messages_constraint!
  update_columns: [dispute_messages_update_column!]! = []
  where: dispute_messages_bool_exp
}

"""Ordering options when selecting data from "dispute_messages"."""
input dispute_messages_order_by {
  attachments: order_by
  created_at: order_by
  dispute: disputes_order_by
  dispute_id: order_by
  id: order_by
  is_internal: order_by
  is_read: order_by
  message: order_by
  message_type: order_by
  metadata: order_by
  read_at: order_by
  sender_id: order_by
  sender_name: order_by
  sender_type: order_by
  updated_at: order_by
  user: auth_users_order_by
}

"""primary key columns input for table: dispute_messages"""
input dispute_messages_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input dispute_messages_prepend_input {
  attachments: jsonb
  metadata: jsonb
}

"""
select columns of table "dispute_messages"
"""
enum dispute_messages_select_column {
  """column name"""
  attachments

  """column name"""
  created_at

  """column name"""
  dispute_id

  """column name"""
  id

  """column name"""
  is_internal

  """column name"""
  is_read

  """column name"""
  message

  """column name"""
  message_type

  """column name"""
  metadata

  """column name"""
  read_at

  """column name"""
  sender_id

  """column name"""
  sender_name

  """column name"""
  sender_type

  """column name"""
  updated_at
}

"""
select "dispute_messages_aggregate_bool_exp_bool_and_arguments_columns" columns of table "dispute_messages"
"""
enum dispute_messages_select_column_dispute_messages_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_internal

  """column name"""
  is_read
}

"""
select "dispute_messages_aggregate_bool_exp_bool_or_arguments_columns" columns of table "dispute_messages"
"""
enum dispute_messages_select_column_dispute_messages_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_internal

  """column name"""
  is_read
}

"""
input type for updating data in table "dispute_messages"
"""
input dispute_messages_set_input {
  attachments: jsonb
  created_at: timestamptz
  dispute_id: uuid
  id: uuid
  is_internal: Boolean
  is_read: Boolean
  message: String
  message_type: String
  metadata: jsonb
  read_at: timestamptz
  sender_id: uuid
  sender_name: String
  sender_type: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "dispute_messages"
"""
input dispute_messages_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: dispute_messages_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input dispute_messages_stream_cursor_value_input {
  attachments: jsonb
  created_at: timestamptz
  dispute_id: uuid
  id: uuid
  is_internal: Boolean
  is_read: Boolean
  message: String
  message_type: String
  metadata: jsonb
  read_at: timestamptz
  sender_id: uuid
  sender_name: String
  sender_type: String
  updated_at: timestamptz
}

"""
update columns of table "dispute_messages"
"""
enum dispute_messages_update_column {
  """column name"""
  attachments

  """column name"""
  created_at

  """column name"""
  dispute_id

  """column name"""
  id

  """column name"""
  is_internal

  """column name"""
  is_read

  """column name"""
  message

  """column name"""
  message_type

  """column name"""
  metadata

  """column name"""
  read_at

  """column name"""
  sender_id

  """column name"""
  sender_name

  """column name"""
  sender_type

  """column name"""
  updated_at
}

input dispute_messages_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: dispute_messages_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: dispute_messages_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: dispute_messages_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: dispute_messages_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: dispute_messages_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: dispute_messages_set_input

  """filter the rows which have to be updated"""
  where: dispute_messages_bool_exp!
}

"""Parties involved in disputes"""
type dispute_parties {
  created_at: timestamptz

  """An object relationship"""
  dispute: disputes!
  dispute_id: uuid!
  id: uuid!
  last_viewed_at: timestamptz
  notes: String
  notified_at: timestamptz
  party_email: String
  party_id: uuid!
  party_name: String!
  party_phone: String
  party_type: String!
  responded_at: timestamptz
  role: String
  updated_at: timestamptz

  """An object relationship"""
  user: auth_users!
}

"""
aggregated selection of "dispute_parties"
"""
type dispute_parties_aggregate {
  aggregate: dispute_parties_aggregate_fields
  nodes: [dispute_parties!]!
}

input dispute_parties_aggregate_bool_exp {
  count: dispute_parties_aggregate_bool_exp_count
}

input dispute_parties_aggregate_bool_exp_count {
  arguments: [dispute_parties_select_column!]
  distinct: Boolean
  filter: dispute_parties_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "dispute_parties"
"""
type dispute_parties_aggregate_fields {
  count(columns: [dispute_parties_select_column!], distinct: Boolean): Int!
  max: dispute_parties_max_fields
  min: dispute_parties_min_fields
}

"""
order by aggregate values of table "dispute_parties"
"""
input dispute_parties_aggregate_order_by {
  count: order_by
  max: dispute_parties_max_order_by
  min: dispute_parties_min_order_by
}

"""
input type for inserting array relation for remote table "dispute_parties"
"""
input dispute_parties_arr_rel_insert_input {
  data: [dispute_parties_insert_input!]!

  """upsert condition"""
  on_conflict: dispute_parties_on_conflict
}

"""
Boolean expression to filter rows from the table "dispute_parties". All fields are combined with a logical 'AND'.
"""
input dispute_parties_bool_exp {
  _and: [dispute_parties_bool_exp!]
  _not: dispute_parties_bool_exp
  _or: [dispute_parties_bool_exp!]
  created_at: timestamptz_comparison_exp
  dispute: disputes_bool_exp
  dispute_id: uuid_comparison_exp
  id: uuid_comparison_exp
  last_viewed_at: timestamptz_comparison_exp
  notes: String_comparison_exp
  notified_at: timestamptz_comparison_exp
  party_email: String_comparison_exp
  party_id: uuid_comparison_exp
  party_name: String_comparison_exp
  party_phone: String_comparison_exp
  party_type: String_comparison_exp
  responded_at: timestamptz_comparison_exp
  role: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
}

"""
unique or primary key constraints on table "dispute_parties"
"""
enum dispute_parties_constraint {
  """
  unique or primary key constraint on columns "dispute_id", "party_id"
  """
  dispute_parties_dispute_id_party_id_key

  """
  unique or primary key constraint on columns "id"
  """
  dispute_parties_pkey
}

"""
input type for inserting data into table "dispute_parties"
"""
input dispute_parties_insert_input {
  created_at: timestamptz
  dispute: disputes_obj_rel_insert_input
  dispute_id: uuid
  id: uuid
  last_viewed_at: timestamptz
  notes: String
  notified_at: timestamptz
  party_email: String
  party_id: uuid
  party_name: String
  party_phone: String
  party_type: String
  responded_at: timestamptz
  role: String
  updated_at: timestamptz
  user: auth_users_obj_rel_insert_input
}

"""aggregate max on columns"""
type dispute_parties_max_fields {
  created_at: timestamptz
  dispute_id: uuid
  id: uuid
  last_viewed_at: timestamptz
  notes: String
  notified_at: timestamptz
  party_email: String
  party_id: uuid
  party_name: String
  party_phone: String
  party_type: String
  responded_at: timestamptz
  role: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "dispute_parties"
"""
input dispute_parties_max_order_by {
  created_at: order_by
  dispute_id: order_by
  id: order_by
  last_viewed_at: order_by
  notes: order_by
  notified_at: order_by
  party_email: order_by
  party_id: order_by
  party_name: order_by
  party_phone: order_by
  party_type: order_by
  responded_at: order_by
  role: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type dispute_parties_min_fields {
  created_at: timestamptz
  dispute_id: uuid
  id: uuid
  last_viewed_at: timestamptz
  notes: String
  notified_at: timestamptz
  party_email: String
  party_id: uuid
  party_name: String
  party_phone: String
  party_type: String
  responded_at: timestamptz
  role: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "dispute_parties"
"""
input dispute_parties_min_order_by {
  created_at: order_by
  dispute_id: order_by
  id: order_by
  last_viewed_at: order_by
  notes: order_by
  notified_at: order_by
  party_email: order_by
  party_id: order_by
  party_name: order_by
  party_phone: order_by
  party_type: order_by
  responded_at: order_by
  role: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "dispute_parties"
"""
type dispute_parties_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [dispute_parties!]!
}

"""
on_conflict condition type for table "dispute_parties"
"""
input dispute_parties_on_conflict {
  constraint: dispute_parties_constraint!
  update_columns: [dispute_parties_update_column!]! = []
  where: dispute_parties_bool_exp
}

"""Ordering options when selecting data from "dispute_parties"."""
input dispute_parties_order_by {
  created_at: order_by
  dispute: disputes_order_by
  dispute_id: order_by
  id: order_by
  last_viewed_at: order_by
  notes: order_by
  notified_at: order_by
  party_email: order_by
  party_id: order_by
  party_name: order_by
  party_phone: order_by
  party_type: order_by
  responded_at: order_by
  role: order_by
  updated_at: order_by
  user: auth_users_order_by
}

"""primary key columns input for table: dispute_parties"""
input dispute_parties_pk_columns_input {
  id: uuid!
}

"""
select columns of table "dispute_parties"
"""
enum dispute_parties_select_column {
  """column name"""
  created_at

  """column name"""
  dispute_id

  """column name"""
  id

  """column name"""
  last_viewed_at

  """column name"""
  notes

  """column name"""
  notified_at

  """column name"""
  party_email

  """column name"""
  party_id

  """column name"""
  party_name

  """column name"""
  party_phone

  """column name"""
  party_type

  """column name"""
  responded_at

  """column name"""
  role

  """column name"""
  updated_at
}

"""
input type for updating data in table "dispute_parties"
"""
input dispute_parties_set_input {
  created_at: timestamptz
  dispute_id: uuid
  id: uuid
  last_viewed_at: timestamptz
  notes: String
  notified_at: timestamptz
  party_email: String
  party_id: uuid
  party_name: String
  party_phone: String
  party_type: String
  responded_at: timestamptz
  role: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "dispute_parties"
"""
input dispute_parties_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: dispute_parties_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input dispute_parties_stream_cursor_value_input {
  created_at: timestamptz
  dispute_id: uuid
  id: uuid
  last_viewed_at: timestamptz
  notes: String
  notified_at: timestamptz
  party_email: String
  party_id: uuid
  party_name: String
  party_phone: String
  party_type: String
  responded_at: timestamptz
  role: String
  updated_at: timestamptz
}

"""
update columns of table "dispute_parties"
"""
enum dispute_parties_update_column {
  """column name"""
  created_at

  """column name"""
  dispute_id

  """column name"""
  id

  """column name"""
  last_viewed_at

  """column name"""
  notes

  """column name"""
  notified_at

  """column name"""
  party_email

  """column name"""
  party_id

  """column name"""
  party_name

  """column name"""
  party_phone

  """column name"""
  party_type

  """column name"""
  responded_at

  """column name"""
  role

  """column name"""
  updated_at
}

input dispute_parties_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: dispute_parties_set_input

  """filter the rows which have to be updated"""
  where: dispute_parties_bool_exp!
}

"""Dispute resolution system for agency-client-maid conflicts"""
type disputes {
  agency_id: uuid

  """An object relationship"""
  agency_placement: agency_placements
  assigned_mediator_id: uuid
  assigned_mediator_name: String
  awarded_amount: numeric
  claimed_amount: numeric
  created_at: timestamptz
  currency: String
  description: String!

  """An array relationship"""
  dispute_evidences(
    """distinct select on columns"""
    distinct_on: [dispute_evidence_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dispute_evidence_order_by!]

    """filter the rows returned"""
    where: dispute_evidence_bool_exp
  ): [dispute_evidence!]!

  """An aggregate relationship"""
  dispute_evidences_aggregate(
    """distinct select on columns"""
    distinct_on: [dispute_evidence_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dispute_evidence_order_by!]

    """filter the rows returned"""
    where: dispute_evidence_bool_exp
  ): dispute_evidence_aggregate!

  """An array relationship"""
  dispute_messages(
    """distinct select on columns"""
    distinct_on: [dispute_messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dispute_messages_order_by!]

    """filter the rows returned"""
    where: dispute_messages_bool_exp
  ): [dispute_messages!]!

  """An aggregate relationship"""
  dispute_messages_aggregate(
    """distinct select on columns"""
    distinct_on: [dispute_messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dispute_messages_order_by!]

    """filter the rows returned"""
    where: dispute_messages_bool_exp
  ): dispute_messages_aggregate!

  """An array relationship"""
  dispute_parties(
    """distinct select on columns"""
    distinct_on: [dispute_parties_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dispute_parties_order_by!]

    """filter the rows returned"""
    where: dispute_parties_bool_exp
  ): [dispute_parties!]!

  """An aggregate relationship"""
  dispute_parties_aggregate(
    """distinct select on columns"""
    distinct_on: [dispute_parties_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dispute_parties_order_by!]

    """filter the rows returned"""
    where: dispute_parties_bool_exp
  ): dispute_parties_aggregate!
  dispute_type: String!
  evidence_summary(
    """JSON select path"""
    path: String
  ): jsonb
  first_response_at: timestamptz
  id: uuid!
  internal_notes: String
  last_activity_at: timestamptz
  maid_id: String
  placement_id: uuid
  priority: String
  raised_by_id: uuid!
  raised_by_type: String!
  resolution_notes: String
  resolution_type: String
  resolved_at: timestamptz
  resolved_by_id: uuid
  sponsor_id: String
  status: String!
  tags: [String!]
  title: String!
  updated_at: timestamptz

  """An object relationship"""
  user: auth_users

  """An object relationship"""
  userByAssignedMediatorId: auth_users

  """An object relationship"""
  userByRaisedById: auth_users!

  """An object relationship"""
  userByResolvedById: auth_users
}

"""
aggregated selection of "disputes"
"""
type disputes_aggregate {
  aggregate: disputes_aggregate_fields
  nodes: [disputes!]!
}

input disputes_aggregate_bool_exp {
  count: disputes_aggregate_bool_exp_count
}

input disputes_aggregate_bool_exp_count {
  arguments: [disputes_select_column!]
  distinct: Boolean
  filter: disputes_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "disputes"
"""
type disputes_aggregate_fields {
  avg: disputes_avg_fields
  count(columns: [disputes_select_column!], distinct: Boolean): Int!
  max: disputes_max_fields
  min: disputes_min_fields
  stddev: disputes_stddev_fields
  stddev_pop: disputes_stddev_pop_fields
  stddev_samp: disputes_stddev_samp_fields
  sum: disputes_sum_fields
  var_pop: disputes_var_pop_fields
  var_samp: disputes_var_samp_fields
  variance: disputes_variance_fields
}

"""
order by aggregate values of table "disputes"
"""
input disputes_aggregate_order_by {
  avg: disputes_avg_order_by
  count: order_by
  max: disputes_max_order_by
  min: disputes_min_order_by
  stddev: disputes_stddev_order_by
  stddev_pop: disputes_stddev_pop_order_by
  stddev_samp: disputes_stddev_samp_order_by
  sum: disputes_sum_order_by
  var_pop: disputes_var_pop_order_by
  var_samp: disputes_var_samp_order_by
  variance: disputes_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input disputes_append_input {
  evidence_summary: jsonb
}

"""
input type for inserting array relation for remote table "disputes"
"""
input disputes_arr_rel_insert_input {
  data: [disputes_insert_input!]!

  """upsert condition"""
  on_conflict: disputes_on_conflict
}

"""aggregate avg on columns"""
type disputes_avg_fields {
  awarded_amount: Float
  claimed_amount: Float
}

"""
order by avg() on columns of table "disputes"
"""
input disputes_avg_order_by {
  awarded_amount: order_by
  claimed_amount: order_by
}

"""
Boolean expression to filter rows from the table "disputes". All fields are combined with a logical 'AND'.
"""
input disputes_bool_exp {
  _and: [disputes_bool_exp!]
  _not: disputes_bool_exp
  _or: [disputes_bool_exp!]
  agency_id: uuid_comparison_exp
  agency_placement: agency_placements_bool_exp
  assigned_mediator_id: uuid_comparison_exp
  assigned_mediator_name: String_comparison_exp
  awarded_amount: numeric_comparison_exp
  claimed_amount: numeric_comparison_exp
  created_at: timestamptz_comparison_exp
  currency: String_comparison_exp
  description: String_comparison_exp
  dispute_evidences: dispute_evidence_bool_exp
  dispute_evidences_aggregate: dispute_evidence_aggregate_bool_exp
  dispute_messages: dispute_messages_bool_exp
  dispute_messages_aggregate: dispute_messages_aggregate_bool_exp
  dispute_parties: dispute_parties_bool_exp
  dispute_parties_aggregate: dispute_parties_aggregate_bool_exp
  dispute_type: String_comparison_exp
  evidence_summary: jsonb_comparison_exp
  first_response_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  internal_notes: String_comparison_exp
  last_activity_at: timestamptz_comparison_exp
  maid_id: String_comparison_exp
  placement_id: uuid_comparison_exp
  priority: String_comparison_exp
  raised_by_id: uuid_comparison_exp
  raised_by_type: String_comparison_exp
  resolution_notes: String_comparison_exp
  resolution_type: String_comparison_exp
  resolved_at: timestamptz_comparison_exp
  resolved_by_id: uuid_comparison_exp
  sponsor_id: String_comparison_exp
  status: String_comparison_exp
  tags: String_array_comparison_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
  userByAssignedMediatorId: auth_users_bool_exp
  userByRaisedById: auth_users_bool_exp
  userByResolvedById: auth_users_bool_exp
}

"""
unique or primary key constraints on table "disputes"
"""
enum disputes_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  disputes_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input disputes_delete_at_path_input {
  evidence_summary: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input disputes_delete_elem_input {
  evidence_summary: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input disputes_delete_key_input {
  evidence_summary: String
}

"""
input type for incrementing numeric columns in table "disputes"
"""
input disputes_inc_input {
  awarded_amount: numeric
  claimed_amount: numeric
}

"""
input type for inserting data into table "disputes"
"""
input disputes_insert_input {
  agency_id: uuid
  agency_placement: agency_placements_obj_rel_insert_input
  assigned_mediator_id: uuid
  assigned_mediator_name: String
  awarded_amount: numeric
  claimed_amount: numeric
  created_at: timestamptz
  currency: String
  description: String
  dispute_evidences: dispute_evidence_arr_rel_insert_input
  dispute_messages: dispute_messages_arr_rel_insert_input
  dispute_parties: dispute_parties_arr_rel_insert_input
  dispute_type: String
  evidence_summary: jsonb
  first_response_at: timestamptz
  id: uuid
  internal_notes: String
  last_activity_at: timestamptz
  maid_id: String
  placement_id: uuid
  priority: String
  raised_by_id: uuid
  raised_by_type: String
  resolution_notes: String
  resolution_type: String
  resolved_at: timestamptz
  resolved_by_id: uuid
  sponsor_id: String
  status: String
  tags: [String!]
  title: String
  updated_at: timestamptz
  user: auth_users_obj_rel_insert_input
  userByAssignedMediatorId: auth_users_obj_rel_insert_input
  userByRaisedById: auth_users_obj_rel_insert_input
  userByResolvedById: auth_users_obj_rel_insert_input
}

"""aggregate max on columns"""
type disputes_max_fields {
  agency_id: uuid
  assigned_mediator_id: uuid
  assigned_mediator_name: String
  awarded_amount: numeric
  claimed_amount: numeric
  created_at: timestamptz
  currency: String
  description: String
  dispute_type: String
  first_response_at: timestamptz
  id: uuid
  internal_notes: String
  last_activity_at: timestamptz
  maid_id: String
  placement_id: uuid
  priority: String
  raised_by_id: uuid
  raised_by_type: String
  resolution_notes: String
  resolution_type: String
  resolved_at: timestamptz
  resolved_by_id: uuid
  sponsor_id: String
  status: String
  tags: [String!]
  title: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "disputes"
"""
input disputes_max_order_by {
  agency_id: order_by
  assigned_mediator_id: order_by
  assigned_mediator_name: order_by
  awarded_amount: order_by
  claimed_amount: order_by
  created_at: order_by
  currency: order_by
  description: order_by
  dispute_type: order_by
  first_response_at: order_by
  id: order_by
  internal_notes: order_by
  last_activity_at: order_by
  maid_id: order_by
  placement_id: order_by
  priority: order_by
  raised_by_id: order_by
  raised_by_type: order_by
  resolution_notes: order_by
  resolution_type: order_by
  resolved_at: order_by
  resolved_by_id: order_by
  sponsor_id: order_by
  status: order_by
  tags: order_by
  title: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type disputes_min_fields {
  agency_id: uuid
  assigned_mediator_id: uuid
  assigned_mediator_name: String
  awarded_amount: numeric
  claimed_amount: numeric
  created_at: timestamptz
  currency: String
  description: String
  dispute_type: String
  first_response_at: timestamptz
  id: uuid
  internal_notes: String
  last_activity_at: timestamptz
  maid_id: String
  placement_id: uuid
  priority: String
  raised_by_id: uuid
  raised_by_type: String
  resolution_notes: String
  resolution_type: String
  resolved_at: timestamptz
  resolved_by_id: uuid
  sponsor_id: String
  status: String
  tags: [String!]
  title: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "disputes"
"""
input disputes_min_order_by {
  agency_id: order_by
  assigned_mediator_id: order_by
  assigned_mediator_name: order_by
  awarded_amount: order_by
  claimed_amount: order_by
  created_at: order_by
  currency: order_by
  description: order_by
  dispute_type: order_by
  first_response_at: order_by
  id: order_by
  internal_notes: order_by
  last_activity_at: order_by
  maid_id: order_by
  placement_id: order_by
  priority: order_by
  raised_by_id: order_by
  raised_by_type: order_by
  resolution_notes: order_by
  resolution_type: order_by
  resolved_at: order_by
  resolved_by_id: order_by
  sponsor_id: order_by
  status: order_by
  tags: order_by
  title: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "disputes"
"""
type disputes_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [disputes!]!
}

"""
input type for inserting object relation for remote table "disputes"
"""
input disputes_obj_rel_insert_input {
  data: disputes_insert_input!

  """upsert condition"""
  on_conflict: disputes_on_conflict
}

"""
on_conflict condition type for table "disputes"
"""
input disputes_on_conflict {
  constraint: disputes_constraint!
  update_columns: [disputes_update_column!]! = []
  where: disputes_bool_exp
}

"""Ordering options when selecting data from "disputes"."""
input disputes_order_by {
  agency_id: order_by
  agency_placement: agency_placements_order_by
  assigned_mediator_id: order_by
  assigned_mediator_name: order_by
  awarded_amount: order_by
  claimed_amount: order_by
  created_at: order_by
  currency: order_by
  description: order_by
  dispute_evidences_aggregate: dispute_evidence_aggregate_order_by
  dispute_messages_aggregate: dispute_messages_aggregate_order_by
  dispute_parties_aggregate: dispute_parties_aggregate_order_by
  dispute_type: order_by
  evidence_summary: order_by
  first_response_at: order_by
  id: order_by
  internal_notes: order_by
  last_activity_at: order_by
  maid_id: order_by
  placement_id: order_by
  priority: order_by
  raised_by_id: order_by
  raised_by_type: order_by
  resolution_notes: order_by
  resolution_type: order_by
  resolved_at: order_by
  resolved_by_id: order_by
  sponsor_id: order_by
  status: order_by
  tags: order_by
  title: order_by
  updated_at: order_by
  user: auth_users_order_by
  userByAssignedMediatorId: auth_users_order_by
  userByRaisedById: auth_users_order_by
  userByResolvedById: auth_users_order_by
}

"""primary key columns input for table: disputes"""
input disputes_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input disputes_prepend_input {
  evidence_summary: jsonb
}

"""
select columns of table "disputes"
"""
enum disputes_select_column {
  """column name"""
  agency_id

  """column name"""
  assigned_mediator_id

  """column name"""
  assigned_mediator_name

  """column name"""
  awarded_amount

  """column name"""
  claimed_amount

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  description

  """column name"""
  dispute_type

  """column name"""
  evidence_summary

  """column name"""
  first_response_at

  """column name"""
  id

  """column name"""
  internal_notes

  """column name"""
  last_activity_at

  """column name"""
  maid_id

  """column name"""
  placement_id

  """column name"""
  priority

  """column name"""
  raised_by_id

  """column name"""
  raised_by_type

  """column name"""
  resolution_notes

  """column name"""
  resolution_type

  """column name"""
  resolved_at

  """column name"""
  resolved_by_id

  """column name"""
  sponsor_id

  """column name"""
  status

  """column name"""
  tags

  """column name"""
  title

  """column name"""
  updated_at
}

"""
input type for updating data in table "disputes"
"""
input disputes_set_input {
  agency_id: uuid
  assigned_mediator_id: uuid
  assigned_mediator_name: String
  awarded_amount: numeric
  claimed_amount: numeric
  created_at: timestamptz
  currency: String
  description: String
  dispute_type: String
  evidence_summary: jsonb
  first_response_at: timestamptz
  id: uuid
  internal_notes: String
  last_activity_at: timestamptz
  maid_id: String
  placement_id: uuid
  priority: String
  raised_by_id: uuid
  raised_by_type: String
  resolution_notes: String
  resolution_type: String
  resolved_at: timestamptz
  resolved_by_id: uuid
  sponsor_id: String
  status: String
  tags: [String!]
  title: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type disputes_stddev_fields {
  awarded_amount: Float
  claimed_amount: Float
}

"""
order by stddev() on columns of table "disputes"
"""
input disputes_stddev_order_by {
  awarded_amount: order_by
  claimed_amount: order_by
}

"""aggregate stddev_pop on columns"""
type disputes_stddev_pop_fields {
  awarded_amount: Float
  claimed_amount: Float
}

"""
order by stddev_pop() on columns of table "disputes"
"""
input disputes_stddev_pop_order_by {
  awarded_amount: order_by
  claimed_amount: order_by
}

"""aggregate stddev_samp on columns"""
type disputes_stddev_samp_fields {
  awarded_amount: Float
  claimed_amount: Float
}

"""
order by stddev_samp() on columns of table "disputes"
"""
input disputes_stddev_samp_order_by {
  awarded_amount: order_by
  claimed_amount: order_by
}

"""
Streaming cursor of the table "disputes"
"""
input disputes_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: disputes_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input disputes_stream_cursor_value_input {
  agency_id: uuid
  assigned_mediator_id: uuid
  assigned_mediator_name: String
  awarded_amount: numeric
  claimed_amount: numeric
  created_at: timestamptz
  currency: String
  description: String
  dispute_type: String
  evidence_summary: jsonb
  first_response_at: timestamptz
  id: uuid
  internal_notes: String
  last_activity_at: timestamptz
  maid_id: String
  placement_id: uuid
  priority: String
  raised_by_id: uuid
  raised_by_type: String
  resolution_notes: String
  resolution_type: String
  resolved_at: timestamptz
  resolved_by_id: uuid
  sponsor_id: String
  status: String
  tags: [String!]
  title: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type disputes_sum_fields {
  awarded_amount: numeric
  claimed_amount: numeric
}

"""
order by sum() on columns of table "disputes"
"""
input disputes_sum_order_by {
  awarded_amount: order_by
  claimed_amount: order_by
}

"""
update columns of table "disputes"
"""
enum disputes_update_column {
  """column name"""
  agency_id

  """column name"""
  assigned_mediator_id

  """column name"""
  assigned_mediator_name

  """column name"""
  awarded_amount

  """column name"""
  claimed_amount

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  description

  """column name"""
  dispute_type

  """column name"""
  evidence_summary

  """column name"""
  first_response_at

  """column name"""
  id

  """column name"""
  internal_notes

  """column name"""
  last_activity_at

  """column name"""
  maid_id

  """column name"""
  placement_id

  """column name"""
  priority

  """column name"""
  raised_by_id

  """column name"""
  raised_by_type

  """column name"""
  resolution_notes

  """column name"""
  resolution_type

  """column name"""
  resolved_at

  """column name"""
  resolved_by_id

  """column name"""
  sponsor_id

  """column name"""
  status

  """column name"""
  tags

  """column name"""
  title

  """column name"""
  updated_at
}

input disputes_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: disputes_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: disputes_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: disputes_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: disputes_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: disputes_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: disputes_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: disputes_set_input

  """filter the rows which have to be updated"""
  where: disputes_bool_exp!
}

"""aggregate var_pop on columns"""
type disputes_var_pop_fields {
  awarded_amount: Float
  claimed_amount: Float
}

"""
order by var_pop() on columns of table "disputes"
"""
input disputes_var_pop_order_by {
  awarded_amount: order_by
  claimed_amount: order_by
}

"""aggregate var_samp on columns"""
type disputes_var_samp_fields {
  awarded_amount: Float
  claimed_amount: Float
}

"""
order by var_samp() on columns of table "disputes"
"""
input disputes_var_samp_order_by {
  awarded_amount: order_by
  claimed_amount: order_by
}

"""aggregate variance on columns"""
type disputes_variance_fields {
  awarded_amount: Float
  claimed_amount: Float
}

"""
order by variance() on columns of table "disputes"
"""
input disputes_variance_order_by {
  awarded_amount: order_by
  claimed_amount: order_by
}

scalar factor_status

"""
Boolean expression to compare columns of type "factor_status". All fields are combined with logical 'AND'.
"""
input factor_status_comparison_exp {
  _eq: factor_status
  _gt: factor_status
  _gte: factor_status
  _in: [factor_status!]
  _is_null: Boolean
  _lt: factor_status
  _lte: factor_status
  _neq: factor_status
  _nin: [factor_status!]
}

scalar factor_type

"""
Boolean expression to compare columns of type "factor_type". All fields are combined with logical 'AND'.
"""
input factor_type_comparison_exp {
  _eq: factor_type
  _gt: factor_type
  _gte: factor_type
  _in: [factor_type!]
  _is_null: Boolean
  _lt: factor_type
  _lte: factor_type
  _neq: factor_type
  _nin: [factor_type!]
}

"""
columns and relationships of "favorites"
"""
type favorites {
  created_at: timestamptz
  id: uuid!
  maid_id: String
  sponsor_id: String
}

"""
aggregated selection of "favorites"
"""
type favorites_aggregate {
  aggregate: favorites_aggregate_fields
  nodes: [favorites!]!
}

"""
aggregate fields of "favorites"
"""
type favorites_aggregate_fields {
  count(columns: [favorites_select_column!], distinct: Boolean): Int!
  max: favorites_max_fields
  min: favorites_min_fields
}

"""
Boolean expression to filter rows from the table "favorites". All fields are combined with a logical 'AND'.
"""
input favorites_bool_exp {
  _and: [favorites_bool_exp!]
  _not: favorites_bool_exp
  _or: [favorites_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  maid_id: String_comparison_exp
  sponsor_id: String_comparison_exp
}

"""
unique or primary key constraints on table "favorites"
"""
enum favorites_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  favorites_pkey

  """
  unique or primary key constraint on columns "maid_id", "sponsor_id"
  """
  favorites_sponsor_id_maid_id_key
}

"""
input type for inserting data into table "favorites"
"""
input favorites_insert_input {
  created_at: timestamptz
  id: uuid
  maid_id: String
  sponsor_id: String
}

"""aggregate max on columns"""
type favorites_max_fields {
  created_at: timestamptz
  id: uuid
  maid_id: String
  sponsor_id: String
}

"""aggregate min on columns"""
type favorites_min_fields {
  created_at: timestamptz
  id: uuid
  maid_id: String
  sponsor_id: String
}

"""
response of any mutation on the table "favorites"
"""
type favorites_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [favorites!]!
}

"""
on_conflict condition type for table "favorites"
"""
input favorites_on_conflict {
  constraint: favorites_constraint!
  update_columns: [favorites_update_column!]! = []
  where: favorites_bool_exp
}

"""Ordering options when selecting data from "favorites"."""
input favorites_order_by {
  created_at: order_by
  id: order_by
  maid_id: order_by
  sponsor_id: order_by
}

"""primary key columns input for table: favorites"""
input favorites_pk_columns_input {
  id: uuid!
}

"""
select columns of table "favorites"
"""
enum favorites_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  maid_id

  """column name"""
  sponsor_id
}

"""
input type for updating data in table "favorites"
"""
input favorites_set_input {
  created_at: timestamptz
  id: uuid
  maid_id: String
  sponsor_id: String
}

"""
Streaming cursor of the table "favorites"
"""
input favorites_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: favorites_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input favorites_stream_cursor_value_input {
  created_at: timestamptz
  id: uuid
  maid_id: String
  sponsor_id: String
}

"""
update columns of table "favorites"
"""
enum favorites_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  maid_id

  """column name"""
  sponsor_id
}

input favorites_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: favorites_set_input

  """filter the rows which have to be updated"""
  where: favorites_bool_exp!
}

input get_current_usage_args {
  p_user_id: uuid
}

scalar inet

"""
Boolean expression to compare columns of type "inet". All fields are combined with logical 'AND'.
"""
input inet_comparison_exp {
  _eq: inet
  _gt: inet
  _gte: inet
  _in: [inet!]
  _is_null: Boolean
  _lt: inet
  _lte: inet
  _neq: inet
  _nin: [inet!]
}

scalar interval

"""
Boolean expression to compare columns of type "interval". All fields are combined with logical 'AND'.
"""
input interval_comparison_exp {
  _eq: interval
  _gt: interval
  _gte: interval
  _in: [interval!]
  _is_null: Boolean
  _lt: interval
  _lte: interval
  _neq: interval
  _nin: [interval!]
}

"""
columns and relationships of "interview_notifications"
"""
type interview_notifications {
  created_at: timestamptz
  delivered_at: timestamptz
  failed_reason: String
  id: uuid!
  interview_id: uuid
  message_data(
    """JSON select path"""
    path: String
  ): jsonb
  message_text: String!
  notification_type: String!
  read_at: timestamptz
  recipient_email: String
  recipient_id: uuid
  recipient_phone: String
  recipient_type: String!
  retry_count: Int
  sent_at: timestamptz
  status: String
  updated_at: timestamptz

  """An object relationship"""
  video_interview: video_interviews
}

"""
aggregated selection of "interview_notifications"
"""
type interview_notifications_aggregate {
  aggregate: interview_notifications_aggregate_fields
  nodes: [interview_notifications!]!
}

input interview_notifications_aggregate_bool_exp {
  count: interview_notifications_aggregate_bool_exp_count
}

input interview_notifications_aggregate_bool_exp_count {
  arguments: [interview_notifications_select_column!]
  distinct: Boolean
  filter: interview_notifications_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "interview_notifications"
"""
type interview_notifications_aggregate_fields {
  avg: interview_notifications_avg_fields
  count(columns: [interview_notifications_select_column!], distinct: Boolean): Int!
  max: interview_notifications_max_fields
  min: interview_notifications_min_fields
  stddev: interview_notifications_stddev_fields
  stddev_pop: interview_notifications_stddev_pop_fields
  stddev_samp: interview_notifications_stddev_samp_fields
  sum: interview_notifications_sum_fields
  var_pop: interview_notifications_var_pop_fields
  var_samp: interview_notifications_var_samp_fields
  variance: interview_notifications_variance_fields
}

"""
order by aggregate values of table "interview_notifications"
"""
input interview_notifications_aggregate_order_by {
  avg: interview_notifications_avg_order_by
  count: order_by
  max: interview_notifications_max_order_by
  min: interview_notifications_min_order_by
  stddev: interview_notifications_stddev_order_by
  stddev_pop: interview_notifications_stddev_pop_order_by
  stddev_samp: interview_notifications_stddev_samp_order_by
  sum: interview_notifications_sum_order_by
  var_pop: interview_notifications_var_pop_order_by
  var_samp: interview_notifications_var_samp_order_by
  variance: interview_notifications_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input interview_notifications_append_input {
  message_data: jsonb
}

"""
input type for inserting array relation for remote table "interview_notifications"
"""
input interview_notifications_arr_rel_insert_input {
  data: [interview_notifications_insert_input!]!

  """upsert condition"""
  on_conflict: interview_notifications_on_conflict
}

"""aggregate avg on columns"""
type interview_notifications_avg_fields {
  retry_count: Float
}

"""
order by avg() on columns of table "interview_notifications"
"""
input interview_notifications_avg_order_by {
  retry_count: order_by
}

"""
Boolean expression to filter rows from the table "interview_notifications". All fields are combined with a logical 'AND'.
"""
input interview_notifications_bool_exp {
  _and: [interview_notifications_bool_exp!]
  _not: interview_notifications_bool_exp
  _or: [interview_notifications_bool_exp!]
  created_at: timestamptz_comparison_exp
  delivered_at: timestamptz_comparison_exp
  failed_reason: String_comparison_exp
  id: uuid_comparison_exp
  interview_id: uuid_comparison_exp
  message_data: jsonb_comparison_exp
  message_text: String_comparison_exp
  notification_type: String_comparison_exp
  read_at: timestamptz_comparison_exp
  recipient_email: String_comparison_exp
  recipient_id: uuid_comparison_exp
  recipient_phone: String_comparison_exp
  recipient_type: String_comparison_exp
  retry_count: Int_comparison_exp
  sent_at: timestamptz_comparison_exp
  status: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  video_interview: video_interviews_bool_exp
}

"""
unique or primary key constraints on table "interview_notifications"
"""
enum interview_notifications_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  interview_notifications_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input interview_notifications_delete_at_path_input {
  message_data: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input interview_notifications_delete_elem_input {
  message_data: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input interview_notifications_delete_key_input {
  message_data: String
}

"""
input type for incrementing numeric columns in table "interview_notifications"
"""
input interview_notifications_inc_input {
  retry_count: Int
}

"""
input type for inserting data into table "interview_notifications"
"""
input interview_notifications_insert_input {
  created_at: timestamptz
  delivered_at: timestamptz
  failed_reason: String
  id: uuid
  interview_id: uuid
  message_data: jsonb
  message_text: String
  notification_type: String
  read_at: timestamptz
  recipient_email: String
  recipient_id: uuid
  recipient_phone: String
  recipient_type: String
  retry_count: Int
  sent_at: timestamptz
  status: String
  updated_at: timestamptz
  video_interview: video_interviews_obj_rel_insert_input
}

"""aggregate max on columns"""
type interview_notifications_max_fields {
  created_at: timestamptz
  delivered_at: timestamptz
  failed_reason: String
  id: uuid
  interview_id: uuid
  message_text: String
  notification_type: String
  read_at: timestamptz
  recipient_email: String
  recipient_id: uuid
  recipient_phone: String
  recipient_type: String
  retry_count: Int
  sent_at: timestamptz
  status: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "interview_notifications"
"""
input interview_notifications_max_order_by {
  created_at: order_by
  delivered_at: order_by
  failed_reason: order_by
  id: order_by
  interview_id: order_by
  message_text: order_by
  notification_type: order_by
  read_at: order_by
  recipient_email: order_by
  recipient_id: order_by
  recipient_phone: order_by
  recipient_type: order_by
  retry_count: order_by
  sent_at: order_by
  status: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type interview_notifications_min_fields {
  created_at: timestamptz
  delivered_at: timestamptz
  failed_reason: String
  id: uuid
  interview_id: uuid
  message_text: String
  notification_type: String
  read_at: timestamptz
  recipient_email: String
  recipient_id: uuid
  recipient_phone: String
  recipient_type: String
  retry_count: Int
  sent_at: timestamptz
  status: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "interview_notifications"
"""
input interview_notifications_min_order_by {
  created_at: order_by
  delivered_at: order_by
  failed_reason: order_by
  id: order_by
  interview_id: order_by
  message_text: order_by
  notification_type: order_by
  read_at: order_by
  recipient_email: order_by
  recipient_id: order_by
  recipient_phone: order_by
  recipient_type: order_by
  retry_count: order_by
  sent_at: order_by
  status: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "interview_notifications"
"""
type interview_notifications_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [interview_notifications!]!
}

"""
on_conflict condition type for table "interview_notifications"
"""
input interview_notifications_on_conflict {
  constraint: interview_notifications_constraint!
  update_columns: [interview_notifications_update_column!]! = []
  where: interview_notifications_bool_exp
}

"""Ordering options when selecting data from "interview_notifications"."""
input interview_notifications_order_by {
  created_at: order_by
  delivered_at: order_by
  failed_reason: order_by
  id: order_by
  interview_id: order_by
  message_data: order_by
  message_text: order_by
  notification_type: order_by
  read_at: order_by
  recipient_email: order_by
  recipient_id: order_by
  recipient_phone: order_by
  recipient_type: order_by
  retry_count: order_by
  sent_at: order_by
  status: order_by
  updated_at: order_by
  video_interview: video_interviews_order_by
}

"""primary key columns input for table: interview_notifications"""
input interview_notifications_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input interview_notifications_prepend_input {
  message_data: jsonb
}

"""
select columns of table "interview_notifications"
"""
enum interview_notifications_select_column {
  """column name"""
  created_at

  """column name"""
  delivered_at

  """column name"""
  failed_reason

  """column name"""
  id

  """column name"""
  interview_id

  """column name"""
  message_data

  """column name"""
  message_text

  """column name"""
  notification_type

  """column name"""
  read_at

  """column name"""
  recipient_email

  """column name"""
  recipient_id

  """column name"""
  recipient_phone

  """column name"""
  recipient_type

  """column name"""
  retry_count

  """column name"""
  sent_at

  """column name"""
  status

  """column name"""
  updated_at
}

"""
input type for updating data in table "interview_notifications"
"""
input interview_notifications_set_input {
  created_at: timestamptz
  delivered_at: timestamptz
  failed_reason: String
  id: uuid
  interview_id: uuid
  message_data: jsonb
  message_text: String
  notification_type: String
  read_at: timestamptz
  recipient_email: String
  recipient_id: uuid
  recipient_phone: String
  recipient_type: String
  retry_count: Int
  sent_at: timestamptz
  status: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type interview_notifications_stddev_fields {
  retry_count: Float
}

"""
order by stddev() on columns of table "interview_notifications"
"""
input interview_notifications_stddev_order_by {
  retry_count: order_by
}

"""aggregate stddev_pop on columns"""
type interview_notifications_stddev_pop_fields {
  retry_count: Float
}

"""
order by stddev_pop() on columns of table "interview_notifications"
"""
input interview_notifications_stddev_pop_order_by {
  retry_count: order_by
}

"""aggregate stddev_samp on columns"""
type interview_notifications_stddev_samp_fields {
  retry_count: Float
}

"""
order by stddev_samp() on columns of table "interview_notifications"
"""
input interview_notifications_stddev_samp_order_by {
  retry_count: order_by
}

"""
Streaming cursor of the table "interview_notifications"
"""
input interview_notifications_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: interview_notifications_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input interview_notifications_stream_cursor_value_input {
  created_at: timestamptz
  delivered_at: timestamptz
  failed_reason: String
  id: uuid
  interview_id: uuid
  message_data: jsonb
  message_text: String
  notification_type: String
  read_at: timestamptz
  recipient_email: String
  recipient_id: uuid
  recipient_phone: String
  recipient_type: String
  retry_count: Int
  sent_at: timestamptz
  status: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type interview_notifications_sum_fields {
  retry_count: Int
}

"""
order by sum() on columns of table "interview_notifications"
"""
input interview_notifications_sum_order_by {
  retry_count: order_by
}

"""
update columns of table "interview_notifications"
"""
enum interview_notifications_update_column {
  """column name"""
  created_at

  """column name"""
  delivered_at

  """column name"""
  failed_reason

  """column name"""
  id

  """column name"""
  interview_id

  """column name"""
  message_data

  """column name"""
  message_text

  """column name"""
  notification_type

  """column name"""
  read_at

  """column name"""
  recipient_email

  """column name"""
  recipient_id

  """column name"""
  recipient_phone

  """column name"""
  recipient_type

  """column name"""
  retry_count

  """column name"""
  sent_at

  """column name"""
  status

  """column name"""
  updated_at
}

input interview_notifications_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: interview_notifications_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: interview_notifications_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: interview_notifications_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: interview_notifications_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: interview_notifications_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: interview_notifications_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: interview_notifications_set_input

  """filter the rows which have to be updated"""
  where: interview_notifications_bool_exp!
}

"""aggregate var_pop on columns"""
type interview_notifications_var_pop_fields {
  retry_count: Float
}

"""
order by var_pop() on columns of table "interview_notifications"
"""
input interview_notifications_var_pop_order_by {
  retry_count: order_by
}

"""aggregate var_samp on columns"""
type interview_notifications_var_samp_fields {
  retry_count: Float
}

"""
order by var_samp() on columns of table "interview_notifications"
"""
input interview_notifications_var_samp_order_by {
  retry_count: order_by
}

"""aggregate variance on columns"""
type interview_notifications_variance_fields {
  retry_count: Float
}

"""
order by variance() on columns of table "interview_notifications"
"""
input interview_notifications_variance_order_by {
  retry_count: order_by
}

"""
columns and relationships of "interview_platform_templates"
"""
type interview_platform_templates {
  created_at: timestamptz
  display_name: String!
  download_link: String
  id: uuid!
  maid_instructions: String
  platform_type: String!
  requires_download: Boolean
  setup_instructions: String
  sponsor_instructions: String
}

"""
aggregated selection of "interview_platform_templates"
"""
type interview_platform_templates_aggregate {
  aggregate: interview_platform_templates_aggregate_fields
  nodes: [interview_platform_templates!]!
}

"""
aggregate fields of "interview_platform_templates"
"""
type interview_platform_templates_aggregate_fields {
  count(columns: [interview_platform_templates_select_column!], distinct: Boolean): Int!
  max: interview_platform_templates_max_fields
  min: interview_platform_templates_min_fields
}

"""
Boolean expression to filter rows from the table "interview_platform_templates". All fields are combined with a logical 'AND'.
"""
input interview_platform_templates_bool_exp {
  _and: [interview_platform_templates_bool_exp!]
  _not: interview_platform_templates_bool_exp
  _or: [interview_platform_templates_bool_exp!]
  created_at: timestamptz_comparison_exp
  display_name: String_comparison_exp
  download_link: String_comparison_exp
  id: uuid_comparison_exp
  maid_instructions: String_comparison_exp
  platform_type: String_comparison_exp
  requires_download: Boolean_comparison_exp
  setup_instructions: String_comparison_exp
  sponsor_instructions: String_comparison_exp
}

"""
unique or primary key constraints on table "interview_platform_templates"
"""
enum interview_platform_templates_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  interview_platform_templates_pkey

  """
  unique or primary key constraint on columns "platform_type"
  """
  interview_platform_templates_platform_type_key
}

"""
input type for inserting data into table "interview_platform_templates"
"""
input interview_platform_templates_insert_input {
  created_at: timestamptz
  display_name: String
  download_link: String
  id: uuid
  maid_instructions: String
  platform_type: String
  requires_download: Boolean
  setup_instructions: String
  sponsor_instructions: String
}

"""aggregate max on columns"""
type interview_platform_templates_max_fields {
  created_at: timestamptz
  display_name: String
  download_link: String
  id: uuid
  maid_instructions: String
  platform_type: String
  setup_instructions: String
  sponsor_instructions: String
}

"""aggregate min on columns"""
type interview_platform_templates_min_fields {
  created_at: timestamptz
  display_name: String
  download_link: String
  id: uuid
  maid_instructions: String
  platform_type: String
  setup_instructions: String
  sponsor_instructions: String
}

"""
response of any mutation on the table "interview_platform_templates"
"""
type interview_platform_templates_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [interview_platform_templates!]!
}

"""
on_conflict condition type for table "interview_platform_templates"
"""
input interview_platform_templates_on_conflict {
  constraint: interview_platform_templates_constraint!
  update_columns: [interview_platform_templates_update_column!]! = []
  where: interview_platform_templates_bool_exp
}

"""
Ordering options when selecting data from "interview_platform_templates".
"""
input interview_platform_templates_order_by {
  created_at: order_by
  display_name: order_by
  download_link: order_by
  id: order_by
  maid_instructions: order_by
  platform_type: order_by
  requires_download: order_by
  setup_instructions: order_by
  sponsor_instructions: order_by
}

"""primary key columns input for table: interview_platform_templates"""
input interview_platform_templates_pk_columns_input {
  id: uuid!
}

"""
select columns of table "interview_platform_templates"
"""
enum interview_platform_templates_select_column {
  """column name"""
  created_at

  """column name"""
  display_name

  """column name"""
  download_link

  """column name"""
  id

  """column name"""
  maid_instructions

  """column name"""
  platform_type

  """column name"""
  requires_download

  """column name"""
  setup_instructions

  """column name"""
  sponsor_instructions
}

"""
input type for updating data in table "interview_platform_templates"
"""
input interview_platform_templates_set_input {
  created_at: timestamptz
  display_name: String
  download_link: String
  id: uuid
  maid_instructions: String
  platform_type: String
  requires_download: Boolean
  setup_instructions: String
  sponsor_instructions: String
}

"""
Streaming cursor of the table "interview_platform_templates"
"""
input interview_platform_templates_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: interview_platform_templates_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input interview_platform_templates_stream_cursor_value_input {
  created_at: timestamptz
  display_name: String
  download_link: String
  id: uuid
  maid_instructions: String
  platform_type: String
  requires_download: Boolean
  setup_instructions: String
  sponsor_instructions: String
}

"""
update columns of table "interview_platform_templates"
"""
enum interview_platform_templates_update_column {
  """column name"""
  created_at

  """column name"""
  display_name

  """column name"""
  download_link

  """column name"""
  id

  """column name"""
  maid_instructions

  """column name"""
  platform_type

  """column name"""
  requires_download

  """column name"""
  setup_instructions

  """column name"""
  sponsor_instructions
}

input interview_platform_templates_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: interview_platform_templates_set_input

  """filter the rows which have to be updated"""
  where: interview_platform_templates_bool_exp!
}

"""
columns and relationships of "job_applications"
"""
type job_applications {
  applied_at: timestamptz
  available_from: date
  cover_letter: String
  created_at: timestamptz
  expected_salary: Int
  id: uuid!
  job_id: uuid!
  maid_id: String
  notes: String
  status: String
  updated_at: timestamptz
}

"""
aggregated selection of "job_applications"
"""
type job_applications_aggregate {
  aggregate: job_applications_aggregate_fields
  nodes: [job_applications!]!
}

"""
aggregate fields of "job_applications"
"""
type job_applications_aggregate_fields {
  avg: job_applications_avg_fields
  count(columns: [job_applications_select_column!], distinct: Boolean): Int!
  max: job_applications_max_fields
  min: job_applications_min_fields
  stddev: job_applications_stddev_fields
  stddev_pop: job_applications_stddev_pop_fields
  stddev_samp: job_applications_stddev_samp_fields
  sum: job_applications_sum_fields
  var_pop: job_applications_var_pop_fields
  var_samp: job_applications_var_samp_fields
  variance: job_applications_variance_fields
}

"""aggregate avg on columns"""
type job_applications_avg_fields {
  expected_salary: Float
}

"""
Boolean expression to filter rows from the table "job_applications". All fields are combined with a logical 'AND'.
"""
input job_applications_bool_exp {
  _and: [job_applications_bool_exp!]
  _not: job_applications_bool_exp
  _or: [job_applications_bool_exp!]
  applied_at: timestamptz_comparison_exp
  available_from: date_comparison_exp
  cover_letter: String_comparison_exp
  created_at: timestamptz_comparison_exp
  expected_salary: Int_comparison_exp
  id: uuid_comparison_exp
  job_id: uuid_comparison_exp
  maid_id: String_comparison_exp
  notes: String_comparison_exp
  status: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "job_applications"
"""
enum job_applications_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  job_applications_pkey
}

"""
input type for incrementing numeric columns in table "job_applications"
"""
input job_applications_inc_input {
  expected_salary: Int
}

"""
input type for inserting data into table "job_applications"
"""
input job_applications_insert_input {
  applied_at: timestamptz
  available_from: date
  cover_letter: String
  created_at: timestamptz
  expected_salary: Int
  id: uuid
  job_id: uuid
  maid_id: String
  notes: String
  status: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type job_applications_max_fields {
  applied_at: timestamptz
  available_from: date
  cover_letter: String
  created_at: timestamptz
  expected_salary: Int
  id: uuid
  job_id: uuid
  maid_id: String
  notes: String
  status: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type job_applications_min_fields {
  applied_at: timestamptz
  available_from: date
  cover_letter: String
  created_at: timestamptz
  expected_salary: Int
  id: uuid
  job_id: uuid
  maid_id: String
  notes: String
  status: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "job_applications"
"""
type job_applications_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [job_applications!]!
}

"""
on_conflict condition type for table "job_applications"
"""
input job_applications_on_conflict {
  constraint: job_applications_constraint!
  update_columns: [job_applications_update_column!]! = []
  where: job_applications_bool_exp
}

"""Ordering options when selecting data from "job_applications"."""
input job_applications_order_by {
  applied_at: order_by
  available_from: order_by
  cover_letter: order_by
  created_at: order_by
  expected_salary: order_by
  id: order_by
  job_id: order_by
  maid_id: order_by
  notes: order_by
  status: order_by
  updated_at: order_by
}

"""primary key columns input for table: job_applications"""
input job_applications_pk_columns_input {
  id: uuid!
}

"""
select columns of table "job_applications"
"""
enum job_applications_select_column {
  """column name"""
  applied_at

  """column name"""
  available_from

  """column name"""
  cover_letter

  """column name"""
  created_at

  """column name"""
  expected_salary

  """column name"""
  id

  """column name"""
  job_id

  """column name"""
  maid_id

  """column name"""
  notes

  """column name"""
  status

  """column name"""
  updated_at
}

"""
input type for updating data in table "job_applications"
"""
input job_applications_set_input {
  applied_at: timestamptz
  available_from: date
  cover_letter: String
  created_at: timestamptz
  expected_salary: Int
  id: uuid
  job_id: uuid
  maid_id: String
  notes: String
  status: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type job_applications_stddev_fields {
  expected_salary: Float
}

"""aggregate stddev_pop on columns"""
type job_applications_stddev_pop_fields {
  expected_salary: Float
}

"""aggregate stddev_samp on columns"""
type job_applications_stddev_samp_fields {
  expected_salary: Float
}

"""
Streaming cursor of the table "job_applications"
"""
input job_applications_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: job_applications_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input job_applications_stream_cursor_value_input {
  applied_at: timestamptz
  available_from: date
  cover_letter: String
  created_at: timestamptz
  expected_salary: Int
  id: uuid
  job_id: uuid
  maid_id: String
  notes: String
  status: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type job_applications_sum_fields {
  expected_salary: Int
}

"""
update columns of table "job_applications"
"""
enum job_applications_update_column {
  """column name"""
  applied_at

  """column name"""
  available_from

  """column name"""
  cover_letter

  """column name"""
  created_at

  """column name"""
  expected_salary

  """column name"""
  id

  """column name"""
  job_id

  """column name"""
  maid_id

  """column name"""
  notes

  """column name"""
  status

  """column name"""
  updated_at
}

input job_applications_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: job_applications_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: job_applications_set_input

  """filter the rows which have to be updated"""
  where: job_applications_bool_exp!
}

"""aggregate var_pop on columns"""
type job_applications_var_pop_fields {
  expected_salary: Float
}

"""aggregate var_samp on columns"""
type job_applications_var_samp_fields {
  expected_salary: Float
}

"""aggregate variance on columns"""
type job_applications_variance_fields {
  expected_salary: Float
}

"""
columns and relationships of "job_postings"
"""
type job_postings {
  agency_id: uuid
  benefits: String
  created_at: timestamptz
  description: String
  expires_at: timestamptz
  id: uuid
  location: String
  requirements: String
  salary_max: numeric
  salary_min: numeric
  status: String
  title: String
  updated_at: timestamptz
}

"""
aggregated selection of "job_postings"
"""
type job_postings_aggregate {
  aggregate: job_postings_aggregate_fields
  nodes: [job_postings!]!
}

"""
aggregate fields of "job_postings"
"""
type job_postings_aggregate_fields {
  avg: job_postings_avg_fields
  count(columns: [job_postings_select_column!], distinct: Boolean): Int!
  max: job_postings_max_fields
  min: job_postings_min_fields
  stddev: job_postings_stddev_fields
  stddev_pop: job_postings_stddev_pop_fields
  stddev_samp: job_postings_stddev_samp_fields
  sum: job_postings_sum_fields
  var_pop: job_postings_var_pop_fields
  var_samp: job_postings_var_samp_fields
  variance: job_postings_variance_fields
}

"""aggregate avg on columns"""
type job_postings_avg_fields {
  salary_max: Float
  salary_min: Float
}

"""
Boolean expression to filter rows from the table "job_postings". All fields are combined with a logical 'AND'.
"""
input job_postings_bool_exp {
  _and: [job_postings_bool_exp!]
  _not: job_postings_bool_exp
  _or: [job_postings_bool_exp!]
  agency_id: uuid_comparison_exp
  benefits: String_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  expires_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  location: String_comparison_exp
  requirements: String_comparison_exp
  salary_max: numeric_comparison_exp
  salary_min: numeric_comparison_exp
  status: String_comparison_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
input type for incrementing numeric columns in table "job_postings"
"""
input job_postings_inc_input {
  salary_max: numeric
  salary_min: numeric
}

"""
input type for inserting data into table "job_postings"
"""
input job_postings_insert_input {
  agency_id: uuid
  benefits: String
  created_at: timestamptz
  description: String
  expires_at: timestamptz
  id: uuid
  location: String
  requirements: String
  salary_max: numeric
  salary_min: numeric
  status: String
  title: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type job_postings_max_fields {
  agency_id: uuid
  benefits: String
  created_at: timestamptz
  description: String
  expires_at: timestamptz
  id: uuid
  location: String
  requirements: String
  salary_max: numeric
  salary_min: numeric
  status: String
  title: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type job_postings_min_fields {
  agency_id: uuid
  benefits: String
  created_at: timestamptz
  description: String
  expires_at: timestamptz
  id: uuid
  location: String
  requirements: String
  salary_max: numeric
  salary_min: numeric
  status: String
  title: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "job_postings"
"""
type job_postings_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [job_postings!]!
}

"""Ordering options when selecting data from "job_postings"."""
input job_postings_order_by {
  agency_id: order_by
  benefits: order_by
  created_at: order_by
  description: order_by
  expires_at: order_by
  id: order_by
  location: order_by
  requirements: order_by
  salary_max: order_by
  salary_min: order_by
  status: order_by
  title: order_by
  updated_at: order_by
}

"""
select columns of table "job_postings"
"""
enum job_postings_select_column {
  """column name"""
  agency_id

  """column name"""
  benefits

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  expires_at

  """column name"""
  id

  """column name"""
  location

  """column name"""
  requirements

  """column name"""
  salary_max

  """column name"""
  salary_min

  """column name"""
  status

  """column name"""
  title

  """column name"""
  updated_at
}

"""
input type for updating data in table "job_postings"
"""
input job_postings_set_input {
  agency_id: uuid
  benefits: String
  created_at: timestamptz
  description: String
  expires_at: timestamptz
  id: uuid
  location: String
  requirements: String
  salary_max: numeric
  salary_min: numeric
  status: String
  title: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type job_postings_stddev_fields {
  salary_max: Float
  salary_min: Float
}

"""aggregate stddev_pop on columns"""
type job_postings_stddev_pop_fields {
  salary_max: Float
  salary_min: Float
}

"""aggregate stddev_samp on columns"""
type job_postings_stddev_samp_fields {
  salary_max: Float
  salary_min: Float
}

"""
Streaming cursor of the table "job_postings"
"""
input job_postings_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: job_postings_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input job_postings_stream_cursor_value_input {
  agency_id: uuid
  benefits: String
  created_at: timestamptz
  description: String
  expires_at: timestamptz
  id: uuid
  location: String
  requirements: String
  salary_max: numeric
  salary_min: numeric
  status: String
  title: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type job_postings_sum_fields {
  salary_max: numeric
  salary_min: numeric
}

input job_postings_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: job_postings_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: job_postings_set_input

  """filter the rows which have to be updated"""
  where: job_postings_bool_exp!
}

"""aggregate var_pop on columns"""
type job_postings_var_pop_fields {
  salary_max: Float
  salary_min: Float
}

"""aggregate var_samp on columns"""
type job_postings_var_samp_fields {
  salary_max: Float
  salary_min: Float
}

"""aggregate variance on columns"""
type job_postings_variance_fields {
  salary_max: Float
  salary_min: Float
}

"""
columns and relationships of "jobs"
"""
type jobs {
  accommodation: String
  address: String
  age_preference_max: Int
  age_preference_min: Int

  """An array relationship"""
  applications(
    """distinct select on columns"""
    distinct_on: [applications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [applications_order_by!]

    """filter the rows returned"""
    where: applications_bool_exp
  ): [applications!]!

  """An aggregate relationship"""
  applications_aggregate(
    """distinct select on columns"""
    distinct_on: [applications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [applications_order_by!]

    """filter the rows returned"""
    where: applications_bool_exp
  ): applications_aggregate!
  applications_count: Int
  auto_expire_days: Int
  benefits: [String!]

  """An array relationship"""
  bookings(
    """distinct select on columns"""
    distinct_on: [bookings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookings_order_by!]

    """filter the rows returned"""
    where: bookings_bool_exp
  ): [bookings!]!

  """An aggregate relationship"""
  bookings_aggregate(
    """distinct select on columns"""
    distinct_on: [bookings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookings_order_by!]

    """filter the rows returned"""
    where: bookings_bool_exp
  ): bookings_aggregate!
  city: String
  contract_duration: String
  contract_duration_months: Int
  country: String
  created_at: timestamptz
  currency: String
  days_off_per_week: Int
  description: String
  education_requirement: String
  employer: String
  end_date: date
  expires_at: timestamptz
  featured: Boolean
  featured_until: timestamptz
  id: uuid!
  job_type: String
  languages_required: [String!]
  live_in_required: Boolean
  location: String
  max_applications: Int
  minimum_experience_years: Int
  overtime_available: Boolean

  """An array relationship"""
  placement_fee_transactions(
    """distinct select on columns"""
    distinct_on: [placement_fee_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [placement_fee_transactions_order_by!]

    """filter the rows returned"""
    where: placement_fee_transactions_bool_exp
  ): [placement_fee_transactions!]!

  """An aggregate relationship"""
  placement_fee_transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [placement_fee_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [placement_fee_transactions_order_by!]

    """filter the rows returned"""
    where: placement_fee_transactions_bool_exp
  ): placement_fee_transactions_aggregate!
  preferred_nationality: [String!]
  probation_period_months: Int
  required_skills: [String!]
  requirements: [String!]
  requires_approval: Boolean
  salary_max: Int
  salary_min: Int
  salary_period: String
  service_type: [String!]

  """An array relationship"""
  shortlists(
    """distinct select on columns"""
    distinct_on: [shortlists_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shortlists_order_by!]

    """filter the rows returned"""
    where: shortlists_bool_exp
  ): [shortlists!]!

  """An aggregate relationship"""
  shortlists_aggregate(
    """distinct select on columns"""
    distinct_on: [shortlists_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shortlists_order_by!]

    """filter the rows returned"""
    where: shortlists_bool_exp
  ): shortlists_aggregate!
  sponsor_id: String

  """An array relationship"""
  sponsor_jobs(
    """distinct select on columns"""
    distinct_on: [sponsor_jobs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sponsor_jobs_order_by!]

    """filter the rows returned"""
    where: sponsor_jobs_bool_exp
  ): [sponsor_jobs!]!

  """An aggregate relationship"""
  sponsor_jobs_aggregate(
    """distinct select on columns"""
    distinct_on: [sponsor_jobs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sponsor_jobs_order_by!]

    """filter the rows returned"""
    where: sponsor_jobs_bool_exp
  ): sponsor_jobs_aggregate!

  """An object relationship"""
  sponsor_profile: sponsor_profiles
  start_date: date
  status: String!
  title: String!
  updated_at: timestamptz
  urgency_level: String
  urgent: Boolean
  views_count: Int
  visa_status_required: [String!]
  working_days_per_week: Int
  working_hours_per_day: Int
}

"""
aggregated selection of "jobs"
"""
type jobs_aggregate {
  aggregate: jobs_aggregate_fields
  nodes: [jobs!]!
}

"""
aggregate fields of "jobs"
"""
type jobs_aggregate_fields {
  avg: jobs_avg_fields
  count(columns: [jobs_select_column!], distinct: Boolean): Int!
  max: jobs_max_fields
  min: jobs_min_fields
  stddev: jobs_stddev_fields
  stddev_pop: jobs_stddev_pop_fields
  stddev_samp: jobs_stddev_samp_fields
  sum: jobs_sum_fields
  var_pop: jobs_var_pop_fields
  var_samp: jobs_var_samp_fields
  variance: jobs_variance_fields
}

"""aggregate avg on columns"""
type jobs_avg_fields {
  age_preference_max: Float
  age_preference_min: Float
  applications_count: Float
  auto_expire_days: Float
  contract_duration_months: Float
  days_off_per_week: Float
  max_applications: Float
  minimum_experience_years: Float
  probation_period_months: Float
  salary_max: Float
  salary_min: Float
  views_count: Float
  working_days_per_week: Float
  working_hours_per_day: Float
}

"""
Boolean expression to filter rows from the table "jobs". All fields are combined with a logical 'AND'.
"""
input jobs_bool_exp {
  _and: [jobs_bool_exp!]
  _not: jobs_bool_exp
  _or: [jobs_bool_exp!]
  accommodation: String_comparison_exp
  address: String_comparison_exp
  age_preference_max: Int_comparison_exp
  age_preference_min: Int_comparison_exp
  applications: applications_bool_exp
  applications_aggregate: applications_aggregate_bool_exp
  applications_count: Int_comparison_exp
  auto_expire_days: Int_comparison_exp
  benefits: String_array_comparison_exp
  bookings: bookings_bool_exp
  bookings_aggregate: bookings_aggregate_bool_exp
  city: String_comparison_exp
  contract_duration: String_comparison_exp
  contract_duration_months: Int_comparison_exp
  country: String_comparison_exp
  created_at: timestamptz_comparison_exp
  currency: String_comparison_exp
  days_off_per_week: Int_comparison_exp
  description: String_comparison_exp
  education_requirement: String_comparison_exp
  employer: String_comparison_exp
  end_date: date_comparison_exp
  expires_at: timestamptz_comparison_exp
  featured: Boolean_comparison_exp
  featured_until: timestamptz_comparison_exp
  id: uuid_comparison_exp
  job_type: String_comparison_exp
  languages_required: String_array_comparison_exp
  live_in_required: Boolean_comparison_exp
  location: String_comparison_exp
  max_applications: Int_comparison_exp
  minimum_experience_years: Int_comparison_exp
  overtime_available: Boolean_comparison_exp
  placement_fee_transactions: placement_fee_transactions_bool_exp
  placement_fee_transactions_aggregate: placement_fee_transactions_aggregate_bool_exp
  preferred_nationality: String_array_comparison_exp
  probation_period_months: Int_comparison_exp
  required_skills: String_array_comparison_exp
  requirements: String_array_comparison_exp
  requires_approval: Boolean_comparison_exp
  salary_max: Int_comparison_exp
  salary_min: Int_comparison_exp
  salary_period: String_comparison_exp
  service_type: String_array_comparison_exp
  shortlists: shortlists_bool_exp
  shortlists_aggregate: shortlists_aggregate_bool_exp
  sponsor_id: String_comparison_exp
  sponsor_jobs: sponsor_jobs_bool_exp
  sponsor_jobs_aggregate: sponsor_jobs_aggregate_bool_exp
  sponsor_profile: sponsor_profiles_bool_exp
  start_date: date_comparison_exp
  status: String_comparison_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  urgency_level: String_comparison_exp
  urgent: Boolean_comparison_exp
  views_count: Int_comparison_exp
  visa_status_required: String_array_comparison_exp
  working_days_per_week: Int_comparison_exp
  working_hours_per_day: Int_comparison_exp
}

"""
unique or primary key constraints on table "jobs"
"""
enum jobs_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  jobs_pkey
}

"""
input type for incrementing numeric columns in table "jobs"
"""
input jobs_inc_input {
  age_preference_max: Int
  age_preference_min: Int
  applications_count: Int
  auto_expire_days: Int
  contract_duration_months: Int
  days_off_per_week: Int
  max_applications: Int
  minimum_experience_years: Int
  probation_period_months: Int
  salary_max: Int
  salary_min: Int
  views_count: Int
  working_days_per_week: Int
  working_hours_per_day: Int
}

"""
input type for inserting data into table "jobs"
"""
input jobs_insert_input {
  accommodation: String
  address: String
  age_preference_max: Int
  age_preference_min: Int
  applications: applications_arr_rel_insert_input
  applications_count: Int
  auto_expire_days: Int
  benefits: [String!]
  bookings: bookings_arr_rel_insert_input
  city: String
  contract_duration: String
  contract_duration_months: Int
  country: String
  created_at: timestamptz
  currency: String
  days_off_per_week: Int
  description: String
  education_requirement: String
  employer: String
  end_date: date
  expires_at: timestamptz
  featured: Boolean
  featured_until: timestamptz
  id: uuid
  job_type: String
  languages_required: [String!]
  live_in_required: Boolean
  location: String
  max_applications: Int
  minimum_experience_years: Int
  overtime_available: Boolean
  placement_fee_transactions: placement_fee_transactions_arr_rel_insert_input
  preferred_nationality: [String!]
  probation_period_months: Int
  required_skills: [String!]
  requirements: [String!]
  requires_approval: Boolean
  salary_max: Int
  salary_min: Int
  salary_period: String
  service_type: [String!]
  shortlists: shortlists_arr_rel_insert_input
  sponsor_id: String
  sponsor_jobs: sponsor_jobs_arr_rel_insert_input
  sponsor_profile: sponsor_profiles_obj_rel_insert_input
  start_date: date
  status: String
  title: String
  updated_at: timestamptz
  urgency_level: String
  urgent: Boolean
  views_count: Int
  visa_status_required: [String!]
  working_days_per_week: Int
  working_hours_per_day: Int
}

"""aggregate max on columns"""
type jobs_max_fields {
  accommodation: String
  address: String
  age_preference_max: Int
  age_preference_min: Int
  applications_count: Int
  auto_expire_days: Int
  benefits: [String!]
  city: String
  contract_duration: String
  contract_duration_months: Int
  country: String
  created_at: timestamptz
  currency: String
  days_off_per_week: Int
  description: String
  education_requirement: String
  employer: String
  end_date: date
  expires_at: timestamptz
  featured_until: timestamptz
  id: uuid
  job_type: String
  languages_required: [String!]
  location: String
  max_applications: Int
  minimum_experience_years: Int
  preferred_nationality: [String!]
  probation_period_months: Int
  required_skills: [String!]
  requirements: [String!]
  salary_max: Int
  salary_min: Int
  salary_period: String
  service_type: [String!]
  sponsor_id: String
  start_date: date
  status: String
  title: String
  updated_at: timestamptz
  urgency_level: String
  views_count: Int
  visa_status_required: [String!]
  working_days_per_week: Int
  working_hours_per_day: Int
}

"""aggregate min on columns"""
type jobs_min_fields {
  accommodation: String
  address: String
  age_preference_max: Int
  age_preference_min: Int
  applications_count: Int
  auto_expire_days: Int
  benefits: [String!]
  city: String
  contract_duration: String
  contract_duration_months: Int
  country: String
  created_at: timestamptz
  currency: String
  days_off_per_week: Int
  description: String
  education_requirement: String
  employer: String
  end_date: date
  expires_at: timestamptz
  featured_until: timestamptz
  id: uuid
  job_type: String
  languages_required: [String!]
  location: String
  max_applications: Int
  minimum_experience_years: Int
  preferred_nationality: [String!]
  probation_period_months: Int
  required_skills: [String!]
  requirements: [String!]
  salary_max: Int
  salary_min: Int
  salary_period: String
  service_type: [String!]
  sponsor_id: String
  start_date: date
  status: String
  title: String
  updated_at: timestamptz
  urgency_level: String
  views_count: Int
  visa_status_required: [String!]
  working_days_per_week: Int
  working_hours_per_day: Int
}

"""
response of any mutation on the table "jobs"
"""
type jobs_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [jobs!]!
}

"""
input type for inserting object relation for remote table "jobs"
"""
input jobs_obj_rel_insert_input {
  data: jobs_insert_input!

  """upsert condition"""
  on_conflict: jobs_on_conflict
}

"""
on_conflict condition type for table "jobs"
"""
input jobs_on_conflict {
  constraint: jobs_constraint!
  update_columns: [jobs_update_column!]! = []
  where: jobs_bool_exp
}

"""Ordering options when selecting data from "jobs"."""
input jobs_order_by {
  accommodation: order_by
  address: order_by
  age_preference_max: order_by
  age_preference_min: order_by
  applications_aggregate: applications_aggregate_order_by
  applications_count: order_by
  auto_expire_days: order_by
  benefits: order_by
  bookings_aggregate: bookings_aggregate_order_by
  city: order_by
  contract_duration: order_by
  contract_duration_months: order_by
  country: order_by
  created_at: order_by
  currency: order_by
  days_off_per_week: order_by
  description: order_by
  education_requirement: order_by
  employer: order_by
  end_date: order_by
  expires_at: order_by
  featured: order_by
  featured_until: order_by
  id: order_by
  job_type: order_by
  languages_required: order_by
  live_in_required: order_by
  location: order_by
  max_applications: order_by
  minimum_experience_years: order_by
  overtime_available: order_by
  placement_fee_transactions_aggregate: placement_fee_transactions_aggregate_order_by
  preferred_nationality: order_by
  probation_period_months: order_by
  required_skills: order_by
  requirements: order_by
  requires_approval: order_by
  salary_max: order_by
  salary_min: order_by
  salary_period: order_by
  service_type: order_by
  shortlists_aggregate: shortlists_aggregate_order_by
  sponsor_id: order_by
  sponsor_jobs_aggregate: sponsor_jobs_aggregate_order_by
  sponsor_profile: sponsor_profiles_order_by
  start_date: order_by
  status: order_by
  title: order_by
  updated_at: order_by
  urgency_level: order_by
  urgent: order_by
  views_count: order_by
  visa_status_required: order_by
  working_days_per_week: order_by
  working_hours_per_day: order_by
}

"""primary key columns input for table: jobs"""
input jobs_pk_columns_input {
  id: uuid!
}

"""
select columns of table "jobs"
"""
enum jobs_select_column {
  """column name"""
  accommodation

  """column name"""
  address

  """column name"""
  age_preference_max

  """column name"""
  age_preference_min

  """column name"""
  applications_count

  """column name"""
  auto_expire_days

  """column name"""
  benefits

  """column name"""
  city

  """column name"""
  contract_duration

  """column name"""
  contract_duration_months

  """column name"""
  country

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  days_off_per_week

  """column name"""
  description

  """column name"""
  education_requirement

  """column name"""
  employer

  """column name"""
  end_date

  """column name"""
  expires_at

  """column name"""
  featured

  """column name"""
  featured_until

  """column name"""
  id

  """column name"""
  job_type

  """column name"""
  languages_required

  """column name"""
  live_in_required

  """column name"""
  location

  """column name"""
  max_applications

  """column name"""
  minimum_experience_years

  """column name"""
  overtime_available

  """column name"""
  preferred_nationality

  """column name"""
  probation_period_months

  """column name"""
  required_skills

  """column name"""
  requirements

  """column name"""
  requires_approval

  """column name"""
  salary_max

  """column name"""
  salary_min

  """column name"""
  salary_period

  """column name"""
  service_type

  """column name"""
  sponsor_id

  """column name"""
  start_date

  """column name"""
  status

  """column name"""
  title

  """column name"""
  updated_at

  """column name"""
  urgency_level

  """column name"""
  urgent

  """column name"""
  views_count

  """column name"""
  visa_status_required

  """column name"""
  working_days_per_week

  """column name"""
  working_hours_per_day
}

"""
input type for updating data in table "jobs"
"""
input jobs_set_input {
  accommodation: String
  address: String
  age_preference_max: Int
  age_preference_min: Int
  applications_count: Int
  auto_expire_days: Int
  benefits: [String!]
  city: String
  contract_duration: String
  contract_duration_months: Int
  country: String
  created_at: timestamptz
  currency: String
  days_off_per_week: Int
  description: String
  education_requirement: String
  employer: String
  end_date: date
  expires_at: timestamptz
  featured: Boolean
  featured_until: timestamptz
  id: uuid
  job_type: String
  languages_required: [String!]
  live_in_required: Boolean
  location: String
  max_applications: Int
  minimum_experience_years: Int
  overtime_available: Boolean
  preferred_nationality: [String!]
  probation_period_months: Int
  required_skills: [String!]
  requirements: [String!]
  requires_approval: Boolean
  salary_max: Int
  salary_min: Int
  salary_period: String
  service_type: [String!]
  sponsor_id: String
  start_date: date
  status: String
  title: String
  updated_at: timestamptz
  urgency_level: String
  urgent: Boolean
  views_count: Int
  visa_status_required: [String!]
  working_days_per_week: Int
  working_hours_per_day: Int
}

"""aggregate stddev on columns"""
type jobs_stddev_fields {
  age_preference_max: Float
  age_preference_min: Float
  applications_count: Float
  auto_expire_days: Float
  contract_duration_months: Float
  days_off_per_week: Float
  max_applications: Float
  minimum_experience_years: Float
  probation_period_months: Float
  salary_max: Float
  salary_min: Float
  views_count: Float
  working_days_per_week: Float
  working_hours_per_day: Float
}

"""aggregate stddev_pop on columns"""
type jobs_stddev_pop_fields {
  age_preference_max: Float
  age_preference_min: Float
  applications_count: Float
  auto_expire_days: Float
  contract_duration_months: Float
  days_off_per_week: Float
  max_applications: Float
  minimum_experience_years: Float
  probation_period_months: Float
  salary_max: Float
  salary_min: Float
  views_count: Float
  working_days_per_week: Float
  working_hours_per_day: Float
}

"""aggregate stddev_samp on columns"""
type jobs_stddev_samp_fields {
  age_preference_max: Float
  age_preference_min: Float
  applications_count: Float
  auto_expire_days: Float
  contract_duration_months: Float
  days_off_per_week: Float
  max_applications: Float
  minimum_experience_years: Float
  probation_period_months: Float
  salary_max: Float
  salary_min: Float
  views_count: Float
  working_days_per_week: Float
  working_hours_per_day: Float
}

"""
Streaming cursor of the table "jobs"
"""
input jobs_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: jobs_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input jobs_stream_cursor_value_input {
  accommodation: String
  address: String
  age_preference_max: Int
  age_preference_min: Int
  applications_count: Int
  auto_expire_days: Int
  benefits: [String!]
  city: String
  contract_duration: String
  contract_duration_months: Int
  country: String
  created_at: timestamptz
  currency: String
  days_off_per_week: Int
  description: String
  education_requirement: String
  employer: String
  end_date: date
  expires_at: timestamptz
  featured: Boolean
  featured_until: timestamptz
  id: uuid
  job_type: String
  languages_required: [String!]
  live_in_required: Boolean
  location: String
  max_applications: Int
  minimum_experience_years: Int
  overtime_available: Boolean
  preferred_nationality: [String!]
  probation_period_months: Int
  required_skills: [String!]
  requirements: [String!]
  requires_approval: Boolean
  salary_max: Int
  salary_min: Int
  salary_period: String
  service_type: [String!]
  sponsor_id: String
  start_date: date
  status: String
  title: String
  updated_at: timestamptz
  urgency_level: String
  urgent: Boolean
  views_count: Int
  visa_status_required: [String!]
  working_days_per_week: Int
  working_hours_per_day: Int
}

"""aggregate sum on columns"""
type jobs_sum_fields {
  age_preference_max: Int
  age_preference_min: Int
  applications_count: Int
  auto_expire_days: Int
  contract_duration_months: Int
  days_off_per_week: Int
  max_applications: Int
  minimum_experience_years: Int
  probation_period_months: Int
  salary_max: Int
  salary_min: Int
  views_count: Int
  working_days_per_week: Int
  working_hours_per_day: Int
}

"""
update columns of table "jobs"
"""
enum jobs_update_column {
  """column name"""
  accommodation

  """column name"""
  address

  """column name"""
  age_preference_max

  """column name"""
  age_preference_min

  """column name"""
  applications_count

  """column name"""
  auto_expire_days

  """column name"""
  benefits

  """column name"""
  city

  """column name"""
  contract_duration

  """column name"""
  contract_duration_months

  """column name"""
  country

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  days_off_per_week

  """column name"""
  description

  """column name"""
  education_requirement

  """column name"""
  employer

  """column name"""
  end_date

  """column name"""
  expires_at

  """column name"""
  featured

  """column name"""
  featured_until

  """column name"""
  id

  """column name"""
  job_type

  """column name"""
  languages_required

  """column name"""
  live_in_required

  """column name"""
  location

  """column name"""
  max_applications

  """column name"""
  minimum_experience_years

  """column name"""
  overtime_available

  """column name"""
  preferred_nationality

  """column name"""
  probation_period_months

  """column name"""
  required_skills

  """column name"""
  requirements

  """column name"""
  requires_approval

  """column name"""
  salary_max

  """column name"""
  salary_min

  """column name"""
  salary_period

  """column name"""
  service_type

  """column name"""
  sponsor_id

  """column name"""
  start_date

  """column name"""
  status

  """column name"""
  title

  """column name"""
  updated_at

  """column name"""
  urgency_level

  """column name"""
  urgent

  """column name"""
  views_count

  """column name"""
  visa_status_required

  """column name"""
  working_days_per_week

  """column name"""
  working_hours_per_day
}

input jobs_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: jobs_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: jobs_set_input

  """filter the rows which have to be updated"""
  where: jobs_bool_exp!
}

"""aggregate var_pop on columns"""
type jobs_var_pop_fields {
  age_preference_max: Float
  age_preference_min: Float
  applications_count: Float
  auto_expire_days: Float
  contract_duration_months: Float
  days_off_per_week: Float
  max_applications: Float
  minimum_experience_years: Float
  probation_period_months: Float
  salary_max: Float
  salary_min: Float
  views_count: Float
  working_days_per_week: Float
  working_hours_per_day: Float
}

"""aggregate var_samp on columns"""
type jobs_var_samp_fields {
  age_preference_max: Float
  age_preference_min: Float
  applications_count: Float
  auto_expire_days: Float
  contract_duration_months: Float
  days_off_per_week: Float
  max_applications: Float
  minimum_experience_years: Float
  probation_period_months: Float
  salary_max: Float
  salary_min: Float
  views_count: Float
  working_days_per_week: Float
  working_hours_per_day: Float
}

"""aggregate variance on columns"""
type jobs_variance_fields {
  age_preference_max: Float
  age_preference_min: Float
  applications_count: Float
  auto_expire_days: Float
  contract_duration_months: Float
  days_off_per_week: Float
  max_applications: Float
  minimum_experience_years: Float
  probation_period_months: Float
  salary_max: Float
  salary_min: Float
  views_count: Float
  working_days_per_week: Float
  working_hours_per_day: Float
}

scalar json

"""
Boolean expression to compare columns of type "json". All fields are combined with logical 'AND'.
"""
input json_comparison_exp {
  _eq: json
  _gt: json
  _gte: json
  _in: [json!]
  _is_null: Boolean
  _lt: json
  _lte: json
  _neq: json
  _nin: [json!]
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
Stores maid booking requests including interviews, hires, and replacements
"""
type maid_bookings {
  booking_date: timestamptz

  """Type: interview, hire, replacement, or inquiry"""
  booking_type: String
  created_at: timestamptz
  id: uuid!

  """References maids table, nullable"""
  maid_id: String
  maid_name: String

  """Flexible JSONB field for storing additional booking data"""
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  notes: String
  phone_number: String!

  """Foreign key to profiles table for authenticated sponsors"""
  sponsor_id: uuid
  sponsor_name: String

  """Status: pending, confirmed, cancelled, completed, or rescheduled"""
  status: String
  updated_at: timestamptz

  """An array relationship"""
  video_interviews(
    """distinct select on columns"""
    distinct_on: [video_interviews_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [video_interviews_order_by!]

    """filter the rows returned"""
    where: video_interviews_bool_exp
  ): [video_interviews!]!

  """An aggregate relationship"""
  video_interviews_aggregate(
    """distinct select on columns"""
    distinct_on: [video_interviews_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [video_interviews_order_by!]

    """filter the rows returned"""
    where: video_interviews_bool_exp
  ): video_interviews_aggregate!
}

"""
aggregated selection of "maid_bookings"
"""
type maid_bookings_aggregate {
  aggregate: maid_bookings_aggregate_fields
  nodes: [maid_bookings!]!
}

"""
aggregate fields of "maid_bookings"
"""
type maid_bookings_aggregate_fields {
  count(columns: [maid_bookings_select_column!], distinct: Boolean): Int!
  max: maid_bookings_max_fields
  min: maid_bookings_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input maid_bookings_append_input {
  """Flexible JSONB field for storing additional booking data"""
  metadata: jsonb
}

"""
Boolean expression to filter rows from the table "maid_bookings". All fields are combined with a logical 'AND'.
"""
input maid_bookings_bool_exp {
  _and: [maid_bookings_bool_exp!]
  _not: maid_bookings_bool_exp
  _or: [maid_bookings_bool_exp!]
  booking_date: timestamptz_comparison_exp
  booking_type: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  maid_id: String_comparison_exp
  maid_name: String_comparison_exp
  metadata: jsonb_comparison_exp
  notes: String_comparison_exp
  phone_number: String_comparison_exp
  sponsor_id: uuid_comparison_exp
  sponsor_name: String_comparison_exp
  status: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  video_interviews: video_interviews_bool_exp
  video_interviews_aggregate: video_interviews_aggregate_bool_exp
}

"""
unique or primary key constraints on table "maid_bookings"
"""
enum maid_bookings_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  maid_bookings_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input maid_bookings_delete_at_path_input {
  """Flexible JSONB field for storing additional booking data"""
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input maid_bookings_delete_elem_input {
  """Flexible JSONB field for storing additional booking data"""
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input maid_bookings_delete_key_input {
  """Flexible JSONB field for storing additional booking data"""
  metadata: String
}

"""
input type for inserting data into table "maid_bookings"
"""
input maid_bookings_insert_input {
  booking_date: timestamptz

  """Type: interview, hire, replacement, or inquiry"""
  booking_type: String
  created_at: timestamptz
  id: uuid

  """References maids table, nullable"""
  maid_id: String
  maid_name: String

  """Flexible JSONB field for storing additional booking data"""
  metadata: jsonb
  notes: String
  phone_number: String

  """Foreign key to profiles table for authenticated sponsors"""
  sponsor_id: uuid
  sponsor_name: String

  """Status: pending, confirmed, cancelled, completed, or rescheduled"""
  status: String
  updated_at: timestamptz
  video_interviews: video_interviews_arr_rel_insert_input
}

"""aggregate max on columns"""
type maid_bookings_max_fields {
  booking_date: timestamptz

  """Type: interview, hire, replacement, or inquiry"""
  booking_type: String
  created_at: timestamptz
  id: uuid

  """References maids table, nullable"""
  maid_id: String
  maid_name: String
  notes: String
  phone_number: String

  """Foreign key to profiles table for authenticated sponsors"""
  sponsor_id: uuid
  sponsor_name: String

  """Status: pending, confirmed, cancelled, completed, or rescheduled"""
  status: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type maid_bookings_min_fields {
  booking_date: timestamptz

  """Type: interview, hire, replacement, or inquiry"""
  booking_type: String
  created_at: timestamptz
  id: uuid

  """References maids table, nullable"""
  maid_id: String
  maid_name: String
  notes: String
  phone_number: String

  """Foreign key to profiles table for authenticated sponsors"""
  sponsor_id: uuid
  sponsor_name: String

  """Status: pending, confirmed, cancelled, completed, or rescheduled"""
  status: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "maid_bookings"
"""
type maid_bookings_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [maid_bookings!]!
}

"""
input type for inserting object relation for remote table "maid_bookings"
"""
input maid_bookings_obj_rel_insert_input {
  data: maid_bookings_insert_input!

  """upsert condition"""
  on_conflict: maid_bookings_on_conflict
}

"""
on_conflict condition type for table "maid_bookings"
"""
input maid_bookings_on_conflict {
  constraint: maid_bookings_constraint!
  update_columns: [maid_bookings_update_column!]! = []
  where: maid_bookings_bool_exp
}

"""Ordering options when selecting data from "maid_bookings"."""
input maid_bookings_order_by {
  booking_date: order_by
  booking_type: order_by
  created_at: order_by
  id: order_by
  maid_id: order_by
  maid_name: order_by
  metadata: order_by
  notes: order_by
  phone_number: order_by
  sponsor_id: order_by
  sponsor_name: order_by
  status: order_by
  updated_at: order_by
  video_interviews_aggregate: video_interviews_aggregate_order_by
}

"""primary key columns input for table: maid_bookings"""
input maid_bookings_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input maid_bookings_prepend_input {
  """Flexible JSONB field for storing additional booking data"""
  metadata: jsonb
}

"""
select columns of table "maid_bookings"
"""
enum maid_bookings_select_column {
  """column name"""
  booking_date

  """column name"""
  booking_type

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  maid_id

  """column name"""
  maid_name

  """column name"""
  metadata

  """column name"""
  notes

  """column name"""
  phone_number

  """column name"""
  sponsor_id

  """column name"""
  sponsor_name

  """column name"""
  status

  """column name"""
  updated_at
}

"""
input type for updating data in table "maid_bookings"
"""
input maid_bookings_set_input {
  booking_date: timestamptz

  """Type: interview, hire, replacement, or inquiry"""
  booking_type: String
  created_at: timestamptz
  id: uuid

  """References maids table, nullable"""
  maid_id: String
  maid_name: String

  """Flexible JSONB field for storing additional booking data"""
  metadata: jsonb
  notes: String
  phone_number: String

  """Foreign key to profiles table for authenticated sponsors"""
  sponsor_id: uuid
  sponsor_name: String

  """Status: pending, confirmed, cancelled, completed, or rescheduled"""
  status: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "maid_bookings"
"""
input maid_bookings_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: maid_bookings_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input maid_bookings_stream_cursor_value_input {
  booking_date: timestamptz

  """Type: interview, hire, replacement, or inquiry"""
  booking_type: String
  created_at: timestamptz
  id: uuid

  """References maids table, nullable"""
  maid_id: String
  maid_name: String

  """Flexible JSONB field for storing additional booking data"""
  metadata: jsonb
  notes: String
  phone_number: String

  """Foreign key to profiles table for authenticated sponsors"""
  sponsor_id: uuid
  sponsor_name: String

  """Status: pending, confirmed, cancelled, completed, or rescheduled"""
  status: String
  updated_at: timestamptz
}

"""
update columns of table "maid_bookings"
"""
enum maid_bookings_update_column {
  """column name"""
  booking_date

  """column name"""
  booking_type

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  maid_id

  """column name"""
  maid_name

  """column name"""
  metadata

  """column name"""
  notes

  """column name"""
  phone_number

  """column name"""
  sponsor_id

  """column name"""
  sponsor_name

  """column name"""
  status

  """column name"""
  updated_at
}

input maid_bookings_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: maid_bookings_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: maid_bookings_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: maid_bookings_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: maid_bookings_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: maid_bookings_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: maid_bookings_set_input

  """filter the rows which have to be updated"""
  where: maid_bookings_bool_exp!
}

"""
columns and relationships of "maid_documents"
"""
type maid_documents {
  created_at: timestamptz
  custom_type_name: String
  description: String
  document_name: String
  document_type: String!
  document_url: String!
  expiry_date: date
  file_name: String
  file_path: String
  file_size: bigint
  file_url: String
  id: uuid!
  maid_id: String
  mime_type: String
  title: String
  type: String
  updated_at: timestamptz
  uploaded_at: timestamptz
  verified: Boolean
}

"""
aggregated selection of "maid_documents"
"""
type maid_documents_aggregate {
  aggregate: maid_documents_aggregate_fields
  nodes: [maid_documents!]!
}

"""
aggregate fields of "maid_documents"
"""
type maid_documents_aggregate_fields {
  avg: maid_documents_avg_fields
  count(columns: [maid_documents_select_column!], distinct: Boolean): Int!
  max: maid_documents_max_fields
  min: maid_documents_min_fields
  stddev: maid_documents_stddev_fields
  stddev_pop: maid_documents_stddev_pop_fields
  stddev_samp: maid_documents_stddev_samp_fields
  sum: maid_documents_sum_fields
  var_pop: maid_documents_var_pop_fields
  var_samp: maid_documents_var_samp_fields
  variance: maid_documents_variance_fields
}

"""aggregate avg on columns"""
type maid_documents_avg_fields {
  file_size: Float
}

"""
Boolean expression to filter rows from the table "maid_documents". All fields are combined with a logical 'AND'.
"""
input maid_documents_bool_exp {
  _and: [maid_documents_bool_exp!]
  _not: maid_documents_bool_exp
  _or: [maid_documents_bool_exp!]
  created_at: timestamptz_comparison_exp
  custom_type_name: String_comparison_exp
  description: String_comparison_exp
  document_name: String_comparison_exp
  document_type: String_comparison_exp
  document_url: String_comparison_exp
  expiry_date: date_comparison_exp
  file_name: String_comparison_exp
  file_path: String_comparison_exp
  file_size: bigint_comparison_exp
  file_url: String_comparison_exp
  id: uuid_comparison_exp
  maid_id: String_comparison_exp
  mime_type: String_comparison_exp
  title: String_comparison_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  uploaded_at: timestamptz_comparison_exp
  verified: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "maid_documents"
"""
enum maid_documents_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  maid_documents_pkey
}

"""
input type for incrementing numeric columns in table "maid_documents"
"""
input maid_documents_inc_input {
  file_size: bigint
}

"""
input type for inserting data into table "maid_documents"
"""
input maid_documents_insert_input {
  created_at: timestamptz
  custom_type_name: String
  description: String
  document_name: String
  document_type: String
  document_url: String
  expiry_date: date
  file_name: String
  file_path: String
  file_size: bigint
  file_url: String
  id: uuid
  maid_id: String
  mime_type: String
  title: String
  type: String
  updated_at: timestamptz
  uploaded_at: timestamptz
  verified: Boolean
}

"""aggregate max on columns"""
type maid_documents_max_fields {
  created_at: timestamptz
  custom_type_name: String
  description: String
  document_name: String
  document_type: String
  document_url: String
  expiry_date: date
  file_name: String
  file_path: String
  file_size: bigint
  file_url: String
  id: uuid
  maid_id: String
  mime_type: String
  title: String
  type: String
  updated_at: timestamptz
  uploaded_at: timestamptz
}

"""aggregate min on columns"""
type maid_documents_min_fields {
  created_at: timestamptz
  custom_type_name: String
  description: String
  document_name: String
  document_type: String
  document_url: String
  expiry_date: date
  file_name: String
  file_path: String
  file_size: bigint
  file_url: String
  id: uuid
  maid_id: String
  mime_type: String
  title: String
  type: String
  updated_at: timestamptz
  uploaded_at: timestamptz
}

"""
response of any mutation on the table "maid_documents"
"""
type maid_documents_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [maid_documents!]!
}

"""
on_conflict condition type for table "maid_documents"
"""
input maid_documents_on_conflict {
  constraint: maid_documents_constraint!
  update_columns: [maid_documents_update_column!]! = []
  where: maid_documents_bool_exp
}

"""Ordering options when selecting data from "maid_documents"."""
input maid_documents_order_by {
  created_at: order_by
  custom_type_name: order_by
  description: order_by
  document_name: order_by
  document_type: order_by
  document_url: order_by
  expiry_date: order_by
  file_name: order_by
  file_path: order_by
  file_size: order_by
  file_url: order_by
  id: order_by
  maid_id: order_by
  mime_type: order_by
  title: order_by
  type: order_by
  updated_at: order_by
  uploaded_at: order_by
  verified: order_by
}

"""primary key columns input for table: maid_documents"""
input maid_documents_pk_columns_input {
  id: uuid!
}

"""
select columns of table "maid_documents"
"""
enum maid_documents_select_column {
  """column name"""
  created_at

  """column name"""
  custom_type_name

  """column name"""
  description

  """column name"""
  document_name

  """column name"""
  document_type

  """column name"""
  document_url

  """column name"""
  expiry_date

  """column name"""
  file_name

  """column name"""
  file_path

  """column name"""
  file_size

  """column name"""
  file_url

  """column name"""
  id

  """column name"""
  maid_id

  """column name"""
  mime_type

  """column name"""
  title

  """column name"""
  type

  """column name"""
  updated_at

  """column name"""
  uploaded_at

  """column name"""
  verified
}

"""
input type for updating data in table "maid_documents"
"""
input maid_documents_set_input {
  created_at: timestamptz
  custom_type_name: String
  description: String
  document_name: String
  document_type: String
  document_url: String
  expiry_date: date
  file_name: String
  file_path: String
  file_size: bigint
  file_url: String
  id: uuid
  maid_id: String
  mime_type: String
  title: String
  type: String
  updated_at: timestamptz
  uploaded_at: timestamptz
  verified: Boolean
}

"""aggregate stddev on columns"""
type maid_documents_stddev_fields {
  file_size: Float
}

"""aggregate stddev_pop on columns"""
type maid_documents_stddev_pop_fields {
  file_size: Float
}

"""aggregate stddev_samp on columns"""
type maid_documents_stddev_samp_fields {
  file_size: Float
}

"""
Streaming cursor of the table "maid_documents"
"""
input maid_documents_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: maid_documents_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input maid_documents_stream_cursor_value_input {
  created_at: timestamptz
  custom_type_name: String
  description: String
  document_name: String
  document_type: String
  document_url: String
  expiry_date: date
  file_name: String
  file_path: String
  file_size: bigint
  file_url: String
  id: uuid
  maid_id: String
  mime_type: String
  title: String
  type: String
  updated_at: timestamptz
  uploaded_at: timestamptz
  verified: Boolean
}

"""aggregate sum on columns"""
type maid_documents_sum_fields {
  file_size: bigint
}

"""
update columns of table "maid_documents"
"""
enum maid_documents_update_column {
  """column name"""
  created_at

  """column name"""
  custom_type_name

  """column name"""
  description

  """column name"""
  document_name

  """column name"""
  document_type

  """column name"""
  document_url

  """column name"""
  expiry_date

  """column name"""
  file_name

  """column name"""
  file_path

  """column name"""
  file_size

  """column name"""
  file_url

  """column name"""
  id

  """column name"""
  maid_id

  """column name"""
  mime_type

  """column name"""
  title

  """column name"""
  type

  """column name"""
  updated_at

  """column name"""
  uploaded_at

  """column name"""
  verified
}

input maid_documents_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: maid_documents_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: maid_documents_set_input

  """filter the rows which have to be updated"""
  where: maid_documents_bool_exp!
}

"""aggregate var_pop on columns"""
type maid_documents_var_pop_fields {
  file_size: Float
}

"""aggregate var_samp on columns"""
type maid_documents_var_samp_fields {
  file_size: Float
}

"""aggregate variance on columns"""
type maid_documents_variance_fields {
  file_size: Float
}

"""
columns and relationships of "maid_images"
"""
type maid_images {
  created_at: timestamptz
  display_order: Int
  file_name: String
  file_path: String
  file_size: Int
  file_url: String!
  id: uuid!
  is_primary: Boolean
  is_processed: Boolean
  maid_id: uuid
  mime_type: String
  updated_at: timestamptz
}

"""
aggregated selection of "maid_images"
"""
type maid_images_aggregate {
  aggregate: maid_images_aggregate_fields
  nodes: [maid_images!]!
}

"""
aggregate fields of "maid_images"
"""
type maid_images_aggregate_fields {
  avg: maid_images_avg_fields
  count(columns: [maid_images_select_column!], distinct: Boolean): Int!
  max: maid_images_max_fields
  min: maid_images_min_fields
  stddev: maid_images_stddev_fields
  stddev_pop: maid_images_stddev_pop_fields
  stddev_samp: maid_images_stddev_samp_fields
  sum: maid_images_sum_fields
  var_pop: maid_images_var_pop_fields
  var_samp: maid_images_var_samp_fields
  variance: maid_images_variance_fields
}

"""aggregate avg on columns"""
type maid_images_avg_fields {
  display_order: Float
  file_size: Float
}

"""
Boolean expression to filter rows from the table "maid_images". All fields are combined with a logical 'AND'.
"""
input maid_images_bool_exp {
  _and: [maid_images_bool_exp!]
  _not: maid_images_bool_exp
  _or: [maid_images_bool_exp!]
  created_at: timestamptz_comparison_exp
  display_order: Int_comparison_exp
  file_name: String_comparison_exp
  file_path: String_comparison_exp
  file_size: Int_comparison_exp
  file_url: String_comparison_exp
  id: uuid_comparison_exp
  is_primary: Boolean_comparison_exp
  is_processed: Boolean_comparison_exp
  maid_id: uuid_comparison_exp
  mime_type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "maid_images"
"""
enum maid_images_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  maid_images_pkey
}

"""
input type for incrementing numeric columns in table "maid_images"
"""
input maid_images_inc_input {
  display_order: Int
  file_size: Int
}

"""
input type for inserting data into table "maid_images"
"""
input maid_images_insert_input {
  created_at: timestamptz
  display_order: Int
  file_name: String
  file_path: String
  file_size: Int
  file_url: String
  id: uuid
  is_primary: Boolean
  is_processed: Boolean
  maid_id: uuid
  mime_type: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type maid_images_max_fields {
  created_at: timestamptz
  display_order: Int
  file_name: String
  file_path: String
  file_size: Int
  file_url: String
  id: uuid
  maid_id: uuid
  mime_type: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type maid_images_min_fields {
  created_at: timestamptz
  display_order: Int
  file_name: String
  file_path: String
  file_size: Int
  file_url: String
  id: uuid
  maid_id: uuid
  mime_type: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "maid_images"
"""
type maid_images_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [maid_images!]!
}

"""
on_conflict condition type for table "maid_images"
"""
input maid_images_on_conflict {
  constraint: maid_images_constraint!
  update_columns: [maid_images_update_column!]! = []
  where: maid_images_bool_exp
}

"""Ordering options when selecting data from "maid_images"."""
input maid_images_order_by {
  created_at: order_by
  display_order: order_by
  file_name: order_by
  file_path: order_by
  file_size: order_by
  file_url: order_by
  id: order_by
  is_primary: order_by
  is_processed: order_by
  maid_id: order_by
  mime_type: order_by
  updated_at: order_by
}

"""primary key columns input for table: maid_images"""
input maid_images_pk_columns_input {
  id: uuid!
}

"""
select columns of table "maid_images"
"""
enum maid_images_select_column {
  """column name"""
  created_at

  """column name"""
  display_order

  """column name"""
  file_name

  """column name"""
  file_path

  """column name"""
  file_size

  """column name"""
  file_url

  """column name"""
  id

  """column name"""
  is_primary

  """column name"""
  is_processed

  """column name"""
  maid_id

  """column name"""
  mime_type

  """column name"""
  updated_at
}

"""
input type for updating data in table "maid_images"
"""
input maid_images_set_input {
  created_at: timestamptz
  display_order: Int
  file_name: String
  file_path: String
  file_size: Int
  file_url: String
  id: uuid
  is_primary: Boolean
  is_processed: Boolean
  maid_id: uuid
  mime_type: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type maid_images_stddev_fields {
  display_order: Float
  file_size: Float
}

"""aggregate stddev_pop on columns"""
type maid_images_stddev_pop_fields {
  display_order: Float
  file_size: Float
}

"""aggregate stddev_samp on columns"""
type maid_images_stddev_samp_fields {
  display_order: Float
  file_size: Float
}

"""
Streaming cursor of the table "maid_images"
"""
input maid_images_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: maid_images_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input maid_images_stream_cursor_value_input {
  created_at: timestamptz
  display_order: Int
  file_name: String
  file_path: String
  file_size: Int
  file_url: String
  id: uuid
  is_primary: Boolean
  is_processed: Boolean
  maid_id: uuid
  mime_type: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type maid_images_sum_fields {
  display_order: Int
  file_size: Int
}

"""
update columns of table "maid_images"
"""
enum maid_images_update_column {
  """column name"""
  created_at

  """column name"""
  display_order

  """column name"""
  file_name

  """column name"""
  file_path

  """column name"""
  file_size

  """column name"""
  file_url

  """column name"""
  id

  """column name"""
  is_primary

  """column name"""
  is_processed

  """column name"""
  maid_id

  """column name"""
  mime_type

  """column name"""
  updated_at
}

input maid_images_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: maid_images_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: maid_images_set_input

  """filter the rows which have to be updated"""
  where: maid_images_bool_exp!
}

"""aggregate var_pop on columns"""
type maid_images_var_pop_fields {
  display_order: Float
  file_size: Float
}

"""aggregate var_samp on columns"""
type maid_images_var_samp_fields {
  display_order: Float
  file_size: Float
}

"""aggregate variance on columns"""
type maid_images_variance_fields {
  display_order: Float
  file_size: Float
}

"""
columns and relationships of "maid_profiles"
"""
type maid_profiles {
  about_me: String
  additional_notes: String
  additional_services: [String!]
  agency_badge: Boolean

  """References agency profiles.id when is_agency_managed is true"""
  agency_id: String
  alternative_phone: String
  availability_status: String
  available_from: date
  average_rating: numeric
  bank_account_encrypted: String
  bank_account_hash: String
  children_count: Int
  contract_duration_preference: String
  country: String
  created_at: timestamptz
  current_location: String
  current_visa_status: String
  current_visa_status_other: String
  date_of_birth: date
  education_level: String
  emergency_contact_phone_encrypted: String
  emergency_contact_phone_hash: String
  experience_years: Int
  first_name: String
  full_name: String
  id: String!
  image_processing_metadata(
    """JSON select path"""
    path: String
  ): jsonb

  """URL to the maid introduction video CV (max 1 minute)"""
  introduction_video_url: String

  """True if maid profile is managed by an agency (no auth account)"""
  is_agency_managed: Boolean
  is_approved: Boolean
  iso_country_code: String
  key_responsibilities: [String!]
  languages: [String!]
  last_name: String
  live_in_preference: Boolean
  marital_status: String
  medical_certificate_valid: Boolean
  medical_info_encrypted: String
  middle_name: String
  national_id_encrypted: String
  national_id_hash: String
  nationality: String
  passport_expiry: date
  passport_number: String
  passport_number_encrypted: String
  passport_number_hash: String
  phone_country_code: String
  phone_number: String
  phone_verified: Boolean
  phone_verified_at: timestamptz
  police_clearance_valid: Boolean
  preferred_currency: String
  preferred_salary_max: Int
  preferred_salary_min: Int
  previous_countries: [String!]
  previous_employer_contact_encrypted: String
  primary_image_original_url: String
  primary_image_processed: Boolean
  primary_image_processed_url: String
  primary_profession: String
  primary_profession_other: String
  profile_completion_percentage: Int
  profile_photo_url: String
  profile_views: Int
  religion: String
  religion_other: String
  skills: [String!]
  special_skills: [String!]
  state_province: String
  street_address: String
  suburb: String
  successful_placements: Int
  total_applications: Int
  two_factor_enabled: Boolean
  two_factor_method: String
  updated_at: timestamptz

  """References profiles.id for self-registered maids only"""
  user_id: String
  verification_status: String

  """Duration of the introduction video in seconds"""
  video_duration: Int
  visa_status: String
  work_history(
    """JSON select path"""
    path: String
  ): jsonb
  work_preferences: [String!]
}

"""
aggregated selection of "maid_profiles"
"""
type maid_profiles_aggregate {
  aggregate: maid_profiles_aggregate_fields
  nodes: [maid_profiles!]!
}

"""
aggregate fields of "maid_profiles"
"""
type maid_profiles_aggregate_fields {
  avg: maid_profiles_avg_fields
  count(columns: [maid_profiles_select_column!], distinct: Boolean): Int!
  max: maid_profiles_max_fields
  min: maid_profiles_min_fields
  stddev: maid_profiles_stddev_fields
  stddev_pop: maid_profiles_stddev_pop_fields
  stddev_samp: maid_profiles_stddev_samp_fields
  sum: maid_profiles_sum_fields
  var_pop: maid_profiles_var_pop_fields
  var_samp: maid_profiles_var_samp_fields
  variance: maid_profiles_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input maid_profiles_append_input {
  image_processing_metadata: jsonb
  work_history: jsonb
}

"""aggregate avg on columns"""
type maid_profiles_avg_fields {
  average_rating: Float
  children_count: Float
  experience_years: Float
  preferred_salary_max: Float
  preferred_salary_min: Float
  profile_completion_percentage: Float
  profile_views: Float
  successful_placements: Float
  total_applications: Float

  """Duration of the introduction video in seconds"""
  video_duration: Float
}

"""
Boolean expression to filter rows from the table "maid_profiles". All fields are combined with a logical 'AND'.
"""
input maid_profiles_bool_exp {
  _and: [maid_profiles_bool_exp!]
  _not: maid_profiles_bool_exp
  _or: [maid_profiles_bool_exp!]
  about_me: String_comparison_exp
  additional_notes: String_comparison_exp
  additional_services: String_array_comparison_exp
  agency_badge: Boolean_comparison_exp
  agency_id: String_comparison_exp
  alternative_phone: String_comparison_exp
  availability_status: String_comparison_exp
  available_from: date_comparison_exp
  average_rating: numeric_comparison_exp
  bank_account_encrypted: String_comparison_exp
  bank_account_hash: String_comparison_exp
  children_count: Int_comparison_exp
  contract_duration_preference: String_comparison_exp
  country: String_comparison_exp
  created_at: timestamptz_comparison_exp
  current_location: String_comparison_exp
  current_visa_status: String_comparison_exp
  current_visa_status_other: String_comparison_exp
  date_of_birth: date_comparison_exp
  education_level: String_comparison_exp
  emergency_contact_phone_encrypted: String_comparison_exp
  emergency_contact_phone_hash: String_comparison_exp
  experience_years: Int_comparison_exp
  first_name: String_comparison_exp
  full_name: String_comparison_exp
  id: String_comparison_exp
  image_processing_metadata: jsonb_comparison_exp
  introduction_video_url: String_comparison_exp
  is_agency_managed: Boolean_comparison_exp
  is_approved: Boolean_comparison_exp
  iso_country_code: String_comparison_exp
  key_responsibilities: String_array_comparison_exp
  languages: String_array_comparison_exp
  last_name: String_comparison_exp
  live_in_preference: Boolean_comparison_exp
  marital_status: String_comparison_exp
  medical_certificate_valid: Boolean_comparison_exp
  medical_info_encrypted: String_comparison_exp
  middle_name: String_comparison_exp
  national_id_encrypted: String_comparison_exp
  national_id_hash: String_comparison_exp
  nationality: String_comparison_exp
  passport_expiry: date_comparison_exp
  passport_number: String_comparison_exp
  passport_number_encrypted: String_comparison_exp
  passport_number_hash: String_comparison_exp
  phone_country_code: String_comparison_exp
  phone_number: String_comparison_exp
  phone_verified: Boolean_comparison_exp
  phone_verified_at: timestamptz_comparison_exp
  police_clearance_valid: Boolean_comparison_exp
  preferred_currency: String_comparison_exp
  preferred_salary_max: Int_comparison_exp
  preferred_salary_min: Int_comparison_exp
  previous_countries: String_array_comparison_exp
  previous_employer_contact_encrypted: String_comparison_exp
  primary_image_original_url: String_comparison_exp
  primary_image_processed: Boolean_comparison_exp
  primary_image_processed_url: String_comparison_exp
  primary_profession: String_comparison_exp
  primary_profession_other: String_comparison_exp
  profile_completion_percentage: Int_comparison_exp
  profile_photo_url: String_comparison_exp
  profile_views: Int_comparison_exp
  religion: String_comparison_exp
  religion_other: String_comparison_exp
  skills: String_array_comparison_exp
  special_skills: String_array_comparison_exp
  state_province: String_comparison_exp
  street_address: String_comparison_exp
  suburb: String_comparison_exp
  successful_placements: Int_comparison_exp
  total_applications: Int_comparison_exp
  two_factor_enabled: Boolean_comparison_exp
  two_factor_method: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
  verification_status: String_comparison_exp
  video_duration: Int_comparison_exp
  visa_status: String_comparison_exp
  work_history: jsonb_comparison_exp
  work_preferences: String_array_comparison_exp
}

"""
unique or primary key constraints on table "maid_profiles"
"""
enum maid_profiles_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  maid_profiles_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input maid_profiles_delete_at_path_input {
  image_processing_metadata: [String!]
  work_history: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input maid_profiles_delete_elem_input {
  image_processing_metadata: Int
  work_history: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input maid_profiles_delete_key_input {
  image_processing_metadata: String
  work_history: String
}

"""
input type for incrementing numeric columns in table "maid_profiles"
"""
input maid_profiles_inc_input {
  average_rating: numeric
  children_count: Int
  experience_years: Int
  preferred_salary_max: Int
  preferred_salary_min: Int
  profile_completion_percentage: Int
  profile_views: Int
  successful_placements: Int
  total_applications: Int

  """Duration of the introduction video in seconds"""
  video_duration: Int
}

"""
input type for inserting data into table "maid_profiles"
"""
input maid_profiles_insert_input {
  about_me: String
  additional_notes: String
  additional_services: [String!]

  """References agency profiles.id when is_agency_managed is true"""
  agency_id: String
  alternative_phone: String
  availability_status: String
  available_from: date
  average_rating: numeric
  bank_account_encrypted: String
  bank_account_hash: String
  children_count: Int
  contract_duration_preference: String
  country: String
  created_at: timestamptz
  current_location: String
  current_visa_status: String
  current_visa_status_other: String
  date_of_birth: date
  education_level: String
  emergency_contact_phone_encrypted: String
  emergency_contact_phone_hash: String
  experience_years: Int
  first_name: String
  full_name: String
  id: String
  image_processing_metadata: jsonb

  """URL to the maid introduction video CV (max 1 minute)"""
  introduction_video_url: String

  """True if maid profile is managed by an agency (no auth account)"""
  is_agency_managed: Boolean
  is_approved: Boolean
  iso_country_code: String
  key_responsibilities: [String!]
  languages: [String!]
  last_name: String
  live_in_preference: Boolean
  marital_status: String
  medical_certificate_valid: Boolean
  medical_info_encrypted: String
  middle_name: String
  national_id_encrypted: String
  national_id_hash: String
  nationality: String
  passport_expiry: date
  passport_number: String
  passport_number_encrypted: String
  passport_number_hash: String
  phone_country_code: String
  phone_number: String
  phone_verified: Boolean
  phone_verified_at: timestamptz
  police_clearance_valid: Boolean
  preferred_currency: String
  preferred_salary_max: Int
  preferred_salary_min: Int
  previous_countries: [String!]
  previous_employer_contact_encrypted: String
  primary_image_original_url: String
  primary_image_processed: Boolean
  primary_image_processed_url: String
  primary_profession: String
  primary_profession_other: String
  profile_completion_percentage: Int
  profile_photo_url: String
  profile_views: Int
  religion: String
  religion_other: String
  skills: [String!]
  special_skills: [String!]
  state_province: String
  street_address: String
  suburb: String
  successful_placements: Int
  total_applications: Int
  two_factor_enabled: Boolean
  two_factor_method: String
  updated_at: timestamptz

  """References profiles.id for self-registered maids only"""
  user_id: String
  verification_status: String

  """Duration of the introduction video in seconds"""
  video_duration: Int
  visa_status: String
  work_history: jsonb
  work_preferences: [String!]
}

"""aggregate max on columns"""
type maid_profiles_max_fields {
  about_me: String
  additional_notes: String
  additional_services: [String!]

  """References agency profiles.id when is_agency_managed is true"""
  agency_id: String
  alternative_phone: String
  availability_status: String
  available_from: date
  average_rating: numeric
  bank_account_encrypted: String
  bank_account_hash: String
  children_count: Int
  contract_duration_preference: String
  country: String
  created_at: timestamptz
  current_location: String
  current_visa_status: String
  current_visa_status_other: String
  date_of_birth: date
  education_level: String
  emergency_contact_phone_encrypted: String
  emergency_contact_phone_hash: String
  experience_years: Int
  first_name: String
  full_name: String
  id: String

  """URL to the maid introduction video CV (max 1 minute)"""
  introduction_video_url: String
  iso_country_code: String
  key_responsibilities: [String!]
  languages: [String!]
  last_name: String
  marital_status: String
  medical_info_encrypted: String
  middle_name: String
  national_id_encrypted: String
  national_id_hash: String
  nationality: String
  passport_expiry: date
  passport_number: String
  passport_number_encrypted: String
  passport_number_hash: String
  phone_country_code: String
  phone_number: String
  phone_verified_at: timestamptz
  preferred_currency: String
  preferred_salary_max: Int
  preferred_salary_min: Int
  previous_countries: [String!]
  previous_employer_contact_encrypted: String
  primary_image_original_url: String
  primary_image_processed_url: String
  primary_profession: String
  primary_profession_other: String
  profile_completion_percentage: Int
  profile_photo_url: String
  profile_views: Int
  religion: String
  religion_other: String
  skills: [String!]
  special_skills: [String!]
  state_province: String
  street_address: String
  suburb: String
  successful_placements: Int
  total_applications: Int
  two_factor_method: String
  updated_at: timestamptz

  """References profiles.id for self-registered maids only"""
  user_id: String
  verification_status: String

  """Duration of the introduction video in seconds"""
  video_duration: Int
  visa_status: String
  work_preferences: [String!]
}

"""aggregate min on columns"""
type maid_profiles_min_fields {
  about_me: String
  additional_notes: String
  additional_services: [String!]

  """References agency profiles.id when is_agency_managed is true"""
  agency_id: String
  alternative_phone: String
  availability_status: String
  available_from: date
  average_rating: numeric
  bank_account_encrypted: String
  bank_account_hash: String
  children_count: Int
  contract_duration_preference: String
  country: String
  created_at: timestamptz
  current_location: String
  current_visa_status: String
  current_visa_status_other: String
  date_of_birth: date
  education_level: String
  emergency_contact_phone_encrypted: String
  emergency_contact_phone_hash: String
  experience_years: Int
  first_name: String
  full_name: String
  id: String

  """URL to the maid introduction video CV (max 1 minute)"""
  introduction_video_url: String
  iso_country_code: String
  key_responsibilities: [String!]
  languages: [String!]
  last_name: String
  marital_status: String
  medical_info_encrypted: String
  middle_name: String
  national_id_encrypted: String
  national_id_hash: String
  nationality: String
  passport_expiry: date
  passport_number: String
  passport_number_encrypted: String
  passport_number_hash: String
  phone_country_code: String
  phone_number: String
  phone_verified_at: timestamptz
  preferred_currency: String
  preferred_salary_max: Int
  preferred_salary_min: Int
  previous_countries: [String!]
  previous_employer_contact_encrypted: String
  primary_image_original_url: String
  primary_image_processed_url: String
  primary_profession: String
  primary_profession_other: String
  profile_completion_percentage: Int
  profile_photo_url: String
  profile_views: Int
  religion: String
  religion_other: String
  skills: [String!]
  special_skills: [String!]
  state_province: String
  street_address: String
  suburb: String
  successful_placements: Int
  total_applications: Int
  two_factor_method: String
  updated_at: timestamptz

  """References profiles.id for self-registered maids only"""
  user_id: String
  verification_status: String

  """Duration of the introduction video in seconds"""
  video_duration: Int
  visa_status: String
  work_preferences: [String!]
}

"""
response of any mutation on the table "maid_profiles"
"""
type maid_profiles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [maid_profiles!]!
}

"""
input type for inserting object relation for remote table "maid_profiles"
"""
input maid_profiles_obj_rel_insert_input {
  data: maid_profiles_insert_input!

  """upsert condition"""
  on_conflict: maid_profiles_on_conflict
}

"""
on_conflict condition type for table "maid_profiles"
"""
input maid_profiles_on_conflict {
  constraint: maid_profiles_constraint!
  update_columns: [maid_profiles_update_column!]! = []
  where: maid_profiles_bool_exp
}

"""Ordering options when selecting data from "maid_profiles"."""
input maid_profiles_order_by {
  about_me: order_by
  additional_notes: order_by
  additional_services: order_by
  agency_badge: order_by
  agency_id: order_by
  alternative_phone: order_by
  availability_status: order_by
  available_from: order_by
  average_rating: order_by
  bank_account_encrypted: order_by
  bank_account_hash: order_by
  children_count: order_by
  contract_duration_preference: order_by
  country: order_by
  created_at: order_by
  current_location: order_by
  current_visa_status: order_by
  current_visa_status_other: order_by
  date_of_birth: order_by
  education_level: order_by
  emergency_contact_phone_encrypted: order_by
  emergency_contact_phone_hash: order_by
  experience_years: order_by
  first_name: order_by
  full_name: order_by
  id: order_by
  image_processing_metadata: order_by
  introduction_video_url: order_by
  is_agency_managed: order_by
  is_approved: order_by
  iso_country_code: order_by
  key_responsibilities: order_by
  languages: order_by
  last_name: order_by
  live_in_preference: order_by
  marital_status: order_by
  medical_certificate_valid: order_by
  medical_info_encrypted: order_by
  middle_name: order_by
  national_id_encrypted: order_by
  national_id_hash: order_by
  nationality: order_by
  passport_expiry: order_by
  passport_number: order_by
  passport_number_encrypted: order_by
  passport_number_hash: order_by
  phone_country_code: order_by
  phone_number: order_by
  phone_verified: order_by
  phone_verified_at: order_by
  police_clearance_valid: order_by
  preferred_currency: order_by
  preferred_salary_max: order_by
  preferred_salary_min: order_by
  previous_countries: order_by
  previous_employer_contact_encrypted: order_by
  primary_image_original_url: order_by
  primary_image_processed: order_by
  primary_image_processed_url: order_by
  primary_profession: order_by
  primary_profession_other: order_by
  profile_completion_percentage: order_by
  profile_photo_url: order_by
  profile_views: order_by
  religion: order_by
  religion_other: order_by
  skills: order_by
  special_skills: order_by
  state_province: order_by
  street_address: order_by
  suburb: order_by
  successful_placements: order_by
  total_applications: order_by
  two_factor_enabled: order_by
  two_factor_method: order_by
  updated_at: order_by
  user_id: order_by
  verification_status: order_by
  video_duration: order_by
  visa_status: order_by
  work_history: order_by
  work_preferences: order_by
}

"""primary key columns input for table: maid_profiles"""
input maid_profiles_pk_columns_input {
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input maid_profiles_prepend_input {
  image_processing_metadata: jsonb
  work_history: jsonb
}

"""
select columns of table "maid_profiles"
"""
enum maid_profiles_select_column {
  """column name"""
  about_me

  """column name"""
  additional_notes

  """column name"""
  additional_services

  """column name"""
  agency_badge

  """column name"""
  agency_id

  """column name"""
  alternative_phone

  """column name"""
  availability_status

  """column name"""
  available_from

  """column name"""
  average_rating

  """column name"""
  bank_account_encrypted

  """column name"""
  bank_account_hash

  """column name"""
  children_count

  """column name"""
  contract_duration_preference

  """column name"""
  country

  """column name"""
  created_at

  """column name"""
  current_location

  """column name"""
  current_visa_status

  """column name"""
  current_visa_status_other

  """column name"""
  date_of_birth

  """column name"""
  education_level

  """column name"""
  emergency_contact_phone_encrypted

  """column name"""
  emergency_contact_phone_hash

  """column name"""
  experience_years

  """column name"""
  first_name

  """column name"""
  full_name

  """column name"""
  id

  """column name"""
  image_processing_metadata

  """column name"""
  introduction_video_url

  """column name"""
  is_agency_managed

  """column name"""
  is_approved

  """column name"""
  iso_country_code

  """column name"""
  key_responsibilities

  """column name"""
  languages

  """column name"""
  last_name

  """column name"""
  live_in_preference

  """column name"""
  marital_status

  """column name"""
  medical_certificate_valid

  """column name"""
  medical_info_encrypted

  """column name"""
  middle_name

  """column name"""
  national_id_encrypted

  """column name"""
  national_id_hash

  """column name"""
  nationality

  """column name"""
  passport_expiry

  """column name"""
  passport_number

  """column name"""
  passport_number_encrypted

  """column name"""
  passport_number_hash

  """column name"""
  phone_country_code

  """column name"""
  phone_number

  """column name"""
  phone_verified

  """column name"""
  phone_verified_at

  """column name"""
  police_clearance_valid

  """column name"""
  preferred_currency

  """column name"""
  preferred_salary_max

  """column name"""
  preferred_salary_min

  """column name"""
  previous_countries

  """column name"""
  previous_employer_contact_encrypted

  """column name"""
  primary_image_original_url

  """column name"""
  primary_image_processed

  """column name"""
  primary_image_processed_url

  """column name"""
  primary_profession

  """column name"""
  primary_profession_other

  """column name"""
  profile_completion_percentage

  """column name"""
  profile_photo_url

  """column name"""
  profile_views

  """column name"""
  religion

  """column name"""
  religion_other

  """column name"""
  skills

  """column name"""
  special_skills

  """column name"""
  state_province

  """column name"""
  street_address

  """column name"""
  suburb

  """column name"""
  successful_placements

  """column name"""
  total_applications

  """column name"""
  two_factor_enabled

  """column name"""
  two_factor_method

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  verification_status

  """column name"""
  video_duration

  """column name"""
  visa_status

  """column name"""
  work_history

  """column name"""
  work_preferences
}

"""
input type for updating data in table "maid_profiles"
"""
input maid_profiles_set_input {
  about_me: String
  additional_notes: String
  additional_services: [String!]

  """References agency profiles.id when is_agency_managed is true"""
  agency_id: String
  alternative_phone: String
  availability_status: String
  available_from: date
  average_rating: numeric
  bank_account_encrypted: String
  bank_account_hash: String
  children_count: Int
  contract_duration_preference: String
  country: String
  created_at: timestamptz
  current_location: String
  current_visa_status: String
  current_visa_status_other: String
  date_of_birth: date
  education_level: String
  emergency_contact_phone_encrypted: String
  emergency_contact_phone_hash: String
  experience_years: Int
  first_name: String
  full_name: String
  id: String
  image_processing_metadata: jsonb

  """URL to the maid introduction video CV (max 1 minute)"""
  introduction_video_url: String

  """True if maid profile is managed by an agency (no auth account)"""
  is_agency_managed: Boolean
  is_approved: Boolean
  iso_country_code: String
  key_responsibilities: [String!]
  languages: [String!]
  last_name: String
  live_in_preference: Boolean
  marital_status: String
  medical_certificate_valid: Boolean
  medical_info_encrypted: String
  middle_name: String
  national_id_encrypted: String
  national_id_hash: String
  nationality: String
  passport_expiry: date
  passport_number: String
  passport_number_encrypted: String
  passport_number_hash: String
  phone_country_code: String
  phone_number: String
  phone_verified: Boolean
  phone_verified_at: timestamptz
  police_clearance_valid: Boolean
  preferred_currency: String
  preferred_salary_max: Int
  preferred_salary_min: Int
  previous_countries: [String!]
  previous_employer_contact_encrypted: String
  primary_image_original_url: String
  primary_image_processed: Boolean
  primary_image_processed_url: String
  primary_profession: String
  primary_profession_other: String
  profile_completion_percentage: Int
  profile_photo_url: String
  profile_views: Int
  religion: String
  religion_other: String
  skills: [String!]
  special_skills: [String!]
  state_province: String
  street_address: String
  suburb: String
  successful_placements: Int
  total_applications: Int
  two_factor_enabled: Boolean
  two_factor_method: String
  updated_at: timestamptz

  """References profiles.id for self-registered maids only"""
  user_id: String
  verification_status: String

  """Duration of the introduction video in seconds"""
  video_duration: Int
  visa_status: String
  work_history: jsonb
  work_preferences: [String!]
}

"""aggregate stddev on columns"""
type maid_profiles_stddev_fields {
  average_rating: Float
  children_count: Float
  experience_years: Float
  preferred_salary_max: Float
  preferred_salary_min: Float
  profile_completion_percentage: Float
  profile_views: Float
  successful_placements: Float
  total_applications: Float

  """Duration of the introduction video in seconds"""
  video_duration: Float
}

"""aggregate stddev_pop on columns"""
type maid_profiles_stddev_pop_fields {
  average_rating: Float
  children_count: Float
  experience_years: Float
  preferred_salary_max: Float
  preferred_salary_min: Float
  profile_completion_percentage: Float
  profile_views: Float
  successful_placements: Float
  total_applications: Float

  """Duration of the introduction video in seconds"""
  video_duration: Float
}

"""aggregate stddev_samp on columns"""
type maid_profiles_stddev_samp_fields {
  average_rating: Float
  children_count: Float
  experience_years: Float
  preferred_salary_max: Float
  preferred_salary_min: Float
  profile_completion_percentage: Float
  profile_views: Float
  successful_placements: Float
  total_applications: Float

  """Duration of the introduction video in seconds"""
  video_duration: Float
}

"""
Streaming cursor of the table "maid_profiles"
"""
input maid_profiles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: maid_profiles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input maid_profiles_stream_cursor_value_input {
  about_me: String
  additional_notes: String
  additional_services: [String!]
  agency_badge: Boolean

  """References agency profiles.id when is_agency_managed is true"""
  agency_id: String
  alternative_phone: String
  availability_status: String
  available_from: date
  average_rating: numeric
  bank_account_encrypted: String
  bank_account_hash: String
  children_count: Int
  contract_duration_preference: String
  country: String
  created_at: timestamptz
  current_location: String
  current_visa_status: String
  current_visa_status_other: String
  date_of_birth: date
  education_level: String
  emergency_contact_phone_encrypted: String
  emergency_contact_phone_hash: String
  experience_years: Int
  first_name: String
  full_name: String
  id: String
  image_processing_metadata: jsonb

  """URL to the maid introduction video CV (max 1 minute)"""
  introduction_video_url: String

  """True if maid profile is managed by an agency (no auth account)"""
  is_agency_managed: Boolean
  is_approved: Boolean
  iso_country_code: String
  key_responsibilities: [String!]
  languages: [String!]
  last_name: String
  live_in_preference: Boolean
  marital_status: String
  medical_certificate_valid: Boolean
  medical_info_encrypted: String
  middle_name: String
  national_id_encrypted: String
  national_id_hash: String
  nationality: String
  passport_expiry: date
  passport_number: String
  passport_number_encrypted: String
  passport_number_hash: String
  phone_country_code: String
  phone_number: String
  phone_verified: Boolean
  phone_verified_at: timestamptz
  police_clearance_valid: Boolean
  preferred_currency: String
  preferred_salary_max: Int
  preferred_salary_min: Int
  previous_countries: [String!]
  previous_employer_contact_encrypted: String
  primary_image_original_url: String
  primary_image_processed: Boolean
  primary_image_processed_url: String
  primary_profession: String
  primary_profession_other: String
  profile_completion_percentage: Int
  profile_photo_url: String
  profile_views: Int
  religion: String
  religion_other: String
  skills: [String!]
  special_skills: [String!]
  state_province: String
  street_address: String
  suburb: String
  successful_placements: Int
  total_applications: Int
  two_factor_enabled: Boolean
  two_factor_method: String
  updated_at: timestamptz

  """References profiles.id for self-registered maids only"""
  user_id: String
  verification_status: String

  """Duration of the introduction video in seconds"""
  video_duration: Int
  visa_status: String
  work_history: jsonb
  work_preferences: [String!]
}

"""aggregate sum on columns"""
type maid_profiles_sum_fields {
  average_rating: numeric
  children_count: Int
  experience_years: Int
  preferred_salary_max: Int
  preferred_salary_min: Int
  profile_completion_percentage: Int
  profile_views: Int
  successful_placements: Int
  total_applications: Int

  """Duration of the introduction video in seconds"""
  video_duration: Int
}

"""
update columns of table "maid_profiles"
"""
enum maid_profiles_update_column {
  """column name"""
  about_me

  """column name"""
  additional_notes

  """column name"""
  additional_services

  """column name"""
  agency_id

  """column name"""
  alternative_phone

  """column name"""
  availability_status

  """column name"""
  available_from

  """column name"""
  average_rating

  """column name"""
  bank_account_encrypted

  """column name"""
  bank_account_hash

  """column name"""
  children_count

  """column name"""
  contract_duration_preference

  """column name"""
  country

  """column name"""
  created_at

  """column name"""
  current_location

  """column name"""
  current_visa_status

  """column name"""
  current_visa_status_other

  """column name"""
  date_of_birth

  """column name"""
  education_level

  """column name"""
  emergency_contact_phone_encrypted

  """column name"""
  emergency_contact_phone_hash

  """column name"""
  experience_years

  """column name"""
  first_name

  """column name"""
  full_name

  """column name"""
  id

  """column name"""
  image_processing_metadata

  """column name"""
  introduction_video_url

  """column name"""
  is_agency_managed

  """column name"""
  is_approved

  """column name"""
  iso_country_code

  """column name"""
  key_responsibilities

  """column name"""
  languages

  """column name"""
  last_name

  """column name"""
  live_in_preference

  """column name"""
  marital_status

  """column name"""
  medical_certificate_valid

  """column name"""
  medical_info_encrypted

  """column name"""
  middle_name

  """column name"""
  national_id_encrypted

  """column name"""
  national_id_hash

  """column name"""
  nationality

  """column name"""
  passport_expiry

  """column name"""
  passport_number

  """column name"""
  passport_number_encrypted

  """column name"""
  passport_number_hash

  """column name"""
  phone_country_code

  """column name"""
  phone_number

  """column name"""
  phone_verified

  """column name"""
  phone_verified_at

  """column name"""
  police_clearance_valid

  """column name"""
  preferred_currency

  """column name"""
  preferred_salary_max

  """column name"""
  preferred_salary_min

  """column name"""
  previous_countries

  """column name"""
  previous_employer_contact_encrypted

  """column name"""
  primary_image_original_url

  """column name"""
  primary_image_processed

  """column name"""
  primary_image_processed_url

  """column name"""
  primary_profession

  """column name"""
  primary_profession_other

  """column name"""
  profile_completion_percentage

  """column name"""
  profile_photo_url

  """column name"""
  profile_views

  """column name"""
  religion

  """column name"""
  religion_other

  """column name"""
  skills

  """column name"""
  special_skills

  """column name"""
  state_province

  """column name"""
  street_address

  """column name"""
  suburb

  """column name"""
  successful_placements

  """column name"""
  total_applications

  """column name"""
  two_factor_enabled

  """column name"""
  two_factor_method

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  verification_status

  """column name"""
  video_duration

  """column name"""
  visa_status

  """column name"""
  work_history

  """column name"""
  work_preferences
}

input maid_profiles_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: maid_profiles_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: maid_profiles_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: maid_profiles_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: maid_profiles_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: maid_profiles_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: maid_profiles_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: maid_profiles_set_input

  """filter the rows which have to be updated"""
  where: maid_profiles_bool_exp!
}

"""aggregate var_pop on columns"""
type maid_profiles_var_pop_fields {
  average_rating: Float
  children_count: Float
  experience_years: Float
  preferred_salary_max: Float
  preferred_salary_min: Float
  profile_completion_percentage: Float
  profile_views: Float
  successful_placements: Float
  total_applications: Float

  """Duration of the introduction video in seconds"""
  video_duration: Float
}

"""aggregate var_samp on columns"""
type maid_profiles_var_samp_fields {
  average_rating: Float
  children_count: Float
  experience_years: Float
  preferred_salary_max: Float
  preferred_salary_min: Float
  profile_completion_percentage: Float
  profile_views: Float
  successful_placements: Float
  total_applications: Float

  """Duration of the introduction video in seconds"""
  video_duration: Float
}

"""aggregate variance on columns"""
type maid_profiles_variance_fields {
  average_rating: Float
  children_count: Float
  experience_years: Float
  preferred_salary_max: Float
  preferred_salary_min: Float
  profile_completion_percentage: Float
  profile_views: Float
  successful_placements: Float
  total_applications: Float

  """Duration of the introduction video in seconds"""
  video_duration: Float
}

"""
columns and relationships of "maid_videos"
"""
type maid_videos {
  created_at: timestamptz
  duration: Int
  file_size: Int
  id: uuid!
  maid_id: uuid
  thumbnail_url: String
  video_path: String
  video_url: String!
}

"""
aggregated selection of "maid_videos"
"""
type maid_videos_aggregate {
  aggregate: maid_videos_aggregate_fields
  nodes: [maid_videos!]!
}

"""
aggregate fields of "maid_videos"
"""
type maid_videos_aggregate_fields {
  avg: maid_videos_avg_fields
  count(columns: [maid_videos_select_column!], distinct: Boolean): Int!
  max: maid_videos_max_fields
  min: maid_videos_min_fields
  stddev: maid_videos_stddev_fields
  stddev_pop: maid_videos_stddev_pop_fields
  stddev_samp: maid_videos_stddev_samp_fields
  sum: maid_videos_sum_fields
  var_pop: maid_videos_var_pop_fields
  var_samp: maid_videos_var_samp_fields
  variance: maid_videos_variance_fields
}

"""aggregate avg on columns"""
type maid_videos_avg_fields {
  duration: Float
  file_size: Float
}

"""
Boolean expression to filter rows from the table "maid_videos". All fields are combined with a logical 'AND'.
"""
input maid_videos_bool_exp {
  _and: [maid_videos_bool_exp!]
  _not: maid_videos_bool_exp
  _or: [maid_videos_bool_exp!]
  created_at: timestamptz_comparison_exp
  duration: Int_comparison_exp
  file_size: Int_comparison_exp
  id: uuid_comparison_exp
  maid_id: uuid_comparison_exp
  thumbnail_url: String_comparison_exp
  video_path: String_comparison_exp
  video_url: String_comparison_exp
}

"""
unique or primary key constraints on table "maid_videos"
"""
enum maid_videos_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  maid_videos_pkey
}

"""
input type for incrementing numeric columns in table "maid_videos"
"""
input maid_videos_inc_input {
  duration: Int
  file_size: Int
}

"""
input type for inserting data into table "maid_videos"
"""
input maid_videos_insert_input {
  created_at: timestamptz
  duration: Int
  file_size: Int
  id: uuid
  maid_id: uuid
  thumbnail_url: String
  video_path: String
  video_url: String
}

"""aggregate max on columns"""
type maid_videos_max_fields {
  created_at: timestamptz
  duration: Int
  file_size: Int
  id: uuid
  maid_id: uuid
  thumbnail_url: String
  video_path: String
  video_url: String
}

"""aggregate min on columns"""
type maid_videos_min_fields {
  created_at: timestamptz
  duration: Int
  file_size: Int
  id: uuid
  maid_id: uuid
  thumbnail_url: String
  video_path: String
  video_url: String
}

"""
response of any mutation on the table "maid_videos"
"""
type maid_videos_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [maid_videos!]!
}

"""
on_conflict condition type for table "maid_videos"
"""
input maid_videos_on_conflict {
  constraint: maid_videos_constraint!
  update_columns: [maid_videos_update_column!]! = []
  where: maid_videos_bool_exp
}

"""Ordering options when selecting data from "maid_videos"."""
input maid_videos_order_by {
  created_at: order_by
  duration: order_by
  file_size: order_by
  id: order_by
  maid_id: order_by
  thumbnail_url: order_by
  video_path: order_by
  video_url: order_by
}

"""primary key columns input for table: maid_videos"""
input maid_videos_pk_columns_input {
  id: uuid!
}

"""
select columns of table "maid_videos"
"""
enum maid_videos_select_column {
  """column name"""
  created_at

  """column name"""
  duration

  """column name"""
  file_size

  """column name"""
  id

  """column name"""
  maid_id

  """column name"""
  thumbnail_url

  """column name"""
  video_path

  """column name"""
  video_url
}

"""
input type for updating data in table "maid_videos"
"""
input maid_videos_set_input {
  created_at: timestamptz
  duration: Int
  file_size: Int
  id: uuid
  maid_id: uuid
  thumbnail_url: String
  video_path: String
  video_url: String
}

"""aggregate stddev on columns"""
type maid_videos_stddev_fields {
  duration: Float
  file_size: Float
}

"""aggregate stddev_pop on columns"""
type maid_videos_stddev_pop_fields {
  duration: Float
  file_size: Float
}

"""aggregate stddev_samp on columns"""
type maid_videos_stddev_samp_fields {
  duration: Float
  file_size: Float
}

"""
Streaming cursor of the table "maid_videos"
"""
input maid_videos_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: maid_videos_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input maid_videos_stream_cursor_value_input {
  created_at: timestamptz
  duration: Int
  file_size: Int
  id: uuid
  maid_id: uuid
  thumbnail_url: String
  video_path: String
  video_url: String
}

"""aggregate sum on columns"""
type maid_videos_sum_fields {
  duration: Int
  file_size: Int
}

"""
update columns of table "maid_videos"
"""
enum maid_videos_update_column {
  """column name"""
  created_at

  """column name"""
  duration

  """column name"""
  file_size

  """column name"""
  id

  """column name"""
  maid_id

  """column name"""
  thumbnail_url

  """column name"""
  video_path

  """column name"""
  video_url
}

input maid_videos_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: maid_videos_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: maid_videos_set_input

  """filter the rows which have to be updated"""
  where: maid_videos_bool_exp!
}

"""aggregate var_pop on columns"""
type maid_videos_var_pop_fields {
  duration: Float
  file_size: Float
}

"""aggregate var_samp on columns"""
type maid_videos_var_samp_fields {
  duration: Float
  file_size: Float
}

"""aggregate variance on columns"""
type maid_videos_variance_fields {
  duration: Float
  file_size: Float
}

"""Stores reusable message templates for agencies"""
type message_templates {
  agency_id: uuid!
  category: String
  content: String!
  created_at: timestamptz
  id: uuid!
  is_active: Boolean
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  name: String!
  subject: String
  updated_at: timestamptz
  usage_count: Int
  variables(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
aggregated selection of "message_templates"
"""
type message_templates_aggregate {
  aggregate: message_templates_aggregate_fields
  nodes: [message_templates!]!
}

"""
aggregate fields of "message_templates"
"""
type message_templates_aggregate_fields {
  avg: message_templates_avg_fields
  count(columns: [message_templates_select_column!], distinct: Boolean): Int!
  max: message_templates_max_fields
  min: message_templates_min_fields
  stddev: message_templates_stddev_fields
  stddev_pop: message_templates_stddev_pop_fields
  stddev_samp: message_templates_stddev_samp_fields
  sum: message_templates_sum_fields
  var_pop: message_templates_var_pop_fields
  var_samp: message_templates_var_samp_fields
  variance: message_templates_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input message_templates_append_input {
  metadata: jsonb
  variables: jsonb
}

"""aggregate avg on columns"""
type message_templates_avg_fields {
  usage_count: Float
}

"""
Boolean expression to filter rows from the table "message_templates". All fields are combined with a logical 'AND'.
"""
input message_templates_bool_exp {
  _and: [message_templates_bool_exp!]
  _not: message_templates_bool_exp
  _or: [message_templates_bool_exp!]
  agency_id: uuid_comparison_exp
  category: String_comparison_exp
  content: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  is_active: Boolean_comparison_exp
  metadata: jsonb_comparison_exp
  name: String_comparison_exp
  subject: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  usage_count: Int_comparison_exp
  variables: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "message_templates"
"""
enum message_templates_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  message_templates_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input message_templates_delete_at_path_input {
  metadata: [String!]
  variables: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input message_templates_delete_elem_input {
  metadata: Int
  variables: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input message_templates_delete_key_input {
  metadata: String
  variables: String
}

"""
input type for incrementing numeric columns in table "message_templates"
"""
input message_templates_inc_input {
  usage_count: Int
}

"""
input type for inserting data into table "message_templates"
"""
input message_templates_insert_input {
  agency_id: uuid
  category: String
  content: String
  created_at: timestamptz
  id: uuid
  is_active: Boolean
  metadata: jsonb
  name: String
  subject: String
  updated_at: timestamptz
  usage_count: Int
  variables: jsonb
}

"""aggregate max on columns"""
type message_templates_max_fields {
  agency_id: uuid
  category: String
  content: String
  created_at: timestamptz
  id: uuid
  name: String
  subject: String
  updated_at: timestamptz
  usage_count: Int
}

"""aggregate min on columns"""
type message_templates_min_fields {
  agency_id: uuid
  category: String
  content: String
  created_at: timestamptz
  id: uuid
  name: String
  subject: String
  updated_at: timestamptz
  usage_count: Int
}

"""
response of any mutation on the table "message_templates"
"""
type message_templates_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [message_templates!]!
}

"""
on_conflict condition type for table "message_templates"
"""
input message_templates_on_conflict {
  constraint: message_templates_constraint!
  update_columns: [message_templates_update_column!]! = []
  where: message_templates_bool_exp
}

"""Ordering options when selecting data from "message_templates"."""
input message_templates_order_by {
  agency_id: order_by
  category: order_by
  content: order_by
  created_at: order_by
  id: order_by
  is_active: order_by
  metadata: order_by
  name: order_by
  subject: order_by
  updated_at: order_by
  usage_count: order_by
  variables: order_by
}

"""primary key columns input for table: message_templates"""
input message_templates_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input message_templates_prepend_input {
  metadata: jsonb
  variables: jsonb
}

"""
select columns of table "message_templates"
"""
enum message_templates_select_column {
  """column name"""
  agency_id

  """column name"""
  category

  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  metadata

  """column name"""
  name

  """column name"""
  subject

  """column name"""
  updated_at

  """column name"""
  usage_count

  """column name"""
  variables
}

"""
input type for updating data in table "message_templates"
"""
input message_templates_set_input {
  agency_id: uuid
  category: String
  content: String
  created_at: timestamptz
  id: uuid
  is_active: Boolean
  metadata: jsonb
  name: String
  subject: String
  updated_at: timestamptz
  usage_count: Int
  variables: jsonb
}

"""aggregate stddev on columns"""
type message_templates_stddev_fields {
  usage_count: Float
}

"""aggregate stddev_pop on columns"""
type message_templates_stddev_pop_fields {
  usage_count: Float
}

"""aggregate stddev_samp on columns"""
type message_templates_stddev_samp_fields {
  usage_count: Float
}

"""
Streaming cursor of the table "message_templates"
"""
input message_templates_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: message_templates_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input message_templates_stream_cursor_value_input {
  agency_id: uuid
  category: String
  content: String
  created_at: timestamptz
  id: uuid
  is_active: Boolean
  metadata: jsonb
  name: String
  subject: String
  updated_at: timestamptz
  usage_count: Int
  variables: jsonb
}

"""aggregate sum on columns"""
type message_templates_sum_fields {
  usage_count: Int
}

"""
update columns of table "message_templates"
"""
enum message_templates_update_column {
  """column name"""
  agency_id

  """column name"""
  category

  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  metadata

  """column name"""
  name

  """column name"""
  subject

  """column name"""
  updated_at

  """column name"""
  usage_count

  """column name"""
  variables
}

input message_templates_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: message_templates_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: message_templates_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: message_templates_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: message_templates_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: message_templates_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: message_templates_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: message_templates_set_input

  """filter the rows which have to be updated"""
  where: message_templates_bool_exp!
}

"""aggregate var_pop on columns"""
type message_templates_var_pop_fields {
  usage_count: Float
}

"""aggregate var_samp on columns"""
type message_templates_var_samp_fields {
  usage_count: Float
}

"""aggregate variance on columns"""
type message_templates_variance_fields {
  usage_count: Float
}

"""
columns and relationships of "messages"
"""
type messages {
  application_id: uuid
  attachments(
    """JSON select path"""
    path: String
  ): jsonb
  content: String!

  """An object relationship"""
  conversation: conversations

  """Links message to a conversation thread"""
  conversation_id: uuid
  created_at: timestamptz
  id: uuid!
  is_archived: Boolean
  is_read: Boolean
  job_id: uuid
  message_type: String
  read: Boolean
  read_at: timestamptz
  receiver_id: String
  recipient_id: String
  sender_id: String
  subject: String
  updated_at: timestamptz
}

"""
aggregated selection of "messages"
"""
type messages_aggregate {
  aggregate: messages_aggregate_fields
  nodes: [messages!]!
}

input messages_aggregate_bool_exp {
  bool_and: messages_aggregate_bool_exp_bool_and
  bool_or: messages_aggregate_bool_exp_bool_or
  count: messages_aggregate_bool_exp_count
}

input messages_aggregate_bool_exp_bool_and {
  arguments: messages_select_column_messages_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: messages_bool_exp
  predicate: Boolean_comparison_exp!
}

input messages_aggregate_bool_exp_bool_or {
  arguments: messages_select_column_messages_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: messages_bool_exp
  predicate: Boolean_comparison_exp!
}

input messages_aggregate_bool_exp_count {
  arguments: [messages_select_column!]
  distinct: Boolean
  filter: messages_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "messages"
"""
type messages_aggregate_fields {
  count(columns: [messages_select_column!], distinct: Boolean): Int!
  max: messages_max_fields
  min: messages_min_fields
}

"""
order by aggregate values of table "messages"
"""
input messages_aggregate_order_by {
  count: order_by
  max: messages_max_order_by
  min: messages_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input messages_append_input {
  attachments: jsonb
}

"""
input type for inserting array relation for remote table "messages"
"""
input messages_arr_rel_insert_input {
  data: [messages_insert_input!]!

  """upsert condition"""
  on_conflict: messages_on_conflict
}

"""
Boolean expression to filter rows from the table "messages". All fields are combined with a logical 'AND'.
"""
input messages_bool_exp {
  _and: [messages_bool_exp!]
  _not: messages_bool_exp
  _or: [messages_bool_exp!]
  application_id: uuid_comparison_exp
  attachments: jsonb_comparison_exp
  content: String_comparison_exp
  conversation: conversations_bool_exp
  conversation_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  is_archived: Boolean_comparison_exp
  is_read: Boolean_comparison_exp
  job_id: uuid_comparison_exp
  message_type: String_comparison_exp
  read: Boolean_comparison_exp
  read_at: timestamptz_comparison_exp
  receiver_id: String_comparison_exp
  recipient_id: String_comparison_exp
  sender_id: String_comparison_exp
  subject: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "messages"
"""
enum messages_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  messages_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input messages_delete_at_path_input {
  attachments: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input messages_delete_elem_input {
  attachments: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input messages_delete_key_input {
  attachments: String
}

"""
input type for inserting data into table "messages"
"""
input messages_insert_input {
  application_id: uuid
  attachments: jsonb
  content: String
  conversation: conversations_obj_rel_insert_input

  """Links message to a conversation thread"""
  conversation_id: uuid
  created_at: timestamptz
  id: uuid
  is_archived: Boolean
  is_read: Boolean
  job_id: uuid
  message_type: String
  read: Boolean
  read_at: timestamptz
  receiver_id: String
  recipient_id: String
  sender_id: String
  subject: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type messages_max_fields {
  application_id: uuid
  content: String

  """Links message to a conversation thread"""
  conversation_id: uuid
  created_at: timestamptz
  id: uuid
  job_id: uuid
  message_type: String
  read_at: timestamptz
  receiver_id: String
  recipient_id: String
  sender_id: String
  subject: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "messages"
"""
input messages_max_order_by {
  application_id: order_by
  content: order_by

  """Links message to a conversation thread"""
  conversation_id: order_by
  created_at: order_by
  id: order_by
  job_id: order_by
  message_type: order_by
  read_at: order_by
  receiver_id: order_by
  recipient_id: order_by
  sender_id: order_by
  subject: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type messages_min_fields {
  application_id: uuid
  content: String

  """Links message to a conversation thread"""
  conversation_id: uuid
  created_at: timestamptz
  id: uuid
  job_id: uuid
  message_type: String
  read_at: timestamptz
  receiver_id: String
  recipient_id: String
  sender_id: String
  subject: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "messages"
"""
input messages_min_order_by {
  application_id: order_by
  content: order_by

  """Links message to a conversation thread"""
  conversation_id: order_by
  created_at: order_by
  id: order_by
  job_id: order_by
  message_type: order_by
  read_at: order_by
  receiver_id: order_by
  recipient_id: order_by
  sender_id: order_by
  subject: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "messages"
"""
type messages_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [messages!]!
}

"""
on_conflict condition type for table "messages"
"""
input messages_on_conflict {
  constraint: messages_constraint!
  update_columns: [messages_update_column!]! = []
  where: messages_bool_exp
}

"""Ordering options when selecting data from "messages"."""
input messages_order_by {
  application_id: order_by
  attachments: order_by
  content: order_by
  conversation: conversations_order_by
  conversation_id: order_by
  created_at: order_by
  id: order_by
  is_archived: order_by
  is_read: order_by
  job_id: order_by
  message_type: order_by
  read: order_by
  read_at: order_by
  receiver_id: order_by
  recipient_id: order_by
  sender_id: order_by
  subject: order_by
  updated_at: order_by
}

"""primary key columns input for table: messages"""
input messages_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input messages_prepend_input {
  attachments: jsonb
}

"""
select columns of table "messages"
"""
enum messages_select_column {
  """column name"""
  application_id

  """column name"""
  attachments

  """column name"""
  content

  """column name"""
  conversation_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  is_archived

  """column name"""
  is_read

  """column name"""
  job_id

  """column name"""
  message_type

  """column name"""
  read

  """column name"""
  read_at

  """column name"""
  receiver_id

  """column name"""
  recipient_id

  """column name"""
  sender_id

  """column name"""
  subject

  """column name"""
  updated_at
}

"""
select "messages_aggregate_bool_exp_bool_and_arguments_columns" columns of table "messages"
"""
enum messages_select_column_messages_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_archived

  """column name"""
  is_read

  """column name"""
  read
}

"""
select "messages_aggregate_bool_exp_bool_or_arguments_columns" columns of table "messages"
"""
enum messages_select_column_messages_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_archived

  """column name"""
  is_read

  """column name"""
  read
}

"""
input type for updating data in table "messages"
"""
input messages_set_input {
  application_id: uuid
  attachments: jsonb
  content: String

  """Links message to a conversation thread"""
  conversation_id: uuid
  created_at: timestamptz
  id: uuid
  is_archived: Boolean
  is_read: Boolean
  job_id: uuid
  message_type: String
  read: Boolean
  read_at: timestamptz
  receiver_id: String
  recipient_id: String
  sender_id: String
  subject: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "messages"
"""
input messages_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: messages_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input messages_stream_cursor_value_input {
  application_id: uuid
  attachments: jsonb
  content: String

  """Links message to a conversation thread"""
  conversation_id: uuid
  created_at: timestamptz
  id: uuid
  is_archived: Boolean
  is_read: Boolean
  job_id: uuid
  message_type: String
  read: Boolean
  read_at: timestamptz
  receiver_id: String
  recipient_id: String
  sender_id: String
  subject: String
  updated_at: timestamptz
}

"""
update columns of table "messages"
"""
enum messages_update_column {
  """column name"""
  application_id

  """column name"""
  attachments

  """column name"""
  content

  """column name"""
  conversation_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  is_archived

  """column name"""
  is_read

  """column name"""
  job_id

  """column name"""
  message_type

  """column name"""
  read

  """column name"""
  read_at

  """column name"""
  receiver_id

  """column name"""
  recipient_id

  """column name"""
  sender_id

  """column name"""
  subject

  """column name"""
  updated_at
}

input messages_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: messages_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: messages_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: messages_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: messages_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: messages_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: messages_set_input

  """filter the rows which have to be updated"""
  where: messages_bool_exp!
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "activity_announcements"
  """
  delete_activity_announcements(
    """filter the rows which have to be deleted"""
    where: activity_announcements_bool_exp!
  ): activity_announcements_mutation_response

  """
  delete single row from the table: "activity_announcements"
  """
  delete_activity_announcements_by_pk(id: uuid!): activity_announcements

  """
  delete data from the table: "activity_log"
  """
  delete_activity_log(
    """filter the rows which have to be deleted"""
    where: activity_log_bool_exp!
  ): activity_log_mutation_response

  """
  delete single row from the table: "activity_log"
  """
  delete_activity_log_by_pk(id: uuid!): activity_log

  """
  delete data from the table: "admin_activity_logs"
  """
  delete_admin_activity_logs(
    """filter the rows which have to be deleted"""
    where: admin_activity_logs_bool_exp!
  ): admin_activity_logs_mutation_response

  """
  delete single row from the table: "admin_activity_logs"
  """
  delete_admin_activity_logs_by_pk(id: uuid!): admin_activity_logs

  """
  delete data from the table: "admin_users"
  """
  delete_admin_users(
    """filter the rows which have to be deleted"""
    where: admin_users_bool_exp!
  ): admin_users_mutation_response

  """
  delete single row from the table: "admin_users"
  """
  delete_admin_users_by_pk(id: uuid!): admin_users

  """
  delete data from the table: "agency_audit_logs"
  """
  delete_agency_audit_logs(
    """filter the rows which have to be deleted"""
    where: agency_audit_logs_bool_exp!
  ): agency_audit_logs_mutation_response

  """
  delete single row from the table: "agency_audit_logs"
  """
  delete_agency_audit_logs_by_pk(id: uuid!): agency_audit_logs

  """
  delete data from the table: "agency_credits"
  """
  delete_agency_credits(
    """filter the rows which have to be deleted"""
    where: agency_credits_bool_exp!
  ): agency_credits_mutation_response

  """
  delete single row from the table: "agency_credits"
  """
  delete_agency_credits_by_pk(id: uuid!): agency_credits

  """
  delete data from the table: "agency_disputes"
  """
  delete_agency_disputes(
    """filter the rows which have to be deleted"""
    where: agency_disputes_bool_exp!
  ): agency_disputes_mutation_response

  """
  delete single row from the table: "agency_disputes"
  """
  delete_agency_disputes_by_pk(id: uuid!): agency_disputes

  """
  delete data from the table: "agency_document_requirements"
  """
  delete_agency_document_requirements(
    """filter the rows which have to be deleted"""
    where: agency_document_requirements_bool_exp!
  ): agency_document_requirements_mutation_response

  """
  delete single row from the table: "agency_document_requirements"
  """
  delete_agency_document_requirements_by_pk(id: uuid!): agency_document_requirements

  """
  delete data from the table: "agency_documents"
  """
  delete_agency_documents(
    """filter the rows which have to be deleted"""
    where: agency_documents_bool_exp!
  ): agency_documents_mutation_response

  """
  delete single row from the table: "agency_documents"
  """
  delete_agency_documents_by_pk(id: uuid!): agency_documents

  """
  delete data from the table: "agency_earnings"
  """
  delete_agency_earnings(
    """filter the rows which have to be deleted"""
    where: agency_earnings_bool_exp!
  ): agency_earnings_mutation_response

  """
  delete single row from the table: "agency_earnings"
  """
  delete_agency_earnings_by_pk(id: uuid!): agency_earnings

  """
  delete data from the table: "agency_interviews"
  """
  delete_agency_interviews(
    """filter the rows which have to be deleted"""
    where: agency_interviews_bool_exp!
  ): agency_interviews_mutation_response

  """
  delete single row from the table: "agency_interviews"
  """
  delete_agency_interviews_by_pk(id: uuid!): agency_interviews

  """
  delete data from the table: "agency_jobs"
  """
  delete_agency_jobs(
    """filter the rows which have to be deleted"""
    where: agency_jobs_bool_exp!
  ): agency_jobs_mutation_response

  """
  delete single row from the table: "agency_jobs"
  """
  delete_agency_jobs_by_pk(id: uuid!): agency_jobs

  """
  delete data from the table: "agency_kyb_audit_log"
  """
  delete_agency_kyb_audit_log(
    """filter the rows which have to be deleted"""
    where: agency_kyb_audit_log_bool_exp!
  ): agency_kyb_audit_log_mutation_response

  """
  delete single row from the table: "agency_kyb_audit_log"
  """
  delete_agency_kyb_audit_log_by_pk(id: uuid!): agency_kyb_audit_log

  """
  delete data from the table: "agency_kyb_documents"
  """
  delete_agency_kyb_documents(
    """filter the rows which have to be deleted"""
    where: agency_kyb_documents_bool_exp!
  ): agency_kyb_documents_mutation_response

  """
  delete single row from the table: "agency_kyb_documents"
  """
  delete_agency_kyb_documents_by_pk(id: uuid!): agency_kyb_documents

  """
  delete data from the table: "agency_kyb_verification"
  """
  delete_agency_kyb_verification(
    """filter the rows which have to be deleted"""
    where: agency_kyb_verification_bool_exp!
  ): agency_kyb_verification_mutation_response

  """
  delete single row from the table: "agency_kyb_verification"
  """
  delete_agency_kyb_verification_by_pk(id: uuid!): agency_kyb_verification

  """
  delete data from the table: "agency_payment_failures"
  """
  delete_agency_payment_failures(
    """filter the rows which have to be deleted"""
    where: agency_payment_failures_bool_exp!
  ): agency_payment_failures_mutation_response

  """
  delete single row from the table: "agency_payment_failures"
  """
  delete_agency_payment_failures_by_pk(id: uuid!): agency_payment_failures

  """
  delete data from the table: "agency_payouts"
  """
  delete_agency_payouts(
    """filter the rows which have to be deleted"""
    where: agency_payouts_bool_exp!
  ): agency_payouts_mutation_response

  """
  delete single row from the table: "agency_payouts"
  """
  delete_agency_payouts_by_pk(id: uuid!): agency_payouts

  """
  delete data from the table: "agency_placements"
  """
  delete_agency_placements(
    """filter the rows which have to be deleted"""
    where: agency_placements_bool_exp!
  ): agency_placements_mutation_response

  """
  delete single row from the table: "agency_placements"
  """
  delete_agency_placements_by_pk(id: uuid!): agency_placements

  """
  delete data from the table: "agency_profiles"
  """
  delete_agency_profiles(
    """filter the rows which have to be deleted"""
    where: agency_profiles_bool_exp!
  ): agency_profiles_mutation_response

  """
  delete single row from the table: "agency_profiles"
  """
  delete_agency_profiles_by_pk(id: String!): agency_profiles

  """
  delete data from the table: "agency_tasks"
  """
  delete_agency_tasks(
    """filter the rows which have to be deleted"""
    where: agency_tasks_bool_exp!
  ): agency_tasks_mutation_response

  """
  delete single row from the table: "agency_tasks"
  """
  delete_agency_tasks_by_pk(id: uuid!): agency_tasks

  """
  delete data from the table: "agency_team_members"
  """
  delete_agency_team_members(
    """filter the rows which have to be deleted"""
    where: agency_team_members_bool_exp!
  ): agency_team_members_mutation_response

  """
  delete single row from the table: "agency_team_members"
  """
  delete_agency_team_members_by_pk(id: uuid!): agency_team_members

  """
  delete data from the table: "analytics_cache"
  """
  delete_analytics_cache(
    """filter the rows which have to be deleted"""
    where: analytics_cache_bool_exp!
  ): analytics_cache_mutation_response

  """
  delete single row from the table: "analytics_cache"
  """
  delete_analytics_cache_by_pk(id: uuid!): analytics_cache

  """
  delete data from the table: "announcement_views"
  """
  delete_announcement_views(
    """filter the rows which have to be deleted"""
    where: announcement_views_bool_exp!
  ): announcement_views_mutation_response

  """
  delete single row from the table: "announcement_views"
  """
  delete_announcement_views_by_pk(id: uuid!): announcement_views

  """
  delete data from the table: "applications"
  """
  delete_applications(
    """filter the rows which have to be deleted"""
    where: applications_bool_exp!
  ): applications_mutation_response

  """
  delete single row from the table: "applications"
  """
  delete_applications_by_pk(id: uuid!): applications

  """
  delete data from the table: "audit_logs"
  """
  delete_audit_logs(
    """filter the rows which have to be deleted"""
    where: audit_logs_bool_exp!
  ): audit_logs_mutation_response

  """
  delete single row from the table: "audit_logs"
  """
  delete_audit_logs_by_pk(id: uuid!): audit_logs

  """
  delete data from the table: "auth.audit_log_entries"
  """
  delete_auth_audit_log_entries(
    """filter the rows which have to be deleted"""
    where: auth_audit_log_entries_bool_exp!
  ): auth_audit_log_entries_mutation_response

  """
  delete single row from the table: "auth.audit_log_entries"
  """
  delete_auth_audit_log_entries_by_pk(id: uuid!): auth_audit_log_entries

  """
  delete data from the table: "auth.flow_state"
  """
  delete_auth_flow_state(
    """filter the rows which have to be deleted"""
    where: auth_flow_state_bool_exp!
  ): auth_flow_state_mutation_response

  """
  delete single row from the table: "auth.flow_state"
  """
  delete_auth_flow_state_by_pk(id: uuid!): auth_flow_state

  """
  delete data from the table: "auth.identities"
  """
  delete_auth_identities(
    """filter the rows which have to be deleted"""
    where: auth_identities_bool_exp!
  ): auth_identities_mutation_response

  """
  delete single row from the table: "auth.identities"
  """
  delete_auth_identities_by_pk(id: uuid!): auth_identities

  """
  delete data from the table: "auth.instances"
  """
  delete_auth_instances(
    """filter the rows which have to be deleted"""
    where: auth_instances_bool_exp!
  ): auth_instances_mutation_response

  """
  delete single row from the table: "auth.instances"
  """
  delete_auth_instances_by_pk(id: uuid!): auth_instances

  """
  delete data from the table: "auth.mfa_amr_claims"
  """
  delete_auth_mfa_amr_claims(
    """filter the rows which have to be deleted"""
    where: auth_mfa_amr_claims_bool_exp!
  ): auth_mfa_amr_claims_mutation_response

  """
  delete single row from the table: "auth.mfa_amr_claims"
  """
  delete_auth_mfa_amr_claims_by_pk(id: uuid!): auth_mfa_amr_claims

  """
  delete data from the table: "auth.mfa_challenges"
  """
  delete_auth_mfa_challenges(
    """filter the rows which have to be deleted"""
    where: auth_mfa_challenges_bool_exp!
  ): auth_mfa_challenges_mutation_response

  """
  delete single row from the table: "auth.mfa_challenges"
  """
  delete_auth_mfa_challenges_by_pk(id: uuid!): auth_mfa_challenges

  """
  delete data from the table: "auth.mfa_factors"
  """
  delete_auth_mfa_factors(
    """filter the rows which have to be deleted"""
    where: auth_mfa_factors_bool_exp!
  ): auth_mfa_factors_mutation_response

  """
  delete single row from the table: "auth.mfa_factors"
  """
  delete_auth_mfa_factors_by_pk(id: uuid!): auth_mfa_factors

  """
  delete data from the table: "auth.oauth_authorizations"
  """
  delete_auth_oauth_authorizations(
    """filter the rows which have to be deleted"""
    where: auth_oauth_authorizations_bool_exp!
  ): auth_oauth_authorizations_mutation_response

  """
  delete single row from the table: "auth.oauth_authorizations"
  """
  delete_auth_oauth_authorizations_by_pk(id: uuid!): auth_oauth_authorizations

  """
  delete data from the table: "auth.oauth_clients"
  """
  delete_auth_oauth_clients(
    """filter the rows which have to be deleted"""
    where: auth_oauth_clients_bool_exp!
  ): auth_oauth_clients_mutation_response

  """
  delete single row from the table: "auth.oauth_clients"
  """
  delete_auth_oauth_clients_by_pk(id: uuid!): auth_oauth_clients

  """
  delete data from the table: "auth.oauth_consents"
  """
  delete_auth_oauth_consents(
    """filter the rows which have to be deleted"""
    where: auth_oauth_consents_bool_exp!
  ): auth_oauth_consents_mutation_response

  """
  delete single row from the table: "auth.oauth_consents"
  """
  delete_auth_oauth_consents_by_pk(id: uuid!): auth_oauth_consents

  """
  delete data from the table: "auth.one_time_tokens"
  """
  delete_auth_one_time_tokens(
    """filter the rows which have to be deleted"""
    where: auth_one_time_tokens_bool_exp!
  ): auth_one_time_tokens_mutation_response

  """
  delete single row from the table: "auth.one_time_tokens"
  """
  delete_auth_one_time_tokens_by_pk(id: uuid!): auth_one_time_tokens

  """
  delete data from the table: "auth.refresh_tokens"
  """
  delete_auth_refresh_tokens(
    """filter the rows which have to be deleted"""
    where: auth_refresh_tokens_bool_exp!
  ): auth_refresh_tokens_mutation_response

  """
  delete single row from the table: "auth.refresh_tokens"
  """
  delete_auth_refresh_tokens_by_pk(id: bigint!): auth_refresh_tokens

  """
  delete data from the table: "auth.saml_providers"
  """
  delete_auth_saml_providers(
    """filter the rows which have to be deleted"""
    where: auth_saml_providers_bool_exp!
  ): auth_saml_providers_mutation_response

  """
  delete single row from the table: "auth.saml_providers"
  """
  delete_auth_saml_providers_by_pk(id: uuid!): auth_saml_providers

  """
  delete data from the table: "auth.saml_relay_states"
  """
  delete_auth_saml_relay_states(
    """filter the rows which have to be deleted"""
    where: auth_saml_relay_states_bool_exp!
  ): auth_saml_relay_states_mutation_response

  """
  delete single row from the table: "auth.saml_relay_states"
  """
  delete_auth_saml_relay_states_by_pk(id: uuid!): auth_saml_relay_states

  """
  delete data from the table: "auth.sessions"
  """
  delete_auth_sessions(
    """filter the rows which have to be deleted"""
    where: auth_sessions_bool_exp!
  ): auth_sessions_mutation_response

  """
  delete single row from the table: "auth.sessions"
  """
  delete_auth_sessions_by_pk(id: uuid!): auth_sessions

  """
  delete data from the table: "auth.sso_domains"
  """
  delete_auth_sso_domains(
    """filter the rows which have to be deleted"""
    where: auth_sso_domains_bool_exp!
  ): auth_sso_domains_mutation_response

  """
  delete single row from the table: "auth.sso_domains"
  """
  delete_auth_sso_domains_by_pk(id: uuid!): auth_sso_domains

  """
  delete data from the table: "auth.sso_providers"
  """
  delete_auth_sso_providers(
    """filter the rows which have to be deleted"""
    where: auth_sso_providers_bool_exp!
  ): auth_sso_providers_mutation_response

  """
  delete single row from the table: "auth.sso_providers"
  """
  delete_auth_sso_providers_by_pk(id: uuid!): auth_sso_providers

  """
  delete data from the table: "auth.users"
  """
  delete_auth_users(
    """filter the rows which have to be deleted"""
    where: auth_users_bool_exp!
  ): auth_users_mutation_response

  """
  delete single row from the table: "auth.users"
  """
  delete_auth_users_by_pk(id: uuid!): auth_users

  """
  delete data from the table: "booking_requests"
  """
  delete_booking_requests(
    """filter the rows which have to be deleted"""
    where: booking_requests_bool_exp!
  ): booking_requests_mutation_response

  """
  delete single row from the table: "booking_requests"
  """
  delete_booking_requests_by_pk(id: uuid!): booking_requests

  """
  delete data from the table: "bookings"
  """
  delete_bookings(
    """filter the rows which have to be deleted"""
    where: bookings_bool_exp!
  ): bookings_mutation_response

  """
  delete single row from the table: "bookings"
  """
  delete_bookings_by_pk(id: uuid!): bookings

  """
  delete data from the table: "calendar_events"
  """
  delete_calendar_events(
    """filter the rows which have to be deleted"""
    where: calendar_events_bool_exp!
  ): calendar_events_mutation_response

  """
  delete single row from the table: "calendar_events"
  """
  delete_calendar_events_by_pk(id: uuid!): calendar_events

  """
  delete data from the table: "client_satisfaction_ratings"
  """
  delete_client_satisfaction_ratings(
    """filter the rows which have to be deleted"""
    where: client_satisfaction_ratings_bool_exp!
  ): client_satisfaction_ratings_mutation_response

  """
  delete single row from the table: "client_satisfaction_ratings"
  """
  delete_client_satisfaction_ratings_by_pk(id: uuid!): client_satisfaction_ratings

  """
  delete data from the table: "compliance_categories"
  """
  delete_compliance_categories(
    """filter the rows which have to be deleted"""
    where: compliance_categories_bool_exp!
  ): compliance_categories_mutation_response

  """
  delete single row from the table: "compliance_categories"
  """
  delete_compliance_categories_by_pk(id: uuid!): compliance_categories

  """
  delete data from the table: "compliance_items"
  """
  delete_compliance_items(
    """filter the rows which have to be deleted"""
    where: compliance_items_bool_exp!
  ): compliance_items_mutation_response

  """
  delete single row from the table: "compliance_items"
  """
  delete_compliance_items_by_pk(id: uuid!): compliance_items

  """
  delete data from the table: "contact_fees"
  """
  delete_contact_fees(
    """filter the rows which have to be deleted"""
    where: contact_fees_bool_exp!
  ): contact_fees_mutation_response

  """
  delete single row from the table: "contact_fees"
  """
  delete_contact_fees_by_pk(id: uuid!): contact_fees

  """
  delete data from the table: "content_moderation_flags"
  """
  delete_content_moderation_flags(
    """filter the rows which have to be deleted"""
    where: content_moderation_flags_bool_exp!
  ): content_moderation_flags_mutation_response

  """
  delete single row from the table: "content_moderation_flags"
  """
  delete_content_moderation_flags_by_pk(id: uuid!): content_moderation_flags

  """
  delete data from the table: "conversations"
  """
  delete_conversations(
    """filter the rows which have to be deleted"""
    where: conversations_bool_exp!
  ): conversations_mutation_response

  """
  delete single row from the table: "conversations"
  """
  delete_conversations_by_pk(id: uuid!): conversations

  """
  delete data from the table: "conversion_events"
  """
  delete_conversion_events(
    """filter the rows which have to be deleted"""
    where: conversion_events_bool_exp!
  ): conversion_events_mutation_response

  """
  delete single row from the table: "conversion_events"
  """
  delete_conversion_events_by_pk(id: uuid!): conversion_events

  """
  delete data from the table: "countries"
  """
  delete_countries(
    """filter the rows which have to be deleted"""
    where: countries_bool_exp!
  ): countries_mutation_response

  """
  delete single row from the table: "countries"
  """
  delete_countries_by_pk(id: Int!): countries

  """
  delete data from the table: "country_codes"
  """
  delete_country_codes(
    """filter the rows which have to be deleted"""
    where: country_codes_bool_exp!
  ): country_codes_mutation_response

  """
  delete single row from the table: "country_codes"
  """
  delete_country_codes_by_pk(id: Int!): country_codes

  """
  delete data from the table: "credit_transactions"
  """
  delete_credit_transactions(
    """filter the rows which have to be deleted"""
    where: credit_transactions_bool_exp!
  ): credit_transactions_mutation_response

  """
  delete single row from the table: "credit_transactions"
  """
  delete_credit_transactions_by_pk(id: uuid!): credit_transactions

  """
  delete data from the table: "dispute_evidence"
  """
  delete_dispute_evidence(
    """filter the rows which have to be deleted"""
    where: dispute_evidence_bool_exp!
  ): dispute_evidence_mutation_response

  """
  delete single row from the table: "dispute_evidence"
  """
  delete_dispute_evidence_by_pk(id: uuid!): dispute_evidence

  """
  delete data from the table: "dispute_messages"
  """
  delete_dispute_messages(
    """filter the rows which have to be deleted"""
    where: dispute_messages_bool_exp!
  ): dispute_messages_mutation_response

  """
  delete single row from the table: "dispute_messages"
  """
  delete_dispute_messages_by_pk(id: uuid!): dispute_messages

  """
  delete data from the table: "dispute_parties"
  """
  delete_dispute_parties(
    """filter the rows which have to be deleted"""
    where: dispute_parties_bool_exp!
  ): dispute_parties_mutation_response

  """
  delete single row from the table: "dispute_parties"
  """
  delete_dispute_parties_by_pk(id: uuid!): dispute_parties

  """
  delete data from the table: "disputes"
  """
  delete_disputes(
    """filter the rows which have to be deleted"""
    where: disputes_bool_exp!
  ): disputes_mutation_response

  """
  delete single row from the table: "disputes"
  """
  delete_disputes_by_pk(id: uuid!): disputes

  """
  delete data from the table: "favorites"
  """
  delete_favorites(
    """filter the rows which have to be deleted"""
    where: favorites_bool_exp!
  ): favorites_mutation_response

  """
  delete single row from the table: "favorites"
  """
  delete_favorites_by_pk(id: uuid!): favorites

  """
  delete data from the table: "interview_notifications"
  """
  delete_interview_notifications(
    """filter the rows which have to be deleted"""
    where: interview_notifications_bool_exp!
  ): interview_notifications_mutation_response

  """
  delete single row from the table: "interview_notifications"
  """
  delete_interview_notifications_by_pk(id: uuid!): interview_notifications

  """
  delete data from the table: "interview_platform_templates"
  """
  delete_interview_platform_templates(
    """filter the rows which have to be deleted"""
    where: interview_platform_templates_bool_exp!
  ): interview_platform_templates_mutation_response

  """
  delete single row from the table: "interview_platform_templates"
  """
  delete_interview_platform_templates_by_pk(id: uuid!): interview_platform_templates

  """
  delete data from the table: "job_applications"
  """
  delete_job_applications(
    """filter the rows which have to be deleted"""
    where: job_applications_bool_exp!
  ): job_applications_mutation_response

  """
  delete single row from the table: "job_applications"
  """
  delete_job_applications_by_pk(id: uuid!): job_applications

  """
  delete data from the table: "job_postings"
  """
  delete_job_postings(
    """filter the rows which have to be deleted"""
    where: job_postings_bool_exp!
  ): job_postings_mutation_response

  """
  delete data from the table: "jobs"
  """
  delete_jobs(
    """filter the rows which have to be deleted"""
    where: jobs_bool_exp!
  ): jobs_mutation_response

  """
  delete single row from the table: "jobs"
  """
  delete_jobs_by_pk(id: uuid!): jobs

  """
  delete data from the table: "maid_bookings"
  """
  delete_maid_bookings(
    """filter the rows which have to be deleted"""
    where: maid_bookings_bool_exp!
  ): maid_bookings_mutation_response

  """
  delete single row from the table: "maid_bookings"
  """
  delete_maid_bookings_by_pk(id: uuid!): maid_bookings

  """
  delete data from the table: "maid_documents"
  """
  delete_maid_documents(
    """filter the rows which have to be deleted"""
    where: maid_documents_bool_exp!
  ): maid_documents_mutation_response

  """
  delete single row from the table: "maid_documents"
  """
  delete_maid_documents_by_pk(id: uuid!): maid_documents

  """
  delete data from the table: "maid_images"
  """
  delete_maid_images(
    """filter the rows which have to be deleted"""
    where: maid_images_bool_exp!
  ): maid_images_mutation_response

  """
  delete single row from the table: "maid_images"
  """
  delete_maid_images_by_pk(id: uuid!): maid_images

  """
  delete data from the table: "maid_profiles"
  """
  delete_maid_profiles(
    """filter the rows which have to be deleted"""
    where: maid_profiles_bool_exp!
  ): maid_profiles_mutation_response

  """
  delete single row from the table: "maid_profiles"
  """
  delete_maid_profiles_by_pk(id: String!): maid_profiles

  """
  delete data from the table: "maid_videos"
  """
  delete_maid_videos(
    """filter the rows which have to be deleted"""
    where: maid_videos_bool_exp!
  ): maid_videos_mutation_response

  """
  delete single row from the table: "maid_videos"
  """
  delete_maid_videos_by_pk(id: uuid!): maid_videos

  """
  delete data from the table: "message_templates"
  """
  delete_message_templates(
    """filter the rows which have to be deleted"""
    where: message_templates_bool_exp!
  ): message_templates_mutation_response

  """
  delete single row from the table: "message_templates"
  """
  delete_message_templates_by_pk(id: uuid!): message_templates

  """
  delete data from the table: "messages"
  """
  delete_messages(
    """filter the rows which have to be deleted"""
    where: messages_bool_exp!
  ): messages_mutation_response

  """
  delete single row from the table: "messages"
  """
  delete_messages_by_pk(id: uuid!): messages

  """
  delete data from the table: "news_items"
  """
  delete_news_items(
    """filter the rows which have to be deleted"""
    where: news_items_bool_exp!
  ): news_items_mutation_response

  """
  delete single row from the table: "news_items"
  """
  delete_news_items_by_pk(id: uuid!): news_items

  """
  delete data from the table: "news_sources"
  """
  delete_news_sources(
    """filter the rows which have to be deleted"""
    where: news_sources_bool_exp!
  ): news_sources_mutation_response

  """
  delete single row from the table: "news_sources"
  """
  delete_news_sources_by_pk(id: uuid!): news_sources

  """
  delete data from the table: "notifications"
  """
  delete_notifications(
    """filter the rows which have to be deleted"""
    where: notifications_bool_exp!
  ): notifications_mutation_response

  """
  delete single row from the table: "notifications"
  """
  delete_notifications_by_pk(id: uuid!): notifications

  """
  delete data from the table: "page_views"
  """
  delete_page_views(
    """filter the rows which have to be deleted"""
    where: page_views_bool_exp!
  ): page_views_mutation_response

  """
  delete single row from the table: "page_views"
  """
  delete_page_views_by_pk(id: uuid!): page_views

  """
  delete data from the table: "password_resets"
  """
  delete_password_resets(
    """filter the rows which have to be deleted"""
    where: password_resets_bool_exp!
  ): password_resets_mutation_response

  """
  delete single row from the table: "password_resets"
  """
  delete_password_resets_by_pk(
    """Unique identifier for the password reset request"""
    id: uuid!
  ): password_resets

  """
  delete data from the table: "payment_idempotency"
  """
  delete_payment_idempotency(
    """filter the rows which have to be deleted"""
    where: payment_idempotency_bool_exp!
  ): payment_idempotency_mutation_response

  """
  delete single row from the table: "payment_idempotency"
  """
  delete_payment_idempotency_by_pk(id: uuid!): payment_idempotency

  """
  delete data from the table: "payment_methods"
  """
  delete_payment_methods(
    """filter the rows which have to be deleted"""
    where: payment_methods_bool_exp!
  ): payment_methods_mutation_response

  """
  delete single row from the table: "payment_methods"
  """
  delete_payment_methods_by_pk(id: uuid!): payment_methods

  """
  delete data from the table: "payments"
  """
  delete_payments(
    """filter the rows which have to be deleted"""
    where: payments_bool_exp!
  ): payments_mutation_response

  """
  delete single row from the table: "payments"
  """
  delete_payments_by_pk(id: uuid!): payments

  """
  delete data from the table: "payout_accounts"
  """
  delete_payout_accounts(
    """filter the rows which have to be deleted"""
    where: payout_accounts_bool_exp!
  ): payout_accounts_mutation_response

  """
  delete single row from the table: "payout_accounts"
  """
  delete_payout_accounts_by_pk(id: uuid!): payout_accounts

  """
  delete data from the table: "payout_schedules"
  """
  delete_payout_schedules(
    """filter the rows which have to be deleted"""
    where: payout_schedules_bool_exp!
  ): payout_schedules_mutation_response

  """
  delete single row from the table: "payout_schedules"
  """
  delete_payout_schedules_by_pk(id: uuid!): payout_schedules

  """
  delete data from the table: "phone_verification_log"
  """
  delete_phone_verification_log(
    """filter the rows which have to be deleted"""
    where: phone_verification_log_bool_exp!
  ): phone_verification_log_mutation_response

  """
  delete single row from the table: "phone_verification_log"
  """
  delete_phone_verification_log_by_pk(id: uuid!): phone_verification_log

  """
  delete data from the table: "phone_verifications"
  """
  delete_phone_verifications(
    """filter the rows which have to be deleted"""
    where: phone_verifications_bool_exp!
  ): phone_verifications_mutation_response

  """
  delete single row from the table: "phone_verifications"
  """
  delete_phone_verifications_by_pk(id: uuid!): phone_verifications

  """
  delete data from the table: "pii_access_log"
  """
  delete_pii_access_log(
    """filter the rows which have to be deleted"""
    where: pii_access_log_bool_exp!
  ): pii_access_log_mutation_response

  """
  delete single row from the table: "pii_access_log"
  """
  delete_pii_access_log_by_pk(id: uuid!): pii_access_log

  """
  delete data from the table: "placement_contracts"
  """
  delete_placement_contracts(
    """filter the rows which have to be deleted"""
    where: placement_contracts_bool_exp!
  ): placement_contracts_mutation_response

  """
  delete single row from the table: "placement_contracts"
  """
  delete_placement_contracts_by_pk(id: uuid!): placement_contracts

  """
  delete data from the table: "placement_fee_transactions"
  """
  delete_placement_fee_transactions(
    """filter the rows which have to be deleted"""
    where: placement_fee_transactions_bool_exp!
  ): placement_fee_transactions_mutation_response

  """
  delete single row from the table: "placement_fee_transactions"
  """
  delete_placement_fee_transactions_by_pk(id: uuid!): placement_fee_transactions

  """
  delete data from the table: "platform_announcements"
  """
  delete_platform_announcements(
    """filter the rows which have to be deleted"""
    where: platform_announcements_bool_exp!
  ): platform_announcements_mutation_response

  """
  delete single row from the table: "platform_announcements"
  """
  delete_platform_announcements_by_pk(id: uuid!): platform_announcements

  """
  delete data from the table: "platform_settings"
  """
  delete_platform_settings(
    """filter the rows which have to be deleted"""
    where: platform_settings_bool_exp!
  ): platform_settings_mutation_response

  """
  delete single row from the table: "platform_settings"
  """
  delete_platform_settings_by_pk(id: uuid!): platform_settings

  """
  delete data from the table: "profiles"
  """
  delete_profiles(
    """filter the rows which have to be deleted"""
    where: profiles_bool_exp!
  ): profiles_mutation_response

  """
  delete single row from the table: "profiles"
  """
  delete_profiles_by_pk(id: String!): profiles

  """
  delete data from the table: "realtime.messages"
  """
  delete_realtime_messages(
    """filter the rows which have to be deleted"""
    where: realtime_messages_bool_exp!
  ): realtime_messages_mutation_response

  """
  delete single row from the table: "realtime.messages"
  """
  delete_realtime_messages_by_pk(id: uuid!, inserted_at: timestamp!): realtime_messages

  """
  delete data from the table: "realtime.subscription"
  """
  delete_realtime_subscription(
    """filter the rows which have to be deleted"""
    where: realtime_subscription_bool_exp!
  ): realtime_subscription_mutation_response

  """
  delete single row from the table: "realtime.subscription"
  """
  delete_realtime_subscription_by_pk(id: bigint!): realtime_subscription

  """
  delete data from the table: "reviews"
  """
  delete_reviews(
    """filter the rows which have to be deleted"""
    where: reviews_bool_exp!
  ): reviews_mutation_response

  """
  delete single row from the table: "reviews"
  """
  delete_reviews_by_pk(id: uuid!): reviews

  """
  delete data from the table: "security_events"
  """
  delete_security_events(
    """filter the rows which have to be deleted"""
    where: security_events_bool_exp!
  ): security_events_mutation_response

  """
  delete single row from the table: "security_events"
  """
  delete_security_events_by_pk(id: uuid!): security_events

  """
  delete data from the table: "shortlist_candidates"
  """
  delete_shortlist_candidates(
    """filter the rows which have to be deleted"""
    where: shortlist_candidates_bool_exp!
  ): shortlist_candidates_mutation_response

  """
  delete single row from the table: "shortlist_candidates"
  """
  delete_shortlist_candidates_by_pk(id: uuid!): shortlist_candidates

  """
  delete data from the table: "shortlists"
  """
  delete_shortlists(
    """filter the rows which have to be deleted"""
    where: shortlists_bool_exp!
  ): shortlists_mutation_response

  """
  delete single row from the table: "shortlists"
  """
  delete_shortlists_by_pk(id: uuid!): shortlists

  """
  delete data from the table: "skills"
  """
  delete_skills(
    """filter the rows which have to be deleted"""
    where: skills_bool_exp!
  ): skills_mutation_response

  """
  delete single row from the table: "skills"
  """
  delete_skills_by_pk(id: Int!): skills

  """
  delete data from the table: "sponsor_document_verification"
  """
  delete_sponsor_document_verification(
    """filter the rows which have to be deleted"""
    where: sponsor_document_verification_bool_exp!
  ): sponsor_document_verification_mutation_response

  """
  delete single row from the table: "sponsor_document_verification"
  """
  delete_sponsor_document_verification_by_pk(id: uuid!): sponsor_document_verification

  """
  delete data from the table: "sponsor_jobs"
  """
  delete_sponsor_jobs(
    """filter the rows which have to be deleted"""
    where: sponsor_jobs_bool_exp!
  ): sponsor_jobs_mutation_response

  """
  delete single row from the table: "sponsor_jobs"
  """
  delete_sponsor_jobs_by_pk(id: uuid!): sponsor_jobs

  """
  delete data from the table: "sponsor_profiles"
  """
  delete_sponsor_profiles(
    """filter the rows which have to be deleted"""
    where: sponsor_profiles_bool_exp!
  ): sponsor_profiles_mutation_response

  """
  delete single row from the table: "sponsor_profiles"
  """
  delete_sponsor_profiles_by_pk(id: String!): sponsor_profiles

  """
  delete data from the table: "sponsors"
  """
  delete_sponsors(
    """filter the rows which have to be deleted"""
    where: sponsors_bool_exp!
  ): sponsors_mutation_response

  """
  delete single row from the table: "sponsors"
  """
  delete_sponsors_by_pk(id: uuid!): sponsors

  """
  delete data from the table: "storage.buckets"
  """
  delete_storage_buckets(
    """filter the rows which have to be deleted"""
    where: storage_buckets_bool_exp!
  ): storage_buckets_mutation_response

  """
  delete data from the table: "storage.buckets_analytics"
  """
  delete_storage_buckets_analytics(
    """filter the rows which have to be deleted"""
    where: storage_buckets_analytics_bool_exp!
  ): storage_buckets_analytics_mutation_response

  """
  delete single row from the table: "storage.buckets_analytics"
  """
  delete_storage_buckets_analytics_by_pk(id: uuid!): storage_buckets_analytics

  """
  delete single row from the table: "storage.buckets"
  """
  delete_storage_buckets_by_pk(id: String!): storage_buckets

  """
  delete data from the table: "storage.migrations"
  """
  delete_storage_migrations(
    """filter the rows which have to be deleted"""
    where: storage_migrations_bool_exp!
  ): storage_migrations_mutation_response

  """
  delete single row from the table: "storage.migrations"
  """
  delete_storage_migrations_by_pk(id: Int!): storage_migrations

  """
  delete data from the table: "storage.objects"
  """
  delete_storage_objects(
    """filter the rows which have to be deleted"""
    where: storage_objects_bool_exp!
  ): storage_objects_mutation_response

  """
  delete single row from the table: "storage.objects"
  """
  delete_storage_objects_by_pk(id: uuid!): storage_objects

  """
  delete data from the table: "storage.prefixes"
  """
  delete_storage_prefixes(
    """filter the rows which have to be deleted"""
    where: storage_prefixes_bool_exp!
  ): storage_prefixes_mutation_response

  """
  delete single row from the table: "storage.prefixes"
  """
  delete_storage_prefixes_by_pk(bucket_id: String!, level: Int!, name: String!): storage_prefixes

  """
  delete data from the table: "storage.s3_multipart_uploads"
  """
  delete_storage_s3_multipart_uploads(
    """filter the rows which have to be deleted"""
    where: storage_s3_multipart_uploads_bool_exp!
  ): storage_s3_multipart_uploads_mutation_response

  """
  delete single row from the table: "storage.s3_multipart_uploads"
  """
  delete_storage_s3_multipart_uploads_by_pk(id: String!): storage_s3_multipart_uploads

  """
  delete data from the table: "storage.s3_multipart_uploads_parts"
  """
  delete_storage_s3_multipart_uploads_parts(
    """filter the rows which have to be deleted"""
    where: storage_s3_multipart_uploads_parts_bool_exp!
  ): storage_s3_multipart_uploads_parts_mutation_response

  """
  delete single row from the table: "storage.s3_multipart_uploads_parts"
  """
  delete_storage_s3_multipart_uploads_parts_by_pk(id: uuid!): storage_s3_multipart_uploads_parts

  """
  delete data from the table: "subscription_limits"
  """
  delete_subscription_limits(
    """filter the rows which have to be deleted"""
    where: subscription_limits_bool_exp!
  ): subscription_limits_mutation_response

  """
  delete single row from the table: "subscription_limits"
  """
  delete_subscription_limits_by_pk(id: uuid!): subscription_limits

  """
  delete data from the table: "subscription_status_log"
  """
  delete_subscription_status_log(
    """filter the rows which have to be deleted"""
    where: subscription_status_log_bool_exp!
  ): subscription_status_log_mutation_response

  """
  delete single row from the table: "subscription_status_log"
  """
  delete_subscription_status_log_by_pk(id: uuid!): subscription_status_log

  """
  delete data from the table: "subscription_usage"
  """
  delete_subscription_usage(
    """filter the rows which have to be deleted"""
    where: subscription_usage_bool_exp!
  ): subscription_usage_mutation_response

  """
  delete single row from the table: "subscription_usage"
  """
  delete_subscription_usage_by_pk(id: uuid!): subscription_usage

  """
  delete data from the table: "subscriptions"
  """
  delete_subscriptions(
    """filter the rows which have to be deleted"""
    where: subscriptions_bool_exp!
  ): subscriptions_mutation_response

  """
  delete single row from the table: "subscriptions"
  """
  delete_subscriptions_by_pk(id: uuid!): subscriptions

  """
  delete data from the table: "supabase_migrations.schema_migrations"
  """
  delete_supabase_migrations_schema_migrations(
    """filter the rows which have to be deleted"""
    where: supabase_migrations_schema_migrations_bool_exp!
  ): supabase_migrations_schema_migrations_mutation_response

  """
  delete single row from the table: "supabase_migrations.schema_migrations"
  """
  delete_supabase_migrations_schema_migrations_by_pk(version: String!): supabase_migrations_schema_migrations

  """
  delete data from the table: "supabase_migrations.seed_files"
  """
  delete_supabase_migrations_seed_files(
    """filter the rows which have to be deleted"""
    where: supabase_migrations_seed_files_bool_exp!
  ): supabase_migrations_seed_files_mutation_response

  """
  delete single row from the table: "supabase_migrations.seed_files"
  """
  delete_supabase_migrations_seed_files_by_pk(path: String!): supabase_migrations_seed_files

  """
  delete data from the table: "support_agents"
  """
  delete_support_agents(
    """filter the rows which have to be deleted"""
    where: support_agents_bool_exp!
  ): support_agents_mutation_response

  """
  delete single row from the table: "support_agents"
  """
  delete_support_agents_by_pk(id: uuid!): support_agents

  """
  delete data from the table: "support_interactions"
  """
  delete_support_interactions(
    """filter the rows which have to be deleted"""
    where: support_interactions_bool_exp!
  ): support_interactions_mutation_response

  """
  delete single row from the table: "support_interactions"
  """
  delete_support_interactions_by_pk(id: uuid!): support_interactions

  """
  delete data from the table: "support_messages"
  """
  delete_support_messages(
    """filter the rows which have to be deleted"""
    where: support_messages_bool_exp!
  ): support_messages_mutation_response

  """
  delete single row from the table: "support_messages"
  """
  delete_support_messages_by_pk(id: uuid!): support_messages

  """
  delete data from the table: "support_tickets"
  """
  delete_support_tickets(
    """filter the rows which have to be deleted"""
    where: support_tickets_bool_exp!
  ): support_tickets_mutation_response

  """
  delete single row from the table: "support_tickets"
  """
  delete_support_tickets_by_pk(id: uuid!): support_tickets

  """
  delete data from the table: "system_settings"
  """
  delete_system_settings(
    """filter the rows which have to be deleted"""
    where: system_settings_bool_exp!
  ): system_settings_mutation_response

  """
  delete single row from the table: "system_settings"
  """
  delete_system_settings_by_pk(id: uuid!): system_settings

  """
  delete data from the table: "team_member_performance"
  """
  delete_team_member_performance(
    """filter the rows which have to be deleted"""
    where: team_member_performance_bool_exp!
  ): team_member_performance_mutation_response

  """
  delete single row from the table: "team_member_performance"
  """
  delete_team_member_performance_by_pk(id: uuid!): team_member_performance

  """
  delete data from the table: "two_factor_backup_codes"
  """
  delete_two_factor_backup_codes(
    """filter the rows which have to be deleted"""
    where: two_factor_backup_codes_bool_exp!
  ): two_factor_backup_codes_mutation_response

  """
  delete single row from the table: "two_factor_backup_codes"
  """
  delete_two_factor_backup_codes_by_pk(id: uuid!): two_factor_backup_codes

  """
  delete data from the table: "user_credits"
  """
  delete_user_credits(
    """filter the rows which have to be deleted"""
    where: user_credits_bool_exp!
  ): user_credits_mutation_response

  """
  delete single row from the table: "user_credits"
  """
  delete_user_credits_by_pk(id: uuid!): user_credits

  """
  delete data from the table: "user_events"
  """
  delete_user_events(
    """filter the rows which have to be deleted"""
    where: user_events_bool_exp!
  ): user_events_mutation_response

  """
  delete single row from the table: "user_events"
  """
  delete_user_events_by_pk(id: uuid!): user_events

  """
  delete data from the table: "user_sessions"
  """
  delete_user_sessions(
    """filter the rows which have to be deleted"""
    where: user_sessions_bool_exp!
  ): user_sessions_mutation_response

  """
  delete single row from the table: "user_sessions"
  """
  delete_user_sessions_by_pk(id: uuid!): user_sessions

  """
  delete data from the table: "video_interviews"
  """
  delete_video_interviews(
    """filter the rows which have to be deleted"""
    where: video_interviews_bool_exp!
  ): video_interviews_mutation_response

  """
  delete single row from the table: "video_interviews"
  """
  delete_video_interviews_by_pk(id: uuid!): video_interviews

  """
  delete data from the table: "webhook_event_logs"
  """
  delete_webhook_event_logs(
    """filter the rows which have to be deleted"""
    where: webhook_event_logs_bool_exp!
  ): webhook_event_logs_mutation_response

  """
  delete single row from the table: "webhook_event_logs"
  """
  delete_webhook_event_logs_by_pk(id: uuid!): webhook_event_logs

  """
  delete data from the table: "whatsapp_messages"
  """
  delete_whatsapp_messages(
    """filter the rows which have to be deleted"""
    where: whatsapp_messages_bool_exp!
  ): whatsapp_messages_mutation_response

  """
  delete single row from the table: "whatsapp_messages"
  """
  delete_whatsapp_messages_by_pk(id: uuid!): whatsapp_messages

  """
  delete data from the table: "work_experience"
  """
  delete_work_experience(
    """filter the rows which have to be deleted"""
    where: work_experience_bool_exp!
  ): work_experience_mutation_response

  """
  delete single row from the table: "work_experience"
  """
  delete_work_experience_by_pk(id: uuid!): work_experience

  """
  execute VOLATILE function "get_current_usage" which returns "subscription_usage"
  """
  get_current_usage(
    """
    input parameters for function "get_current_usage"
    """
    args: get_current_usage_args!

    """distinct select on columns"""
    distinct_on: [subscription_usage_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscription_usage_order_by!]

    """filter the rows returned"""
    where: subscription_usage_bool_exp
  ): [subscription_usage!]!

  """
  insert data into the table: "activity_announcements"
  """
  insert_activity_announcements(
    """the rows to be inserted"""
    objects: [activity_announcements_insert_input!]!

    """upsert condition"""
    on_conflict: activity_announcements_on_conflict
  ): activity_announcements_mutation_response

  """
  insert a single row into the table: "activity_announcements"
  """
  insert_activity_announcements_one(
    """the row to be inserted"""
    object: activity_announcements_insert_input!

    """upsert condition"""
    on_conflict: activity_announcements_on_conflict
  ): activity_announcements

  """
  insert data into the table: "activity_log"
  """
  insert_activity_log(
    """the rows to be inserted"""
    objects: [activity_log_insert_input!]!

    """upsert condition"""
    on_conflict: activity_log_on_conflict
  ): activity_log_mutation_response

  """
  insert a single row into the table: "activity_log"
  """
  insert_activity_log_one(
    """the row to be inserted"""
    object: activity_log_insert_input!

    """upsert condition"""
    on_conflict: activity_log_on_conflict
  ): activity_log

  """
  insert data into the table: "admin_activity_logs"
  """
  insert_admin_activity_logs(
    """the rows to be inserted"""
    objects: [admin_activity_logs_insert_input!]!

    """upsert condition"""
    on_conflict: admin_activity_logs_on_conflict
  ): admin_activity_logs_mutation_response

  """
  insert a single row into the table: "admin_activity_logs"
  """
  insert_admin_activity_logs_one(
    """the row to be inserted"""
    object: admin_activity_logs_insert_input!

    """upsert condition"""
    on_conflict: admin_activity_logs_on_conflict
  ): admin_activity_logs

  """
  insert data into the table: "admin_users"
  """
  insert_admin_users(
    """the rows to be inserted"""
    objects: [admin_users_insert_input!]!

    """upsert condition"""
    on_conflict: admin_users_on_conflict
  ): admin_users_mutation_response

  """
  insert a single row into the table: "admin_users"
  """
  insert_admin_users_one(
    """the row to be inserted"""
    object: admin_users_insert_input!

    """upsert condition"""
    on_conflict: admin_users_on_conflict
  ): admin_users

  """
  insert data into the table: "agency_audit_logs"
  """
  insert_agency_audit_logs(
    """the rows to be inserted"""
    objects: [agency_audit_logs_insert_input!]!

    """upsert condition"""
    on_conflict: agency_audit_logs_on_conflict
  ): agency_audit_logs_mutation_response

  """
  insert a single row into the table: "agency_audit_logs"
  """
  insert_agency_audit_logs_one(
    """the row to be inserted"""
    object: agency_audit_logs_insert_input!

    """upsert condition"""
    on_conflict: agency_audit_logs_on_conflict
  ): agency_audit_logs

  """
  insert data into the table: "agency_credits"
  """
  insert_agency_credits(
    """the rows to be inserted"""
    objects: [agency_credits_insert_input!]!

    """upsert condition"""
    on_conflict: agency_credits_on_conflict
  ): agency_credits_mutation_response

  """
  insert a single row into the table: "agency_credits"
  """
  insert_agency_credits_one(
    """the row to be inserted"""
    object: agency_credits_insert_input!

    """upsert condition"""
    on_conflict: agency_credits_on_conflict
  ): agency_credits

  """
  insert data into the table: "agency_disputes"
  """
  insert_agency_disputes(
    """the rows to be inserted"""
    objects: [agency_disputes_insert_input!]!

    """upsert condition"""
    on_conflict: agency_disputes_on_conflict
  ): agency_disputes_mutation_response

  """
  insert a single row into the table: "agency_disputes"
  """
  insert_agency_disputes_one(
    """the row to be inserted"""
    object: agency_disputes_insert_input!

    """upsert condition"""
    on_conflict: agency_disputes_on_conflict
  ): agency_disputes

  """
  insert data into the table: "agency_document_requirements"
  """
  insert_agency_document_requirements(
    """the rows to be inserted"""
    objects: [agency_document_requirements_insert_input!]!

    """upsert condition"""
    on_conflict: agency_document_requirements_on_conflict
  ): agency_document_requirements_mutation_response

  """
  insert a single row into the table: "agency_document_requirements"
  """
  insert_agency_document_requirements_one(
    """the row to be inserted"""
    object: agency_document_requirements_insert_input!

    """upsert condition"""
    on_conflict: agency_document_requirements_on_conflict
  ): agency_document_requirements

  """
  insert data into the table: "agency_documents"
  """
  insert_agency_documents(
    """the rows to be inserted"""
    objects: [agency_documents_insert_input!]!

    """upsert condition"""
    on_conflict: agency_documents_on_conflict
  ): agency_documents_mutation_response

  """
  insert a single row into the table: "agency_documents"
  """
  insert_agency_documents_one(
    """the row to be inserted"""
    object: agency_documents_insert_input!

    """upsert condition"""
    on_conflict: agency_documents_on_conflict
  ): agency_documents

  """
  insert data into the table: "agency_earnings"
  """
  insert_agency_earnings(
    """the rows to be inserted"""
    objects: [agency_earnings_insert_input!]!

    """upsert condition"""
    on_conflict: agency_earnings_on_conflict
  ): agency_earnings_mutation_response

  """
  insert a single row into the table: "agency_earnings"
  """
  insert_agency_earnings_one(
    """the row to be inserted"""
    object: agency_earnings_insert_input!

    """upsert condition"""
    on_conflict: agency_earnings_on_conflict
  ): agency_earnings

  """
  insert data into the table: "agency_interviews"
  """
  insert_agency_interviews(
    """the rows to be inserted"""
    objects: [agency_interviews_insert_input!]!

    """upsert condition"""
    on_conflict: agency_interviews_on_conflict
  ): agency_interviews_mutation_response

  """
  insert a single row into the table: "agency_interviews"
  """
  insert_agency_interviews_one(
    """the row to be inserted"""
    object: agency_interviews_insert_input!

    """upsert condition"""
    on_conflict: agency_interviews_on_conflict
  ): agency_interviews

  """
  insert data into the table: "agency_jobs"
  """
  insert_agency_jobs(
    """the rows to be inserted"""
    objects: [agency_jobs_insert_input!]!

    """upsert condition"""
    on_conflict: agency_jobs_on_conflict
  ): agency_jobs_mutation_response

  """
  insert a single row into the table: "agency_jobs"
  """
  insert_agency_jobs_one(
    """the row to be inserted"""
    object: agency_jobs_insert_input!

    """upsert condition"""
    on_conflict: agency_jobs_on_conflict
  ): agency_jobs

  """
  insert data into the table: "agency_kyb_audit_log"
  """
  insert_agency_kyb_audit_log(
    """the rows to be inserted"""
    objects: [agency_kyb_audit_log_insert_input!]!

    """upsert condition"""
    on_conflict: agency_kyb_audit_log_on_conflict
  ): agency_kyb_audit_log_mutation_response

  """
  insert a single row into the table: "agency_kyb_audit_log"
  """
  insert_agency_kyb_audit_log_one(
    """the row to be inserted"""
    object: agency_kyb_audit_log_insert_input!

    """upsert condition"""
    on_conflict: agency_kyb_audit_log_on_conflict
  ): agency_kyb_audit_log

  """
  insert data into the table: "agency_kyb_documents"
  """
  insert_agency_kyb_documents(
    """the rows to be inserted"""
    objects: [agency_kyb_documents_insert_input!]!

    """upsert condition"""
    on_conflict: agency_kyb_documents_on_conflict
  ): agency_kyb_documents_mutation_response

  """
  insert a single row into the table: "agency_kyb_documents"
  """
  insert_agency_kyb_documents_one(
    """the row to be inserted"""
    object: agency_kyb_documents_insert_input!

    """upsert condition"""
    on_conflict: agency_kyb_documents_on_conflict
  ): agency_kyb_documents

  """
  insert data into the table: "agency_kyb_verification"
  """
  insert_agency_kyb_verification(
    """the rows to be inserted"""
    objects: [agency_kyb_verification_insert_input!]!

    """upsert condition"""
    on_conflict: agency_kyb_verification_on_conflict
  ): agency_kyb_verification_mutation_response

  """
  insert a single row into the table: "agency_kyb_verification"
  """
  insert_agency_kyb_verification_one(
    """the row to be inserted"""
    object: agency_kyb_verification_insert_input!

    """upsert condition"""
    on_conflict: agency_kyb_verification_on_conflict
  ): agency_kyb_verification

  """
  insert data into the table: "agency_payment_failures"
  """
  insert_agency_payment_failures(
    """the rows to be inserted"""
    objects: [agency_payment_failures_insert_input!]!

    """upsert condition"""
    on_conflict: agency_payment_failures_on_conflict
  ): agency_payment_failures_mutation_response

  """
  insert a single row into the table: "agency_payment_failures"
  """
  insert_agency_payment_failures_one(
    """the row to be inserted"""
    object: agency_payment_failures_insert_input!

    """upsert condition"""
    on_conflict: agency_payment_failures_on_conflict
  ): agency_payment_failures

  """
  insert data into the table: "agency_payouts"
  """
  insert_agency_payouts(
    """the rows to be inserted"""
    objects: [agency_payouts_insert_input!]!

    """upsert condition"""
    on_conflict: agency_payouts_on_conflict
  ): agency_payouts_mutation_response

  """
  insert a single row into the table: "agency_payouts"
  """
  insert_agency_payouts_one(
    """the row to be inserted"""
    object: agency_payouts_insert_input!

    """upsert condition"""
    on_conflict: agency_payouts_on_conflict
  ): agency_payouts

  """
  insert data into the table: "agency_placements"
  """
  insert_agency_placements(
    """the rows to be inserted"""
    objects: [agency_placements_insert_input!]!

    """upsert condition"""
    on_conflict: agency_placements_on_conflict
  ): agency_placements_mutation_response

  """
  insert a single row into the table: "agency_placements"
  """
  insert_agency_placements_one(
    """the row to be inserted"""
    object: agency_placements_insert_input!

    """upsert condition"""
    on_conflict: agency_placements_on_conflict
  ): agency_placements

  """
  insert data into the table: "agency_profiles"
  """
  insert_agency_profiles(
    """the rows to be inserted"""
    objects: [agency_profiles_insert_input!]!

    """upsert condition"""
    on_conflict: agency_profiles_on_conflict
  ): agency_profiles_mutation_response

  """
  insert a single row into the table: "agency_profiles"
  """
  insert_agency_profiles_one(
    """the row to be inserted"""
    object: agency_profiles_insert_input!

    """upsert condition"""
    on_conflict: agency_profiles_on_conflict
  ): agency_profiles

  """
  insert data into the table: "agency_tasks"
  """
  insert_agency_tasks(
    """the rows to be inserted"""
    objects: [agency_tasks_insert_input!]!

    """upsert condition"""
    on_conflict: agency_tasks_on_conflict
  ): agency_tasks_mutation_response

  """
  insert a single row into the table: "agency_tasks"
  """
  insert_agency_tasks_one(
    """the row to be inserted"""
    object: agency_tasks_insert_input!

    """upsert condition"""
    on_conflict: agency_tasks_on_conflict
  ): agency_tasks

  """
  insert data into the table: "agency_team_members"
  """
  insert_agency_team_members(
    """the rows to be inserted"""
    objects: [agency_team_members_insert_input!]!

    """upsert condition"""
    on_conflict: agency_team_members_on_conflict
  ): agency_team_members_mutation_response

  """
  insert a single row into the table: "agency_team_members"
  """
  insert_agency_team_members_one(
    """the row to be inserted"""
    object: agency_team_members_insert_input!

    """upsert condition"""
    on_conflict: agency_team_members_on_conflict
  ): agency_team_members

  """
  insert data into the table: "analytics_cache"
  """
  insert_analytics_cache(
    """the rows to be inserted"""
    objects: [analytics_cache_insert_input!]!

    """upsert condition"""
    on_conflict: analytics_cache_on_conflict
  ): analytics_cache_mutation_response

  """
  insert a single row into the table: "analytics_cache"
  """
  insert_analytics_cache_one(
    """the row to be inserted"""
    object: analytics_cache_insert_input!

    """upsert condition"""
    on_conflict: analytics_cache_on_conflict
  ): analytics_cache

  """
  insert data into the table: "announcement_views"
  """
  insert_announcement_views(
    """the rows to be inserted"""
    objects: [announcement_views_insert_input!]!

    """upsert condition"""
    on_conflict: announcement_views_on_conflict
  ): announcement_views_mutation_response

  """
  insert a single row into the table: "announcement_views"
  """
  insert_announcement_views_one(
    """the row to be inserted"""
    object: announcement_views_insert_input!

    """upsert condition"""
    on_conflict: announcement_views_on_conflict
  ): announcement_views

  """
  insert data into the table: "applications"
  """
  insert_applications(
    """the rows to be inserted"""
    objects: [applications_insert_input!]!

    """upsert condition"""
    on_conflict: applications_on_conflict
  ): applications_mutation_response

  """
  insert a single row into the table: "applications"
  """
  insert_applications_one(
    """the row to be inserted"""
    object: applications_insert_input!

    """upsert condition"""
    on_conflict: applications_on_conflict
  ): applications

  """
  insert data into the table: "audit_logs"
  """
  insert_audit_logs(
    """the rows to be inserted"""
    objects: [audit_logs_insert_input!]!

    """upsert condition"""
    on_conflict: audit_logs_on_conflict
  ): audit_logs_mutation_response

  """
  insert a single row into the table: "audit_logs"
  """
  insert_audit_logs_one(
    """the row to be inserted"""
    object: audit_logs_insert_input!

    """upsert condition"""
    on_conflict: audit_logs_on_conflict
  ): audit_logs

  """
  insert data into the table: "auth.audit_log_entries"
  """
  insert_auth_audit_log_entries(
    """the rows to be inserted"""
    objects: [auth_audit_log_entries_insert_input!]!

    """upsert condition"""
    on_conflict: auth_audit_log_entries_on_conflict
  ): auth_audit_log_entries_mutation_response

  """
  insert a single row into the table: "auth.audit_log_entries"
  """
  insert_auth_audit_log_entries_one(
    """the row to be inserted"""
    object: auth_audit_log_entries_insert_input!

    """upsert condition"""
    on_conflict: auth_audit_log_entries_on_conflict
  ): auth_audit_log_entries

  """
  insert data into the table: "auth.flow_state"
  """
  insert_auth_flow_state(
    """the rows to be inserted"""
    objects: [auth_flow_state_insert_input!]!

    """upsert condition"""
    on_conflict: auth_flow_state_on_conflict
  ): auth_flow_state_mutation_response

  """
  insert a single row into the table: "auth.flow_state"
  """
  insert_auth_flow_state_one(
    """the row to be inserted"""
    object: auth_flow_state_insert_input!

    """upsert condition"""
    on_conflict: auth_flow_state_on_conflict
  ): auth_flow_state

  """
  insert data into the table: "auth.identities"
  """
  insert_auth_identities(
    """the rows to be inserted"""
    objects: [auth_identities_insert_input!]!

    """upsert condition"""
    on_conflict: auth_identities_on_conflict
  ): auth_identities_mutation_response

  """
  insert a single row into the table: "auth.identities"
  """
  insert_auth_identities_one(
    """the row to be inserted"""
    object: auth_identities_insert_input!

    """upsert condition"""
    on_conflict: auth_identities_on_conflict
  ): auth_identities

  """
  insert data into the table: "auth.instances"
  """
  insert_auth_instances(
    """the rows to be inserted"""
    objects: [auth_instances_insert_input!]!

    """upsert condition"""
    on_conflict: auth_instances_on_conflict
  ): auth_instances_mutation_response

  """
  insert a single row into the table: "auth.instances"
  """
  insert_auth_instances_one(
    """the row to be inserted"""
    object: auth_instances_insert_input!

    """upsert condition"""
    on_conflict: auth_instances_on_conflict
  ): auth_instances

  """
  insert data into the table: "auth.mfa_amr_claims"
  """
  insert_auth_mfa_amr_claims(
    """the rows to be inserted"""
    objects: [auth_mfa_amr_claims_insert_input!]!

    """upsert condition"""
    on_conflict: auth_mfa_amr_claims_on_conflict
  ): auth_mfa_amr_claims_mutation_response

  """
  insert a single row into the table: "auth.mfa_amr_claims"
  """
  insert_auth_mfa_amr_claims_one(
    """the row to be inserted"""
    object: auth_mfa_amr_claims_insert_input!

    """upsert condition"""
    on_conflict: auth_mfa_amr_claims_on_conflict
  ): auth_mfa_amr_claims

  """
  insert data into the table: "auth.mfa_challenges"
  """
  insert_auth_mfa_challenges(
    """the rows to be inserted"""
    objects: [auth_mfa_challenges_insert_input!]!

    """upsert condition"""
    on_conflict: auth_mfa_challenges_on_conflict
  ): auth_mfa_challenges_mutation_response

  """
  insert a single row into the table: "auth.mfa_challenges"
  """
  insert_auth_mfa_challenges_one(
    """the row to be inserted"""
    object: auth_mfa_challenges_insert_input!

    """upsert condition"""
    on_conflict: auth_mfa_challenges_on_conflict
  ): auth_mfa_challenges

  """
  insert data into the table: "auth.mfa_factors"
  """
  insert_auth_mfa_factors(
    """the rows to be inserted"""
    objects: [auth_mfa_factors_insert_input!]!

    """upsert condition"""
    on_conflict: auth_mfa_factors_on_conflict
  ): auth_mfa_factors_mutation_response

  """
  insert a single row into the table: "auth.mfa_factors"
  """
  insert_auth_mfa_factors_one(
    """the row to be inserted"""
    object: auth_mfa_factors_insert_input!

    """upsert condition"""
    on_conflict: auth_mfa_factors_on_conflict
  ): auth_mfa_factors

  """
  insert data into the table: "auth.oauth_authorizations"
  """
  insert_auth_oauth_authorizations(
    """the rows to be inserted"""
    objects: [auth_oauth_authorizations_insert_input!]!

    """upsert condition"""
    on_conflict: auth_oauth_authorizations_on_conflict
  ): auth_oauth_authorizations_mutation_response

  """
  insert a single row into the table: "auth.oauth_authorizations"
  """
  insert_auth_oauth_authorizations_one(
    """the row to be inserted"""
    object: auth_oauth_authorizations_insert_input!

    """upsert condition"""
    on_conflict: auth_oauth_authorizations_on_conflict
  ): auth_oauth_authorizations

  """
  insert data into the table: "auth.oauth_clients"
  """
  insert_auth_oauth_clients(
    """the rows to be inserted"""
    objects: [auth_oauth_clients_insert_input!]!

    """upsert condition"""
    on_conflict: auth_oauth_clients_on_conflict
  ): auth_oauth_clients_mutation_response

  """
  insert a single row into the table: "auth.oauth_clients"
  """
  insert_auth_oauth_clients_one(
    """the row to be inserted"""
    object: auth_oauth_clients_insert_input!

    """upsert condition"""
    on_conflict: auth_oauth_clients_on_conflict
  ): auth_oauth_clients

  """
  insert data into the table: "auth.oauth_consents"
  """
  insert_auth_oauth_consents(
    """the rows to be inserted"""
    objects: [auth_oauth_consents_insert_input!]!

    """upsert condition"""
    on_conflict: auth_oauth_consents_on_conflict
  ): auth_oauth_consents_mutation_response

  """
  insert a single row into the table: "auth.oauth_consents"
  """
  insert_auth_oauth_consents_one(
    """the row to be inserted"""
    object: auth_oauth_consents_insert_input!

    """upsert condition"""
    on_conflict: auth_oauth_consents_on_conflict
  ): auth_oauth_consents

  """
  insert data into the table: "auth.one_time_tokens"
  """
  insert_auth_one_time_tokens(
    """the rows to be inserted"""
    objects: [auth_one_time_tokens_insert_input!]!

    """upsert condition"""
    on_conflict: auth_one_time_tokens_on_conflict
  ): auth_one_time_tokens_mutation_response

  """
  insert a single row into the table: "auth.one_time_tokens"
  """
  insert_auth_one_time_tokens_one(
    """the row to be inserted"""
    object: auth_one_time_tokens_insert_input!

    """upsert condition"""
    on_conflict: auth_one_time_tokens_on_conflict
  ): auth_one_time_tokens

  """
  insert data into the table: "auth.refresh_tokens"
  """
  insert_auth_refresh_tokens(
    """the rows to be inserted"""
    objects: [auth_refresh_tokens_insert_input!]!

    """upsert condition"""
    on_conflict: auth_refresh_tokens_on_conflict
  ): auth_refresh_tokens_mutation_response

  """
  insert a single row into the table: "auth.refresh_tokens"
  """
  insert_auth_refresh_tokens_one(
    """the row to be inserted"""
    object: auth_refresh_tokens_insert_input!

    """upsert condition"""
    on_conflict: auth_refresh_tokens_on_conflict
  ): auth_refresh_tokens

  """
  insert data into the table: "auth.saml_providers"
  """
  insert_auth_saml_providers(
    """the rows to be inserted"""
    objects: [auth_saml_providers_insert_input!]!

    """upsert condition"""
    on_conflict: auth_saml_providers_on_conflict
  ): auth_saml_providers_mutation_response

  """
  insert a single row into the table: "auth.saml_providers"
  """
  insert_auth_saml_providers_one(
    """the row to be inserted"""
    object: auth_saml_providers_insert_input!

    """upsert condition"""
    on_conflict: auth_saml_providers_on_conflict
  ): auth_saml_providers

  """
  insert data into the table: "auth.saml_relay_states"
  """
  insert_auth_saml_relay_states(
    """the rows to be inserted"""
    objects: [auth_saml_relay_states_insert_input!]!

    """upsert condition"""
    on_conflict: auth_saml_relay_states_on_conflict
  ): auth_saml_relay_states_mutation_response

  """
  insert a single row into the table: "auth.saml_relay_states"
  """
  insert_auth_saml_relay_states_one(
    """the row to be inserted"""
    object: auth_saml_relay_states_insert_input!

    """upsert condition"""
    on_conflict: auth_saml_relay_states_on_conflict
  ): auth_saml_relay_states

  """
  insert data into the table: "auth.sessions"
  """
  insert_auth_sessions(
    """the rows to be inserted"""
    objects: [auth_sessions_insert_input!]!

    """upsert condition"""
    on_conflict: auth_sessions_on_conflict
  ): auth_sessions_mutation_response

  """
  insert a single row into the table: "auth.sessions"
  """
  insert_auth_sessions_one(
    """the row to be inserted"""
    object: auth_sessions_insert_input!

    """upsert condition"""
    on_conflict: auth_sessions_on_conflict
  ): auth_sessions

  """
  insert data into the table: "auth.sso_domains"
  """
  insert_auth_sso_domains(
    """the rows to be inserted"""
    objects: [auth_sso_domains_insert_input!]!

    """upsert condition"""
    on_conflict: auth_sso_domains_on_conflict
  ): auth_sso_domains_mutation_response

  """
  insert a single row into the table: "auth.sso_domains"
  """
  insert_auth_sso_domains_one(
    """the row to be inserted"""
    object: auth_sso_domains_insert_input!

    """upsert condition"""
    on_conflict: auth_sso_domains_on_conflict
  ): auth_sso_domains

  """
  insert data into the table: "auth.sso_providers"
  """
  insert_auth_sso_providers(
    """the rows to be inserted"""
    objects: [auth_sso_providers_insert_input!]!

    """upsert condition"""
    on_conflict: auth_sso_providers_on_conflict
  ): auth_sso_providers_mutation_response

  """
  insert a single row into the table: "auth.sso_providers"
  """
  insert_auth_sso_providers_one(
    """the row to be inserted"""
    object: auth_sso_providers_insert_input!

    """upsert condition"""
    on_conflict: auth_sso_providers_on_conflict
  ): auth_sso_providers

  """
  insert data into the table: "auth.users"
  """
  insert_auth_users(
    """the rows to be inserted"""
    objects: [auth_users_insert_input!]!

    """upsert condition"""
    on_conflict: auth_users_on_conflict
  ): auth_users_mutation_response

  """
  insert a single row into the table: "auth.users"
  """
  insert_auth_users_one(
    """the row to be inserted"""
    object: auth_users_insert_input!

    """upsert condition"""
    on_conflict: auth_users_on_conflict
  ): auth_users

  """
  insert data into the table: "booking_requests"
  """
  insert_booking_requests(
    """the rows to be inserted"""
    objects: [booking_requests_insert_input!]!

    """upsert condition"""
    on_conflict: booking_requests_on_conflict
  ): booking_requests_mutation_response

  """
  insert a single row into the table: "booking_requests"
  """
  insert_booking_requests_one(
    """the row to be inserted"""
    object: booking_requests_insert_input!

    """upsert condition"""
    on_conflict: booking_requests_on_conflict
  ): booking_requests

  """
  insert data into the table: "bookings"
  """
  insert_bookings(
    """the rows to be inserted"""
    objects: [bookings_insert_input!]!

    """upsert condition"""
    on_conflict: bookings_on_conflict
  ): bookings_mutation_response

  """
  insert a single row into the table: "bookings"
  """
  insert_bookings_one(
    """the row to be inserted"""
    object: bookings_insert_input!

    """upsert condition"""
    on_conflict: bookings_on_conflict
  ): bookings

  """
  insert data into the table: "calendar_events"
  """
  insert_calendar_events(
    """the rows to be inserted"""
    objects: [calendar_events_insert_input!]!

    """upsert condition"""
    on_conflict: calendar_events_on_conflict
  ): calendar_events_mutation_response

  """
  insert a single row into the table: "calendar_events"
  """
  insert_calendar_events_one(
    """the row to be inserted"""
    object: calendar_events_insert_input!

    """upsert condition"""
    on_conflict: calendar_events_on_conflict
  ): calendar_events

  """
  insert data into the table: "client_satisfaction_ratings"
  """
  insert_client_satisfaction_ratings(
    """the rows to be inserted"""
    objects: [client_satisfaction_ratings_insert_input!]!

    """upsert condition"""
    on_conflict: client_satisfaction_ratings_on_conflict
  ): client_satisfaction_ratings_mutation_response

  """
  insert a single row into the table: "client_satisfaction_ratings"
  """
  insert_client_satisfaction_ratings_one(
    """the row to be inserted"""
    object: client_satisfaction_ratings_insert_input!

    """upsert condition"""
    on_conflict: client_satisfaction_ratings_on_conflict
  ): client_satisfaction_ratings

  """
  insert data into the table: "compliance_categories"
  """
  insert_compliance_categories(
    """the rows to be inserted"""
    objects: [compliance_categories_insert_input!]!

    """upsert condition"""
    on_conflict: compliance_categories_on_conflict
  ): compliance_categories_mutation_response

  """
  insert a single row into the table: "compliance_categories"
  """
  insert_compliance_categories_one(
    """the row to be inserted"""
    object: compliance_categories_insert_input!

    """upsert condition"""
    on_conflict: compliance_categories_on_conflict
  ): compliance_categories

  """
  insert data into the table: "compliance_items"
  """
  insert_compliance_items(
    """the rows to be inserted"""
    objects: [compliance_items_insert_input!]!

    """upsert condition"""
    on_conflict: compliance_items_on_conflict
  ): compliance_items_mutation_response

  """
  insert a single row into the table: "compliance_items"
  """
  insert_compliance_items_one(
    """the row to be inserted"""
    object: compliance_items_insert_input!

    """upsert condition"""
    on_conflict: compliance_items_on_conflict
  ): compliance_items

  """
  insert data into the table: "contact_fees"
  """
  insert_contact_fees(
    """the rows to be inserted"""
    objects: [contact_fees_insert_input!]!

    """upsert condition"""
    on_conflict: contact_fees_on_conflict
  ): contact_fees_mutation_response

  """
  insert a single row into the table: "contact_fees"
  """
  insert_contact_fees_one(
    """the row to be inserted"""
    object: contact_fees_insert_input!

    """upsert condition"""
    on_conflict: contact_fees_on_conflict
  ): contact_fees

  """
  insert data into the table: "content_moderation_flags"
  """
  insert_content_moderation_flags(
    """the rows to be inserted"""
    objects: [content_moderation_flags_insert_input!]!

    """upsert condition"""
    on_conflict: content_moderation_flags_on_conflict
  ): content_moderation_flags_mutation_response

  """
  insert a single row into the table: "content_moderation_flags"
  """
  insert_content_moderation_flags_one(
    """the row to be inserted"""
    object: content_moderation_flags_insert_input!

    """upsert condition"""
    on_conflict: content_moderation_flags_on_conflict
  ): content_moderation_flags

  """
  insert data into the table: "conversations"
  """
  insert_conversations(
    """the rows to be inserted"""
    objects: [conversations_insert_input!]!

    """upsert condition"""
    on_conflict: conversations_on_conflict
  ): conversations_mutation_response

  """
  insert a single row into the table: "conversations"
  """
  insert_conversations_one(
    """the row to be inserted"""
    object: conversations_insert_input!

    """upsert condition"""
    on_conflict: conversations_on_conflict
  ): conversations

  """
  insert data into the table: "conversion_events"
  """
  insert_conversion_events(
    """the rows to be inserted"""
    objects: [conversion_events_insert_input!]!

    """upsert condition"""
    on_conflict: conversion_events_on_conflict
  ): conversion_events_mutation_response

  """
  insert a single row into the table: "conversion_events"
  """
  insert_conversion_events_one(
    """the row to be inserted"""
    object: conversion_events_insert_input!

    """upsert condition"""
    on_conflict: conversion_events_on_conflict
  ): conversion_events

  """
  insert data into the table: "countries"
  """
  insert_countries(
    """the rows to be inserted"""
    objects: [countries_insert_input!]!

    """upsert condition"""
    on_conflict: countries_on_conflict
  ): countries_mutation_response

  """
  insert a single row into the table: "countries"
  """
  insert_countries_one(
    """the row to be inserted"""
    object: countries_insert_input!

    """upsert condition"""
    on_conflict: countries_on_conflict
  ): countries

  """
  insert data into the table: "country_codes"
  """
  insert_country_codes(
    """the rows to be inserted"""
    objects: [country_codes_insert_input!]!

    """upsert condition"""
    on_conflict: country_codes_on_conflict
  ): country_codes_mutation_response

  """
  insert a single row into the table: "country_codes"
  """
  insert_country_codes_one(
    """the row to be inserted"""
    object: country_codes_insert_input!

    """upsert condition"""
    on_conflict: country_codes_on_conflict
  ): country_codes

  """
  insert data into the table: "credit_transactions"
  """
  insert_credit_transactions(
    """the rows to be inserted"""
    objects: [credit_transactions_insert_input!]!

    """upsert condition"""
    on_conflict: credit_transactions_on_conflict
  ): credit_transactions_mutation_response

  """
  insert a single row into the table: "credit_transactions"
  """
  insert_credit_transactions_one(
    """the row to be inserted"""
    object: credit_transactions_insert_input!

    """upsert condition"""
    on_conflict: credit_transactions_on_conflict
  ): credit_transactions

  """
  insert data into the table: "dispute_evidence"
  """
  insert_dispute_evidence(
    """the rows to be inserted"""
    objects: [dispute_evidence_insert_input!]!

    """upsert condition"""
    on_conflict: dispute_evidence_on_conflict
  ): dispute_evidence_mutation_response

  """
  insert a single row into the table: "dispute_evidence"
  """
  insert_dispute_evidence_one(
    """the row to be inserted"""
    object: dispute_evidence_insert_input!

    """upsert condition"""
    on_conflict: dispute_evidence_on_conflict
  ): dispute_evidence

  """
  insert data into the table: "dispute_messages"
  """
  insert_dispute_messages(
    """the rows to be inserted"""
    objects: [dispute_messages_insert_input!]!

    """upsert condition"""
    on_conflict: dispute_messages_on_conflict
  ): dispute_messages_mutation_response

  """
  insert a single row into the table: "dispute_messages"
  """
  insert_dispute_messages_one(
    """the row to be inserted"""
    object: dispute_messages_insert_input!

    """upsert condition"""
    on_conflict: dispute_messages_on_conflict
  ): dispute_messages

  """
  insert data into the table: "dispute_parties"
  """
  insert_dispute_parties(
    """the rows to be inserted"""
    objects: [dispute_parties_insert_input!]!

    """upsert condition"""
    on_conflict: dispute_parties_on_conflict
  ): dispute_parties_mutation_response

  """
  insert a single row into the table: "dispute_parties"
  """
  insert_dispute_parties_one(
    """the row to be inserted"""
    object: dispute_parties_insert_input!

    """upsert condition"""
    on_conflict: dispute_parties_on_conflict
  ): dispute_parties

  """
  insert data into the table: "disputes"
  """
  insert_disputes(
    """the rows to be inserted"""
    objects: [disputes_insert_input!]!

    """upsert condition"""
    on_conflict: disputes_on_conflict
  ): disputes_mutation_response

  """
  insert a single row into the table: "disputes"
  """
  insert_disputes_one(
    """the row to be inserted"""
    object: disputes_insert_input!

    """upsert condition"""
    on_conflict: disputes_on_conflict
  ): disputes

  """
  insert data into the table: "favorites"
  """
  insert_favorites(
    """the rows to be inserted"""
    objects: [favorites_insert_input!]!

    """upsert condition"""
    on_conflict: favorites_on_conflict
  ): favorites_mutation_response

  """
  insert a single row into the table: "favorites"
  """
  insert_favorites_one(
    """the row to be inserted"""
    object: favorites_insert_input!

    """upsert condition"""
    on_conflict: favorites_on_conflict
  ): favorites

  """
  insert data into the table: "interview_notifications"
  """
  insert_interview_notifications(
    """the rows to be inserted"""
    objects: [interview_notifications_insert_input!]!

    """upsert condition"""
    on_conflict: interview_notifications_on_conflict
  ): interview_notifications_mutation_response

  """
  insert a single row into the table: "interview_notifications"
  """
  insert_interview_notifications_one(
    """the row to be inserted"""
    object: interview_notifications_insert_input!

    """upsert condition"""
    on_conflict: interview_notifications_on_conflict
  ): interview_notifications

  """
  insert data into the table: "interview_platform_templates"
  """
  insert_interview_platform_templates(
    """the rows to be inserted"""
    objects: [interview_platform_templates_insert_input!]!

    """upsert condition"""
    on_conflict: interview_platform_templates_on_conflict
  ): interview_platform_templates_mutation_response

  """
  insert a single row into the table: "interview_platform_templates"
  """
  insert_interview_platform_templates_one(
    """the row to be inserted"""
    object: interview_platform_templates_insert_input!

    """upsert condition"""
    on_conflict: interview_platform_templates_on_conflict
  ): interview_platform_templates

  """
  insert data into the table: "job_applications"
  """
  insert_job_applications(
    """the rows to be inserted"""
    objects: [job_applications_insert_input!]!

    """upsert condition"""
    on_conflict: job_applications_on_conflict
  ): job_applications_mutation_response

  """
  insert a single row into the table: "job_applications"
  """
  insert_job_applications_one(
    """the row to be inserted"""
    object: job_applications_insert_input!

    """upsert condition"""
    on_conflict: job_applications_on_conflict
  ): job_applications

  """
  insert data into the table: "job_postings"
  """
  insert_job_postings(
    """the rows to be inserted"""
    objects: [job_postings_insert_input!]!
  ): job_postings_mutation_response

  """
  insert a single row into the table: "job_postings"
  """
  insert_job_postings_one(
    """the row to be inserted"""
    object: job_postings_insert_input!
  ): job_postings

  """
  insert data into the table: "jobs"
  """
  insert_jobs(
    """the rows to be inserted"""
    objects: [jobs_insert_input!]!

    """upsert condition"""
    on_conflict: jobs_on_conflict
  ): jobs_mutation_response

  """
  insert a single row into the table: "jobs"
  """
  insert_jobs_one(
    """the row to be inserted"""
    object: jobs_insert_input!

    """upsert condition"""
    on_conflict: jobs_on_conflict
  ): jobs

  """
  insert data into the table: "maid_bookings"
  """
  insert_maid_bookings(
    """the rows to be inserted"""
    objects: [maid_bookings_insert_input!]!

    """upsert condition"""
    on_conflict: maid_bookings_on_conflict
  ): maid_bookings_mutation_response

  """
  insert a single row into the table: "maid_bookings"
  """
  insert_maid_bookings_one(
    """the row to be inserted"""
    object: maid_bookings_insert_input!

    """upsert condition"""
    on_conflict: maid_bookings_on_conflict
  ): maid_bookings

  """
  insert data into the table: "maid_documents"
  """
  insert_maid_documents(
    """the rows to be inserted"""
    objects: [maid_documents_insert_input!]!

    """upsert condition"""
    on_conflict: maid_documents_on_conflict
  ): maid_documents_mutation_response

  """
  insert a single row into the table: "maid_documents"
  """
  insert_maid_documents_one(
    """the row to be inserted"""
    object: maid_documents_insert_input!

    """upsert condition"""
    on_conflict: maid_documents_on_conflict
  ): maid_documents

  """
  insert data into the table: "maid_images"
  """
  insert_maid_images(
    """the rows to be inserted"""
    objects: [maid_images_insert_input!]!

    """upsert condition"""
    on_conflict: maid_images_on_conflict
  ): maid_images_mutation_response

  """
  insert a single row into the table: "maid_images"
  """
  insert_maid_images_one(
    """the row to be inserted"""
    object: maid_images_insert_input!

    """upsert condition"""
    on_conflict: maid_images_on_conflict
  ): maid_images

  """
  insert data into the table: "maid_profiles"
  """
  insert_maid_profiles(
    """the rows to be inserted"""
    objects: [maid_profiles_insert_input!]!

    """upsert condition"""
    on_conflict: maid_profiles_on_conflict
  ): maid_profiles_mutation_response

  """
  insert a single row into the table: "maid_profiles"
  """
  insert_maid_profiles_one(
    """the row to be inserted"""
    object: maid_profiles_insert_input!

    """upsert condition"""
    on_conflict: maid_profiles_on_conflict
  ): maid_profiles

  """
  insert data into the table: "maid_videos"
  """
  insert_maid_videos(
    """the rows to be inserted"""
    objects: [maid_videos_insert_input!]!

    """upsert condition"""
    on_conflict: maid_videos_on_conflict
  ): maid_videos_mutation_response

  """
  insert a single row into the table: "maid_videos"
  """
  insert_maid_videos_one(
    """the row to be inserted"""
    object: maid_videos_insert_input!

    """upsert condition"""
    on_conflict: maid_videos_on_conflict
  ): maid_videos

  """
  insert data into the table: "message_templates"
  """
  insert_message_templates(
    """the rows to be inserted"""
    objects: [message_templates_insert_input!]!

    """upsert condition"""
    on_conflict: message_templates_on_conflict
  ): message_templates_mutation_response

  """
  insert a single row into the table: "message_templates"
  """
  insert_message_templates_one(
    """the row to be inserted"""
    object: message_templates_insert_input!

    """upsert condition"""
    on_conflict: message_templates_on_conflict
  ): message_templates

  """
  insert data into the table: "messages"
  """
  insert_messages(
    """the rows to be inserted"""
    objects: [messages_insert_input!]!

    """upsert condition"""
    on_conflict: messages_on_conflict
  ): messages_mutation_response

  """
  insert a single row into the table: "messages"
  """
  insert_messages_one(
    """the row to be inserted"""
    object: messages_insert_input!

    """upsert condition"""
    on_conflict: messages_on_conflict
  ): messages

  """
  insert data into the table: "news_items"
  """
  insert_news_items(
    """the rows to be inserted"""
    objects: [news_items_insert_input!]!

    """upsert condition"""
    on_conflict: news_items_on_conflict
  ): news_items_mutation_response

  """
  insert a single row into the table: "news_items"
  """
  insert_news_items_one(
    """the row to be inserted"""
    object: news_items_insert_input!

    """upsert condition"""
    on_conflict: news_items_on_conflict
  ): news_items

  """
  insert data into the table: "news_sources"
  """
  insert_news_sources(
    """the rows to be inserted"""
    objects: [news_sources_insert_input!]!

    """upsert condition"""
    on_conflict: news_sources_on_conflict
  ): news_sources_mutation_response

  """
  insert a single row into the table: "news_sources"
  """
  insert_news_sources_one(
    """the row to be inserted"""
    object: news_sources_insert_input!

    """upsert condition"""
    on_conflict: news_sources_on_conflict
  ): news_sources

  """
  insert data into the table: "notifications"
  """
  insert_notifications(
    """the rows to be inserted"""
    objects: [notifications_insert_input!]!

    """upsert condition"""
    on_conflict: notifications_on_conflict
  ): notifications_mutation_response

  """
  insert a single row into the table: "notifications"
  """
  insert_notifications_one(
    """the row to be inserted"""
    object: notifications_insert_input!

    """upsert condition"""
    on_conflict: notifications_on_conflict
  ): notifications

  """
  insert data into the table: "page_views"
  """
  insert_page_views(
    """the rows to be inserted"""
    objects: [page_views_insert_input!]!

    """upsert condition"""
    on_conflict: page_views_on_conflict
  ): page_views_mutation_response

  """
  insert a single row into the table: "page_views"
  """
  insert_page_views_one(
    """the row to be inserted"""
    object: page_views_insert_input!

    """upsert condition"""
    on_conflict: page_views_on_conflict
  ): page_views

  """
  insert data into the table: "password_resets"
  """
  insert_password_resets(
    """the rows to be inserted"""
    objects: [password_resets_insert_input!]!

    """upsert condition"""
    on_conflict: password_resets_on_conflict
  ): password_resets_mutation_response

  """
  insert a single row into the table: "password_resets"
  """
  insert_password_resets_one(
    """the row to be inserted"""
    object: password_resets_insert_input!

    """upsert condition"""
    on_conflict: password_resets_on_conflict
  ): password_resets

  """
  insert data into the table: "payment_idempotency"
  """
  insert_payment_idempotency(
    """the rows to be inserted"""
    objects: [payment_idempotency_insert_input!]!

    """upsert condition"""
    on_conflict: payment_idempotency_on_conflict
  ): payment_idempotency_mutation_response

  """
  insert a single row into the table: "payment_idempotency"
  """
  insert_payment_idempotency_one(
    """the row to be inserted"""
    object: payment_idempotency_insert_input!

    """upsert condition"""
    on_conflict: payment_idempotency_on_conflict
  ): payment_idempotency

  """
  insert data into the table: "payment_methods"
  """
  insert_payment_methods(
    """the rows to be inserted"""
    objects: [payment_methods_insert_input!]!

    """upsert condition"""
    on_conflict: payment_methods_on_conflict
  ): payment_methods_mutation_response

  """
  insert a single row into the table: "payment_methods"
  """
  insert_payment_methods_one(
    """the row to be inserted"""
    object: payment_methods_insert_input!

    """upsert condition"""
    on_conflict: payment_methods_on_conflict
  ): payment_methods

  """
  insert data into the table: "payments"
  """
  insert_payments(
    """the rows to be inserted"""
    objects: [payments_insert_input!]!

    """upsert condition"""
    on_conflict: payments_on_conflict
  ): payments_mutation_response

  """
  insert a single row into the table: "payments"
  """
  insert_payments_one(
    """the row to be inserted"""
    object: payments_insert_input!

    """upsert condition"""
    on_conflict: payments_on_conflict
  ): payments

  """
  insert data into the table: "payout_accounts"
  """
  insert_payout_accounts(
    """the rows to be inserted"""
    objects: [payout_accounts_insert_input!]!

    """upsert condition"""
    on_conflict: payout_accounts_on_conflict
  ): payout_accounts_mutation_response

  """
  insert a single row into the table: "payout_accounts"
  """
  insert_payout_accounts_one(
    """the row to be inserted"""
    object: payout_accounts_insert_input!

    """upsert condition"""
    on_conflict: payout_accounts_on_conflict
  ): payout_accounts

  """
  insert data into the table: "payout_schedules"
  """
  insert_payout_schedules(
    """the rows to be inserted"""
    objects: [payout_schedules_insert_input!]!

    """upsert condition"""
    on_conflict: payout_schedules_on_conflict
  ): payout_schedules_mutation_response

  """
  insert a single row into the table: "payout_schedules"
  """
  insert_payout_schedules_one(
    """the row to be inserted"""
    object: payout_schedules_insert_input!

    """upsert condition"""
    on_conflict: payout_schedules_on_conflict
  ): payout_schedules

  """
  insert data into the table: "phone_verification_log"
  """
  insert_phone_verification_log(
    """the rows to be inserted"""
    objects: [phone_verification_log_insert_input!]!

    """upsert condition"""
    on_conflict: phone_verification_log_on_conflict
  ): phone_verification_log_mutation_response

  """
  insert a single row into the table: "phone_verification_log"
  """
  insert_phone_verification_log_one(
    """the row to be inserted"""
    object: phone_verification_log_insert_input!

    """upsert condition"""
    on_conflict: phone_verification_log_on_conflict
  ): phone_verification_log

  """
  insert data into the table: "phone_verifications"
  """
  insert_phone_verifications(
    """the rows to be inserted"""
    objects: [phone_verifications_insert_input!]!

    """upsert condition"""
    on_conflict: phone_verifications_on_conflict
  ): phone_verifications_mutation_response

  """
  insert a single row into the table: "phone_verifications"
  """
  insert_phone_verifications_one(
    """the row to be inserted"""
    object: phone_verifications_insert_input!

    """upsert condition"""
    on_conflict: phone_verifications_on_conflict
  ): phone_verifications

  """
  insert data into the table: "pii_access_log"
  """
  insert_pii_access_log(
    """the rows to be inserted"""
    objects: [pii_access_log_insert_input!]!

    """upsert condition"""
    on_conflict: pii_access_log_on_conflict
  ): pii_access_log_mutation_response

  """
  insert a single row into the table: "pii_access_log"
  """
  insert_pii_access_log_one(
    """the row to be inserted"""
    object: pii_access_log_insert_input!

    """upsert condition"""
    on_conflict: pii_access_log_on_conflict
  ): pii_access_log

  """
  insert data into the table: "placement_contracts"
  """
  insert_placement_contracts(
    """the rows to be inserted"""
    objects: [placement_contracts_insert_input!]!

    """upsert condition"""
    on_conflict: placement_contracts_on_conflict
  ): placement_contracts_mutation_response

  """
  insert a single row into the table: "placement_contracts"
  """
  insert_placement_contracts_one(
    """the row to be inserted"""
    object: placement_contracts_insert_input!

    """upsert condition"""
    on_conflict: placement_contracts_on_conflict
  ): placement_contracts

  """
  insert data into the table: "placement_fee_transactions"
  """
  insert_placement_fee_transactions(
    """the rows to be inserted"""
    objects: [placement_fee_transactions_insert_input!]!

    """upsert condition"""
    on_conflict: placement_fee_transactions_on_conflict
  ): placement_fee_transactions_mutation_response

  """
  insert a single row into the table: "placement_fee_transactions"
  """
  insert_placement_fee_transactions_one(
    """the row to be inserted"""
    object: placement_fee_transactions_insert_input!

    """upsert condition"""
    on_conflict: placement_fee_transactions_on_conflict
  ): placement_fee_transactions

  """
  insert data into the table: "platform_announcements"
  """
  insert_platform_announcements(
    """the rows to be inserted"""
    objects: [platform_announcements_insert_input!]!

    """upsert condition"""
    on_conflict: platform_announcements_on_conflict
  ): platform_announcements_mutation_response

  """
  insert a single row into the table: "platform_announcements"
  """
  insert_platform_announcements_one(
    """the row to be inserted"""
    object: platform_announcements_insert_input!

    """upsert condition"""
    on_conflict: platform_announcements_on_conflict
  ): platform_announcements

  """
  insert data into the table: "platform_settings"
  """
  insert_platform_settings(
    """the rows to be inserted"""
    objects: [platform_settings_insert_input!]!

    """upsert condition"""
    on_conflict: platform_settings_on_conflict
  ): platform_settings_mutation_response

  """
  insert a single row into the table: "platform_settings"
  """
  insert_platform_settings_one(
    """the row to be inserted"""
    object: platform_settings_insert_input!

    """upsert condition"""
    on_conflict: platform_settings_on_conflict
  ): platform_settings

  """
  insert data into the table: "profiles"
  """
  insert_profiles(
    """the rows to be inserted"""
    objects: [profiles_insert_input!]!

    """upsert condition"""
    on_conflict: profiles_on_conflict
  ): profiles_mutation_response

  """
  insert a single row into the table: "profiles"
  """
  insert_profiles_one(
    """the row to be inserted"""
    object: profiles_insert_input!

    """upsert condition"""
    on_conflict: profiles_on_conflict
  ): profiles

  """
  insert data into the table: "realtime.messages"
  """
  insert_realtime_messages(
    """the rows to be inserted"""
    objects: [realtime_messages_insert_input!]!

    """upsert condition"""
    on_conflict: realtime_messages_on_conflict
  ): realtime_messages_mutation_response

  """
  insert a single row into the table: "realtime.messages"
  """
  insert_realtime_messages_one(
    """the row to be inserted"""
    object: realtime_messages_insert_input!

    """upsert condition"""
    on_conflict: realtime_messages_on_conflict
  ): realtime_messages

  """
  insert data into the table: "realtime.subscription"
  """
  insert_realtime_subscription(
    """the rows to be inserted"""
    objects: [realtime_subscription_insert_input!]!

    """upsert condition"""
    on_conflict: realtime_subscription_on_conflict
  ): realtime_subscription_mutation_response

  """
  insert a single row into the table: "realtime.subscription"
  """
  insert_realtime_subscription_one(
    """the row to be inserted"""
    object: realtime_subscription_insert_input!

    """upsert condition"""
    on_conflict: realtime_subscription_on_conflict
  ): realtime_subscription

  """
  insert data into the table: "reviews"
  """
  insert_reviews(
    """the rows to be inserted"""
    objects: [reviews_insert_input!]!

    """upsert condition"""
    on_conflict: reviews_on_conflict
  ): reviews_mutation_response

  """
  insert a single row into the table: "reviews"
  """
  insert_reviews_one(
    """the row to be inserted"""
    object: reviews_insert_input!

    """upsert condition"""
    on_conflict: reviews_on_conflict
  ): reviews

  """
  insert data into the table: "security_events"
  """
  insert_security_events(
    """the rows to be inserted"""
    objects: [security_events_insert_input!]!

    """upsert condition"""
    on_conflict: security_events_on_conflict
  ): security_events_mutation_response

  """
  insert a single row into the table: "security_events"
  """
  insert_security_events_one(
    """the row to be inserted"""
    object: security_events_insert_input!

    """upsert condition"""
    on_conflict: security_events_on_conflict
  ): security_events

  """
  insert data into the table: "shortlist_candidates"
  """
  insert_shortlist_candidates(
    """the rows to be inserted"""
    objects: [shortlist_candidates_insert_input!]!

    """upsert condition"""
    on_conflict: shortlist_candidates_on_conflict
  ): shortlist_candidates_mutation_response

  """
  insert a single row into the table: "shortlist_candidates"
  """
  insert_shortlist_candidates_one(
    """the row to be inserted"""
    object: shortlist_candidates_insert_input!

    """upsert condition"""
    on_conflict: shortlist_candidates_on_conflict
  ): shortlist_candidates

  """
  insert data into the table: "shortlists"
  """
  insert_shortlists(
    """the rows to be inserted"""
    objects: [shortlists_insert_input!]!

    """upsert condition"""
    on_conflict: shortlists_on_conflict
  ): shortlists_mutation_response

  """
  insert a single row into the table: "shortlists"
  """
  insert_shortlists_one(
    """the row to be inserted"""
    object: shortlists_insert_input!

    """upsert condition"""
    on_conflict: shortlists_on_conflict
  ): shortlists

  """
  insert data into the table: "skills"
  """
  insert_skills(
    """the rows to be inserted"""
    objects: [skills_insert_input!]!

    """upsert condition"""
    on_conflict: skills_on_conflict
  ): skills_mutation_response

  """
  insert a single row into the table: "skills"
  """
  insert_skills_one(
    """the row to be inserted"""
    object: skills_insert_input!

    """upsert condition"""
    on_conflict: skills_on_conflict
  ): skills

  """
  insert data into the table: "sponsor_document_verification"
  """
  insert_sponsor_document_verification(
    """the rows to be inserted"""
    objects: [sponsor_document_verification_insert_input!]!

    """upsert condition"""
    on_conflict: sponsor_document_verification_on_conflict
  ): sponsor_document_verification_mutation_response

  """
  insert a single row into the table: "sponsor_document_verification"
  """
  insert_sponsor_document_verification_one(
    """the row to be inserted"""
    object: sponsor_document_verification_insert_input!

    """upsert condition"""
    on_conflict: sponsor_document_verification_on_conflict
  ): sponsor_document_verification

  """
  insert data into the table: "sponsor_jobs"
  """
  insert_sponsor_jobs(
    """the rows to be inserted"""
    objects: [sponsor_jobs_insert_input!]!

    """upsert condition"""
    on_conflict: sponsor_jobs_on_conflict
  ): sponsor_jobs_mutation_response

  """
  insert a single row into the table: "sponsor_jobs"
  """
  insert_sponsor_jobs_one(
    """the row to be inserted"""
    object: sponsor_jobs_insert_input!

    """upsert condition"""
    on_conflict: sponsor_jobs_on_conflict
  ): sponsor_jobs

  """
  insert data into the table: "sponsor_profiles"
  """
  insert_sponsor_profiles(
    """the rows to be inserted"""
    objects: [sponsor_profiles_insert_input!]!

    """upsert condition"""
    on_conflict: sponsor_profiles_on_conflict
  ): sponsor_profiles_mutation_response

  """
  insert a single row into the table: "sponsor_profiles"
  """
  insert_sponsor_profiles_one(
    """the row to be inserted"""
    object: sponsor_profiles_insert_input!

    """upsert condition"""
    on_conflict: sponsor_profiles_on_conflict
  ): sponsor_profiles

  """
  insert data into the table: "sponsors"
  """
  insert_sponsors(
    """the rows to be inserted"""
    objects: [sponsors_insert_input!]!

    """upsert condition"""
    on_conflict: sponsors_on_conflict
  ): sponsors_mutation_response

  """
  insert a single row into the table: "sponsors"
  """
  insert_sponsors_one(
    """the row to be inserted"""
    object: sponsors_insert_input!

    """upsert condition"""
    on_conflict: sponsors_on_conflict
  ): sponsors

  """
  insert data into the table: "storage.buckets"
  """
  insert_storage_buckets(
    """the rows to be inserted"""
    objects: [storage_buckets_insert_input!]!

    """upsert condition"""
    on_conflict: storage_buckets_on_conflict
  ): storage_buckets_mutation_response

  """
  insert data into the table: "storage.buckets_analytics"
  """
  insert_storage_buckets_analytics(
    """the rows to be inserted"""
    objects: [storage_buckets_analytics_insert_input!]!

    """upsert condition"""
    on_conflict: storage_buckets_analytics_on_conflict
  ): storage_buckets_analytics_mutation_response

  """
  insert a single row into the table: "storage.buckets_analytics"
  """
  insert_storage_buckets_analytics_one(
    """the row to be inserted"""
    object: storage_buckets_analytics_insert_input!

    """upsert condition"""
    on_conflict: storage_buckets_analytics_on_conflict
  ): storage_buckets_analytics

  """
  insert a single row into the table: "storage.buckets"
  """
  insert_storage_buckets_one(
    """the row to be inserted"""
    object: storage_buckets_insert_input!

    """upsert condition"""
    on_conflict: storage_buckets_on_conflict
  ): storage_buckets

  """
  insert data into the table: "storage.migrations"
  """
  insert_storage_migrations(
    """the rows to be inserted"""
    objects: [storage_migrations_insert_input!]!

    """upsert condition"""
    on_conflict: storage_migrations_on_conflict
  ): storage_migrations_mutation_response

  """
  insert a single row into the table: "storage.migrations"
  """
  insert_storage_migrations_one(
    """the row to be inserted"""
    object: storage_migrations_insert_input!

    """upsert condition"""
    on_conflict: storage_migrations_on_conflict
  ): storage_migrations

  """
  insert data into the table: "storage.objects"
  """
  insert_storage_objects(
    """the rows to be inserted"""
    objects: [storage_objects_insert_input!]!

    """upsert condition"""
    on_conflict: storage_objects_on_conflict
  ): storage_objects_mutation_response

  """
  insert a single row into the table: "storage.objects"
  """
  insert_storage_objects_one(
    """the row to be inserted"""
    object: storage_objects_insert_input!

    """upsert condition"""
    on_conflict: storage_objects_on_conflict
  ): storage_objects

  """
  insert data into the table: "storage.prefixes"
  """
  insert_storage_prefixes(
    """the rows to be inserted"""
    objects: [storage_prefixes_insert_input!]!

    """upsert condition"""
    on_conflict: storage_prefixes_on_conflict
  ): storage_prefixes_mutation_response

  """
  insert a single row into the table: "storage.prefixes"
  """
  insert_storage_prefixes_one(
    """the row to be inserted"""
    object: storage_prefixes_insert_input!

    """upsert condition"""
    on_conflict: storage_prefixes_on_conflict
  ): storage_prefixes

  """
  insert data into the table: "storage.s3_multipart_uploads"
  """
  insert_storage_s3_multipart_uploads(
    """the rows to be inserted"""
    objects: [storage_s3_multipart_uploads_insert_input!]!

    """upsert condition"""
    on_conflict: storage_s3_multipart_uploads_on_conflict
  ): storage_s3_multipart_uploads_mutation_response

  """
  insert a single row into the table: "storage.s3_multipart_uploads"
  """
  insert_storage_s3_multipart_uploads_one(
    """the row to be inserted"""
    object: storage_s3_multipart_uploads_insert_input!

    """upsert condition"""
    on_conflict: storage_s3_multipart_uploads_on_conflict
  ): storage_s3_multipart_uploads

  """
  insert data into the table: "storage.s3_multipart_uploads_parts"
  """
  insert_storage_s3_multipart_uploads_parts(
    """the rows to be inserted"""
    objects: [storage_s3_multipart_uploads_parts_insert_input!]!

    """upsert condition"""
    on_conflict: storage_s3_multipart_uploads_parts_on_conflict
  ): storage_s3_multipart_uploads_parts_mutation_response

  """
  insert a single row into the table: "storage.s3_multipart_uploads_parts"
  """
  insert_storage_s3_multipart_uploads_parts_one(
    """the row to be inserted"""
    object: storage_s3_multipart_uploads_parts_insert_input!

    """upsert condition"""
    on_conflict: storage_s3_multipart_uploads_parts_on_conflict
  ): storage_s3_multipart_uploads_parts

  """
  insert data into the table: "subscription_limits"
  """
  insert_subscription_limits(
    """the rows to be inserted"""
    objects: [subscription_limits_insert_input!]!

    """upsert condition"""
    on_conflict: subscription_limits_on_conflict
  ): subscription_limits_mutation_response

  """
  insert a single row into the table: "subscription_limits"
  """
  insert_subscription_limits_one(
    """the row to be inserted"""
    object: subscription_limits_insert_input!

    """upsert condition"""
    on_conflict: subscription_limits_on_conflict
  ): subscription_limits

  """
  insert data into the table: "subscription_status_log"
  """
  insert_subscription_status_log(
    """the rows to be inserted"""
    objects: [subscription_status_log_insert_input!]!

    """upsert condition"""
    on_conflict: subscription_status_log_on_conflict
  ): subscription_status_log_mutation_response

  """
  insert a single row into the table: "subscription_status_log"
  """
  insert_subscription_status_log_one(
    """the row to be inserted"""
    object: subscription_status_log_insert_input!

    """upsert condition"""
    on_conflict: subscription_status_log_on_conflict
  ): subscription_status_log

  """
  insert data into the table: "subscription_usage"
  """
  insert_subscription_usage(
    """the rows to be inserted"""
    objects: [subscription_usage_insert_input!]!

    """upsert condition"""
    on_conflict: subscription_usage_on_conflict
  ): subscription_usage_mutation_response

  """
  insert a single row into the table: "subscription_usage"
  """
  insert_subscription_usage_one(
    """the row to be inserted"""
    object: subscription_usage_insert_input!

    """upsert condition"""
    on_conflict: subscription_usage_on_conflict
  ): subscription_usage

  """
  insert data into the table: "subscriptions"
  """
  insert_subscriptions(
    """the rows to be inserted"""
    objects: [subscriptions_insert_input!]!

    """upsert condition"""
    on_conflict: subscriptions_on_conflict
  ): subscriptions_mutation_response

  """
  insert a single row into the table: "subscriptions"
  """
  insert_subscriptions_one(
    """the row to be inserted"""
    object: subscriptions_insert_input!

    """upsert condition"""
    on_conflict: subscriptions_on_conflict
  ): subscriptions

  """
  insert data into the table: "supabase_migrations.schema_migrations"
  """
  insert_supabase_migrations_schema_migrations(
    """the rows to be inserted"""
    objects: [supabase_migrations_schema_migrations_insert_input!]!

    """upsert condition"""
    on_conflict: supabase_migrations_schema_migrations_on_conflict
  ): supabase_migrations_schema_migrations_mutation_response

  """
  insert a single row into the table: "supabase_migrations.schema_migrations"
  """
  insert_supabase_migrations_schema_migrations_one(
    """the row to be inserted"""
    object: supabase_migrations_schema_migrations_insert_input!

    """upsert condition"""
    on_conflict: supabase_migrations_schema_migrations_on_conflict
  ): supabase_migrations_schema_migrations

  """
  insert data into the table: "supabase_migrations.seed_files"
  """
  insert_supabase_migrations_seed_files(
    """the rows to be inserted"""
    objects: [supabase_migrations_seed_files_insert_input!]!

    """upsert condition"""
    on_conflict: supabase_migrations_seed_files_on_conflict
  ): supabase_migrations_seed_files_mutation_response

  """
  insert a single row into the table: "supabase_migrations.seed_files"
  """
  insert_supabase_migrations_seed_files_one(
    """the row to be inserted"""
    object: supabase_migrations_seed_files_insert_input!

    """upsert condition"""
    on_conflict: supabase_migrations_seed_files_on_conflict
  ): supabase_migrations_seed_files

  """
  insert data into the table: "support_agents"
  """
  insert_support_agents(
    """the rows to be inserted"""
    objects: [support_agents_insert_input!]!

    """upsert condition"""
    on_conflict: support_agents_on_conflict
  ): support_agents_mutation_response

  """
  insert a single row into the table: "support_agents"
  """
  insert_support_agents_one(
    """the row to be inserted"""
    object: support_agents_insert_input!

    """upsert condition"""
    on_conflict: support_agents_on_conflict
  ): support_agents

  """
  insert data into the table: "support_interactions"
  """
  insert_support_interactions(
    """the rows to be inserted"""
    objects: [support_interactions_insert_input!]!

    """upsert condition"""
    on_conflict: support_interactions_on_conflict
  ): support_interactions_mutation_response

  """
  insert a single row into the table: "support_interactions"
  """
  insert_support_interactions_one(
    """the row to be inserted"""
    object: support_interactions_insert_input!

    """upsert condition"""
    on_conflict: support_interactions_on_conflict
  ): support_interactions

  """
  insert data into the table: "support_messages"
  """
  insert_support_messages(
    """the rows to be inserted"""
    objects: [support_messages_insert_input!]!

    """upsert condition"""
    on_conflict: support_messages_on_conflict
  ): support_messages_mutation_response

  """
  insert a single row into the table: "support_messages"
  """
  insert_support_messages_one(
    """the row to be inserted"""
    object: support_messages_insert_input!

    """upsert condition"""
    on_conflict: support_messages_on_conflict
  ): support_messages

  """
  insert data into the table: "support_tickets"
  """
  insert_support_tickets(
    """the rows to be inserted"""
    objects: [support_tickets_insert_input!]!

    """upsert condition"""
    on_conflict: support_tickets_on_conflict
  ): support_tickets_mutation_response

  """
  insert a single row into the table: "support_tickets"
  """
  insert_support_tickets_one(
    """the row to be inserted"""
    object: support_tickets_insert_input!

    """upsert condition"""
    on_conflict: support_tickets_on_conflict
  ): support_tickets

  """
  insert data into the table: "system_settings"
  """
  insert_system_settings(
    """the rows to be inserted"""
    objects: [system_settings_insert_input!]!

    """upsert condition"""
    on_conflict: system_settings_on_conflict
  ): system_settings_mutation_response

  """
  insert a single row into the table: "system_settings"
  """
  insert_system_settings_one(
    """the row to be inserted"""
    object: system_settings_insert_input!

    """upsert condition"""
    on_conflict: system_settings_on_conflict
  ): system_settings

  """
  insert data into the table: "team_member_performance"
  """
  insert_team_member_performance(
    """the rows to be inserted"""
    objects: [team_member_performance_insert_input!]!

    """upsert condition"""
    on_conflict: team_member_performance_on_conflict
  ): team_member_performance_mutation_response

  """
  insert a single row into the table: "team_member_performance"
  """
  insert_team_member_performance_one(
    """the row to be inserted"""
    object: team_member_performance_insert_input!

    """upsert condition"""
    on_conflict: team_member_performance_on_conflict
  ): team_member_performance

  """
  insert data into the table: "two_factor_backup_codes"
  """
  insert_two_factor_backup_codes(
    """the rows to be inserted"""
    objects: [two_factor_backup_codes_insert_input!]!

    """upsert condition"""
    on_conflict: two_factor_backup_codes_on_conflict
  ): two_factor_backup_codes_mutation_response

  """
  insert a single row into the table: "two_factor_backup_codes"
  """
  insert_two_factor_backup_codes_one(
    """the row to be inserted"""
    object: two_factor_backup_codes_insert_input!

    """upsert condition"""
    on_conflict: two_factor_backup_codes_on_conflict
  ): two_factor_backup_codes

  """
  insert data into the table: "user_credits"
  """
  insert_user_credits(
    """the rows to be inserted"""
    objects: [user_credits_insert_input!]!

    """upsert condition"""
    on_conflict: user_credits_on_conflict
  ): user_credits_mutation_response

  """
  insert a single row into the table: "user_credits"
  """
  insert_user_credits_one(
    """the row to be inserted"""
    object: user_credits_insert_input!

    """upsert condition"""
    on_conflict: user_credits_on_conflict
  ): user_credits

  """
  insert data into the table: "user_events"
  """
  insert_user_events(
    """the rows to be inserted"""
    objects: [user_events_insert_input!]!

    """upsert condition"""
    on_conflict: user_events_on_conflict
  ): user_events_mutation_response

  """
  insert a single row into the table: "user_events"
  """
  insert_user_events_one(
    """the row to be inserted"""
    object: user_events_insert_input!

    """upsert condition"""
    on_conflict: user_events_on_conflict
  ): user_events

  """
  insert data into the table: "user_sessions"
  """
  insert_user_sessions(
    """the rows to be inserted"""
    objects: [user_sessions_insert_input!]!

    """upsert condition"""
    on_conflict: user_sessions_on_conflict
  ): user_sessions_mutation_response

  """
  insert a single row into the table: "user_sessions"
  """
  insert_user_sessions_one(
    """the row to be inserted"""
    object: user_sessions_insert_input!

    """upsert condition"""
    on_conflict: user_sessions_on_conflict
  ): user_sessions

  """
  insert data into the table: "video_interviews"
  """
  insert_video_interviews(
    """the rows to be inserted"""
    objects: [video_interviews_insert_input!]!

    """upsert condition"""
    on_conflict: video_interviews_on_conflict
  ): video_interviews_mutation_response

  """
  insert a single row into the table: "video_interviews"
  """
  insert_video_interviews_one(
    """the row to be inserted"""
    object: video_interviews_insert_input!

    """upsert condition"""
    on_conflict: video_interviews_on_conflict
  ): video_interviews

  """
  insert data into the table: "webhook_event_logs"
  """
  insert_webhook_event_logs(
    """the rows to be inserted"""
    objects: [webhook_event_logs_insert_input!]!

    """upsert condition"""
    on_conflict: webhook_event_logs_on_conflict
  ): webhook_event_logs_mutation_response

  """
  insert a single row into the table: "webhook_event_logs"
  """
  insert_webhook_event_logs_one(
    """the row to be inserted"""
    object: webhook_event_logs_insert_input!

    """upsert condition"""
    on_conflict: webhook_event_logs_on_conflict
  ): webhook_event_logs

  """
  insert data into the table: "whatsapp_messages"
  """
  insert_whatsapp_messages(
    """the rows to be inserted"""
    objects: [whatsapp_messages_insert_input!]!

    """upsert condition"""
    on_conflict: whatsapp_messages_on_conflict
  ): whatsapp_messages_mutation_response

  """
  insert a single row into the table: "whatsapp_messages"
  """
  insert_whatsapp_messages_one(
    """the row to be inserted"""
    object: whatsapp_messages_insert_input!

    """upsert condition"""
    on_conflict: whatsapp_messages_on_conflict
  ): whatsapp_messages

  """
  insert data into the table: "work_experience"
  """
  insert_work_experience(
    """the rows to be inserted"""
    objects: [work_experience_insert_input!]!

    """upsert condition"""
    on_conflict: work_experience_on_conflict
  ): work_experience_mutation_response

  """
  insert a single row into the table: "work_experience"
  """
  insert_work_experience_one(
    """the row to be inserted"""
    object: work_experience_insert_input!

    """upsert condition"""
    on_conflict: work_experience_on_conflict
  ): work_experience

  """
  update data of the table: "activity_announcements"
  """
  update_activity_announcements(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: activity_announcements_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: activity_announcements_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: activity_announcements_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: activity_announcements_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: activity_announcements_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: activity_announcements_set_input

    """filter the rows which have to be updated"""
    where: activity_announcements_bool_exp!
  ): activity_announcements_mutation_response

  """
  update single row of the table: "activity_announcements"
  """
  update_activity_announcements_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: activity_announcements_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: activity_announcements_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: activity_announcements_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: activity_announcements_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: activity_announcements_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: activity_announcements_set_input
    pk_columns: activity_announcements_pk_columns_input!
  ): activity_announcements

  """
  update multiples rows of table: "activity_announcements"
  """
  update_activity_announcements_many(
    """updates to execute, in order"""
    updates: [activity_announcements_updates!]!
  ): [activity_announcements_mutation_response]

  """
  update data of the table: "activity_log"
  """
  update_activity_log(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: activity_log_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: activity_log_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: activity_log_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: activity_log_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: activity_log_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: activity_log_set_input

    """filter the rows which have to be updated"""
    where: activity_log_bool_exp!
  ): activity_log_mutation_response

  """
  update single row of the table: "activity_log"
  """
  update_activity_log_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: activity_log_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: activity_log_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: activity_log_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: activity_log_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: activity_log_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: activity_log_set_input
    pk_columns: activity_log_pk_columns_input!
  ): activity_log

  """
  update multiples rows of table: "activity_log"
  """
  update_activity_log_many(
    """updates to execute, in order"""
    updates: [activity_log_updates!]!
  ): [activity_log_mutation_response]

  """
  update data of the table: "admin_activity_logs"
  """
  update_admin_activity_logs(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: admin_activity_logs_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: admin_activity_logs_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: admin_activity_logs_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: admin_activity_logs_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: admin_activity_logs_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: admin_activity_logs_set_input

    """filter the rows which have to be updated"""
    where: admin_activity_logs_bool_exp!
  ): admin_activity_logs_mutation_response

  """
  update single row of the table: "admin_activity_logs"
  """
  update_admin_activity_logs_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: admin_activity_logs_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: admin_activity_logs_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: admin_activity_logs_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: admin_activity_logs_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: admin_activity_logs_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: admin_activity_logs_set_input
    pk_columns: admin_activity_logs_pk_columns_input!
  ): admin_activity_logs

  """
  update multiples rows of table: "admin_activity_logs"
  """
  update_admin_activity_logs_many(
    """updates to execute, in order"""
    updates: [admin_activity_logs_updates!]!
  ): [admin_activity_logs_mutation_response]

  """
  update data of the table: "admin_users"
  """
  update_admin_users(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: admin_users_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: admin_users_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: admin_users_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: admin_users_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: admin_users_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: admin_users_set_input

    """filter the rows which have to be updated"""
    where: admin_users_bool_exp!
  ): admin_users_mutation_response

  """
  update single row of the table: "admin_users"
  """
  update_admin_users_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: admin_users_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: admin_users_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: admin_users_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: admin_users_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: admin_users_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: admin_users_set_input
    pk_columns: admin_users_pk_columns_input!
  ): admin_users

  """
  update multiples rows of table: "admin_users"
  """
  update_admin_users_many(
    """updates to execute, in order"""
    updates: [admin_users_updates!]!
  ): [admin_users_mutation_response]

  """
  update data of the table: "agency_audit_logs"
  """
  update_agency_audit_logs(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: agency_audit_logs_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: agency_audit_logs_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: agency_audit_logs_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: agency_audit_logs_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: agency_audit_logs_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: agency_audit_logs_set_input

    """filter the rows which have to be updated"""
    where: agency_audit_logs_bool_exp!
  ): agency_audit_logs_mutation_response

  """
  update single row of the table: "agency_audit_logs"
  """
  update_agency_audit_logs_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: agency_audit_logs_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: agency_audit_logs_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: agency_audit_logs_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: agency_audit_logs_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: agency_audit_logs_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: agency_audit_logs_set_input
    pk_columns: agency_audit_logs_pk_columns_input!
  ): agency_audit_logs

  """
  update multiples rows of table: "agency_audit_logs"
  """
  update_agency_audit_logs_many(
    """updates to execute, in order"""
    updates: [agency_audit_logs_updates!]!
  ): [agency_audit_logs_mutation_response]

  """
  update data of the table: "agency_credits"
  """
  update_agency_credits(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: agency_credits_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: agency_credits_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: agency_credits_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: agency_credits_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: agency_credits_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: agency_credits_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: agency_credits_set_input

    """filter the rows which have to be updated"""
    where: agency_credits_bool_exp!
  ): agency_credits_mutation_response

  """
  update single row of the table: "agency_credits"
  """
  update_agency_credits_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: agency_credits_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: agency_credits_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: agency_credits_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: agency_credits_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: agency_credits_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: agency_credits_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: agency_credits_set_input
    pk_columns: agency_credits_pk_columns_input!
  ): agency_credits

  """
  update multiples rows of table: "agency_credits"
  """
  update_agency_credits_many(
    """updates to execute, in order"""
    updates: [agency_credits_updates!]!
  ): [agency_credits_mutation_response]

  """
  update data of the table: "agency_disputes"
  """
  update_agency_disputes(
    """sets the columns of the filtered rows to the given values"""
    _set: agency_disputes_set_input

    """filter the rows which have to be updated"""
    where: agency_disputes_bool_exp!
  ): agency_disputes_mutation_response

  """
  update single row of the table: "agency_disputes"
  """
  update_agency_disputes_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: agency_disputes_set_input
    pk_columns: agency_disputes_pk_columns_input!
  ): agency_disputes

  """
  update multiples rows of table: "agency_disputes"
  """
  update_agency_disputes_many(
    """updates to execute, in order"""
    updates: [agency_disputes_updates!]!
  ): [agency_disputes_mutation_response]

  """
  update data of the table: "agency_document_requirements"
  """
  update_agency_document_requirements(
    """sets the columns of the filtered rows to the given values"""
    _set: agency_document_requirements_set_input

    """filter the rows which have to be updated"""
    where: agency_document_requirements_bool_exp!
  ): agency_document_requirements_mutation_response

  """
  update single row of the table: "agency_document_requirements"
  """
  update_agency_document_requirements_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: agency_document_requirements_set_input
    pk_columns: agency_document_requirements_pk_columns_input!
  ): agency_document_requirements

  """
  update multiples rows of table: "agency_document_requirements"
  """
  update_agency_document_requirements_many(
    """updates to execute, in order"""
    updates: [agency_document_requirements_updates!]!
  ): [agency_document_requirements_mutation_response]

  """
  update data of the table: "agency_documents"
  """
  update_agency_documents(
    """increments the numeric columns with given value of the filtered values"""
    _inc: agency_documents_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: agency_documents_set_input

    """filter the rows which have to be updated"""
    where: agency_documents_bool_exp!
  ): agency_documents_mutation_response

  """
  update single row of the table: "agency_documents"
  """
  update_agency_documents_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: agency_documents_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: agency_documents_set_input
    pk_columns: agency_documents_pk_columns_input!
  ): agency_documents

  """
  update multiples rows of table: "agency_documents"
  """
  update_agency_documents_many(
    """updates to execute, in order"""
    updates: [agency_documents_updates!]!
  ): [agency_documents_mutation_response]

  """
  update data of the table: "agency_earnings"
  """
  update_agency_earnings(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: agency_earnings_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: agency_earnings_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: agency_earnings_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: agency_earnings_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: agency_earnings_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: agency_earnings_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: agency_earnings_set_input

    """filter the rows which have to be updated"""
    where: agency_earnings_bool_exp!
  ): agency_earnings_mutation_response

  """
  update single row of the table: "agency_earnings"
  """
  update_agency_earnings_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: agency_earnings_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: agency_earnings_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: agency_earnings_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: agency_earnings_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: agency_earnings_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: agency_earnings_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: agency_earnings_set_input
    pk_columns: agency_earnings_pk_columns_input!
  ): agency_earnings

  """
  update multiples rows of table: "agency_earnings"
  """
  update_agency_earnings_many(
    """updates to execute, in order"""
    updates: [agency_earnings_updates!]!
  ): [agency_earnings_mutation_response]

  """
  update data of the table: "agency_interviews"
  """
  update_agency_interviews(
    """increments the numeric columns with given value of the filtered values"""
    _inc: agency_interviews_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: agency_interviews_set_input

    """filter the rows which have to be updated"""
    where: agency_interviews_bool_exp!
  ): agency_interviews_mutation_response

  """
  update single row of the table: "agency_interviews"
  """
  update_agency_interviews_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: agency_interviews_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: agency_interviews_set_input
    pk_columns: agency_interviews_pk_columns_input!
  ): agency_interviews

  """
  update multiples rows of table: "agency_interviews"
  """
  update_agency_interviews_many(
    """updates to execute, in order"""
    updates: [agency_interviews_updates!]!
  ): [agency_interviews_mutation_response]

  """
  update data of the table: "agency_jobs"
  """
  update_agency_jobs(
    """increments the numeric columns with given value of the filtered values"""
    _inc: agency_jobs_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: agency_jobs_set_input

    """filter the rows which have to be updated"""
    where: agency_jobs_bool_exp!
  ): agency_jobs_mutation_response

  """
  update single row of the table: "agency_jobs"
  """
  update_agency_jobs_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: agency_jobs_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: agency_jobs_set_input
    pk_columns: agency_jobs_pk_columns_input!
  ): agency_jobs

  """
  update multiples rows of table: "agency_jobs"
  """
  update_agency_jobs_many(
    """updates to execute, in order"""
    updates: [agency_jobs_updates!]!
  ): [agency_jobs_mutation_response]

  """
  update data of the table: "agency_kyb_audit_log"
  """
  update_agency_kyb_audit_log(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: agency_kyb_audit_log_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: agency_kyb_audit_log_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: agency_kyb_audit_log_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: agency_kyb_audit_log_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: agency_kyb_audit_log_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: agency_kyb_audit_log_set_input

    """filter the rows which have to be updated"""
    where: agency_kyb_audit_log_bool_exp!
  ): agency_kyb_audit_log_mutation_response

  """
  update single row of the table: "agency_kyb_audit_log"
  """
  update_agency_kyb_audit_log_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: agency_kyb_audit_log_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: agency_kyb_audit_log_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: agency_kyb_audit_log_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: agency_kyb_audit_log_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: agency_kyb_audit_log_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: agency_kyb_audit_log_set_input
    pk_columns: agency_kyb_audit_log_pk_columns_input!
  ): agency_kyb_audit_log

  """
  update multiples rows of table: "agency_kyb_audit_log"
  """
  update_agency_kyb_audit_log_many(
    """updates to execute, in order"""
    updates: [agency_kyb_audit_log_updates!]!
  ): [agency_kyb_audit_log_mutation_response]

  """
  update data of the table: "agency_kyb_documents"
  """
  update_agency_kyb_documents(
    """increments the numeric columns with given value of the filtered values"""
    _inc: agency_kyb_documents_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: agency_kyb_documents_set_input

    """filter the rows which have to be updated"""
    where: agency_kyb_documents_bool_exp!
  ): agency_kyb_documents_mutation_response

  """
  update single row of the table: "agency_kyb_documents"
  """
  update_agency_kyb_documents_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: agency_kyb_documents_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: agency_kyb_documents_set_input
    pk_columns: agency_kyb_documents_pk_columns_input!
  ): agency_kyb_documents

  """
  update multiples rows of table: "agency_kyb_documents"
  """
  update_agency_kyb_documents_many(
    """updates to execute, in order"""
    updates: [agency_kyb_documents_updates!]!
  ): [agency_kyb_documents_mutation_response]

  """
  update data of the table: "agency_kyb_verification"
  """
  update_agency_kyb_verification(
    """increments the numeric columns with given value of the filtered values"""
    _inc: agency_kyb_verification_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: agency_kyb_verification_set_input

    """filter the rows which have to be updated"""
    where: agency_kyb_verification_bool_exp!
  ): agency_kyb_verification_mutation_response

  """
  update single row of the table: "agency_kyb_verification"
  """
  update_agency_kyb_verification_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: agency_kyb_verification_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: agency_kyb_verification_set_input
    pk_columns: agency_kyb_verification_pk_columns_input!
  ): agency_kyb_verification

  """
  update multiples rows of table: "agency_kyb_verification"
  """
  update_agency_kyb_verification_many(
    """updates to execute, in order"""
    updates: [agency_kyb_verification_updates!]!
  ): [agency_kyb_verification_mutation_response]

  """
  update data of the table: "agency_payment_failures"
  """
  update_agency_payment_failures(
    """increments the numeric columns with given value of the filtered values"""
    _inc: agency_payment_failures_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: agency_payment_failures_set_input

    """filter the rows which have to be updated"""
    where: agency_payment_failures_bool_exp!
  ): agency_payment_failures_mutation_response

  """
  update single row of the table: "agency_payment_failures"
  """
  update_agency_payment_failures_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: agency_payment_failures_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: agency_payment_failures_set_input
    pk_columns: agency_payment_failures_pk_columns_input!
  ): agency_payment_failures

  """
  update multiples rows of table: "agency_payment_failures"
  """
  update_agency_payment_failures_many(
    """updates to execute, in order"""
    updates: [agency_payment_failures_updates!]!
  ): [agency_payment_failures_mutation_response]

  """
  update data of the table: "agency_payouts"
  """
  update_agency_payouts(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: agency_payouts_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: agency_payouts_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: agency_payouts_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: agency_payouts_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: agency_payouts_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: agency_payouts_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: agency_payouts_set_input

    """filter the rows which have to be updated"""
    where: agency_payouts_bool_exp!
  ): agency_payouts_mutation_response

  """
  update single row of the table: "agency_payouts"
  """
  update_agency_payouts_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: agency_payouts_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: agency_payouts_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: agency_payouts_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: agency_payouts_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: agency_payouts_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: agency_payouts_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: agency_payouts_set_input
    pk_columns: agency_payouts_pk_columns_input!
  ): agency_payouts

  """
  update multiples rows of table: "agency_payouts"
  """
  update_agency_payouts_many(
    """updates to execute, in order"""
    updates: [agency_payouts_updates!]!
  ): [agency_payouts_mutation_response]

  """
  update data of the table: "agency_placements"
  """
  update_agency_placements(
    """sets the columns of the filtered rows to the given values"""
    _set: agency_placements_set_input

    """filter the rows which have to be updated"""
    where: agency_placements_bool_exp!
  ): agency_placements_mutation_response

  """
  update single row of the table: "agency_placements"
  """
  update_agency_placements_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: agency_placements_set_input
    pk_columns: agency_placements_pk_columns_input!
  ): agency_placements

  """
  update multiples rows of table: "agency_placements"
  """
  update_agency_placements_many(
    """updates to execute, in order"""
    updates: [agency_placements_updates!]!
  ): [agency_placements_mutation_response]

  """
  update data of the table: "agency_profiles"
  """
  update_agency_profiles(
    """increments the numeric columns with given value of the filtered values"""
    _inc: agency_profiles_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: agency_profiles_set_input

    """filter the rows which have to be updated"""
    where: agency_profiles_bool_exp!
  ): agency_profiles_mutation_response

  """
  update single row of the table: "agency_profiles"
  """
  update_agency_profiles_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: agency_profiles_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: agency_profiles_set_input
    pk_columns: agency_profiles_pk_columns_input!
  ): agency_profiles

  """
  update multiples rows of table: "agency_profiles"
  """
  update_agency_profiles_many(
    """updates to execute, in order"""
    updates: [agency_profiles_updates!]!
  ): [agency_profiles_mutation_response]

  """
  update data of the table: "agency_tasks"
  """
  update_agency_tasks(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: agency_tasks_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: agency_tasks_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: agency_tasks_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: agency_tasks_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: agency_tasks_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: agency_tasks_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: agency_tasks_set_input

    """filter the rows which have to be updated"""
    where: agency_tasks_bool_exp!
  ): agency_tasks_mutation_response

  """
  update single row of the table: "agency_tasks"
  """
  update_agency_tasks_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: agency_tasks_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: agency_tasks_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: agency_tasks_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: agency_tasks_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: agency_tasks_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: agency_tasks_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: agency_tasks_set_input
    pk_columns: agency_tasks_pk_columns_input!
  ): agency_tasks

  """
  update multiples rows of table: "agency_tasks"
  """
  update_agency_tasks_many(
    """updates to execute, in order"""
    updates: [agency_tasks_updates!]!
  ): [agency_tasks_mutation_response]

  """
  update data of the table: "agency_team_members"
  """
  update_agency_team_members(
    """sets the columns of the filtered rows to the given values"""
    _set: agency_team_members_set_input

    """filter the rows which have to be updated"""
    where: agency_team_members_bool_exp!
  ): agency_team_members_mutation_response

  """
  update single row of the table: "agency_team_members"
  """
  update_agency_team_members_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: agency_team_members_set_input
    pk_columns: agency_team_members_pk_columns_input!
  ): agency_team_members

  """
  update multiples rows of table: "agency_team_members"
  """
  update_agency_team_members_many(
    """updates to execute, in order"""
    updates: [agency_team_members_updates!]!
  ): [agency_team_members_mutation_response]

  """
  update data of the table: "analytics_cache"
  """
  update_analytics_cache(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: analytics_cache_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: analytics_cache_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: analytics_cache_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: analytics_cache_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: analytics_cache_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: analytics_cache_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: analytics_cache_set_input

    """filter the rows which have to be updated"""
    where: analytics_cache_bool_exp!
  ): analytics_cache_mutation_response

  """
  update single row of the table: "analytics_cache"
  """
  update_analytics_cache_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: analytics_cache_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: analytics_cache_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: analytics_cache_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: analytics_cache_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: analytics_cache_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: analytics_cache_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: analytics_cache_set_input
    pk_columns: analytics_cache_pk_columns_input!
  ): analytics_cache

  """
  update multiples rows of table: "analytics_cache"
  """
  update_analytics_cache_many(
    """updates to execute, in order"""
    updates: [analytics_cache_updates!]!
  ): [analytics_cache_mutation_response]

  """
  update data of the table: "announcement_views"
  """
  update_announcement_views(
    """sets the columns of the filtered rows to the given values"""
    _set: announcement_views_set_input

    """filter the rows which have to be updated"""
    where: announcement_views_bool_exp!
  ): announcement_views_mutation_response

  """
  update single row of the table: "announcement_views"
  """
  update_announcement_views_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: announcement_views_set_input
    pk_columns: announcement_views_pk_columns_input!
  ): announcement_views

  """
  update multiples rows of table: "announcement_views"
  """
  update_announcement_views_many(
    """updates to execute, in order"""
    updates: [announcement_views_updates!]!
  ): [announcement_views_mutation_response]

  """
  update data of the table: "applications"
  """
  update_applications(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: applications_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: applications_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: applications_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: applications_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: applications_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: applications_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: applications_set_input

    """filter the rows which have to be updated"""
    where: applications_bool_exp!
  ): applications_mutation_response

  """
  update single row of the table: "applications"
  """
  update_applications_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: applications_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: applications_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: applications_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: applications_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: applications_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: applications_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: applications_set_input
    pk_columns: applications_pk_columns_input!
  ): applications

  """
  update multiples rows of table: "applications"
  """
  update_applications_many(
    """updates to execute, in order"""
    updates: [applications_updates!]!
  ): [applications_mutation_response]

  """
  update data of the table: "audit_logs"
  """
  update_audit_logs(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: audit_logs_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: audit_logs_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: audit_logs_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: audit_logs_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: audit_logs_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: audit_logs_set_input

    """filter the rows which have to be updated"""
    where: audit_logs_bool_exp!
  ): audit_logs_mutation_response

  """
  update single row of the table: "audit_logs"
  """
  update_audit_logs_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: audit_logs_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: audit_logs_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: audit_logs_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: audit_logs_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: audit_logs_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: audit_logs_set_input
    pk_columns: audit_logs_pk_columns_input!
  ): audit_logs

  """
  update multiples rows of table: "audit_logs"
  """
  update_audit_logs_many(
    """updates to execute, in order"""
    updates: [audit_logs_updates!]!
  ): [audit_logs_mutation_response]

  """
  update data of the table: "auth.audit_log_entries"
  """
  update_auth_audit_log_entries(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_audit_log_entries_set_input

    """filter the rows which have to be updated"""
    where: auth_audit_log_entries_bool_exp!
  ): auth_audit_log_entries_mutation_response

  """
  update single row of the table: "auth.audit_log_entries"
  """
  update_auth_audit_log_entries_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_audit_log_entries_set_input
    pk_columns: auth_audit_log_entries_pk_columns_input!
  ): auth_audit_log_entries

  """
  update multiples rows of table: "auth.audit_log_entries"
  """
  update_auth_audit_log_entries_many(
    """updates to execute, in order"""
    updates: [auth_audit_log_entries_updates!]!
  ): [auth_audit_log_entries_mutation_response]

  """
  update data of the table: "auth.flow_state"
  """
  update_auth_flow_state(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_flow_state_set_input

    """filter the rows which have to be updated"""
    where: auth_flow_state_bool_exp!
  ): auth_flow_state_mutation_response

  """
  update single row of the table: "auth.flow_state"
  """
  update_auth_flow_state_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_flow_state_set_input
    pk_columns: auth_flow_state_pk_columns_input!
  ): auth_flow_state

  """
  update multiples rows of table: "auth.flow_state"
  """
  update_auth_flow_state_many(
    """updates to execute, in order"""
    updates: [auth_flow_state_updates!]!
  ): [auth_flow_state_mutation_response]

  """
  update data of the table: "auth.identities"
  """
  update_auth_identities(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: auth_identities_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: auth_identities_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: auth_identities_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: auth_identities_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: auth_identities_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: auth_identities_set_input

    """filter the rows which have to be updated"""
    where: auth_identities_bool_exp!
  ): auth_identities_mutation_response

  """
  update single row of the table: "auth.identities"
  """
  update_auth_identities_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: auth_identities_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: auth_identities_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: auth_identities_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: auth_identities_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: auth_identities_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: auth_identities_set_input
    pk_columns: auth_identities_pk_columns_input!
  ): auth_identities

  """
  update multiples rows of table: "auth.identities"
  """
  update_auth_identities_many(
    """updates to execute, in order"""
    updates: [auth_identities_updates!]!
  ): [auth_identities_mutation_response]

  """
  update data of the table: "auth.instances"
  """
  update_auth_instances(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_instances_set_input

    """filter the rows which have to be updated"""
    where: auth_instances_bool_exp!
  ): auth_instances_mutation_response

  """
  update single row of the table: "auth.instances"
  """
  update_auth_instances_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_instances_set_input
    pk_columns: auth_instances_pk_columns_input!
  ): auth_instances

  """
  update multiples rows of table: "auth.instances"
  """
  update_auth_instances_many(
    """updates to execute, in order"""
    updates: [auth_instances_updates!]!
  ): [auth_instances_mutation_response]

  """
  update data of the table: "auth.mfa_amr_claims"
  """
  update_auth_mfa_amr_claims(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_mfa_amr_claims_set_input

    """filter the rows which have to be updated"""
    where: auth_mfa_amr_claims_bool_exp!
  ): auth_mfa_amr_claims_mutation_response

  """
  update single row of the table: "auth.mfa_amr_claims"
  """
  update_auth_mfa_amr_claims_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_mfa_amr_claims_set_input
    pk_columns: auth_mfa_amr_claims_pk_columns_input!
  ): auth_mfa_amr_claims

  """
  update multiples rows of table: "auth.mfa_amr_claims"
  """
  update_auth_mfa_amr_claims_many(
    """updates to execute, in order"""
    updates: [auth_mfa_amr_claims_updates!]!
  ): [auth_mfa_amr_claims_mutation_response]

  """
  update data of the table: "auth.mfa_challenges"
  """
  update_auth_mfa_challenges(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: auth_mfa_challenges_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: auth_mfa_challenges_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: auth_mfa_challenges_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: auth_mfa_challenges_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: auth_mfa_challenges_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: auth_mfa_challenges_set_input

    """filter the rows which have to be updated"""
    where: auth_mfa_challenges_bool_exp!
  ): auth_mfa_challenges_mutation_response

  """
  update single row of the table: "auth.mfa_challenges"
  """
  update_auth_mfa_challenges_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: auth_mfa_challenges_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: auth_mfa_challenges_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: auth_mfa_challenges_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: auth_mfa_challenges_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: auth_mfa_challenges_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: auth_mfa_challenges_set_input
    pk_columns: auth_mfa_challenges_pk_columns_input!
  ): auth_mfa_challenges

  """
  update multiples rows of table: "auth.mfa_challenges"
  """
  update_auth_mfa_challenges_many(
    """updates to execute, in order"""
    updates: [auth_mfa_challenges_updates!]!
  ): [auth_mfa_challenges_mutation_response]

  """
  update data of the table: "auth.mfa_factors"
  """
  update_auth_mfa_factors(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: auth_mfa_factors_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: auth_mfa_factors_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: auth_mfa_factors_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: auth_mfa_factors_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: auth_mfa_factors_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: auth_mfa_factors_set_input

    """filter the rows which have to be updated"""
    where: auth_mfa_factors_bool_exp!
  ): auth_mfa_factors_mutation_response

  """
  update single row of the table: "auth.mfa_factors"
  """
  update_auth_mfa_factors_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: auth_mfa_factors_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: auth_mfa_factors_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: auth_mfa_factors_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: auth_mfa_factors_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: auth_mfa_factors_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: auth_mfa_factors_set_input
    pk_columns: auth_mfa_factors_pk_columns_input!
  ): auth_mfa_factors

  """
  update multiples rows of table: "auth.mfa_factors"
  """
  update_auth_mfa_factors_many(
    """updates to execute, in order"""
    updates: [auth_mfa_factors_updates!]!
  ): [auth_mfa_factors_mutation_response]

  """
  update data of the table: "auth.oauth_authorizations"
  """
  update_auth_oauth_authorizations(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_oauth_authorizations_set_input

    """filter the rows which have to be updated"""
    where: auth_oauth_authorizations_bool_exp!
  ): auth_oauth_authorizations_mutation_response

  """
  update single row of the table: "auth.oauth_authorizations"
  """
  update_auth_oauth_authorizations_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_oauth_authorizations_set_input
    pk_columns: auth_oauth_authorizations_pk_columns_input!
  ): auth_oauth_authorizations

  """
  update multiples rows of table: "auth.oauth_authorizations"
  """
  update_auth_oauth_authorizations_many(
    """updates to execute, in order"""
    updates: [auth_oauth_authorizations_updates!]!
  ): [auth_oauth_authorizations_mutation_response]

  """
  update data of the table: "auth.oauth_clients"
  """
  update_auth_oauth_clients(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_oauth_clients_set_input

    """filter the rows which have to be updated"""
    where: auth_oauth_clients_bool_exp!
  ): auth_oauth_clients_mutation_response

  """
  update single row of the table: "auth.oauth_clients"
  """
  update_auth_oauth_clients_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_oauth_clients_set_input
    pk_columns: auth_oauth_clients_pk_columns_input!
  ): auth_oauth_clients

  """
  update multiples rows of table: "auth.oauth_clients"
  """
  update_auth_oauth_clients_many(
    """updates to execute, in order"""
    updates: [auth_oauth_clients_updates!]!
  ): [auth_oauth_clients_mutation_response]

  """
  update data of the table: "auth.oauth_consents"
  """
  update_auth_oauth_consents(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_oauth_consents_set_input

    """filter the rows which have to be updated"""
    where: auth_oauth_consents_bool_exp!
  ): auth_oauth_consents_mutation_response

  """
  update single row of the table: "auth.oauth_consents"
  """
  update_auth_oauth_consents_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_oauth_consents_set_input
    pk_columns: auth_oauth_consents_pk_columns_input!
  ): auth_oauth_consents

  """
  update multiples rows of table: "auth.oauth_consents"
  """
  update_auth_oauth_consents_many(
    """updates to execute, in order"""
    updates: [auth_oauth_consents_updates!]!
  ): [auth_oauth_consents_mutation_response]

  """
  update data of the table: "auth.one_time_tokens"
  """
  update_auth_one_time_tokens(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_one_time_tokens_set_input

    """filter the rows which have to be updated"""
    where: auth_one_time_tokens_bool_exp!
  ): auth_one_time_tokens_mutation_response

  """
  update single row of the table: "auth.one_time_tokens"
  """
  update_auth_one_time_tokens_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_one_time_tokens_set_input
    pk_columns: auth_one_time_tokens_pk_columns_input!
  ): auth_one_time_tokens

  """
  update multiples rows of table: "auth.one_time_tokens"
  """
  update_auth_one_time_tokens_many(
    """updates to execute, in order"""
    updates: [auth_one_time_tokens_updates!]!
  ): [auth_one_time_tokens_mutation_response]

  """
  update data of the table: "auth.refresh_tokens"
  """
  update_auth_refresh_tokens(
    """increments the numeric columns with given value of the filtered values"""
    _inc: auth_refresh_tokens_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: auth_refresh_tokens_set_input

    """filter the rows which have to be updated"""
    where: auth_refresh_tokens_bool_exp!
  ): auth_refresh_tokens_mutation_response

  """
  update single row of the table: "auth.refresh_tokens"
  """
  update_auth_refresh_tokens_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: auth_refresh_tokens_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: auth_refresh_tokens_set_input
    pk_columns: auth_refresh_tokens_pk_columns_input!
  ): auth_refresh_tokens

  """
  update multiples rows of table: "auth.refresh_tokens"
  """
  update_auth_refresh_tokens_many(
    """updates to execute, in order"""
    updates: [auth_refresh_tokens_updates!]!
  ): [auth_refresh_tokens_mutation_response]

  """
  update data of the table: "auth.saml_providers"
  """
  update_auth_saml_providers(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: auth_saml_providers_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: auth_saml_providers_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: auth_saml_providers_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: auth_saml_providers_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: auth_saml_providers_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: auth_saml_providers_set_input

    """filter the rows which have to be updated"""
    where: auth_saml_providers_bool_exp!
  ): auth_saml_providers_mutation_response

  """
  update single row of the table: "auth.saml_providers"
  """
  update_auth_saml_providers_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: auth_saml_providers_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: auth_saml_providers_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: auth_saml_providers_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: auth_saml_providers_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: auth_saml_providers_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: auth_saml_providers_set_input
    pk_columns: auth_saml_providers_pk_columns_input!
  ): auth_saml_providers

  """
  update multiples rows of table: "auth.saml_providers"
  """
  update_auth_saml_providers_many(
    """updates to execute, in order"""
    updates: [auth_saml_providers_updates!]!
  ): [auth_saml_providers_mutation_response]

  """
  update data of the table: "auth.saml_relay_states"
  """
  update_auth_saml_relay_states(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_saml_relay_states_set_input

    """filter the rows which have to be updated"""
    where: auth_saml_relay_states_bool_exp!
  ): auth_saml_relay_states_mutation_response

  """
  update single row of the table: "auth.saml_relay_states"
  """
  update_auth_saml_relay_states_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_saml_relay_states_set_input
    pk_columns: auth_saml_relay_states_pk_columns_input!
  ): auth_saml_relay_states

  """
  update multiples rows of table: "auth.saml_relay_states"
  """
  update_auth_saml_relay_states_many(
    """updates to execute, in order"""
    updates: [auth_saml_relay_states_updates!]!
  ): [auth_saml_relay_states_mutation_response]

  """
  update data of the table: "auth.sessions"
  """
  update_auth_sessions(
    """increments the numeric columns with given value of the filtered values"""
    _inc: auth_sessions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: auth_sessions_set_input

    """filter the rows which have to be updated"""
    where: auth_sessions_bool_exp!
  ): auth_sessions_mutation_response

  """
  update single row of the table: "auth.sessions"
  """
  update_auth_sessions_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: auth_sessions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: auth_sessions_set_input
    pk_columns: auth_sessions_pk_columns_input!
  ): auth_sessions

  """
  update multiples rows of table: "auth.sessions"
  """
  update_auth_sessions_many(
    """updates to execute, in order"""
    updates: [auth_sessions_updates!]!
  ): [auth_sessions_mutation_response]

  """
  update data of the table: "auth.sso_domains"
  """
  update_auth_sso_domains(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_sso_domains_set_input

    """filter the rows which have to be updated"""
    where: auth_sso_domains_bool_exp!
  ): auth_sso_domains_mutation_response

  """
  update single row of the table: "auth.sso_domains"
  """
  update_auth_sso_domains_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_sso_domains_set_input
    pk_columns: auth_sso_domains_pk_columns_input!
  ): auth_sso_domains

  """
  update multiples rows of table: "auth.sso_domains"
  """
  update_auth_sso_domains_many(
    """updates to execute, in order"""
    updates: [auth_sso_domains_updates!]!
  ): [auth_sso_domains_mutation_response]

  """
  update data of the table: "auth.sso_providers"
  """
  update_auth_sso_providers(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_sso_providers_set_input

    """filter the rows which have to be updated"""
    where: auth_sso_providers_bool_exp!
  ): auth_sso_providers_mutation_response

  """
  update single row of the table: "auth.sso_providers"
  """
  update_auth_sso_providers_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_sso_providers_set_input
    pk_columns: auth_sso_providers_pk_columns_input!
  ): auth_sso_providers

  """
  update multiples rows of table: "auth.sso_providers"
  """
  update_auth_sso_providers_many(
    """updates to execute, in order"""
    updates: [auth_sso_providers_updates!]!
  ): [auth_sso_providers_mutation_response]

  """
  update data of the table: "auth.users"
  """
  update_auth_users(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: auth_users_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: auth_users_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: auth_users_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: auth_users_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: auth_users_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: auth_users_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: auth_users_set_input

    """filter the rows which have to be updated"""
    where: auth_users_bool_exp!
  ): auth_users_mutation_response

  """
  update single row of the table: "auth.users"
  """
  update_auth_users_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: auth_users_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: auth_users_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: auth_users_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: auth_users_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: auth_users_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: auth_users_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: auth_users_set_input
    pk_columns: auth_users_pk_columns_input!
  ): auth_users

  """
  update multiples rows of table: "auth.users"
  """
  update_auth_users_many(
    """updates to execute, in order"""
    updates: [auth_users_updates!]!
  ): [auth_users_mutation_response]

  """
  update data of the table: "booking_requests"
  """
  update_booking_requests(
    """increments the numeric columns with given value of the filtered values"""
    _inc: booking_requests_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: booking_requests_set_input

    """filter the rows which have to be updated"""
    where: booking_requests_bool_exp!
  ): booking_requests_mutation_response

  """
  update single row of the table: "booking_requests"
  """
  update_booking_requests_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: booking_requests_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: booking_requests_set_input
    pk_columns: booking_requests_pk_columns_input!
  ): booking_requests

  """
  update multiples rows of table: "booking_requests"
  """
  update_booking_requests_many(
    """updates to execute, in order"""
    updates: [booking_requests_updates!]!
  ): [booking_requests_mutation_response]

  """
  update data of the table: "bookings"
  """
  update_bookings(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: bookings_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: bookings_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: bookings_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: bookings_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: bookings_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: bookings_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: bookings_set_input

    """filter the rows which have to be updated"""
    where: bookings_bool_exp!
  ): bookings_mutation_response

  """
  update single row of the table: "bookings"
  """
  update_bookings_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: bookings_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: bookings_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: bookings_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: bookings_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: bookings_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: bookings_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: bookings_set_input
    pk_columns: bookings_pk_columns_input!
  ): bookings

  """
  update multiples rows of table: "bookings"
  """
  update_bookings_many(
    """updates to execute, in order"""
    updates: [bookings_updates!]!
  ): [bookings_mutation_response]

  """
  update data of the table: "calendar_events"
  """
  update_calendar_events(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: calendar_events_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: calendar_events_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: calendar_events_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: calendar_events_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: calendar_events_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: calendar_events_set_input

    """filter the rows which have to be updated"""
    where: calendar_events_bool_exp!
  ): calendar_events_mutation_response

  """
  update single row of the table: "calendar_events"
  """
  update_calendar_events_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: calendar_events_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: calendar_events_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: calendar_events_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: calendar_events_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: calendar_events_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: calendar_events_set_input
    pk_columns: calendar_events_pk_columns_input!
  ): calendar_events

  """
  update multiples rows of table: "calendar_events"
  """
  update_calendar_events_many(
    """updates to execute, in order"""
    updates: [calendar_events_updates!]!
  ): [calendar_events_mutation_response]

  """
  update data of the table: "client_satisfaction_ratings"
  """
  update_client_satisfaction_ratings(
    """increments the numeric columns with given value of the filtered values"""
    _inc: client_satisfaction_ratings_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: client_satisfaction_ratings_set_input

    """filter the rows which have to be updated"""
    where: client_satisfaction_ratings_bool_exp!
  ): client_satisfaction_ratings_mutation_response

  """
  update single row of the table: "client_satisfaction_ratings"
  """
  update_client_satisfaction_ratings_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: client_satisfaction_ratings_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: client_satisfaction_ratings_set_input
    pk_columns: client_satisfaction_ratings_pk_columns_input!
  ): client_satisfaction_ratings

  """
  update multiples rows of table: "client_satisfaction_ratings"
  """
  update_client_satisfaction_ratings_many(
    """updates to execute, in order"""
    updates: [client_satisfaction_ratings_updates!]!
  ): [client_satisfaction_ratings_mutation_response]

  """
  update data of the table: "compliance_categories"
  """
  update_compliance_categories(
    """increments the numeric columns with given value of the filtered values"""
    _inc: compliance_categories_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: compliance_categories_set_input

    """filter the rows which have to be updated"""
    where: compliance_categories_bool_exp!
  ): compliance_categories_mutation_response

  """
  update single row of the table: "compliance_categories"
  """
  update_compliance_categories_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: compliance_categories_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: compliance_categories_set_input
    pk_columns: compliance_categories_pk_columns_input!
  ): compliance_categories

  """
  update multiples rows of table: "compliance_categories"
  """
  update_compliance_categories_many(
    """updates to execute, in order"""
    updates: [compliance_categories_updates!]!
  ): [compliance_categories_mutation_response]

  """
  update data of the table: "compliance_items"
  """
  update_compliance_items(
    """sets the columns of the filtered rows to the given values"""
    _set: compliance_items_set_input

    """filter the rows which have to be updated"""
    where: compliance_items_bool_exp!
  ): compliance_items_mutation_response

  """
  update single row of the table: "compliance_items"
  """
  update_compliance_items_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: compliance_items_set_input
    pk_columns: compliance_items_pk_columns_input!
  ): compliance_items

  """
  update multiples rows of table: "compliance_items"
  """
  update_compliance_items_many(
    """updates to execute, in order"""
    updates: [compliance_items_updates!]!
  ): [compliance_items_mutation_response]

  """
  update data of the table: "contact_fees"
  """
  update_contact_fees(
    """increments the numeric columns with given value of the filtered values"""
    _inc: contact_fees_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: contact_fees_set_input

    """filter the rows which have to be updated"""
    where: contact_fees_bool_exp!
  ): contact_fees_mutation_response

  """
  update single row of the table: "contact_fees"
  """
  update_contact_fees_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: contact_fees_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: contact_fees_set_input
    pk_columns: contact_fees_pk_columns_input!
  ): contact_fees

  """
  update multiples rows of table: "contact_fees"
  """
  update_contact_fees_many(
    """updates to execute, in order"""
    updates: [contact_fees_updates!]!
  ): [contact_fees_mutation_response]

  """
  update data of the table: "content_moderation_flags"
  """
  update_content_moderation_flags(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: content_moderation_flags_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: content_moderation_flags_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: content_moderation_flags_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: content_moderation_flags_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: content_moderation_flags_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: content_moderation_flags_set_input

    """filter the rows which have to be updated"""
    where: content_moderation_flags_bool_exp!
  ): content_moderation_flags_mutation_response

  """
  update single row of the table: "content_moderation_flags"
  """
  update_content_moderation_flags_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: content_moderation_flags_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: content_moderation_flags_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: content_moderation_flags_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: content_moderation_flags_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: content_moderation_flags_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: content_moderation_flags_set_input
    pk_columns: content_moderation_flags_pk_columns_input!
  ): content_moderation_flags

  """
  update multiples rows of table: "content_moderation_flags"
  """
  update_content_moderation_flags_many(
    """updates to execute, in order"""
    updates: [content_moderation_flags_updates!]!
  ): [content_moderation_flags_mutation_response]

  """
  update data of the table: "conversations"
  """
  update_conversations(
    """increments the numeric columns with given value of the filtered values"""
    _inc: conversations_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: conversations_set_input

    """filter the rows which have to be updated"""
    where: conversations_bool_exp!
  ): conversations_mutation_response

  """
  update single row of the table: "conversations"
  """
  update_conversations_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: conversations_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: conversations_set_input
    pk_columns: conversations_pk_columns_input!
  ): conversations

  """
  update multiples rows of table: "conversations"
  """
  update_conversations_many(
    """updates to execute, in order"""
    updates: [conversations_updates!]!
  ): [conversations_mutation_response]

  """
  update data of the table: "conversion_events"
  """
  update_conversion_events(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: conversion_events_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: conversion_events_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: conversion_events_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: conversion_events_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: conversion_events_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: conversion_events_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: conversion_events_set_input

    """filter the rows which have to be updated"""
    where: conversion_events_bool_exp!
  ): conversion_events_mutation_response

  """
  update single row of the table: "conversion_events"
  """
  update_conversion_events_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: conversion_events_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: conversion_events_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: conversion_events_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: conversion_events_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: conversion_events_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: conversion_events_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: conversion_events_set_input
    pk_columns: conversion_events_pk_columns_input!
  ): conversion_events

  """
  update multiples rows of table: "conversion_events"
  """
  update_conversion_events_many(
    """updates to execute, in order"""
    updates: [conversion_events_updates!]!
  ): [conversion_events_mutation_response]

  """
  update data of the table: "countries"
  """
  update_countries(
    """increments the numeric columns with given value of the filtered values"""
    _inc: countries_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: countries_set_input

    """filter the rows which have to be updated"""
    where: countries_bool_exp!
  ): countries_mutation_response

  """
  update single row of the table: "countries"
  """
  update_countries_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: countries_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: countries_set_input
    pk_columns: countries_pk_columns_input!
  ): countries

  """
  update multiples rows of table: "countries"
  """
  update_countries_many(
    """updates to execute, in order"""
    updates: [countries_updates!]!
  ): [countries_mutation_response]

  """
  update data of the table: "country_codes"
  """
  update_country_codes(
    """increments the numeric columns with given value of the filtered values"""
    _inc: country_codes_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: country_codes_set_input

    """filter the rows which have to be updated"""
    where: country_codes_bool_exp!
  ): country_codes_mutation_response

  """
  update single row of the table: "country_codes"
  """
  update_country_codes_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: country_codes_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: country_codes_set_input
    pk_columns: country_codes_pk_columns_input!
  ): country_codes

  """
  update multiples rows of table: "country_codes"
  """
  update_country_codes_many(
    """updates to execute, in order"""
    updates: [country_codes_updates!]!
  ): [country_codes_mutation_response]

  """
  update data of the table: "credit_transactions"
  """
  update_credit_transactions(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: credit_transactions_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: credit_transactions_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: credit_transactions_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: credit_transactions_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: credit_transactions_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: credit_transactions_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: credit_transactions_set_input

    """filter the rows which have to be updated"""
    where: credit_transactions_bool_exp!
  ): credit_transactions_mutation_response

  """
  update single row of the table: "credit_transactions"
  """
  update_credit_transactions_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: credit_transactions_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: credit_transactions_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: credit_transactions_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: credit_transactions_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: credit_transactions_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: credit_transactions_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: credit_transactions_set_input
    pk_columns: credit_transactions_pk_columns_input!
  ): credit_transactions

  """
  update multiples rows of table: "credit_transactions"
  """
  update_credit_transactions_many(
    """updates to execute, in order"""
    updates: [credit_transactions_updates!]!
  ): [credit_transactions_mutation_response]

  """
  update data of the table: "dispute_evidence"
  """
  update_dispute_evidence(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: dispute_evidence_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: dispute_evidence_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: dispute_evidence_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: dispute_evidence_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: dispute_evidence_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: dispute_evidence_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: dispute_evidence_set_input

    """filter the rows which have to be updated"""
    where: dispute_evidence_bool_exp!
  ): dispute_evidence_mutation_response

  """
  update single row of the table: "dispute_evidence"
  """
  update_dispute_evidence_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: dispute_evidence_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: dispute_evidence_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: dispute_evidence_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: dispute_evidence_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: dispute_evidence_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: dispute_evidence_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: dispute_evidence_set_input
    pk_columns: dispute_evidence_pk_columns_input!
  ): dispute_evidence

  """
  update multiples rows of table: "dispute_evidence"
  """
  update_dispute_evidence_many(
    """updates to execute, in order"""
    updates: [dispute_evidence_updates!]!
  ): [dispute_evidence_mutation_response]

  """
  update data of the table: "dispute_messages"
  """
  update_dispute_messages(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: dispute_messages_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: dispute_messages_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: dispute_messages_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: dispute_messages_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: dispute_messages_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: dispute_messages_set_input

    """filter the rows which have to be updated"""
    where: dispute_messages_bool_exp!
  ): dispute_messages_mutation_response

  """
  update single row of the table: "dispute_messages"
  """
  update_dispute_messages_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: dispute_messages_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: dispute_messages_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: dispute_messages_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: dispute_messages_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: dispute_messages_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: dispute_messages_set_input
    pk_columns: dispute_messages_pk_columns_input!
  ): dispute_messages

  """
  update multiples rows of table: "dispute_messages"
  """
  update_dispute_messages_many(
    """updates to execute, in order"""
    updates: [dispute_messages_updates!]!
  ): [dispute_messages_mutation_response]

  """
  update data of the table: "dispute_parties"
  """
  update_dispute_parties(
    """sets the columns of the filtered rows to the given values"""
    _set: dispute_parties_set_input

    """filter the rows which have to be updated"""
    where: dispute_parties_bool_exp!
  ): dispute_parties_mutation_response

  """
  update single row of the table: "dispute_parties"
  """
  update_dispute_parties_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: dispute_parties_set_input
    pk_columns: dispute_parties_pk_columns_input!
  ): dispute_parties

  """
  update multiples rows of table: "dispute_parties"
  """
  update_dispute_parties_many(
    """updates to execute, in order"""
    updates: [dispute_parties_updates!]!
  ): [dispute_parties_mutation_response]

  """
  update data of the table: "disputes"
  """
  update_disputes(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: disputes_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: disputes_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: disputes_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: disputes_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: disputes_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: disputes_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: disputes_set_input

    """filter the rows which have to be updated"""
    where: disputes_bool_exp!
  ): disputes_mutation_response

  """
  update single row of the table: "disputes"
  """
  update_disputes_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: disputes_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: disputes_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: disputes_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: disputes_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: disputes_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: disputes_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: disputes_set_input
    pk_columns: disputes_pk_columns_input!
  ): disputes

  """
  update multiples rows of table: "disputes"
  """
  update_disputes_many(
    """updates to execute, in order"""
    updates: [disputes_updates!]!
  ): [disputes_mutation_response]

  """
  update data of the table: "favorites"
  """
  update_favorites(
    """sets the columns of the filtered rows to the given values"""
    _set: favorites_set_input

    """filter the rows which have to be updated"""
    where: favorites_bool_exp!
  ): favorites_mutation_response

  """
  update single row of the table: "favorites"
  """
  update_favorites_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: favorites_set_input
    pk_columns: favorites_pk_columns_input!
  ): favorites

  """
  update multiples rows of table: "favorites"
  """
  update_favorites_many(
    """updates to execute, in order"""
    updates: [favorites_updates!]!
  ): [favorites_mutation_response]

  """
  update data of the table: "interview_notifications"
  """
  update_interview_notifications(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: interview_notifications_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: interview_notifications_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: interview_notifications_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: interview_notifications_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: interview_notifications_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: interview_notifications_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: interview_notifications_set_input

    """filter the rows which have to be updated"""
    where: interview_notifications_bool_exp!
  ): interview_notifications_mutation_response

  """
  update single row of the table: "interview_notifications"
  """
  update_interview_notifications_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: interview_notifications_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: interview_notifications_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: interview_notifications_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: interview_notifications_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: interview_notifications_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: interview_notifications_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: interview_notifications_set_input
    pk_columns: interview_notifications_pk_columns_input!
  ): interview_notifications

  """
  update multiples rows of table: "interview_notifications"
  """
  update_interview_notifications_many(
    """updates to execute, in order"""
    updates: [interview_notifications_updates!]!
  ): [interview_notifications_mutation_response]

  """
  update data of the table: "interview_platform_templates"
  """
  update_interview_platform_templates(
    """sets the columns of the filtered rows to the given values"""
    _set: interview_platform_templates_set_input

    """filter the rows which have to be updated"""
    where: interview_platform_templates_bool_exp!
  ): interview_platform_templates_mutation_response

  """
  update single row of the table: "interview_platform_templates"
  """
  update_interview_platform_templates_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: interview_platform_templates_set_input
    pk_columns: interview_platform_templates_pk_columns_input!
  ): interview_platform_templates

  """
  update multiples rows of table: "interview_platform_templates"
  """
  update_interview_platform_templates_many(
    """updates to execute, in order"""
    updates: [interview_platform_templates_updates!]!
  ): [interview_platform_templates_mutation_response]

  """
  update data of the table: "job_applications"
  """
  update_job_applications(
    """increments the numeric columns with given value of the filtered values"""
    _inc: job_applications_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: job_applications_set_input

    """filter the rows which have to be updated"""
    where: job_applications_bool_exp!
  ): job_applications_mutation_response

  """
  update single row of the table: "job_applications"
  """
  update_job_applications_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: job_applications_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: job_applications_set_input
    pk_columns: job_applications_pk_columns_input!
  ): job_applications

  """
  update multiples rows of table: "job_applications"
  """
  update_job_applications_many(
    """updates to execute, in order"""
    updates: [job_applications_updates!]!
  ): [job_applications_mutation_response]

  """
  update data of the table: "job_postings"
  """
  update_job_postings(
    """increments the numeric columns with given value of the filtered values"""
    _inc: job_postings_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: job_postings_set_input

    """filter the rows which have to be updated"""
    where: job_postings_bool_exp!
  ): job_postings_mutation_response

  """
  update multiples rows of table: "job_postings"
  """
  update_job_postings_many(
    """updates to execute, in order"""
    updates: [job_postings_updates!]!
  ): [job_postings_mutation_response]

  """
  update data of the table: "jobs"
  """
  update_jobs(
    """increments the numeric columns with given value of the filtered values"""
    _inc: jobs_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: jobs_set_input

    """filter the rows which have to be updated"""
    where: jobs_bool_exp!
  ): jobs_mutation_response

  """
  update single row of the table: "jobs"
  """
  update_jobs_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: jobs_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: jobs_set_input
    pk_columns: jobs_pk_columns_input!
  ): jobs

  """
  update multiples rows of table: "jobs"
  """
  update_jobs_many(
    """updates to execute, in order"""
    updates: [jobs_updates!]!
  ): [jobs_mutation_response]

  """
  update data of the table: "maid_bookings"
  """
  update_maid_bookings(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: maid_bookings_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: maid_bookings_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: maid_bookings_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: maid_bookings_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: maid_bookings_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: maid_bookings_set_input

    """filter the rows which have to be updated"""
    where: maid_bookings_bool_exp!
  ): maid_bookings_mutation_response

  """
  update single row of the table: "maid_bookings"
  """
  update_maid_bookings_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: maid_bookings_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: maid_bookings_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: maid_bookings_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: maid_bookings_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: maid_bookings_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: maid_bookings_set_input
    pk_columns: maid_bookings_pk_columns_input!
  ): maid_bookings

  """
  update multiples rows of table: "maid_bookings"
  """
  update_maid_bookings_many(
    """updates to execute, in order"""
    updates: [maid_bookings_updates!]!
  ): [maid_bookings_mutation_response]

  """
  update data of the table: "maid_documents"
  """
  update_maid_documents(
    """increments the numeric columns with given value of the filtered values"""
    _inc: maid_documents_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: maid_documents_set_input

    """filter the rows which have to be updated"""
    where: maid_documents_bool_exp!
  ): maid_documents_mutation_response

  """
  update single row of the table: "maid_documents"
  """
  update_maid_documents_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: maid_documents_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: maid_documents_set_input
    pk_columns: maid_documents_pk_columns_input!
  ): maid_documents

  """
  update multiples rows of table: "maid_documents"
  """
  update_maid_documents_many(
    """updates to execute, in order"""
    updates: [maid_documents_updates!]!
  ): [maid_documents_mutation_response]

  """
  update data of the table: "maid_images"
  """
  update_maid_images(
    """increments the numeric columns with given value of the filtered values"""
    _inc: maid_images_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: maid_images_set_input

    """filter the rows which have to be updated"""
    where: maid_images_bool_exp!
  ): maid_images_mutation_response

  """
  update single row of the table: "maid_images"
  """
  update_maid_images_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: maid_images_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: maid_images_set_input
    pk_columns: maid_images_pk_columns_input!
  ): maid_images

  """
  update multiples rows of table: "maid_images"
  """
  update_maid_images_many(
    """updates to execute, in order"""
    updates: [maid_images_updates!]!
  ): [maid_images_mutation_response]

  """
  update data of the table: "maid_profiles"
  """
  update_maid_profiles(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: maid_profiles_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: maid_profiles_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: maid_profiles_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: maid_profiles_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: maid_profiles_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: maid_profiles_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: maid_profiles_set_input

    """filter the rows which have to be updated"""
    where: maid_profiles_bool_exp!
  ): maid_profiles_mutation_response

  """
  update single row of the table: "maid_profiles"
  """
  update_maid_profiles_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: maid_profiles_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: maid_profiles_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: maid_profiles_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: maid_profiles_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: maid_profiles_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: maid_profiles_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: maid_profiles_set_input
    pk_columns: maid_profiles_pk_columns_input!
  ): maid_profiles

  """
  update multiples rows of table: "maid_profiles"
  """
  update_maid_profiles_many(
    """updates to execute, in order"""
    updates: [maid_profiles_updates!]!
  ): [maid_profiles_mutation_response]

  """
  update data of the table: "maid_videos"
  """
  update_maid_videos(
    """increments the numeric columns with given value of the filtered values"""
    _inc: maid_videos_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: maid_videos_set_input

    """filter the rows which have to be updated"""
    where: maid_videos_bool_exp!
  ): maid_videos_mutation_response

  """
  update single row of the table: "maid_videos"
  """
  update_maid_videos_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: maid_videos_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: maid_videos_set_input
    pk_columns: maid_videos_pk_columns_input!
  ): maid_videos

  """
  update multiples rows of table: "maid_videos"
  """
  update_maid_videos_many(
    """updates to execute, in order"""
    updates: [maid_videos_updates!]!
  ): [maid_videos_mutation_response]

  """
  update data of the table: "message_templates"
  """
  update_message_templates(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: message_templates_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: message_templates_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: message_templates_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: message_templates_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: message_templates_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: message_templates_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: message_templates_set_input

    """filter the rows which have to be updated"""
    where: message_templates_bool_exp!
  ): message_templates_mutation_response

  """
  update single row of the table: "message_templates"
  """
  update_message_templates_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: message_templates_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: message_templates_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: message_templates_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: message_templates_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: message_templates_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: message_templates_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: message_templates_set_input
    pk_columns: message_templates_pk_columns_input!
  ): message_templates

  """
  update multiples rows of table: "message_templates"
  """
  update_message_templates_many(
    """updates to execute, in order"""
    updates: [message_templates_updates!]!
  ): [message_templates_mutation_response]

  """
  update data of the table: "messages"
  """
  update_messages(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: messages_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: messages_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: messages_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: messages_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: messages_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: messages_set_input

    """filter the rows which have to be updated"""
    where: messages_bool_exp!
  ): messages_mutation_response

  """
  update single row of the table: "messages"
  """
  update_messages_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: messages_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: messages_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: messages_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: messages_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: messages_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: messages_set_input
    pk_columns: messages_pk_columns_input!
  ): messages

  """
  update multiples rows of table: "messages"
  """
  update_messages_many(
    """updates to execute, in order"""
    updates: [messages_updates!]!
  ): [messages_mutation_response]

  """
  update data of the table: "news_items"
  """
  update_news_items(
    """increments the numeric columns with given value of the filtered values"""
    _inc: news_items_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: news_items_set_input

    """filter the rows which have to be updated"""
    where: news_items_bool_exp!
  ): news_items_mutation_response

  """
  update single row of the table: "news_items"
  """
  update_news_items_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: news_items_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: news_items_set_input
    pk_columns: news_items_pk_columns_input!
  ): news_items

  """
  update multiples rows of table: "news_items"
  """
  update_news_items_many(
    """updates to execute, in order"""
    updates: [news_items_updates!]!
  ): [news_items_mutation_response]

  """
  update data of the table: "news_sources"
  """
  update_news_sources(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: news_sources_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: news_sources_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: news_sources_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: news_sources_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: news_sources_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: news_sources_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: news_sources_set_input

    """filter the rows which have to be updated"""
    where: news_sources_bool_exp!
  ): news_sources_mutation_response

  """
  update single row of the table: "news_sources"
  """
  update_news_sources_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: news_sources_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: news_sources_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: news_sources_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: news_sources_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: news_sources_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: news_sources_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: news_sources_set_input
    pk_columns: news_sources_pk_columns_input!
  ): news_sources

  """
  update multiples rows of table: "news_sources"
  """
  update_news_sources_many(
    """updates to execute, in order"""
    updates: [news_sources_updates!]!
  ): [news_sources_mutation_response]

  """
  update data of the table: "notifications"
  """
  update_notifications(
    """sets the columns of the filtered rows to the given values"""
    _set: notifications_set_input

    """filter the rows which have to be updated"""
    where: notifications_bool_exp!
  ): notifications_mutation_response

  """
  update single row of the table: "notifications"
  """
  update_notifications_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: notifications_set_input
    pk_columns: notifications_pk_columns_input!
  ): notifications

  """
  update multiples rows of table: "notifications"
  """
  update_notifications_many(
    """updates to execute, in order"""
    updates: [notifications_updates!]!
  ): [notifications_mutation_response]

  """
  update data of the table: "page_views"
  """
  update_page_views(
    """increments the numeric columns with given value of the filtered values"""
    _inc: page_views_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: page_views_set_input

    """filter the rows which have to be updated"""
    where: page_views_bool_exp!
  ): page_views_mutation_response

  """
  update single row of the table: "page_views"
  """
  update_page_views_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: page_views_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: page_views_set_input
    pk_columns: page_views_pk_columns_input!
  ): page_views

  """
  update multiples rows of table: "page_views"
  """
  update_page_views_many(
    """updates to execute, in order"""
    updates: [page_views_updates!]!
  ): [page_views_mutation_response]

  """
  update data of the table: "password_resets"
  """
  update_password_resets(
    """sets the columns of the filtered rows to the given values"""
    _set: password_resets_set_input

    """filter the rows which have to be updated"""
    where: password_resets_bool_exp!
  ): password_resets_mutation_response

  """
  update single row of the table: "password_resets"
  """
  update_password_resets_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: password_resets_set_input
    pk_columns: password_resets_pk_columns_input!
  ): password_resets

  """
  update multiples rows of table: "password_resets"
  """
  update_password_resets_many(
    """updates to execute, in order"""
    updates: [password_resets_updates!]!
  ): [password_resets_mutation_response]

  """
  update data of the table: "payment_idempotency"
  """
  update_payment_idempotency(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: payment_idempotency_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: payment_idempotency_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: payment_idempotency_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: payment_idempotency_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: payment_idempotency_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: payment_idempotency_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: payment_idempotency_set_input

    """filter the rows which have to be updated"""
    where: payment_idempotency_bool_exp!
  ): payment_idempotency_mutation_response

  """
  update single row of the table: "payment_idempotency"
  """
  update_payment_idempotency_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: payment_idempotency_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: payment_idempotency_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: payment_idempotency_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: payment_idempotency_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: payment_idempotency_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: payment_idempotency_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: payment_idempotency_set_input
    pk_columns: payment_idempotency_pk_columns_input!
  ): payment_idempotency

  """
  update multiples rows of table: "payment_idempotency"
  """
  update_payment_idempotency_many(
    """updates to execute, in order"""
    updates: [payment_idempotency_updates!]!
  ): [payment_idempotency_mutation_response]

  """
  update data of the table: "payment_methods"
  """
  update_payment_methods(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: payment_methods_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: payment_methods_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: payment_methods_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: payment_methods_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: payment_methods_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: payment_methods_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: payment_methods_set_input

    """filter the rows which have to be updated"""
    where: payment_methods_bool_exp!
  ): payment_methods_mutation_response

  """
  update single row of the table: "payment_methods"
  """
  update_payment_methods_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: payment_methods_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: payment_methods_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: payment_methods_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: payment_methods_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: payment_methods_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: payment_methods_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: payment_methods_set_input
    pk_columns: payment_methods_pk_columns_input!
  ): payment_methods

  """
  update multiples rows of table: "payment_methods"
  """
  update_payment_methods_many(
    """updates to execute, in order"""
    updates: [payment_methods_updates!]!
  ): [payment_methods_mutation_response]

  """
  update data of the table: "payments"
  """
  update_payments(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: payments_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: payments_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: payments_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: payments_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: payments_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: payments_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: payments_set_input

    """filter the rows which have to be updated"""
    where: payments_bool_exp!
  ): payments_mutation_response

  """
  update single row of the table: "payments"
  """
  update_payments_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: payments_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: payments_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: payments_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: payments_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: payments_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: payments_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: payments_set_input
    pk_columns: payments_pk_columns_input!
  ): payments

  """
  update multiples rows of table: "payments"
  """
  update_payments_many(
    """updates to execute, in order"""
    updates: [payments_updates!]!
  ): [payments_mutation_response]

  """
  update data of the table: "payout_accounts"
  """
  update_payout_accounts(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: payout_accounts_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: payout_accounts_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: payout_accounts_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: payout_accounts_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: payout_accounts_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: payout_accounts_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: payout_accounts_set_input

    """filter the rows which have to be updated"""
    where: payout_accounts_bool_exp!
  ): payout_accounts_mutation_response

  """
  update single row of the table: "payout_accounts"
  """
  update_payout_accounts_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: payout_accounts_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: payout_accounts_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: payout_accounts_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: payout_accounts_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: payout_accounts_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: payout_accounts_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: payout_accounts_set_input
    pk_columns: payout_accounts_pk_columns_input!
  ): payout_accounts

  """
  update multiples rows of table: "payout_accounts"
  """
  update_payout_accounts_many(
    """updates to execute, in order"""
    updates: [payout_accounts_updates!]!
  ): [payout_accounts_mutation_response]

  """
  update data of the table: "payout_schedules"
  """
  update_payout_schedules(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payout_schedules_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payout_schedules_set_input

    """filter the rows which have to be updated"""
    where: payout_schedules_bool_exp!
  ): payout_schedules_mutation_response

  """
  update single row of the table: "payout_schedules"
  """
  update_payout_schedules_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payout_schedules_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payout_schedules_set_input
    pk_columns: payout_schedules_pk_columns_input!
  ): payout_schedules

  """
  update multiples rows of table: "payout_schedules"
  """
  update_payout_schedules_many(
    """updates to execute, in order"""
    updates: [payout_schedules_updates!]!
  ): [payout_schedules_mutation_response]

  """
  update data of the table: "phone_verification_log"
  """
  update_phone_verification_log(
    """sets the columns of the filtered rows to the given values"""
    _set: phone_verification_log_set_input

    """filter the rows which have to be updated"""
    where: phone_verification_log_bool_exp!
  ): phone_verification_log_mutation_response

  """
  update single row of the table: "phone_verification_log"
  """
  update_phone_verification_log_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: phone_verification_log_set_input
    pk_columns: phone_verification_log_pk_columns_input!
  ): phone_verification_log

  """
  update multiples rows of table: "phone_verification_log"
  """
  update_phone_verification_log_many(
    """updates to execute, in order"""
    updates: [phone_verification_log_updates!]!
  ): [phone_verification_log_mutation_response]

  """
  update data of the table: "phone_verifications"
  """
  update_phone_verifications(
    """increments the numeric columns with given value of the filtered values"""
    _inc: phone_verifications_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: phone_verifications_set_input

    """filter the rows which have to be updated"""
    where: phone_verifications_bool_exp!
  ): phone_verifications_mutation_response

  """
  update single row of the table: "phone_verifications"
  """
  update_phone_verifications_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: phone_verifications_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: phone_verifications_set_input
    pk_columns: phone_verifications_pk_columns_input!
  ): phone_verifications

  """
  update multiples rows of table: "phone_verifications"
  """
  update_phone_verifications_many(
    """updates to execute, in order"""
    updates: [phone_verifications_updates!]!
  ): [phone_verifications_mutation_response]

  """
  update data of the table: "pii_access_log"
  """
  update_pii_access_log(
    """sets the columns of the filtered rows to the given values"""
    _set: pii_access_log_set_input

    """filter the rows which have to be updated"""
    where: pii_access_log_bool_exp!
  ): pii_access_log_mutation_response

  """
  update single row of the table: "pii_access_log"
  """
  update_pii_access_log_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: pii_access_log_set_input
    pk_columns: pii_access_log_pk_columns_input!
  ): pii_access_log

  """
  update multiples rows of table: "pii_access_log"
  """
  update_pii_access_log_many(
    """updates to execute, in order"""
    updates: [pii_access_log_updates!]!
  ): [pii_access_log_mutation_response]

  """
  update data of the table: "placement_contracts"
  """
  update_placement_contracts(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: placement_contracts_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: placement_contracts_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: placement_contracts_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: placement_contracts_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: placement_contracts_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: placement_contracts_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: placement_contracts_set_input

    """filter the rows which have to be updated"""
    where: placement_contracts_bool_exp!
  ): placement_contracts_mutation_response

  """
  update single row of the table: "placement_contracts"
  """
  update_placement_contracts_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: placement_contracts_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: placement_contracts_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: placement_contracts_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: placement_contracts_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: placement_contracts_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: placement_contracts_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: placement_contracts_set_input
    pk_columns: placement_contracts_pk_columns_input!
  ): placement_contracts

  """
  update multiples rows of table: "placement_contracts"
  """
  update_placement_contracts_many(
    """updates to execute, in order"""
    updates: [placement_contracts_updates!]!
  ): [placement_contracts_mutation_response]

  """
  update data of the table: "placement_fee_transactions"
  """
  update_placement_fee_transactions(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: placement_fee_transactions_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: placement_fee_transactions_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: placement_fee_transactions_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: placement_fee_transactions_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: placement_fee_transactions_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: placement_fee_transactions_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: placement_fee_transactions_set_input

    """filter the rows which have to be updated"""
    where: placement_fee_transactions_bool_exp!
  ): placement_fee_transactions_mutation_response

  """
  update single row of the table: "placement_fee_transactions"
  """
  update_placement_fee_transactions_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: placement_fee_transactions_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: placement_fee_transactions_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: placement_fee_transactions_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: placement_fee_transactions_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: placement_fee_transactions_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: placement_fee_transactions_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: placement_fee_transactions_set_input
    pk_columns: placement_fee_transactions_pk_columns_input!
  ): placement_fee_transactions

  """
  update multiples rows of table: "placement_fee_transactions"
  """
  update_placement_fee_transactions_many(
    """updates to execute, in order"""
    updates: [placement_fee_transactions_updates!]!
  ): [placement_fee_transactions_mutation_response]

  """
  update data of the table: "platform_announcements"
  """
  update_platform_announcements(
    """increments the numeric columns with given value of the filtered values"""
    _inc: platform_announcements_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: platform_announcements_set_input

    """filter the rows which have to be updated"""
    where: platform_announcements_bool_exp!
  ): platform_announcements_mutation_response

  """
  update single row of the table: "platform_announcements"
  """
  update_platform_announcements_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: platform_announcements_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: platform_announcements_set_input
    pk_columns: platform_announcements_pk_columns_input!
  ): platform_announcements

  """
  update multiples rows of table: "platform_announcements"
  """
  update_platform_announcements_many(
    """updates to execute, in order"""
    updates: [platform_announcements_updates!]!
  ): [platform_announcements_mutation_response]

  """
  update data of the table: "platform_settings"
  """
  update_platform_settings(
    """increments the numeric columns with given value of the filtered values"""
    _inc: platform_settings_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: platform_settings_set_input

    """filter the rows which have to be updated"""
    where: platform_settings_bool_exp!
  ): platform_settings_mutation_response

  """
  update single row of the table: "platform_settings"
  """
  update_platform_settings_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: platform_settings_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: platform_settings_set_input
    pk_columns: platform_settings_pk_columns_input!
  ): platform_settings

  """
  update multiples rows of table: "platform_settings"
  """
  update_platform_settings_many(
    """updates to execute, in order"""
    updates: [platform_settings_updates!]!
  ): [platform_settings_mutation_response]

  """
  update data of the table: "profiles"
  """
  update_profiles(
    """increments the numeric columns with given value of the filtered values"""
    _inc: profiles_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: profiles_set_input

    """filter the rows which have to be updated"""
    where: profiles_bool_exp!
  ): profiles_mutation_response

  """
  update single row of the table: "profiles"
  """
  update_profiles_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: profiles_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: profiles_set_input
    pk_columns: profiles_pk_columns_input!
  ): profiles

  """
  update multiples rows of table: "profiles"
  """
  update_profiles_many(
    """updates to execute, in order"""
    updates: [profiles_updates!]!
  ): [profiles_mutation_response]

  """
  update data of the table: "realtime.messages"
  """
  update_realtime_messages(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: realtime_messages_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: realtime_messages_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: realtime_messages_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: realtime_messages_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: realtime_messages_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: realtime_messages_set_input

    """filter the rows which have to be updated"""
    where: realtime_messages_bool_exp!
  ): realtime_messages_mutation_response

  """
  update single row of the table: "realtime.messages"
  """
  update_realtime_messages_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: realtime_messages_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: realtime_messages_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: realtime_messages_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: realtime_messages_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: realtime_messages_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: realtime_messages_set_input
    pk_columns: realtime_messages_pk_columns_input!
  ): realtime_messages

  """
  update multiples rows of table: "realtime.messages"
  """
  update_realtime_messages_many(
    """updates to execute, in order"""
    updates: [realtime_messages_updates!]!
  ): [realtime_messages_mutation_response]

  """
  update data of the table: "realtime.subscription"
  """
  update_realtime_subscription(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: realtime_subscription_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: realtime_subscription_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: realtime_subscription_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: realtime_subscription_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: realtime_subscription_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: realtime_subscription_set_input

    """filter the rows which have to be updated"""
    where: realtime_subscription_bool_exp!
  ): realtime_subscription_mutation_response

  """
  update single row of the table: "realtime.subscription"
  """
  update_realtime_subscription_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: realtime_subscription_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: realtime_subscription_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: realtime_subscription_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: realtime_subscription_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: realtime_subscription_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: realtime_subscription_set_input
    pk_columns: realtime_subscription_pk_columns_input!
  ): realtime_subscription

  """
  update multiples rows of table: "realtime.subscription"
  """
  update_realtime_subscription_many(
    """updates to execute, in order"""
    updates: [realtime_subscription_updates!]!
  ): [realtime_subscription_mutation_response]

  """
  update data of the table: "reviews"
  """
  update_reviews(
    """increments the numeric columns with given value of the filtered values"""
    _inc: reviews_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: reviews_set_input

    """filter the rows which have to be updated"""
    where: reviews_bool_exp!
  ): reviews_mutation_response

  """
  update single row of the table: "reviews"
  """
  update_reviews_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: reviews_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: reviews_set_input
    pk_columns: reviews_pk_columns_input!
  ): reviews

  """
  update multiples rows of table: "reviews"
  """
  update_reviews_many(
    """updates to execute, in order"""
    updates: [reviews_updates!]!
  ): [reviews_mutation_response]

  """
  update data of the table: "security_events"
  """
  update_security_events(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: security_events_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: security_events_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: security_events_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: security_events_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: security_events_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: security_events_set_input

    """filter the rows which have to be updated"""
    where: security_events_bool_exp!
  ): security_events_mutation_response

  """
  update single row of the table: "security_events"
  """
  update_security_events_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: security_events_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: security_events_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: security_events_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: security_events_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: security_events_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: security_events_set_input
    pk_columns: security_events_pk_columns_input!
  ): security_events

  """
  update multiples rows of table: "security_events"
  """
  update_security_events_many(
    """updates to execute, in order"""
    updates: [security_events_updates!]!
  ): [security_events_mutation_response]

  """
  update data of the table: "shortlist_candidates"
  """
  update_shortlist_candidates(
    """increments the numeric columns with given value of the filtered values"""
    _inc: shortlist_candidates_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: shortlist_candidates_set_input

    """filter the rows which have to be updated"""
    where: shortlist_candidates_bool_exp!
  ): shortlist_candidates_mutation_response

  """
  update single row of the table: "shortlist_candidates"
  """
  update_shortlist_candidates_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: shortlist_candidates_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: shortlist_candidates_set_input
    pk_columns: shortlist_candidates_pk_columns_input!
  ): shortlist_candidates

  """
  update multiples rows of table: "shortlist_candidates"
  """
  update_shortlist_candidates_many(
    """updates to execute, in order"""
    updates: [shortlist_candidates_updates!]!
  ): [shortlist_candidates_mutation_response]

  """
  update data of the table: "shortlists"
  """
  update_shortlists(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: shortlists_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: shortlists_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: shortlists_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: shortlists_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: shortlists_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: shortlists_set_input

    """filter the rows which have to be updated"""
    where: shortlists_bool_exp!
  ): shortlists_mutation_response

  """
  update single row of the table: "shortlists"
  """
  update_shortlists_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: shortlists_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: shortlists_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: shortlists_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: shortlists_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: shortlists_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: shortlists_set_input
    pk_columns: shortlists_pk_columns_input!
  ): shortlists

  """
  update multiples rows of table: "shortlists"
  """
  update_shortlists_many(
    """updates to execute, in order"""
    updates: [shortlists_updates!]!
  ): [shortlists_mutation_response]

  """
  update data of the table: "skills"
  """
  update_skills(
    """increments the numeric columns with given value of the filtered values"""
    _inc: skills_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: skills_set_input

    """filter the rows which have to be updated"""
    where: skills_bool_exp!
  ): skills_mutation_response

  """
  update single row of the table: "skills"
  """
  update_skills_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: skills_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: skills_set_input
    pk_columns: skills_pk_columns_input!
  ): skills

  """
  update multiples rows of table: "skills"
  """
  update_skills_many(
    """updates to execute, in order"""
    updates: [skills_updates!]!
  ): [skills_mutation_response]

  """
  update data of the table: "sponsor_document_verification"
  """
  update_sponsor_document_verification(
    """increments the numeric columns with given value of the filtered values"""
    _inc: sponsor_document_verification_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: sponsor_document_verification_set_input

    """filter the rows which have to be updated"""
    where: sponsor_document_verification_bool_exp!
  ): sponsor_document_verification_mutation_response

  """
  update single row of the table: "sponsor_document_verification"
  """
  update_sponsor_document_verification_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: sponsor_document_verification_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: sponsor_document_verification_set_input
    pk_columns: sponsor_document_verification_pk_columns_input!
  ): sponsor_document_verification

  """
  update multiples rows of table: "sponsor_document_verification"
  """
  update_sponsor_document_verification_many(
    """updates to execute, in order"""
    updates: [sponsor_document_verification_updates!]!
  ): [sponsor_document_verification_mutation_response]

  """
  update data of the table: "sponsor_jobs"
  """
  update_sponsor_jobs(
    """sets the columns of the filtered rows to the given values"""
    _set: sponsor_jobs_set_input

    """filter the rows which have to be updated"""
    where: sponsor_jobs_bool_exp!
  ): sponsor_jobs_mutation_response

  """
  update single row of the table: "sponsor_jobs"
  """
  update_sponsor_jobs_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: sponsor_jobs_set_input
    pk_columns: sponsor_jobs_pk_columns_input!
  ): sponsor_jobs

  """
  update multiples rows of table: "sponsor_jobs"
  """
  update_sponsor_jobs_many(
    """updates to execute, in order"""
    updates: [sponsor_jobs_updates!]!
  ): [sponsor_jobs_mutation_response]

  """
  update data of the table: "sponsor_profiles"
  """
  update_sponsor_profiles(
    """increments the numeric columns with given value of the filtered values"""
    _inc: sponsor_profiles_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: sponsor_profiles_set_input

    """filter the rows which have to be updated"""
    where: sponsor_profiles_bool_exp!
  ): sponsor_profiles_mutation_response

  """
  update single row of the table: "sponsor_profiles"
  """
  update_sponsor_profiles_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: sponsor_profiles_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: sponsor_profiles_set_input
    pk_columns: sponsor_profiles_pk_columns_input!
  ): sponsor_profiles

  """
  update multiples rows of table: "sponsor_profiles"
  """
  update_sponsor_profiles_many(
    """updates to execute, in order"""
    updates: [sponsor_profiles_updates!]!
  ): [sponsor_profiles_mutation_response]

  """
  update data of the table: "sponsors"
  """
  update_sponsors(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: sponsors_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: sponsors_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: sponsors_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: sponsors_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: sponsors_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: sponsors_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: sponsors_set_input

    """filter the rows which have to be updated"""
    where: sponsors_bool_exp!
  ): sponsors_mutation_response

  """
  update single row of the table: "sponsors"
  """
  update_sponsors_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: sponsors_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: sponsors_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: sponsors_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: sponsors_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: sponsors_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: sponsors_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: sponsors_set_input
    pk_columns: sponsors_pk_columns_input!
  ): sponsors

  """
  update multiples rows of table: "sponsors"
  """
  update_sponsors_many(
    """updates to execute, in order"""
    updates: [sponsors_updates!]!
  ): [sponsors_mutation_response]

  """
  update data of the table: "storage.buckets"
  """
  update_storage_buckets(
    """increments the numeric columns with given value of the filtered values"""
    _inc: storage_buckets_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: storage_buckets_set_input

    """filter the rows which have to be updated"""
    where: storage_buckets_bool_exp!
  ): storage_buckets_mutation_response

  """
  update data of the table: "storage.buckets_analytics"
  """
  update_storage_buckets_analytics(
    """sets the columns of the filtered rows to the given values"""
    _set: storage_buckets_analytics_set_input

    """filter the rows which have to be updated"""
    where: storage_buckets_analytics_bool_exp!
  ): storage_buckets_analytics_mutation_response

  """
  update single row of the table: "storage.buckets_analytics"
  """
  update_storage_buckets_analytics_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: storage_buckets_analytics_set_input
    pk_columns: storage_buckets_analytics_pk_columns_input!
  ): storage_buckets_analytics

  """
  update multiples rows of table: "storage.buckets_analytics"
  """
  update_storage_buckets_analytics_many(
    """updates to execute, in order"""
    updates: [storage_buckets_analytics_updates!]!
  ): [storage_buckets_analytics_mutation_response]

  """
  update single row of the table: "storage.buckets"
  """
  update_storage_buckets_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: storage_buckets_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: storage_buckets_set_input
    pk_columns: storage_buckets_pk_columns_input!
  ): storage_buckets

  """
  update multiples rows of table: "storage.buckets"
  """
  update_storage_buckets_many(
    """updates to execute, in order"""
    updates: [storage_buckets_updates!]!
  ): [storage_buckets_mutation_response]

  """
  update data of the table: "storage.migrations"
  """
  update_storage_migrations(
    """increments the numeric columns with given value of the filtered values"""
    _inc: storage_migrations_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: storage_migrations_set_input

    """filter the rows which have to be updated"""
    where: storage_migrations_bool_exp!
  ): storage_migrations_mutation_response

  """
  update single row of the table: "storage.migrations"
  """
  update_storage_migrations_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: storage_migrations_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: storage_migrations_set_input
    pk_columns: storage_migrations_pk_columns_input!
  ): storage_migrations

  """
  update multiples rows of table: "storage.migrations"
  """
  update_storage_migrations_many(
    """updates to execute, in order"""
    updates: [storage_migrations_updates!]!
  ): [storage_migrations_mutation_response]

  """
  update data of the table: "storage.objects"
  """
  update_storage_objects(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: storage_objects_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: storage_objects_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: storage_objects_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: storage_objects_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: storage_objects_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: storage_objects_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: storage_objects_set_input

    """filter the rows which have to be updated"""
    where: storage_objects_bool_exp!
  ): storage_objects_mutation_response

  """
  update single row of the table: "storage.objects"
  """
  update_storage_objects_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: storage_objects_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: storage_objects_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: storage_objects_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: storage_objects_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: storage_objects_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: storage_objects_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: storage_objects_set_input
    pk_columns: storage_objects_pk_columns_input!
  ): storage_objects

  """
  update multiples rows of table: "storage.objects"
  """
  update_storage_objects_many(
    """updates to execute, in order"""
    updates: [storage_objects_updates!]!
  ): [storage_objects_mutation_response]

  """
  update data of the table: "storage.prefixes"
  """
  update_storage_prefixes(
    """sets the columns of the filtered rows to the given values"""
    _set: storage_prefixes_set_input

    """filter the rows which have to be updated"""
    where: storage_prefixes_bool_exp!
  ): storage_prefixes_mutation_response

  """
  update single row of the table: "storage.prefixes"
  """
  update_storage_prefixes_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: storage_prefixes_set_input
    pk_columns: storage_prefixes_pk_columns_input!
  ): storage_prefixes

  """
  update multiples rows of table: "storage.prefixes"
  """
  update_storage_prefixes_many(
    """updates to execute, in order"""
    updates: [storage_prefixes_updates!]!
  ): [storage_prefixes_mutation_response]

  """
  update data of the table: "storage.s3_multipart_uploads"
  """
  update_storage_s3_multipart_uploads(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: storage_s3_multipart_uploads_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: storage_s3_multipart_uploads_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: storage_s3_multipart_uploads_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: storage_s3_multipart_uploads_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: storage_s3_multipart_uploads_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: storage_s3_multipart_uploads_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: storage_s3_multipart_uploads_set_input

    """filter the rows which have to be updated"""
    where: storage_s3_multipart_uploads_bool_exp!
  ): storage_s3_multipart_uploads_mutation_response

  """
  update single row of the table: "storage.s3_multipart_uploads"
  """
  update_storage_s3_multipart_uploads_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: storage_s3_multipart_uploads_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: storage_s3_multipart_uploads_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: storage_s3_multipart_uploads_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: storage_s3_multipart_uploads_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: storage_s3_multipart_uploads_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: storage_s3_multipart_uploads_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: storage_s3_multipart_uploads_set_input
    pk_columns: storage_s3_multipart_uploads_pk_columns_input!
  ): storage_s3_multipart_uploads

  """
  update multiples rows of table: "storage.s3_multipart_uploads"
  """
  update_storage_s3_multipart_uploads_many(
    """updates to execute, in order"""
    updates: [storage_s3_multipart_uploads_updates!]!
  ): [storage_s3_multipart_uploads_mutation_response]

  """
  update data of the table: "storage.s3_multipart_uploads_parts"
  """
  update_storage_s3_multipart_uploads_parts(
    """increments the numeric columns with given value of the filtered values"""
    _inc: storage_s3_multipart_uploads_parts_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: storage_s3_multipart_uploads_parts_set_input

    """filter the rows which have to be updated"""
    where: storage_s3_multipart_uploads_parts_bool_exp!
  ): storage_s3_multipart_uploads_parts_mutation_response

  """
  update single row of the table: "storage.s3_multipart_uploads_parts"
  """
  update_storage_s3_multipart_uploads_parts_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: storage_s3_multipart_uploads_parts_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: storage_s3_multipart_uploads_parts_set_input
    pk_columns: storage_s3_multipart_uploads_parts_pk_columns_input!
  ): storage_s3_multipart_uploads_parts

  """
  update multiples rows of table: "storage.s3_multipart_uploads_parts"
  """
  update_storage_s3_multipart_uploads_parts_many(
    """updates to execute, in order"""
    updates: [storage_s3_multipart_uploads_parts_updates!]!
  ): [storage_s3_multipart_uploads_parts_mutation_response]

  """
  update data of the table: "subscription_limits"
  """
  update_subscription_limits(
    """increments the numeric columns with given value of the filtered values"""
    _inc: subscription_limits_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: subscription_limits_set_input

    """filter the rows which have to be updated"""
    where: subscription_limits_bool_exp!
  ): subscription_limits_mutation_response

  """
  update single row of the table: "subscription_limits"
  """
  update_subscription_limits_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: subscription_limits_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: subscription_limits_set_input
    pk_columns: subscription_limits_pk_columns_input!
  ): subscription_limits

  """
  update multiples rows of table: "subscription_limits"
  """
  update_subscription_limits_many(
    """updates to execute, in order"""
    updates: [subscription_limits_updates!]!
  ): [subscription_limits_mutation_response]

  """
  update data of the table: "subscription_status_log"
  """
  update_subscription_status_log(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: subscription_status_log_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: subscription_status_log_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: subscription_status_log_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: subscription_status_log_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: subscription_status_log_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: subscription_status_log_set_input

    """filter the rows which have to be updated"""
    where: subscription_status_log_bool_exp!
  ): subscription_status_log_mutation_response

  """
  update single row of the table: "subscription_status_log"
  """
  update_subscription_status_log_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: subscription_status_log_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: subscription_status_log_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: subscription_status_log_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: subscription_status_log_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: subscription_status_log_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: subscription_status_log_set_input
    pk_columns: subscription_status_log_pk_columns_input!
  ): subscription_status_log

  """
  update multiples rows of table: "subscription_status_log"
  """
  update_subscription_status_log_many(
    """updates to execute, in order"""
    updates: [subscription_status_log_updates!]!
  ): [subscription_status_log_mutation_response]

  """
  update data of the table: "subscription_usage"
  """
  update_subscription_usage(
    """increments the numeric columns with given value of the filtered values"""
    _inc: subscription_usage_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: subscription_usage_set_input

    """filter the rows which have to be updated"""
    where: subscription_usage_bool_exp!
  ): subscription_usage_mutation_response

  """
  update single row of the table: "subscription_usage"
  """
  update_subscription_usage_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: subscription_usage_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: subscription_usage_set_input
    pk_columns: subscription_usage_pk_columns_input!
  ): subscription_usage

  """
  update multiples rows of table: "subscription_usage"
  """
  update_subscription_usage_many(
    """updates to execute, in order"""
    updates: [subscription_usage_updates!]!
  ): [subscription_usage_mutation_response]

  """
  update data of the table: "subscriptions"
  """
  update_subscriptions(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: subscriptions_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: subscriptions_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: subscriptions_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: subscriptions_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: subscriptions_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: subscriptions_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: subscriptions_set_input

    """filter the rows which have to be updated"""
    where: subscriptions_bool_exp!
  ): subscriptions_mutation_response

  """
  update single row of the table: "subscriptions"
  """
  update_subscriptions_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: subscriptions_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: subscriptions_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: subscriptions_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: subscriptions_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: subscriptions_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: subscriptions_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: subscriptions_set_input
    pk_columns: subscriptions_pk_columns_input!
  ): subscriptions

  """
  update multiples rows of table: "subscriptions"
  """
  update_subscriptions_many(
    """updates to execute, in order"""
    updates: [subscriptions_updates!]!
  ): [subscriptions_mutation_response]

  """
  update data of the table: "supabase_migrations.schema_migrations"
  """
  update_supabase_migrations_schema_migrations(
    """sets the columns of the filtered rows to the given values"""
    _set: supabase_migrations_schema_migrations_set_input

    """filter the rows which have to be updated"""
    where: supabase_migrations_schema_migrations_bool_exp!
  ): supabase_migrations_schema_migrations_mutation_response

  """
  update single row of the table: "supabase_migrations.schema_migrations"
  """
  update_supabase_migrations_schema_migrations_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: supabase_migrations_schema_migrations_set_input
    pk_columns: supabase_migrations_schema_migrations_pk_columns_input!
  ): supabase_migrations_schema_migrations

  """
  update multiples rows of table: "supabase_migrations.schema_migrations"
  """
  update_supabase_migrations_schema_migrations_many(
    """updates to execute, in order"""
    updates: [supabase_migrations_schema_migrations_updates!]!
  ): [supabase_migrations_schema_migrations_mutation_response]

  """
  update data of the table: "supabase_migrations.seed_files"
  """
  update_supabase_migrations_seed_files(
    """sets the columns of the filtered rows to the given values"""
    _set: supabase_migrations_seed_files_set_input

    """filter the rows which have to be updated"""
    where: supabase_migrations_seed_files_bool_exp!
  ): supabase_migrations_seed_files_mutation_response

  """
  update single row of the table: "supabase_migrations.seed_files"
  """
  update_supabase_migrations_seed_files_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: supabase_migrations_seed_files_set_input
    pk_columns: supabase_migrations_seed_files_pk_columns_input!
  ): supabase_migrations_seed_files

  """
  update multiples rows of table: "supabase_migrations.seed_files"
  """
  update_supabase_migrations_seed_files_many(
    """updates to execute, in order"""
    updates: [supabase_migrations_seed_files_updates!]!
  ): [supabase_migrations_seed_files_mutation_response]

  """
  update data of the table: "support_agents"
  """
  update_support_agents(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: support_agents_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: support_agents_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: support_agents_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: support_agents_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: support_agents_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: support_agents_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: support_agents_set_input

    """filter the rows which have to be updated"""
    where: support_agents_bool_exp!
  ): support_agents_mutation_response

  """
  update single row of the table: "support_agents"
  """
  update_support_agents_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: support_agents_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: support_agents_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: support_agents_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: support_agents_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: support_agents_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: support_agents_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: support_agents_set_input
    pk_columns: support_agents_pk_columns_input!
  ): support_agents

  """
  update multiples rows of table: "support_agents"
  """
  update_support_agents_many(
    """updates to execute, in order"""
    updates: [support_agents_updates!]!
  ): [support_agents_mutation_response]

  """
  update data of the table: "support_interactions"
  """
  update_support_interactions(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: support_interactions_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: support_interactions_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: support_interactions_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: support_interactions_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: support_interactions_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: support_interactions_set_input

    """filter the rows which have to be updated"""
    where: support_interactions_bool_exp!
  ): support_interactions_mutation_response

  """
  update single row of the table: "support_interactions"
  """
  update_support_interactions_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: support_interactions_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: support_interactions_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: support_interactions_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: support_interactions_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: support_interactions_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: support_interactions_set_input
    pk_columns: support_interactions_pk_columns_input!
  ): support_interactions

  """
  update multiples rows of table: "support_interactions"
  """
  update_support_interactions_many(
    """updates to execute, in order"""
    updates: [support_interactions_updates!]!
  ): [support_interactions_mutation_response]

  """
  update data of the table: "support_messages"
  """
  update_support_messages(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: support_messages_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: support_messages_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: support_messages_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: support_messages_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: support_messages_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: support_messages_set_input

    """filter the rows which have to be updated"""
    where: support_messages_bool_exp!
  ): support_messages_mutation_response

  """
  update single row of the table: "support_messages"
  """
  update_support_messages_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: support_messages_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: support_messages_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: support_messages_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: support_messages_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: support_messages_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: support_messages_set_input
    pk_columns: support_messages_pk_columns_input!
  ): support_messages

  """
  update multiples rows of table: "support_messages"
  """
  update_support_messages_many(
    """updates to execute, in order"""
    updates: [support_messages_updates!]!
  ): [support_messages_mutation_response]

  """
  update data of the table: "support_tickets"
  """
  update_support_tickets(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: support_tickets_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: support_tickets_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: support_tickets_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: support_tickets_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: support_tickets_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: support_tickets_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: support_tickets_set_input

    """filter the rows which have to be updated"""
    where: support_tickets_bool_exp!
  ): support_tickets_mutation_response

  """
  update single row of the table: "support_tickets"
  """
  update_support_tickets_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: support_tickets_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: support_tickets_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: support_tickets_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: support_tickets_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: support_tickets_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: support_tickets_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: support_tickets_set_input
    pk_columns: support_tickets_pk_columns_input!
  ): support_tickets

  """
  update multiples rows of table: "support_tickets"
  """
  update_support_tickets_many(
    """updates to execute, in order"""
    updates: [support_tickets_updates!]!
  ): [support_tickets_mutation_response]

  """
  update data of the table: "system_settings"
  """
  update_system_settings(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: system_settings_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: system_settings_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: system_settings_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: system_settings_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: system_settings_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: system_settings_set_input

    """filter the rows which have to be updated"""
    where: system_settings_bool_exp!
  ): system_settings_mutation_response

  """
  update single row of the table: "system_settings"
  """
  update_system_settings_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: system_settings_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: system_settings_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: system_settings_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: system_settings_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: system_settings_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: system_settings_set_input
    pk_columns: system_settings_pk_columns_input!
  ): system_settings

  """
  update multiples rows of table: "system_settings"
  """
  update_system_settings_many(
    """updates to execute, in order"""
    updates: [system_settings_updates!]!
  ): [system_settings_mutation_response]

  """
  update data of the table: "team_member_performance"
  """
  update_team_member_performance(
    """increments the numeric columns with given value of the filtered values"""
    _inc: team_member_performance_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: team_member_performance_set_input

    """filter the rows which have to be updated"""
    where: team_member_performance_bool_exp!
  ): team_member_performance_mutation_response

  """
  update single row of the table: "team_member_performance"
  """
  update_team_member_performance_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: team_member_performance_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: team_member_performance_set_input
    pk_columns: team_member_performance_pk_columns_input!
  ): team_member_performance

  """
  update multiples rows of table: "team_member_performance"
  """
  update_team_member_performance_many(
    """updates to execute, in order"""
    updates: [team_member_performance_updates!]!
  ): [team_member_performance_mutation_response]

  """
  update data of the table: "two_factor_backup_codes"
  """
  update_two_factor_backup_codes(
    """sets the columns of the filtered rows to the given values"""
    _set: two_factor_backup_codes_set_input

    """filter the rows which have to be updated"""
    where: two_factor_backup_codes_bool_exp!
  ): two_factor_backup_codes_mutation_response

  """
  update single row of the table: "two_factor_backup_codes"
  """
  update_two_factor_backup_codes_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: two_factor_backup_codes_set_input
    pk_columns: two_factor_backup_codes_pk_columns_input!
  ): two_factor_backup_codes

  """
  update multiples rows of table: "two_factor_backup_codes"
  """
  update_two_factor_backup_codes_many(
    """updates to execute, in order"""
    updates: [two_factor_backup_codes_updates!]!
  ): [two_factor_backup_codes_mutation_response]

  """
  update data of the table: "user_credits"
  """
  update_user_credits(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_credits_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_credits_set_input

    """filter the rows which have to be updated"""
    where: user_credits_bool_exp!
  ): user_credits_mutation_response

  """
  update single row of the table: "user_credits"
  """
  update_user_credits_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_credits_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_credits_set_input
    pk_columns: user_credits_pk_columns_input!
  ): user_credits

  """
  update multiples rows of table: "user_credits"
  """
  update_user_credits_many(
    """updates to execute, in order"""
    updates: [user_credits_updates!]!
  ): [user_credits_mutation_response]

  """
  update data of the table: "user_events"
  """
  update_user_events(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: user_events_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: user_events_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: user_events_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: user_events_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: user_events_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: user_events_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_events_set_input

    """filter the rows which have to be updated"""
    where: user_events_bool_exp!
  ): user_events_mutation_response

  """
  update single row of the table: "user_events"
  """
  update_user_events_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: user_events_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: user_events_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: user_events_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: user_events_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: user_events_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: user_events_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_events_set_input
    pk_columns: user_events_pk_columns_input!
  ): user_events

  """
  update multiples rows of table: "user_events"
  """
  update_user_events_many(
    """updates to execute, in order"""
    updates: [user_events_updates!]!
  ): [user_events_mutation_response]

  """
  update data of the table: "user_sessions"
  """
  update_user_sessions(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_sessions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_sessions_set_input

    """filter the rows which have to be updated"""
    where: user_sessions_bool_exp!
  ): user_sessions_mutation_response

  """
  update single row of the table: "user_sessions"
  """
  update_user_sessions_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_sessions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_sessions_set_input
    pk_columns: user_sessions_pk_columns_input!
  ): user_sessions

  """
  update multiples rows of table: "user_sessions"
  """
  update_user_sessions_many(
    """updates to execute, in order"""
    updates: [user_sessions_updates!]!
  ): [user_sessions_mutation_response]

  """
  update data of the table: "video_interviews"
  """
  update_video_interviews(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: video_interviews_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: video_interviews_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: video_interviews_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: video_interviews_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: video_interviews_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: video_interviews_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: video_interviews_set_input

    """filter the rows which have to be updated"""
    where: video_interviews_bool_exp!
  ): video_interviews_mutation_response

  """
  update single row of the table: "video_interviews"
  """
  update_video_interviews_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: video_interviews_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: video_interviews_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: video_interviews_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: video_interviews_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: video_interviews_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: video_interviews_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: video_interviews_set_input
    pk_columns: video_interviews_pk_columns_input!
  ): video_interviews

  """
  update multiples rows of table: "video_interviews"
  """
  update_video_interviews_many(
    """updates to execute, in order"""
    updates: [video_interviews_updates!]!
  ): [video_interviews_mutation_response]

  """
  update data of the table: "webhook_event_logs"
  """
  update_webhook_event_logs(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: webhook_event_logs_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: webhook_event_logs_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: webhook_event_logs_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: webhook_event_logs_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: webhook_event_logs_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: webhook_event_logs_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: webhook_event_logs_set_input

    """filter the rows which have to be updated"""
    where: webhook_event_logs_bool_exp!
  ): webhook_event_logs_mutation_response

  """
  update single row of the table: "webhook_event_logs"
  """
  update_webhook_event_logs_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: webhook_event_logs_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: webhook_event_logs_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: webhook_event_logs_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: webhook_event_logs_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: webhook_event_logs_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: webhook_event_logs_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: webhook_event_logs_set_input
    pk_columns: webhook_event_logs_pk_columns_input!
  ): webhook_event_logs

  """
  update multiples rows of table: "webhook_event_logs"
  """
  update_webhook_event_logs_many(
    """updates to execute, in order"""
    updates: [webhook_event_logs_updates!]!
  ): [webhook_event_logs_mutation_response]

  """
  update data of the table: "whatsapp_messages"
  """
  update_whatsapp_messages(
    """sets the columns of the filtered rows to the given values"""
    _set: whatsapp_messages_set_input

    """filter the rows which have to be updated"""
    where: whatsapp_messages_bool_exp!
  ): whatsapp_messages_mutation_response

  """
  update single row of the table: "whatsapp_messages"
  """
  update_whatsapp_messages_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: whatsapp_messages_set_input
    pk_columns: whatsapp_messages_pk_columns_input!
  ): whatsapp_messages

  """
  update multiples rows of table: "whatsapp_messages"
  """
  update_whatsapp_messages_many(
    """updates to execute, in order"""
    updates: [whatsapp_messages_updates!]!
  ): [whatsapp_messages_mutation_response]

  """
  update data of the table: "work_experience"
  """
  update_work_experience(
    """sets the columns of the filtered rows to the given values"""
    _set: work_experience_set_input

    """filter the rows which have to be updated"""
    where: work_experience_bool_exp!
  ): work_experience_mutation_response

  """
  update single row of the table: "work_experience"
  """
  update_work_experience_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: work_experience_set_input
    pk_columns: work_experience_pk_columns_input!
  ): work_experience

  """
  update multiples rows of table: "work_experience"
  """
  update_work_experience_many(
    """updates to execute, in order"""
    updates: [work_experience_updates!]!
  ): [work_experience_mutation_response]
}

"""Aggregated analytics data refreshed hourly"""
type mv_agency_analytics_summary {
  agency_id: uuid
  avg_fee: numeric
  escrow_balance: numeric
  month: timestamptz
  period_end: timestamptz
  period_start: timestamptz
  placements_count: bigint
  revenue: numeric
  unique_maids: bigint
  unique_sponsors: bigint
}

"""
aggregated selection of "mv_agency_analytics_summary"
"""
type mv_agency_analytics_summary_aggregate {
  aggregate: mv_agency_analytics_summary_aggregate_fields
  nodes: [mv_agency_analytics_summary!]!
}

"""
aggregate fields of "mv_agency_analytics_summary"
"""
type mv_agency_analytics_summary_aggregate_fields {
  avg: mv_agency_analytics_summary_avg_fields
  count(columns: [mv_agency_analytics_summary_select_column!], distinct: Boolean): Int!
  max: mv_agency_analytics_summary_max_fields
  min: mv_agency_analytics_summary_min_fields
  stddev: mv_agency_analytics_summary_stddev_fields
  stddev_pop: mv_agency_analytics_summary_stddev_pop_fields
  stddev_samp: mv_agency_analytics_summary_stddev_samp_fields
  sum: mv_agency_analytics_summary_sum_fields
  var_pop: mv_agency_analytics_summary_var_pop_fields
  var_samp: mv_agency_analytics_summary_var_samp_fields
  variance: mv_agency_analytics_summary_variance_fields
}

"""aggregate avg on columns"""
type mv_agency_analytics_summary_avg_fields {
  avg_fee: Float
  escrow_balance: Float
  placements_count: Float
  revenue: Float
  unique_maids: Float
  unique_sponsors: Float
}

"""
Boolean expression to filter rows from the table "mv_agency_analytics_summary". All fields are combined with a logical 'AND'.
"""
input mv_agency_analytics_summary_bool_exp {
  _and: [mv_agency_analytics_summary_bool_exp!]
  _not: mv_agency_analytics_summary_bool_exp
  _or: [mv_agency_analytics_summary_bool_exp!]
  agency_id: uuid_comparison_exp
  avg_fee: numeric_comparison_exp
  escrow_balance: numeric_comparison_exp
  month: timestamptz_comparison_exp
  period_end: timestamptz_comparison_exp
  period_start: timestamptz_comparison_exp
  placements_count: bigint_comparison_exp
  revenue: numeric_comparison_exp
  unique_maids: bigint_comparison_exp
  unique_sponsors: bigint_comparison_exp
}

"""aggregate max on columns"""
type mv_agency_analytics_summary_max_fields {
  agency_id: uuid
  avg_fee: numeric
  escrow_balance: numeric
  month: timestamptz
  period_end: timestamptz
  period_start: timestamptz
  placements_count: bigint
  revenue: numeric
  unique_maids: bigint
  unique_sponsors: bigint
}

"""aggregate min on columns"""
type mv_agency_analytics_summary_min_fields {
  agency_id: uuid
  avg_fee: numeric
  escrow_balance: numeric
  month: timestamptz
  period_end: timestamptz
  period_start: timestamptz
  placements_count: bigint
  revenue: numeric
  unique_maids: bigint
  unique_sponsors: bigint
}

"""
Ordering options when selecting data from "mv_agency_analytics_summary".
"""
input mv_agency_analytics_summary_order_by {
  agency_id: order_by
  avg_fee: order_by
  escrow_balance: order_by
  month: order_by
  period_end: order_by
  period_start: order_by
  placements_count: order_by
  revenue: order_by
  unique_maids: order_by
  unique_sponsors: order_by
}

"""
select columns of table "mv_agency_analytics_summary"
"""
enum mv_agency_analytics_summary_select_column {
  """column name"""
  agency_id

  """column name"""
  avg_fee

  """column name"""
  escrow_balance

  """column name"""
  month

  """column name"""
  period_end

  """column name"""
  period_start

  """column name"""
  placements_count

  """column name"""
  revenue

  """column name"""
  unique_maids

  """column name"""
  unique_sponsors
}

"""aggregate stddev on columns"""
type mv_agency_analytics_summary_stddev_fields {
  avg_fee: Float
  escrow_balance: Float
  placements_count: Float
  revenue: Float
  unique_maids: Float
  unique_sponsors: Float
}

"""aggregate stddev_pop on columns"""
type mv_agency_analytics_summary_stddev_pop_fields {
  avg_fee: Float
  escrow_balance: Float
  placements_count: Float
  revenue: Float
  unique_maids: Float
  unique_sponsors: Float
}

"""aggregate stddev_samp on columns"""
type mv_agency_analytics_summary_stddev_samp_fields {
  avg_fee: Float
  escrow_balance: Float
  placements_count: Float
  revenue: Float
  unique_maids: Float
  unique_sponsors: Float
}

"""
Streaming cursor of the table "mv_agency_analytics_summary"
"""
input mv_agency_analytics_summary_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: mv_agency_analytics_summary_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input mv_agency_analytics_summary_stream_cursor_value_input {
  agency_id: uuid
  avg_fee: numeric
  escrow_balance: numeric
  month: timestamptz
  period_end: timestamptz
  period_start: timestamptz
  placements_count: bigint
  revenue: numeric
  unique_maids: bigint
  unique_sponsors: bigint
}

"""aggregate sum on columns"""
type mv_agency_analytics_summary_sum_fields {
  avg_fee: numeric
  escrow_balance: numeric
  placements_count: bigint
  revenue: numeric
  unique_maids: bigint
  unique_sponsors: bigint
}

"""aggregate var_pop on columns"""
type mv_agency_analytics_summary_var_pop_fields {
  avg_fee: Float
  escrow_balance: Float
  placements_count: Float
  revenue: Float
  unique_maids: Float
  unique_sponsors: Float
}

"""aggregate var_samp on columns"""
type mv_agency_analytics_summary_var_samp_fields {
  avg_fee: Float
  escrow_balance: Float
  placements_count: Float
  revenue: Float
  unique_maids: Float
  unique_sponsors: Float
}

"""aggregate variance on columns"""
type mv_agency_analytics_summary_variance_fields {
  avg_fee: Float
  escrow_balance: Float
  placements_count: Float
  revenue: Float
  unique_maids: Float
  unique_sponsors: Float
}

"""Aggregated news items from various sources"""
type news_items {
  category: String!
  content: String
  country: String
  created_at: timestamptz
  id: uuid!
  image_url: String
  is_featured: Boolean
  keywords: [String!]

  """An object relationship"""
  news_source: news_sources
  priority: Int
  published_at: timestamptz!
  sentiment: String
  source_id: uuid
  summary: String
  title: String!
  updated_at: timestamptz
  url: String
  view_count: Int
}

"""
aggregated selection of "news_items"
"""
type news_items_aggregate {
  aggregate: news_items_aggregate_fields
  nodes: [news_items!]!
}

input news_items_aggregate_bool_exp {
  bool_and: news_items_aggregate_bool_exp_bool_and
  bool_or: news_items_aggregate_bool_exp_bool_or
  count: news_items_aggregate_bool_exp_count
}

input news_items_aggregate_bool_exp_bool_and {
  arguments: news_items_select_column_news_items_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: news_items_bool_exp
  predicate: Boolean_comparison_exp!
}

input news_items_aggregate_bool_exp_bool_or {
  arguments: news_items_select_column_news_items_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: news_items_bool_exp
  predicate: Boolean_comparison_exp!
}

input news_items_aggregate_bool_exp_count {
  arguments: [news_items_select_column!]
  distinct: Boolean
  filter: news_items_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "news_items"
"""
type news_items_aggregate_fields {
  avg: news_items_avg_fields
  count(columns: [news_items_select_column!], distinct: Boolean): Int!
  max: news_items_max_fields
  min: news_items_min_fields
  stddev: news_items_stddev_fields
  stddev_pop: news_items_stddev_pop_fields
  stddev_samp: news_items_stddev_samp_fields
  sum: news_items_sum_fields
  var_pop: news_items_var_pop_fields
  var_samp: news_items_var_samp_fields
  variance: news_items_variance_fields
}

"""
order by aggregate values of table "news_items"
"""
input news_items_aggregate_order_by {
  avg: news_items_avg_order_by
  count: order_by
  max: news_items_max_order_by
  min: news_items_min_order_by
  stddev: news_items_stddev_order_by
  stddev_pop: news_items_stddev_pop_order_by
  stddev_samp: news_items_stddev_samp_order_by
  sum: news_items_sum_order_by
  var_pop: news_items_var_pop_order_by
  var_samp: news_items_var_samp_order_by
  variance: news_items_variance_order_by
}

"""
input type for inserting array relation for remote table "news_items"
"""
input news_items_arr_rel_insert_input {
  data: [news_items_insert_input!]!

  """upsert condition"""
  on_conflict: news_items_on_conflict
}

"""aggregate avg on columns"""
type news_items_avg_fields {
  priority: Float
  view_count: Float
}

"""
order by avg() on columns of table "news_items"
"""
input news_items_avg_order_by {
  priority: order_by
  view_count: order_by
}

"""
Boolean expression to filter rows from the table "news_items". All fields are combined with a logical 'AND'.
"""
input news_items_bool_exp {
  _and: [news_items_bool_exp!]
  _not: news_items_bool_exp
  _or: [news_items_bool_exp!]
  category: String_comparison_exp
  content: String_comparison_exp
  country: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  image_url: String_comparison_exp
  is_featured: Boolean_comparison_exp
  keywords: String_array_comparison_exp
  news_source: news_sources_bool_exp
  priority: Int_comparison_exp
  published_at: timestamptz_comparison_exp
  sentiment: String_comparison_exp
  source_id: uuid_comparison_exp
  summary: String_comparison_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  url: String_comparison_exp
  view_count: Int_comparison_exp
}

"""
unique or primary key constraints on table "news_items"
"""
enum news_items_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  news_items_pkey
}

"""
input type for incrementing numeric columns in table "news_items"
"""
input news_items_inc_input {
  priority: Int
  view_count: Int
}

"""
input type for inserting data into table "news_items"
"""
input news_items_insert_input {
  category: String
  content: String
  country: String
  created_at: timestamptz
  id: uuid
  image_url: String
  is_featured: Boolean
  keywords: [String!]
  news_source: news_sources_obj_rel_insert_input
  priority: Int
  published_at: timestamptz
  sentiment: String
  source_id: uuid
  summary: String
  title: String
  updated_at: timestamptz
  url: String
  view_count: Int
}

"""aggregate max on columns"""
type news_items_max_fields {
  category: String
  content: String
  country: String
  created_at: timestamptz
  id: uuid
  image_url: String
  keywords: [String!]
  priority: Int
  published_at: timestamptz
  sentiment: String
  source_id: uuid
  summary: String
  title: String
  updated_at: timestamptz
  url: String
  view_count: Int
}

"""
order by max() on columns of table "news_items"
"""
input news_items_max_order_by {
  category: order_by
  content: order_by
  country: order_by
  created_at: order_by
  id: order_by
  image_url: order_by
  keywords: order_by
  priority: order_by
  published_at: order_by
  sentiment: order_by
  source_id: order_by
  summary: order_by
  title: order_by
  updated_at: order_by
  url: order_by
  view_count: order_by
}

"""aggregate min on columns"""
type news_items_min_fields {
  category: String
  content: String
  country: String
  created_at: timestamptz
  id: uuid
  image_url: String
  keywords: [String!]
  priority: Int
  published_at: timestamptz
  sentiment: String
  source_id: uuid
  summary: String
  title: String
  updated_at: timestamptz
  url: String
  view_count: Int
}

"""
order by min() on columns of table "news_items"
"""
input news_items_min_order_by {
  category: order_by
  content: order_by
  country: order_by
  created_at: order_by
  id: order_by
  image_url: order_by
  keywords: order_by
  priority: order_by
  published_at: order_by
  sentiment: order_by
  source_id: order_by
  summary: order_by
  title: order_by
  updated_at: order_by
  url: order_by
  view_count: order_by
}

"""
response of any mutation on the table "news_items"
"""
type news_items_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [news_items!]!
}

"""
on_conflict condition type for table "news_items"
"""
input news_items_on_conflict {
  constraint: news_items_constraint!
  update_columns: [news_items_update_column!]! = []
  where: news_items_bool_exp
}

"""Ordering options when selecting data from "news_items"."""
input news_items_order_by {
  category: order_by
  content: order_by
  country: order_by
  created_at: order_by
  id: order_by
  image_url: order_by
  is_featured: order_by
  keywords: order_by
  news_source: news_sources_order_by
  priority: order_by
  published_at: order_by
  sentiment: order_by
  source_id: order_by
  summary: order_by
  title: order_by
  updated_at: order_by
  url: order_by
  view_count: order_by
}

"""primary key columns input for table: news_items"""
input news_items_pk_columns_input {
  id: uuid!
}

"""
select columns of table "news_items"
"""
enum news_items_select_column {
  """column name"""
  category

  """column name"""
  content

  """column name"""
  country

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  image_url

  """column name"""
  is_featured

  """column name"""
  keywords

  """column name"""
  priority

  """column name"""
  published_at

  """column name"""
  sentiment

  """column name"""
  source_id

  """column name"""
  summary

  """column name"""
  title

  """column name"""
  updated_at

  """column name"""
  url

  """column name"""
  view_count
}

"""
select "news_items_aggregate_bool_exp_bool_and_arguments_columns" columns of table "news_items"
"""
enum news_items_select_column_news_items_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_featured
}

"""
select "news_items_aggregate_bool_exp_bool_or_arguments_columns" columns of table "news_items"
"""
enum news_items_select_column_news_items_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_featured
}

"""
input type for updating data in table "news_items"
"""
input news_items_set_input {
  category: String
  content: String
  country: String
  created_at: timestamptz
  id: uuid
  image_url: String
  is_featured: Boolean
  keywords: [String!]
  priority: Int
  published_at: timestamptz
  sentiment: String
  source_id: uuid
  summary: String
  title: String
  updated_at: timestamptz
  url: String
  view_count: Int
}

"""aggregate stddev on columns"""
type news_items_stddev_fields {
  priority: Float
  view_count: Float
}

"""
order by stddev() on columns of table "news_items"
"""
input news_items_stddev_order_by {
  priority: order_by
  view_count: order_by
}

"""aggregate stddev_pop on columns"""
type news_items_stddev_pop_fields {
  priority: Float
  view_count: Float
}

"""
order by stddev_pop() on columns of table "news_items"
"""
input news_items_stddev_pop_order_by {
  priority: order_by
  view_count: order_by
}

"""aggregate stddev_samp on columns"""
type news_items_stddev_samp_fields {
  priority: Float
  view_count: Float
}

"""
order by stddev_samp() on columns of table "news_items"
"""
input news_items_stddev_samp_order_by {
  priority: order_by
  view_count: order_by
}

"""
Streaming cursor of the table "news_items"
"""
input news_items_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: news_items_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input news_items_stream_cursor_value_input {
  category: String
  content: String
  country: String
  created_at: timestamptz
  id: uuid
  image_url: String
  is_featured: Boolean
  keywords: [String!]
  priority: Int
  published_at: timestamptz
  sentiment: String
  source_id: uuid
  summary: String
  title: String
  updated_at: timestamptz
  url: String
  view_count: Int
}

"""aggregate sum on columns"""
type news_items_sum_fields {
  priority: Int
  view_count: Int
}

"""
order by sum() on columns of table "news_items"
"""
input news_items_sum_order_by {
  priority: order_by
  view_count: order_by
}

"""
update columns of table "news_items"
"""
enum news_items_update_column {
  """column name"""
  category

  """column name"""
  content

  """column name"""
  country

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  image_url

  """column name"""
  is_featured

  """column name"""
  keywords

  """column name"""
  priority

  """column name"""
  published_at

  """column name"""
  sentiment

  """column name"""
  source_id

  """column name"""
  summary

  """column name"""
  title

  """column name"""
  updated_at

  """column name"""
  url

  """column name"""
  view_count
}

input news_items_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: news_items_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: news_items_set_input

  """filter the rows which have to be updated"""
  where: news_items_bool_exp!
}

"""aggregate var_pop on columns"""
type news_items_var_pop_fields {
  priority: Float
  view_count: Float
}

"""
order by var_pop() on columns of table "news_items"
"""
input news_items_var_pop_order_by {
  priority: order_by
  view_count: order_by
}

"""aggregate var_samp on columns"""
type news_items_var_samp_fields {
  priority: Float
  view_count: Float
}

"""
order by var_samp() on columns of table "news_items"
"""
input news_items_var_samp_order_by {
  priority: order_by
  view_count: order_by
}

"""aggregate variance on columns"""
type news_items_variance_fields {
  priority: Float
  view_count: Float
}

"""
order by variance() on columns of table "news_items"
"""
input news_items_variance_order_by {
  priority: order_by
  view_count: order_by
}

"""External news sources for GCC labor and recruitment news"""
type news_sources {
  category: String!
  config(
    """JSON select path"""
    path: String
  ): jsonb
  country: String
  created_at: timestamptz
  fetch_interval_minutes: Int
  id: uuid!
  is_active: Boolean
  last_fetched_at: timestamptz
  name: String!

  """An array relationship"""
  news_items(
    """distinct select on columns"""
    distinct_on: [news_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [news_items_order_by!]

    """filter the rows returned"""
    where: news_items_bool_exp
  ): [news_items!]!

  """An aggregate relationship"""
  news_items_aggregate(
    """distinct select on columns"""
    distinct_on: [news_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [news_items_order_by!]

    """filter the rows returned"""
    where: news_items_bool_exp
  ): news_items_aggregate!
  source_type: String!
  updated_at: timestamptz
  url: String
}

"""
aggregated selection of "news_sources"
"""
type news_sources_aggregate {
  aggregate: news_sources_aggregate_fields
  nodes: [news_sources!]!
}

"""
aggregate fields of "news_sources"
"""
type news_sources_aggregate_fields {
  avg: news_sources_avg_fields
  count(columns: [news_sources_select_column!], distinct: Boolean): Int!
  max: news_sources_max_fields
  min: news_sources_min_fields
  stddev: news_sources_stddev_fields
  stddev_pop: news_sources_stddev_pop_fields
  stddev_samp: news_sources_stddev_samp_fields
  sum: news_sources_sum_fields
  var_pop: news_sources_var_pop_fields
  var_samp: news_sources_var_samp_fields
  variance: news_sources_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input news_sources_append_input {
  config: jsonb
}

"""aggregate avg on columns"""
type news_sources_avg_fields {
  fetch_interval_minutes: Float
}

"""
Boolean expression to filter rows from the table "news_sources". All fields are combined with a logical 'AND'.
"""
input news_sources_bool_exp {
  _and: [news_sources_bool_exp!]
  _not: news_sources_bool_exp
  _or: [news_sources_bool_exp!]
  category: String_comparison_exp
  config: jsonb_comparison_exp
  country: String_comparison_exp
  created_at: timestamptz_comparison_exp
  fetch_interval_minutes: Int_comparison_exp
  id: uuid_comparison_exp
  is_active: Boolean_comparison_exp
  last_fetched_at: timestamptz_comparison_exp
  name: String_comparison_exp
  news_items: news_items_bool_exp
  news_items_aggregate: news_items_aggregate_bool_exp
  source_type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  url: String_comparison_exp
}

"""
unique or primary key constraints on table "news_sources"
"""
enum news_sources_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  news_sources_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input news_sources_delete_at_path_input {
  config: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input news_sources_delete_elem_input {
  config: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input news_sources_delete_key_input {
  config: String
}

"""
input type for incrementing numeric columns in table "news_sources"
"""
input news_sources_inc_input {
  fetch_interval_minutes: Int
}

"""
input type for inserting data into table "news_sources"
"""
input news_sources_insert_input {
  category: String
  config: jsonb
  country: String
  created_at: timestamptz
  fetch_interval_minutes: Int
  id: uuid
  is_active: Boolean
  last_fetched_at: timestamptz
  name: String
  news_items: news_items_arr_rel_insert_input
  source_type: String
  updated_at: timestamptz
  url: String
}

"""aggregate max on columns"""
type news_sources_max_fields {
  category: String
  country: String
  created_at: timestamptz
  fetch_interval_minutes: Int
  id: uuid
  last_fetched_at: timestamptz
  name: String
  source_type: String
  updated_at: timestamptz
  url: String
}

"""aggregate min on columns"""
type news_sources_min_fields {
  category: String
  country: String
  created_at: timestamptz
  fetch_interval_minutes: Int
  id: uuid
  last_fetched_at: timestamptz
  name: String
  source_type: String
  updated_at: timestamptz
  url: String
}

"""
response of any mutation on the table "news_sources"
"""
type news_sources_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [news_sources!]!
}

"""
input type for inserting object relation for remote table "news_sources"
"""
input news_sources_obj_rel_insert_input {
  data: news_sources_insert_input!

  """upsert condition"""
  on_conflict: news_sources_on_conflict
}

"""
on_conflict condition type for table "news_sources"
"""
input news_sources_on_conflict {
  constraint: news_sources_constraint!
  update_columns: [news_sources_update_column!]! = []
  where: news_sources_bool_exp
}

"""Ordering options when selecting data from "news_sources"."""
input news_sources_order_by {
  category: order_by
  config: order_by
  country: order_by
  created_at: order_by
  fetch_interval_minutes: order_by
  id: order_by
  is_active: order_by
  last_fetched_at: order_by
  name: order_by
  news_items_aggregate: news_items_aggregate_order_by
  source_type: order_by
  updated_at: order_by
  url: order_by
}

"""primary key columns input for table: news_sources"""
input news_sources_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input news_sources_prepend_input {
  config: jsonb
}

"""
select columns of table "news_sources"
"""
enum news_sources_select_column {
  """column name"""
  category

  """column name"""
  config

  """column name"""
  country

  """column name"""
  created_at

  """column name"""
  fetch_interval_minutes

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  last_fetched_at

  """column name"""
  name

  """column name"""
  source_type

  """column name"""
  updated_at

  """column name"""
  url
}

"""
input type for updating data in table "news_sources"
"""
input news_sources_set_input {
  category: String
  config: jsonb
  country: String
  created_at: timestamptz
  fetch_interval_minutes: Int
  id: uuid
  is_active: Boolean
  last_fetched_at: timestamptz
  name: String
  source_type: String
  updated_at: timestamptz
  url: String
}

"""aggregate stddev on columns"""
type news_sources_stddev_fields {
  fetch_interval_minutes: Float
}

"""aggregate stddev_pop on columns"""
type news_sources_stddev_pop_fields {
  fetch_interval_minutes: Float
}

"""aggregate stddev_samp on columns"""
type news_sources_stddev_samp_fields {
  fetch_interval_minutes: Float
}

"""
Streaming cursor of the table "news_sources"
"""
input news_sources_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: news_sources_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input news_sources_stream_cursor_value_input {
  category: String
  config: jsonb
  country: String
  created_at: timestamptz
  fetch_interval_minutes: Int
  id: uuid
  is_active: Boolean
  last_fetched_at: timestamptz
  name: String
  source_type: String
  updated_at: timestamptz
  url: String
}

"""aggregate sum on columns"""
type news_sources_sum_fields {
  fetch_interval_minutes: Int
}

"""
update columns of table "news_sources"
"""
enum news_sources_update_column {
  """column name"""
  category

  """column name"""
  config

  """column name"""
  country

  """column name"""
  created_at

  """column name"""
  fetch_interval_minutes

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  last_fetched_at

  """column name"""
  name

  """column name"""
  source_type

  """column name"""
  updated_at

  """column name"""
  url
}

input news_sources_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: news_sources_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: news_sources_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: news_sources_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: news_sources_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: news_sources_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: news_sources_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: news_sources_set_input

  """filter the rows which have to be updated"""
  where: news_sources_bool_exp!
}

"""aggregate var_pop on columns"""
type news_sources_var_pop_fields {
  fetch_interval_minutes: Float
}

"""aggregate var_samp on columns"""
type news_sources_var_samp_fields {
  fetch_interval_minutes: Float
}

"""aggregate variance on columns"""
type news_sources_variance_fields {
  fetch_interval_minutes: Float
}

"""
columns and relationships of "notifications"
"""
type notifications {
  action_url: String
  created_at: timestamptz
  expires_at: timestamptz
  id: uuid!
  link: String
  message: String!
  priority: String
  read: Boolean
  read_at: timestamptz
  related_id: uuid
  related_type: String
  title: String!
  type: String!
  user_id: String
}

"""
aggregated selection of "notifications"
"""
type notifications_aggregate {
  aggregate: notifications_aggregate_fields
  nodes: [notifications!]!
}

"""
aggregate fields of "notifications"
"""
type notifications_aggregate_fields {
  count(columns: [notifications_select_column!], distinct: Boolean): Int!
  max: notifications_max_fields
  min: notifications_min_fields
}

"""
Boolean expression to filter rows from the table "notifications". All fields are combined with a logical 'AND'.
"""
input notifications_bool_exp {
  _and: [notifications_bool_exp!]
  _not: notifications_bool_exp
  _or: [notifications_bool_exp!]
  action_url: String_comparison_exp
  created_at: timestamptz_comparison_exp
  expires_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  link: String_comparison_exp
  message: String_comparison_exp
  priority: String_comparison_exp
  read: Boolean_comparison_exp
  read_at: timestamptz_comparison_exp
  related_id: uuid_comparison_exp
  related_type: String_comparison_exp
  title: String_comparison_exp
  type: String_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "notifications"
"""
enum notifications_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  notifications_pkey
}

"""
input type for inserting data into table "notifications"
"""
input notifications_insert_input {
  action_url: String
  created_at: timestamptz
  expires_at: timestamptz
  id: uuid
  link: String
  message: String
  priority: String
  read: Boolean
  read_at: timestamptz
  related_id: uuid
  related_type: String
  title: String
  type: String
  user_id: String
}

"""aggregate max on columns"""
type notifications_max_fields {
  action_url: String
  created_at: timestamptz
  expires_at: timestamptz
  id: uuid
  link: String
  message: String
  priority: String
  read_at: timestamptz
  related_id: uuid
  related_type: String
  title: String
  type: String
  user_id: String
}

"""aggregate min on columns"""
type notifications_min_fields {
  action_url: String
  created_at: timestamptz
  expires_at: timestamptz
  id: uuid
  link: String
  message: String
  priority: String
  read_at: timestamptz
  related_id: uuid
  related_type: String
  title: String
  type: String
  user_id: String
}

"""
response of any mutation on the table "notifications"
"""
type notifications_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notifications!]!
}

"""
on_conflict condition type for table "notifications"
"""
input notifications_on_conflict {
  constraint: notifications_constraint!
  update_columns: [notifications_update_column!]! = []
  where: notifications_bool_exp
}

"""Ordering options when selecting data from "notifications"."""
input notifications_order_by {
  action_url: order_by
  created_at: order_by
  expires_at: order_by
  id: order_by
  link: order_by
  message: order_by
  priority: order_by
  read: order_by
  read_at: order_by
  related_id: order_by
  related_type: order_by
  title: order_by
  type: order_by
  user_id: order_by
}

"""primary key columns input for table: notifications"""
input notifications_pk_columns_input {
  id: uuid!
}

"""
select columns of table "notifications"
"""
enum notifications_select_column {
  """column name"""
  action_url

  """column name"""
  created_at

  """column name"""
  expires_at

  """column name"""
  id

  """column name"""
  link

  """column name"""
  message

  """column name"""
  priority

  """column name"""
  read

  """column name"""
  read_at

  """column name"""
  related_id

  """column name"""
  related_type

  """column name"""
  title

  """column name"""
  type

  """column name"""
  user_id
}

"""
input type for updating data in table "notifications"
"""
input notifications_set_input {
  action_url: String
  created_at: timestamptz
  expires_at: timestamptz
  id: uuid
  link: String
  message: String
  priority: String
  read: Boolean
  read_at: timestamptz
  related_id: uuid
  related_type: String
  title: String
  type: String
  user_id: String
}

"""
Streaming cursor of the table "notifications"
"""
input notifications_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notifications_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notifications_stream_cursor_value_input {
  action_url: String
  created_at: timestamptz
  expires_at: timestamptz
  id: uuid
  link: String
  message: String
  priority: String
  read: Boolean
  read_at: timestamptz
  related_id: uuid
  related_type: String
  title: String
  type: String
  user_id: String
}

"""
update columns of table "notifications"
"""
enum notifications_update_column {
  """column name"""
  action_url

  """column name"""
  created_at

  """column name"""
  expires_at

  """column name"""
  id

  """column name"""
  link

  """column name"""
  message

  """column name"""
  priority

  """column name"""
  read

  """column name"""
  read_at

  """column name"""
  related_id

  """column name"""
  related_type

  """column name"""
  title

  """column name"""
  type

  """column name"""
  user_id
}

input notifications_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: notifications_set_input

  """filter the rows which have to be updated"""
  where: notifications_bool_exp!
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

scalar oauth_authorization_status

"""
Boolean expression to compare columns of type "oauth_authorization_status". All fields are combined with logical 'AND'.
"""
input oauth_authorization_status_comparison_exp {
  _eq: oauth_authorization_status
  _gt: oauth_authorization_status
  _gte: oauth_authorization_status
  _in: [oauth_authorization_status!]
  _is_null: Boolean
  _lt: oauth_authorization_status
  _lte: oauth_authorization_status
  _neq: oauth_authorization_status
  _nin: [oauth_authorization_status!]
}

scalar oauth_client_type

"""
Boolean expression to compare columns of type "oauth_client_type". All fields are combined with logical 'AND'.
"""
input oauth_client_type_comparison_exp {
  _eq: oauth_client_type
  _gt: oauth_client_type
  _gte: oauth_client_type
  _in: [oauth_client_type!]
  _is_null: Boolean
  _lt: oauth_client_type
  _lte: oauth_client_type
  _neq: oauth_client_type
  _nin: [oauth_client_type!]
}

scalar oauth_registration_type

"""
Boolean expression to compare columns of type "oauth_registration_type". All fields are combined with logical 'AND'.
"""
input oauth_registration_type_comparison_exp {
  _eq: oauth_registration_type
  _gt: oauth_registration_type
  _gte: oauth_registration_type
  _in: [oauth_registration_type!]
  _is_null: Boolean
  _lt: oauth_registration_type
  _lte: oauth_registration_type
  _neq: oauth_registration_type
  _nin: [oauth_registration_type!]
}

scalar oauth_response_type

"""
Boolean expression to compare columns of type "oauth_response_type". All fields are combined with logical 'AND'.
"""
input oauth_response_type_comparison_exp {
  _eq: oauth_response_type
  _gt: oauth_response_type
  _gte: oauth_response_type
  _in: [oauth_response_type!]
  _is_null: Boolean
  _lt: oauth_response_type
  _lte: oauth_response_type
  _neq: oauth_response_type
  _nin: [oauth_response_type!]
}

scalar one_time_token_type

"""
Boolean expression to compare columns of type "one_time_token_type". All fields are combined with logical 'AND'.
"""
input one_time_token_type_comparison_exp {
  _eq: one_time_token_type
  _gt: one_time_token_type
  _gte: one_time_token_type
  _in: [one_time_token_type!]
  _is_null: Boolean
  _lt: one_time_token_type
  _lte: one_time_token_type
  _neq: one_time_token_type
  _nin: [one_time_token_type!]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""Tracks individual page views with timing and device info"""
type page_views {
  browser: String
  city: String
  country: String
  created_at: timestamptz
  device_type: String
  duration: Int
  id: uuid!
  ip_address: inet
  load_time: Int
  os: String
  page_title: String
  path: String!
  referrer: String
  session_id: uuid!
  user_agent: String
  user_id: uuid
  viewed_at: timestamptz
}

"""
aggregated selection of "page_views"
"""
type page_views_aggregate {
  aggregate: page_views_aggregate_fields
  nodes: [page_views!]!
}

"""
aggregate fields of "page_views"
"""
type page_views_aggregate_fields {
  avg: page_views_avg_fields
  count(columns: [page_views_select_column!], distinct: Boolean): Int!
  max: page_views_max_fields
  min: page_views_min_fields
  stddev: page_views_stddev_fields
  stddev_pop: page_views_stddev_pop_fields
  stddev_samp: page_views_stddev_samp_fields
  sum: page_views_sum_fields
  var_pop: page_views_var_pop_fields
  var_samp: page_views_var_samp_fields
  variance: page_views_variance_fields
}

"""aggregate avg on columns"""
type page_views_avg_fields {
  duration: Float
  load_time: Float
}

"""
Boolean expression to filter rows from the table "page_views". All fields are combined with a logical 'AND'.
"""
input page_views_bool_exp {
  _and: [page_views_bool_exp!]
  _not: page_views_bool_exp
  _or: [page_views_bool_exp!]
  browser: String_comparison_exp
  city: String_comparison_exp
  country: String_comparison_exp
  created_at: timestamptz_comparison_exp
  device_type: String_comparison_exp
  duration: Int_comparison_exp
  id: uuid_comparison_exp
  ip_address: inet_comparison_exp
  load_time: Int_comparison_exp
  os: String_comparison_exp
  page_title: String_comparison_exp
  path: String_comparison_exp
  referrer: String_comparison_exp
  session_id: uuid_comparison_exp
  user_agent: String_comparison_exp
  user_id: uuid_comparison_exp
  viewed_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "page_views"
"""
enum page_views_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  page_views_pkey
}

"""
input type for incrementing numeric columns in table "page_views"
"""
input page_views_inc_input {
  duration: Int
  load_time: Int
}

"""
input type for inserting data into table "page_views"
"""
input page_views_insert_input {
  browser: String
  city: String
  country: String
  created_at: timestamptz
  device_type: String
  duration: Int
  id: uuid
  ip_address: inet
  load_time: Int
  os: String
  page_title: String
  path: String
  referrer: String
  session_id: uuid
  user_agent: String
  user_id: uuid
  viewed_at: timestamptz
}

"""aggregate max on columns"""
type page_views_max_fields {
  browser: String
  city: String
  country: String
  created_at: timestamptz
  device_type: String
  duration: Int
  id: uuid
  load_time: Int
  os: String
  page_title: String
  path: String
  referrer: String
  session_id: uuid
  user_agent: String
  user_id: uuid
  viewed_at: timestamptz
}

"""aggregate min on columns"""
type page_views_min_fields {
  browser: String
  city: String
  country: String
  created_at: timestamptz
  device_type: String
  duration: Int
  id: uuid
  load_time: Int
  os: String
  page_title: String
  path: String
  referrer: String
  session_id: uuid
  user_agent: String
  user_id: uuid
  viewed_at: timestamptz
}

"""
response of any mutation on the table "page_views"
"""
type page_views_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [page_views!]!
}

"""
on_conflict condition type for table "page_views"
"""
input page_views_on_conflict {
  constraint: page_views_constraint!
  update_columns: [page_views_update_column!]! = []
  where: page_views_bool_exp
}

"""Ordering options when selecting data from "page_views"."""
input page_views_order_by {
  browser: order_by
  city: order_by
  country: order_by
  created_at: order_by
  device_type: order_by
  duration: order_by
  id: order_by
  ip_address: order_by
  load_time: order_by
  os: order_by
  page_title: order_by
  path: order_by
  referrer: order_by
  session_id: order_by
  user_agent: order_by
  user_id: order_by
  viewed_at: order_by
}

"""primary key columns input for table: page_views"""
input page_views_pk_columns_input {
  id: uuid!
}

"""
select columns of table "page_views"
"""
enum page_views_select_column {
  """column name"""
  browser

  """column name"""
  city

  """column name"""
  country

  """column name"""
  created_at

  """column name"""
  device_type

  """column name"""
  duration

  """column name"""
  id

  """column name"""
  ip_address

  """column name"""
  load_time

  """column name"""
  os

  """column name"""
  page_title

  """column name"""
  path

  """column name"""
  referrer

  """column name"""
  session_id

  """column name"""
  user_agent

  """column name"""
  user_id

  """column name"""
  viewed_at
}

"""
input type for updating data in table "page_views"
"""
input page_views_set_input {
  browser: String
  city: String
  country: String
  created_at: timestamptz
  device_type: String
  duration: Int
  id: uuid
  ip_address: inet
  load_time: Int
  os: String
  page_title: String
  path: String
  referrer: String
  session_id: uuid
  user_agent: String
  user_id: uuid
  viewed_at: timestamptz
}

"""aggregate stddev on columns"""
type page_views_stddev_fields {
  duration: Float
  load_time: Float
}

"""aggregate stddev_pop on columns"""
type page_views_stddev_pop_fields {
  duration: Float
  load_time: Float
}

"""aggregate stddev_samp on columns"""
type page_views_stddev_samp_fields {
  duration: Float
  load_time: Float
}

"""
Streaming cursor of the table "page_views"
"""
input page_views_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: page_views_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input page_views_stream_cursor_value_input {
  browser: String
  city: String
  country: String
  created_at: timestamptz
  device_type: String
  duration: Int
  id: uuid
  ip_address: inet
  load_time: Int
  os: String
  page_title: String
  path: String
  referrer: String
  session_id: uuid
  user_agent: String
  user_id: uuid
  viewed_at: timestamptz
}

"""aggregate sum on columns"""
type page_views_sum_fields {
  duration: Int
  load_time: Int
}

"""
update columns of table "page_views"
"""
enum page_views_update_column {
  """column name"""
  browser

  """column name"""
  city

  """column name"""
  country

  """column name"""
  created_at

  """column name"""
  device_type

  """column name"""
  duration

  """column name"""
  id

  """column name"""
  ip_address

  """column name"""
  load_time

  """column name"""
  os

  """column name"""
  page_title

  """column name"""
  path

  """column name"""
  referrer

  """column name"""
  session_id

  """column name"""
  user_agent

  """column name"""
  user_id

  """column name"""
  viewed_at
}

input page_views_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: page_views_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: page_views_set_input

  """filter the rows which have to be updated"""
  where: page_views_bool_exp!
}

"""aggregate var_pop on columns"""
type page_views_var_pop_fields {
  duration: Float
  load_time: Float
}

"""aggregate var_samp on columns"""
type page_views_var_samp_fields {
  duration: Float
  load_time: Float
}

"""aggregate variance on columns"""
type page_views_variance_fields {
  duration: Float
  load_time: Float
}

"""Stores password reset requests for secure password recovery flow"""
type password_resets {
  """Timestamp when reset was requested"""
  created_at: timestamptz!

  """Email address associated with the reset request"""
  email: String!

  """Token expiry timestamp (default 1 hour from creation)"""
  expires_at: timestamptz!

  """Unique identifier for the password reset request"""
  id: uuid!

  """IP address of the requester (for security tracking)"""
  ip_address: String

  """Current status: pending, used, expired, or cancelled"""
  status: String!

  """Unique secure token for password reset (hashed)"""
  token: String!

  """Timestamp of last update"""
  updated_at: timestamptz!

  """Timestamp when token was successfully used"""
  used_at: timestamptz

  """An object relationship"""
  user: auth_users!

  """Reference to the user requesting password reset"""
  user_id: uuid!
}

"""
aggregated selection of "password_resets"
"""
type password_resets_aggregate {
  aggregate: password_resets_aggregate_fields
  nodes: [password_resets!]!
}

"""
aggregate fields of "password_resets"
"""
type password_resets_aggregate_fields {
  count(columns: [password_resets_select_column!], distinct: Boolean): Int!
  max: password_resets_max_fields
  min: password_resets_min_fields
}

"""
Boolean expression to filter rows from the table "password_resets". All fields are combined with a logical 'AND'.
"""
input password_resets_bool_exp {
  _and: [password_resets_bool_exp!]
  _not: password_resets_bool_exp
  _or: [password_resets_bool_exp!]
  created_at: timestamptz_comparison_exp
  email: String_comparison_exp
  expires_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  ip_address: String_comparison_exp
  status: String_comparison_exp
  token: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  used_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "password_resets"
"""
enum password_resets_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  password_resets_pkey

  """
  unique or primary key constraint on columns "token"
  """
  password_resets_token_key
}

"""
input type for inserting data into table "password_resets"
"""
input password_resets_insert_input {
  """Timestamp when reset was requested"""
  created_at: timestamptz

  """Email address associated with the reset request"""
  email: String

  """Token expiry timestamp (default 1 hour from creation)"""
  expires_at: timestamptz

  """Unique identifier for the password reset request"""
  id: uuid

  """IP address of the requester (for security tracking)"""
  ip_address: String

  """Current status: pending, used, expired, or cancelled"""
  status: String

  """Unique secure token for password reset (hashed)"""
  token: String

  """Timestamp of last update"""
  updated_at: timestamptz

  """Timestamp when token was successfully used"""
  used_at: timestamptz
  user: auth_users_obj_rel_insert_input

  """Reference to the user requesting password reset"""
  user_id: uuid
}

"""aggregate max on columns"""
type password_resets_max_fields {
  """Timestamp when reset was requested"""
  created_at: timestamptz

  """Email address associated with the reset request"""
  email: String

  """Token expiry timestamp (default 1 hour from creation)"""
  expires_at: timestamptz

  """Unique identifier for the password reset request"""
  id: uuid

  """IP address of the requester (for security tracking)"""
  ip_address: String

  """Current status: pending, used, expired, or cancelled"""
  status: String

  """Unique secure token for password reset (hashed)"""
  token: String

  """Timestamp of last update"""
  updated_at: timestamptz

  """Timestamp when token was successfully used"""
  used_at: timestamptz

  """Reference to the user requesting password reset"""
  user_id: uuid
}

"""aggregate min on columns"""
type password_resets_min_fields {
  """Timestamp when reset was requested"""
  created_at: timestamptz

  """Email address associated with the reset request"""
  email: String

  """Token expiry timestamp (default 1 hour from creation)"""
  expires_at: timestamptz

  """Unique identifier for the password reset request"""
  id: uuid

  """IP address of the requester (for security tracking)"""
  ip_address: String

  """Current status: pending, used, expired, or cancelled"""
  status: String

  """Unique secure token for password reset (hashed)"""
  token: String

  """Timestamp of last update"""
  updated_at: timestamptz

  """Timestamp when token was successfully used"""
  used_at: timestamptz

  """Reference to the user requesting password reset"""
  user_id: uuid
}

"""
response of any mutation on the table "password_resets"
"""
type password_resets_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [password_resets!]!
}

"""
on_conflict condition type for table "password_resets"
"""
input password_resets_on_conflict {
  constraint: password_resets_constraint!
  update_columns: [password_resets_update_column!]! = []
  where: password_resets_bool_exp
}

"""Ordering options when selecting data from "password_resets"."""
input password_resets_order_by {
  created_at: order_by
  email: order_by
  expires_at: order_by
  id: order_by
  ip_address: order_by
  status: order_by
  token: order_by
  updated_at: order_by
  used_at: order_by
  user: auth_users_order_by
  user_id: order_by
}

"""primary key columns input for table: password_resets"""
input password_resets_pk_columns_input {
  """Unique identifier for the password reset request"""
  id: uuid!
}

"""
select columns of table "password_resets"
"""
enum password_resets_select_column {
  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  expires_at

  """column name"""
  id

  """column name"""
  ip_address

  """column name"""
  status

  """column name"""
  token

  """column name"""
  updated_at

  """column name"""
  used_at

  """column name"""
  user_id
}

"""
input type for updating data in table "password_resets"
"""
input password_resets_set_input {
  """Timestamp when reset was requested"""
  created_at: timestamptz

  """Email address associated with the reset request"""
  email: String

  """Token expiry timestamp (default 1 hour from creation)"""
  expires_at: timestamptz

  """Unique identifier for the password reset request"""
  id: uuid

  """IP address of the requester (for security tracking)"""
  ip_address: String

  """Current status: pending, used, expired, or cancelled"""
  status: String

  """Unique secure token for password reset (hashed)"""
  token: String

  """Timestamp of last update"""
  updated_at: timestamptz

  """Timestamp when token was successfully used"""
  used_at: timestamptz

  """Reference to the user requesting password reset"""
  user_id: uuid
}

"""
Streaming cursor of the table "password_resets"
"""
input password_resets_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: password_resets_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input password_resets_stream_cursor_value_input {
  """Timestamp when reset was requested"""
  created_at: timestamptz

  """Email address associated with the reset request"""
  email: String

  """Token expiry timestamp (default 1 hour from creation)"""
  expires_at: timestamptz

  """Unique identifier for the password reset request"""
  id: uuid

  """IP address of the requester (for security tracking)"""
  ip_address: String

  """Current status: pending, used, expired, or cancelled"""
  status: String

  """Unique secure token for password reset (hashed)"""
  token: String

  """Timestamp of last update"""
  updated_at: timestamptz

  """Timestamp when token was successfully used"""
  used_at: timestamptz

  """Reference to the user requesting password reset"""
  user_id: uuid
}

"""
update columns of table "password_resets"
"""
enum password_resets_update_column {
  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  expires_at

  """column name"""
  id

  """column name"""
  ip_address

  """column name"""
  status

  """column name"""
  token

  """column name"""
  updated_at

  """column name"""
  used_at

  """column name"""
  user_id
}

input password_resets_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: password_resets_set_input

  """filter the rows which have to be updated"""
  where: password_resets_bool_exp!
}

"""
columns and relationships of "payment_idempotency"
"""
type payment_idempotency {
  amount: Int!

  """An array relationship"""
  contact_fees(
    """distinct select on columns"""
    distinct_on: [contact_fees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [contact_fees_order_by!]

    """filter the rows returned"""
    where: contact_fees_bool_exp
  ): [contact_fees!]!

  """An aggregate relationship"""
  contact_fees_aggregate(
    """distinct select on columns"""
    distinct_on: [contact_fees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [contact_fees_order_by!]

    """filter the rows returned"""
    where: contact_fees_bool_exp
  ): contact_fees_aggregate!
  created_at: timestamptz

  """An array relationship"""
  credit_transactions(
    """distinct select on columns"""
    distinct_on: [credit_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [credit_transactions_order_by!]

    """filter the rows returned"""
    where: credit_transactions_bool_exp
  ): [credit_transactions!]!

  """An aggregate relationship"""
  credit_transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [credit_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [credit_transactions_order_by!]

    """filter the rows returned"""
    where: credit_transactions_bool_exp
  ): credit_transactions_aggregate!
  currency: String!
  expires_at: timestamptz
  id: uuid!
  key: String!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  operation_type: String!
  processed_at: timestamptz
  status: String
  stripe_charge_id: String
  stripe_payment_intent_id: String

  """An object relationship"""
  user: auth_users
  user_id: uuid
}

"""
aggregated selection of "payment_idempotency"
"""
type payment_idempotency_aggregate {
  aggregate: payment_idempotency_aggregate_fields
  nodes: [payment_idempotency!]!
}

"""
aggregate fields of "payment_idempotency"
"""
type payment_idempotency_aggregate_fields {
  avg: payment_idempotency_avg_fields
  count(columns: [payment_idempotency_select_column!], distinct: Boolean): Int!
  max: payment_idempotency_max_fields
  min: payment_idempotency_min_fields
  stddev: payment_idempotency_stddev_fields
  stddev_pop: payment_idempotency_stddev_pop_fields
  stddev_samp: payment_idempotency_stddev_samp_fields
  sum: payment_idempotency_sum_fields
  var_pop: payment_idempotency_var_pop_fields
  var_samp: payment_idempotency_var_samp_fields
  variance: payment_idempotency_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input payment_idempotency_append_input {
  metadata: jsonb
}

"""aggregate avg on columns"""
type payment_idempotency_avg_fields {
  amount: Float
}

"""
Boolean expression to filter rows from the table "payment_idempotency". All fields are combined with a logical 'AND'.
"""
input payment_idempotency_bool_exp {
  _and: [payment_idempotency_bool_exp!]
  _not: payment_idempotency_bool_exp
  _or: [payment_idempotency_bool_exp!]
  amount: Int_comparison_exp
  contact_fees: contact_fees_bool_exp
  contact_fees_aggregate: contact_fees_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  credit_transactions: credit_transactions_bool_exp
  credit_transactions_aggregate: credit_transactions_aggregate_bool_exp
  currency: String_comparison_exp
  expires_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  key: String_comparison_exp
  metadata: jsonb_comparison_exp
  operation_type: String_comparison_exp
  processed_at: timestamptz_comparison_exp
  status: String_comparison_exp
  stripe_charge_id: String_comparison_exp
  stripe_payment_intent_id: String_comparison_exp
  user: auth_users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "payment_idempotency"
"""
enum payment_idempotency_constraint {
  """
  unique or primary key constraint on columns "key"
  """
  payment_idempotency_key_key

  """
  unique or primary key constraint on columns "id"
  """
  payment_idempotency_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input payment_idempotency_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input payment_idempotency_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input payment_idempotency_delete_key_input {
  metadata: String
}

"""
input type for incrementing numeric columns in table "payment_idempotency"
"""
input payment_idempotency_inc_input {
  amount: Int
}

"""
input type for inserting data into table "payment_idempotency"
"""
input payment_idempotency_insert_input {
  amount: Int
  contact_fees: contact_fees_arr_rel_insert_input
  created_at: timestamptz
  credit_transactions: credit_transactions_arr_rel_insert_input
  currency: String
  expires_at: timestamptz
  id: uuid
  key: String
  metadata: jsonb
  operation_type: String
  processed_at: timestamptz
  status: String
  stripe_charge_id: String
  stripe_payment_intent_id: String
  user: auth_users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type payment_idempotency_max_fields {
  amount: Int
  created_at: timestamptz
  currency: String
  expires_at: timestamptz
  id: uuid
  key: String
  operation_type: String
  processed_at: timestamptz
  status: String
  stripe_charge_id: String
  stripe_payment_intent_id: String
  user_id: uuid
}

"""aggregate min on columns"""
type payment_idempotency_min_fields {
  amount: Int
  created_at: timestamptz
  currency: String
  expires_at: timestamptz
  id: uuid
  key: String
  operation_type: String
  processed_at: timestamptz
  status: String
  stripe_charge_id: String
  stripe_payment_intent_id: String
  user_id: uuid
}

"""
response of any mutation on the table "payment_idempotency"
"""
type payment_idempotency_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payment_idempotency!]!
}

"""
input type for inserting object relation for remote table "payment_idempotency"
"""
input payment_idempotency_obj_rel_insert_input {
  data: payment_idempotency_insert_input!

  """upsert condition"""
  on_conflict: payment_idempotency_on_conflict
}

"""
on_conflict condition type for table "payment_idempotency"
"""
input payment_idempotency_on_conflict {
  constraint: payment_idempotency_constraint!
  update_columns: [payment_idempotency_update_column!]! = []
  where: payment_idempotency_bool_exp
}

"""Ordering options when selecting data from "payment_idempotency"."""
input payment_idempotency_order_by {
  amount: order_by
  contact_fees_aggregate: contact_fees_aggregate_order_by
  created_at: order_by
  credit_transactions_aggregate: credit_transactions_aggregate_order_by
  currency: order_by
  expires_at: order_by
  id: order_by
  key: order_by
  metadata: order_by
  operation_type: order_by
  processed_at: order_by
  status: order_by
  stripe_charge_id: order_by
  stripe_payment_intent_id: order_by
  user: auth_users_order_by
  user_id: order_by
}

"""primary key columns input for table: payment_idempotency"""
input payment_idempotency_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input payment_idempotency_prepend_input {
  metadata: jsonb
}

"""
select columns of table "payment_idempotency"
"""
enum payment_idempotency_select_column {
  """column name"""
  amount

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  expires_at

  """column name"""
  id

  """column name"""
  key

  """column name"""
  metadata

  """column name"""
  operation_type

  """column name"""
  processed_at

  """column name"""
  status

  """column name"""
  stripe_charge_id

  """column name"""
  stripe_payment_intent_id

  """column name"""
  user_id
}

"""
input type for updating data in table "payment_idempotency"
"""
input payment_idempotency_set_input {
  amount: Int
  created_at: timestamptz
  currency: String
  expires_at: timestamptz
  id: uuid
  key: String
  metadata: jsonb
  operation_type: String
  processed_at: timestamptz
  status: String
  stripe_charge_id: String
  stripe_payment_intent_id: String
  user_id: uuid
}

"""aggregate stddev on columns"""
type payment_idempotency_stddev_fields {
  amount: Float
}

"""aggregate stddev_pop on columns"""
type payment_idempotency_stddev_pop_fields {
  amount: Float
}

"""aggregate stddev_samp on columns"""
type payment_idempotency_stddev_samp_fields {
  amount: Float
}

"""
Streaming cursor of the table "payment_idempotency"
"""
input payment_idempotency_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: payment_idempotency_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input payment_idempotency_stream_cursor_value_input {
  amount: Int
  created_at: timestamptz
  currency: String
  expires_at: timestamptz
  id: uuid
  key: String
  metadata: jsonb
  operation_type: String
  processed_at: timestamptz
  status: String
  stripe_charge_id: String
  stripe_payment_intent_id: String
  user_id: uuid
}

"""aggregate sum on columns"""
type payment_idempotency_sum_fields {
  amount: Int
}

"""
update columns of table "payment_idempotency"
"""
enum payment_idempotency_update_column {
  """column name"""
  amount

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  expires_at

  """column name"""
  id

  """column name"""
  key

  """column name"""
  metadata

  """column name"""
  operation_type

  """column name"""
  processed_at

  """column name"""
  status

  """column name"""
  stripe_charge_id

  """column name"""
  stripe_payment_intent_id

  """column name"""
  user_id
}

input payment_idempotency_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: payment_idempotency_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: payment_idempotency_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: payment_idempotency_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: payment_idempotency_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: payment_idempotency_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: payment_idempotency_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: payment_idempotency_set_input

  """filter the rows which have to be updated"""
  where: payment_idempotency_bool_exp!
}

"""aggregate var_pop on columns"""
type payment_idempotency_var_pop_fields {
  amount: Float
}

"""aggregate var_samp on columns"""
type payment_idempotency_var_samp_fields {
  amount: Float
}

"""aggregate variance on columns"""
type payment_idempotency_variance_fields {
  amount: Float
}

"""
columns and relationships of "payment_methods"
"""
type payment_methods {
  billing_address(
    """JSON select path"""
    path: String
  ): jsonb
  billing_email: String
  billing_name: String!
  billing_phone: String
  card_brand: String
  card_exp_month: Int
  card_exp_year: Int
  card_last4: String
  created_at: timestamptz
  id: uuid!
  is_default: Boolean
  is_verified: Boolean
  last_used_at: timestamptz
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  method_type: String!
  nickname: String
  status: String!
  stripe_customer_id: String
  stripe_payment_method_id: String
  updated_at: timestamptz
  user_id: String!
}

"""
aggregated selection of "payment_methods"
"""
type payment_methods_aggregate {
  aggregate: payment_methods_aggregate_fields
  nodes: [payment_methods!]!
}

"""
aggregate fields of "payment_methods"
"""
type payment_methods_aggregate_fields {
  avg: payment_methods_avg_fields
  count(columns: [payment_methods_select_column!], distinct: Boolean): Int!
  max: payment_methods_max_fields
  min: payment_methods_min_fields
  stddev: payment_methods_stddev_fields
  stddev_pop: payment_methods_stddev_pop_fields
  stddev_samp: payment_methods_stddev_samp_fields
  sum: payment_methods_sum_fields
  var_pop: payment_methods_var_pop_fields
  var_samp: payment_methods_var_samp_fields
  variance: payment_methods_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input payment_methods_append_input {
  billing_address: jsonb
  metadata: jsonb
}

"""aggregate avg on columns"""
type payment_methods_avg_fields {
  card_exp_month: Float
  card_exp_year: Float
}

"""
Boolean expression to filter rows from the table "payment_methods". All fields are combined with a logical 'AND'.
"""
input payment_methods_bool_exp {
  _and: [payment_methods_bool_exp!]
  _not: payment_methods_bool_exp
  _or: [payment_methods_bool_exp!]
  billing_address: jsonb_comparison_exp
  billing_email: String_comparison_exp
  billing_name: String_comparison_exp
  billing_phone: String_comparison_exp
  card_brand: String_comparison_exp
  card_exp_month: Int_comparison_exp
  card_exp_year: Int_comparison_exp
  card_last4: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  is_default: Boolean_comparison_exp
  is_verified: Boolean_comparison_exp
  last_used_at: timestamptz_comparison_exp
  metadata: jsonb_comparison_exp
  method_type: String_comparison_exp
  nickname: String_comparison_exp
  status: String_comparison_exp
  stripe_customer_id: String_comparison_exp
  stripe_payment_method_id: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "payment_methods"
"""
enum payment_methods_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  payment_methods_pkey

  """
  unique or primary key constraint on columns "stripe_payment_method_id"
  """
  payment_methods_stripe_payment_method_id_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input payment_methods_delete_at_path_input {
  billing_address: [String!]
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input payment_methods_delete_elem_input {
  billing_address: Int
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input payment_methods_delete_key_input {
  billing_address: String
  metadata: String
}

"""
input type for incrementing numeric columns in table "payment_methods"
"""
input payment_methods_inc_input {
  card_exp_month: Int
  card_exp_year: Int
}

"""
input type for inserting data into table "payment_methods"
"""
input payment_methods_insert_input {
  billing_address: jsonb
  billing_email: String
  billing_name: String
  billing_phone: String
  card_brand: String
  card_exp_month: Int
  card_exp_year: Int
  card_last4: String
  created_at: timestamptz
  id: uuid
  is_default: Boolean
  is_verified: Boolean
  last_used_at: timestamptz
  metadata: jsonb
  method_type: String
  nickname: String
  status: String
  stripe_customer_id: String
  stripe_payment_method_id: String
  updated_at: timestamptz
  user_id: String
}

"""aggregate max on columns"""
type payment_methods_max_fields {
  billing_email: String
  billing_name: String
  billing_phone: String
  card_brand: String
  card_exp_month: Int
  card_exp_year: Int
  card_last4: String
  created_at: timestamptz
  id: uuid
  last_used_at: timestamptz
  method_type: String
  nickname: String
  status: String
  stripe_customer_id: String
  stripe_payment_method_id: String
  updated_at: timestamptz
  user_id: String
}

"""aggregate min on columns"""
type payment_methods_min_fields {
  billing_email: String
  billing_name: String
  billing_phone: String
  card_brand: String
  card_exp_month: Int
  card_exp_year: Int
  card_last4: String
  created_at: timestamptz
  id: uuid
  last_used_at: timestamptz
  method_type: String
  nickname: String
  status: String
  stripe_customer_id: String
  stripe_payment_method_id: String
  updated_at: timestamptz
  user_id: String
}

"""
response of any mutation on the table "payment_methods"
"""
type payment_methods_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payment_methods!]!
}

"""
on_conflict condition type for table "payment_methods"
"""
input payment_methods_on_conflict {
  constraint: payment_methods_constraint!
  update_columns: [payment_methods_update_column!]! = []
  where: payment_methods_bool_exp
}

"""Ordering options when selecting data from "payment_methods"."""
input payment_methods_order_by {
  billing_address: order_by
  billing_email: order_by
  billing_name: order_by
  billing_phone: order_by
  card_brand: order_by
  card_exp_month: order_by
  card_exp_year: order_by
  card_last4: order_by
  created_at: order_by
  id: order_by
  is_default: order_by
  is_verified: order_by
  last_used_at: order_by
  metadata: order_by
  method_type: order_by
  nickname: order_by
  status: order_by
  stripe_customer_id: order_by
  stripe_payment_method_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""primary key columns input for table: payment_methods"""
input payment_methods_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input payment_methods_prepend_input {
  billing_address: jsonb
  metadata: jsonb
}

"""
select columns of table "payment_methods"
"""
enum payment_methods_select_column {
  """column name"""
  billing_address

  """column name"""
  billing_email

  """column name"""
  billing_name

  """column name"""
  billing_phone

  """column name"""
  card_brand

  """column name"""
  card_exp_month

  """column name"""
  card_exp_year

  """column name"""
  card_last4

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  is_default

  """column name"""
  is_verified

  """column name"""
  last_used_at

  """column name"""
  metadata

  """column name"""
  method_type

  """column name"""
  nickname

  """column name"""
  status

  """column name"""
  stripe_customer_id

  """column name"""
  stripe_payment_method_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "payment_methods"
"""
input payment_methods_set_input {
  billing_address: jsonb
  billing_email: String
  billing_name: String
  billing_phone: String
  card_brand: String
  card_exp_month: Int
  card_exp_year: Int
  card_last4: String
  created_at: timestamptz
  id: uuid
  is_default: Boolean
  is_verified: Boolean
  last_used_at: timestamptz
  metadata: jsonb
  method_type: String
  nickname: String
  status: String
  stripe_customer_id: String
  stripe_payment_method_id: String
  updated_at: timestamptz
  user_id: String
}

"""aggregate stddev on columns"""
type payment_methods_stddev_fields {
  card_exp_month: Float
  card_exp_year: Float
}

"""aggregate stddev_pop on columns"""
type payment_methods_stddev_pop_fields {
  card_exp_month: Float
  card_exp_year: Float
}

"""aggregate stddev_samp on columns"""
type payment_methods_stddev_samp_fields {
  card_exp_month: Float
  card_exp_year: Float
}

"""
Streaming cursor of the table "payment_methods"
"""
input payment_methods_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: payment_methods_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input payment_methods_stream_cursor_value_input {
  billing_address: jsonb
  billing_email: String
  billing_name: String
  billing_phone: String
  card_brand: String
  card_exp_month: Int
  card_exp_year: Int
  card_last4: String
  created_at: timestamptz
  id: uuid
  is_default: Boolean
  is_verified: Boolean
  last_used_at: timestamptz
  metadata: jsonb
  method_type: String
  nickname: String
  status: String
  stripe_customer_id: String
  stripe_payment_method_id: String
  updated_at: timestamptz
  user_id: String
}

"""aggregate sum on columns"""
type payment_methods_sum_fields {
  card_exp_month: Int
  card_exp_year: Int
}

"""
update columns of table "payment_methods"
"""
enum payment_methods_update_column {
  """column name"""
  billing_address

  """column name"""
  billing_email

  """column name"""
  billing_name

  """column name"""
  billing_phone

  """column name"""
  card_brand

  """column name"""
  card_exp_month

  """column name"""
  card_exp_year

  """column name"""
  card_last4

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  is_default

  """column name"""
  is_verified

  """column name"""
  last_used_at

  """column name"""
  metadata

  """column name"""
  method_type

  """column name"""
  nickname

  """column name"""
  status

  """column name"""
  stripe_customer_id

  """column name"""
  stripe_payment_method_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

input payment_methods_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: payment_methods_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: payment_methods_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: payment_methods_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: payment_methods_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: payment_methods_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: payment_methods_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: payment_methods_set_input

  """filter the rows which have to be updated"""
  where: payment_methods_bool_exp!
}

"""aggregate var_pop on columns"""
type payment_methods_var_pop_fields {
  card_exp_month: Float
  card_exp_year: Float
}

"""aggregate var_samp on columns"""
type payment_methods_var_samp_fields {
  card_exp_month: Float
  card_exp_year: Float
}

"""aggregate variance on columns"""
type payment_methods_variance_fields {
  card_exp_month: Float
  card_exp_year: Float
}

"""
columns and relationships of "payments"
"""
type payments {
  amount: numeric!

  """An object relationship"""
  booking: bookings
  booking_id: uuid
  completed_at: timestamptz
  created_at: timestamptz
  currency: String
  description: String
  error_code: String
  failure_reason: String
  id: uuid!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  payment_method: String
  payment_type: String!
  processed_at: timestamptz
  receipt_url: String
  reference_number: String
  status: String!
  stripe_charge_id: String
  stripe_payment_intent_id: String
  subscription_id: uuid
  transaction_id: String
  user_id: uuid
}

"""
aggregated selection of "payments"
"""
type payments_aggregate {
  aggregate: payments_aggregate_fields
  nodes: [payments!]!
}

input payments_aggregate_bool_exp {
  count: payments_aggregate_bool_exp_count
}

input payments_aggregate_bool_exp_count {
  arguments: [payments_select_column!]
  distinct: Boolean
  filter: payments_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "payments"
"""
type payments_aggregate_fields {
  avg: payments_avg_fields
  count(columns: [payments_select_column!], distinct: Boolean): Int!
  max: payments_max_fields
  min: payments_min_fields
  stddev: payments_stddev_fields
  stddev_pop: payments_stddev_pop_fields
  stddev_samp: payments_stddev_samp_fields
  sum: payments_sum_fields
  var_pop: payments_var_pop_fields
  var_samp: payments_var_samp_fields
  variance: payments_variance_fields
}

"""
order by aggregate values of table "payments"
"""
input payments_aggregate_order_by {
  avg: payments_avg_order_by
  count: order_by
  max: payments_max_order_by
  min: payments_min_order_by
  stddev: payments_stddev_order_by
  stddev_pop: payments_stddev_pop_order_by
  stddev_samp: payments_stddev_samp_order_by
  sum: payments_sum_order_by
  var_pop: payments_var_pop_order_by
  var_samp: payments_var_samp_order_by
  variance: payments_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input payments_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "payments"
"""
input payments_arr_rel_insert_input {
  data: [payments_insert_input!]!

  """upsert condition"""
  on_conflict: payments_on_conflict
}

"""aggregate avg on columns"""
type payments_avg_fields {
  amount: Float
}

"""
order by avg() on columns of table "payments"
"""
input payments_avg_order_by {
  amount: order_by
}

"""
Boolean expression to filter rows from the table "payments". All fields are combined with a logical 'AND'.
"""
input payments_bool_exp {
  _and: [payments_bool_exp!]
  _not: payments_bool_exp
  _or: [payments_bool_exp!]
  amount: numeric_comparison_exp
  booking: bookings_bool_exp
  booking_id: uuid_comparison_exp
  completed_at: timestamptz_comparison_exp
  created_at: timestamptz_comparison_exp
  currency: String_comparison_exp
  description: String_comparison_exp
  error_code: String_comparison_exp
  failure_reason: String_comparison_exp
  id: uuid_comparison_exp
  metadata: jsonb_comparison_exp
  payment_method: String_comparison_exp
  payment_type: String_comparison_exp
  processed_at: timestamptz_comparison_exp
  receipt_url: String_comparison_exp
  reference_number: String_comparison_exp
  status: String_comparison_exp
  stripe_charge_id: String_comparison_exp
  stripe_payment_intent_id: String_comparison_exp
  subscription_id: uuid_comparison_exp
  transaction_id: String_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "payments"
"""
enum payments_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  payments_pkey

  """
  unique or primary key constraint on columns "transaction_id"
  """
  payments_transaction_id_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input payments_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input payments_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input payments_delete_key_input {
  metadata: String
}

"""
input type for incrementing numeric columns in table "payments"
"""
input payments_inc_input {
  amount: numeric
}

"""
input type for inserting data into table "payments"
"""
input payments_insert_input {
  amount: numeric
  booking: bookings_obj_rel_insert_input
  booking_id: uuid
  completed_at: timestamptz
  created_at: timestamptz
  currency: String
  description: String
  error_code: String
  failure_reason: String
  id: uuid
  metadata: jsonb
  payment_method: String
  payment_type: String
  processed_at: timestamptz
  receipt_url: String
  reference_number: String
  status: String
  stripe_charge_id: String
  stripe_payment_intent_id: String
  subscription_id: uuid
  transaction_id: String
  user_id: uuid
}

"""aggregate max on columns"""
type payments_max_fields {
  amount: numeric
  booking_id: uuid
  completed_at: timestamptz
  created_at: timestamptz
  currency: String
  description: String
  error_code: String
  failure_reason: String
  id: uuid
  payment_method: String
  payment_type: String
  processed_at: timestamptz
  receipt_url: String
  reference_number: String
  status: String
  stripe_charge_id: String
  stripe_payment_intent_id: String
  subscription_id: uuid
  transaction_id: String
  user_id: uuid
}

"""
order by max() on columns of table "payments"
"""
input payments_max_order_by {
  amount: order_by
  booking_id: order_by
  completed_at: order_by
  created_at: order_by
  currency: order_by
  description: order_by
  error_code: order_by
  failure_reason: order_by
  id: order_by
  payment_method: order_by
  payment_type: order_by
  processed_at: order_by
  receipt_url: order_by
  reference_number: order_by
  status: order_by
  stripe_charge_id: order_by
  stripe_payment_intent_id: order_by
  subscription_id: order_by
  transaction_id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type payments_min_fields {
  amount: numeric
  booking_id: uuid
  completed_at: timestamptz
  created_at: timestamptz
  currency: String
  description: String
  error_code: String
  failure_reason: String
  id: uuid
  payment_method: String
  payment_type: String
  processed_at: timestamptz
  receipt_url: String
  reference_number: String
  status: String
  stripe_charge_id: String
  stripe_payment_intent_id: String
  subscription_id: uuid
  transaction_id: String
  user_id: uuid
}

"""
order by min() on columns of table "payments"
"""
input payments_min_order_by {
  amount: order_by
  booking_id: order_by
  completed_at: order_by
  created_at: order_by
  currency: order_by
  description: order_by
  error_code: order_by
  failure_reason: order_by
  id: order_by
  payment_method: order_by
  payment_type: order_by
  processed_at: order_by
  receipt_url: order_by
  reference_number: order_by
  status: order_by
  stripe_charge_id: order_by
  stripe_payment_intent_id: order_by
  subscription_id: order_by
  transaction_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "payments"
"""
type payments_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payments!]!
}

"""
on_conflict condition type for table "payments"
"""
input payments_on_conflict {
  constraint: payments_constraint!
  update_columns: [payments_update_column!]! = []
  where: payments_bool_exp
}

"""Ordering options when selecting data from "payments"."""
input payments_order_by {
  amount: order_by
  booking: bookings_order_by
  booking_id: order_by
  completed_at: order_by
  created_at: order_by
  currency: order_by
  description: order_by
  error_code: order_by
  failure_reason: order_by
  id: order_by
  metadata: order_by
  payment_method: order_by
  payment_type: order_by
  processed_at: order_by
  receipt_url: order_by
  reference_number: order_by
  status: order_by
  stripe_charge_id: order_by
  stripe_payment_intent_id: order_by
  subscription_id: order_by
  transaction_id: order_by
  user_id: order_by
}

"""primary key columns input for table: payments"""
input payments_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input payments_prepend_input {
  metadata: jsonb
}

"""
select columns of table "payments"
"""
enum payments_select_column {
  """column name"""
  amount

  """column name"""
  booking_id

  """column name"""
  completed_at

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  description

  """column name"""
  error_code

  """column name"""
  failure_reason

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  payment_method

  """column name"""
  payment_type

  """column name"""
  processed_at

  """column name"""
  receipt_url

  """column name"""
  reference_number

  """column name"""
  status

  """column name"""
  stripe_charge_id

  """column name"""
  stripe_payment_intent_id

  """column name"""
  subscription_id

  """column name"""
  transaction_id

  """column name"""
  user_id
}

"""
input type for updating data in table "payments"
"""
input payments_set_input {
  amount: numeric
  booking_id: uuid
  completed_at: timestamptz
  created_at: timestamptz
  currency: String
  description: String
  error_code: String
  failure_reason: String
  id: uuid
  metadata: jsonb
  payment_method: String
  payment_type: String
  processed_at: timestamptz
  receipt_url: String
  reference_number: String
  status: String
  stripe_charge_id: String
  stripe_payment_intent_id: String
  subscription_id: uuid
  transaction_id: String
  user_id: uuid
}

"""aggregate stddev on columns"""
type payments_stddev_fields {
  amount: Float
}

"""
order by stddev() on columns of table "payments"
"""
input payments_stddev_order_by {
  amount: order_by
}

"""aggregate stddev_pop on columns"""
type payments_stddev_pop_fields {
  amount: Float
}

"""
order by stddev_pop() on columns of table "payments"
"""
input payments_stddev_pop_order_by {
  amount: order_by
}

"""aggregate stddev_samp on columns"""
type payments_stddev_samp_fields {
  amount: Float
}

"""
order by stddev_samp() on columns of table "payments"
"""
input payments_stddev_samp_order_by {
  amount: order_by
}

"""
Streaming cursor of the table "payments"
"""
input payments_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: payments_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input payments_stream_cursor_value_input {
  amount: numeric
  booking_id: uuid
  completed_at: timestamptz
  created_at: timestamptz
  currency: String
  description: String
  error_code: String
  failure_reason: String
  id: uuid
  metadata: jsonb
  payment_method: String
  payment_type: String
  processed_at: timestamptz
  receipt_url: String
  reference_number: String
  status: String
  stripe_charge_id: String
  stripe_payment_intent_id: String
  subscription_id: uuid
  transaction_id: String
  user_id: uuid
}

"""aggregate sum on columns"""
type payments_sum_fields {
  amount: numeric
}

"""
order by sum() on columns of table "payments"
"""
input payments_sum_order_by {
  amount: order_by
}

"""
update columns of table "payments"
"""
enum payments_update_column {
  """column name"""
  amount

  """column name"""
  booking_id

  """column name"""
  completed_at

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  description

  """column name"""
  error_code

  """column name"""
  failure_reason

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  payment_method

  """column name"""
  payment_type

  """column name"""
  processed_at

  """column name"""
  receipt_url

  """column name"""
  reference_number

  """column name"""
  status

  """column name"""
  stripe_charge_id

  """column name"""
  stripe_payment_intent_id

  """column name"""
  subscription_id

  """column name"""
  transaction_id

  """column name"""
  user_id
}

input payments_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: payments_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: payments_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: payments_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: payments_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: payments_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: payments_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: payments_set_input

  """filter the rows which have to be updated"""
  where: payments_bool_exp!
}

"""aggregate var_pop on columns"""
type payments_var_pop_fields {
  amount: Float
}

"""
order by var_pop() on columns of table "payments"
"""
input payments_var_pop_order_by {
  amount: order_by
}

"""aggregate var_samp on columns"""
type payments_var_samp_fields {
  amount: Float
}

"""
order by var_samp() on columns of table "payments"
"""
input payments_var_samp_order_by {
  amount: order_by
}

"""aggregate variance on columns"""
type payments_variance_fields {
  amount: Float
}

"""
order by variance() on columns of table "payments"
"""
input payments_variance_order_by {
  amount: order_by
}

"""Bank accounts and payment methods for receiving payouts"""
type payout_accounts {
  account_holder_name: String!
  account_number_last4: String
  account_type: String!
  agency_id: uuid!
  bank_code: String
  bank_name: String
  country: String
  created_at: timestamptz
  currency: String
  email: String
  id: uuid!
  is_default: Boolean
  is_verified: Boolean
  last_used_at: timestamptz
  max_payout_amount: numeric
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  min_payout_amount: numeric

  """An array relationship"""
  payout_schedules(
    """distinct select on columns"""
    distinct_on: [payout_schedules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payout_schedules_order_by!]

    """filter the rows returned"""
    where: payout_schedules_bool_exp
  ): [payout_schedules!]!

  """An aggregate relationship"""
  payout_schedules_aggregate(
    """distinct select on columns"""
    distinct_on: [payout_schedules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payout_schedules_order_by!]

    """filter the rows returned"""
    where: payout_schedules_bool_exp
  ): payout_schedules_aggregate!
  phone_number: String
  provider_account_id: String
  status: String
  stripe_account_id: String
  updated_at: timestamptz

  """An object relationship"""
  user: auth_users!
  verification_status: String
  verified_at: timestamptz
}

"""
aggregated selection of "payout_accounts"
"""
type payout_accounts_aggregate {
  aggregate: payout_accounts_aggregate_fields
  nodes: [payout_accounts!]!
}

"""
aggregate fields of "payout_accounts"
"""
type payout_accounts_aggregate_fields {
  avg: payout_accounts_avg_fields
  count(columns: [payout_accounts_select_column!], distinct: Boolean): Int!
  max: payout_accounts_max_fields
  min: payout_accounts_min_fields
  stddev: payout_accounts_stddev_fields
  stddev_pop: payout_accounts_stddev_pop_fields
  stddev_samp: payout_accounts_stddev_samp_fields
  sum: payout_accounts_sum_fields
  var_pop: payout_accounts_var_pop_fields
  var_samp: payout_accounts_var_samp_fields
  variance: payout_accounts_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input payout_accounts_append_input {
  metadata: jsonb
}

"""aggregate avg on columns"""
type payout_accounts_avg_fields {
  max_payout_amount: Float
  min_payout_amount: Float
}

"""
Boolean expression to filter rows from the table "payout_accounts". All fields are combined with a logical 'AND'.
"""
input payout_accounts_bool_exp {
  _and: [payout_accounts_bool_exp!]
  _not: payout_accounts_bool_exp
  _or: [payout_accounts_bool_exp!]
  account_holder_name: String_comparison_exp
  account_number_last4: String_comparison_exp
  account_type: String_comparison_exp
  agency_id: uuid_comparison_exp
  bank_code: String_comparison_exp
  bank_name: String_comparison_exp
  country: String_comparison_exp
  created_at: timestamptz_comparison_exp
  currency: String_comparison_exp
  email: String_comparison_exp
  id: uuid_comparison_exp
  is_default: Boolean_comparison_exp
  is_verified: Boolean_comparison_exp
  last_used_at: timestamptz_comparison_exp
  max_payout_amount: numeric_comparison_exp
  metadata: jsonb_comparison_exp
  min_payout_amount: numeric_comparison_exp
  payout_schedules: payout_schedules_bool_exp
  payout_schedules_aggregate: payout_schedules_aggregate_bool_exp
  phone_number: String_comparison_exp
  provider_account_id: String_comparison_exp
  status: String_comparison_exp
  stripe_account_id: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
  verification_status: String_comparison_exp
  verified_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "payout_accounts"
"""
enum payout_accounts_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  payout_accounts_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input payout_accounts_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input payout_accounts_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input payout_accounts_delete_key_input {
  metadata: String
}

"""
input type for incrementing numeric columns in table "payout_accounts"
"""
input payout_accounts_inc_input {
  max_payout_amount: numeric
  min_payout_amount: numeric
}

"""
input type for inserting data into table "payout_accounts"
"""
input payout_accounts_insert_input {
  account_holder_name: String
  account_number_last4: String
  account_type: String
  agency_id: uuid
  bank_code: String
  bank_name: String
  country: String
  created_at: timestamptz
  currency: String
  email: String
  id: uuid
  is_default: Boolean
  is_verified: Boolean
  last_used_at: timestamptz
  max_payout_amount: numeric
  metadata: jsonb
  min_payout_amount: numeric
  payout_schedules: payout_schedules_arr_rel_insert_input
  phone_number: String
  provider_account_id: String
  status: String
  stripe_account_id: String
  updated_at: timestamptz
  user: auth_users_obj_rel_insert_input
  verification_status: String
  verified_at: timestamptz
}

"""aggregate max on columns"""
type payout_accounts_max_fields {
  account_holder_name: String
  account_number_last4: String
  account_type: String
  agency_id: uuid
  bank_code: String
  bank_name: String
  country: String
  created_at: timestamptz
  currency: String
  email: String
  id: uuid
  last_used_at: timestamptz
  max_payout_amount: numeric
  min_payout_amount: numeric
  phone_number: String
  provider_account_id: String
  status: String
  stripe_account_id: String
  updated_at: timestamptz
  verification_status: String
  verified_at: timestamptz
}

"""aggregate min on columns"""
type payout_accounts_min_fields {
  account_holder_name: String
  account_number_last4: String
  account_type: String
  agency_id: uuid
  bank_code: String
  bank_name: String
  country: String
  created_at: timestamptz
  currency: String
  email: String
  id: uuid
  last_used_at: timestamptz
  max_payout_amount: numeric
  min_payout_amount: numeric
  phone_number: String
  provider_account_id: String
  status: String
  stripe_account_id: String
  updated_at: timestamptz
  verification_status: String
  verified_at: timestamptz
}

"""
response of any mutation on the table "payout_accounts"
"""
type payout_accounts_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payout_accounts!]!
}

"""
input type for inserting object relation for remote table "payout_accounts"
"""
input payout_accounts_obj_rel_insert_input {
  data: payout_accounts_insert_input!

  """upsert condition"""
  on_conflict: payout_accounts_on_conflict
}

"""
on_conflict condition type for table "payout_accounts"
"""
input payout_accounts_on_conflict {
  constraint: payout_accounts_constraint!
  update_columns: [payout_accounts_update_column!]! = []
  where: payout_accounts_bool_exp
}

"""Ordering options when selecting data from "payout_accounts"."""
input payout_accounts_order_by {
  account_holder_name: order_by
  account_number_last4: order_by
  account_type: order_by
  agency_id: order_by
  bank_code: order_by
  bank_name: order_by
  country: order_by
  created_at: order_by
  currency: order_by
  email: order_by
  id: order_by
  is_default: order_by
  is_verified: order_by
  last_used_at: order_by
  max_payout_amount: order_by
  metadata: order_by
  min_payout_amount: order_by
  payout_schedules_aggregate: payout_schedules_aggregate_order_by
  phone_number: order_by
  provider_account_id: order_by
  status: order_by
  stripe_account_id: order_by
  updated_at: order_by
  user: auth_users_order_by
  verification_status: order_by
  verified_at: order_by
}

"""primary key columns input for table: payout_accounts"""
input payout_accounts_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input payout_accounts_prepend_input {
  metadata: jsonb
}

"""
select columns of table "payout_accounts"
"""
enum payout_accounts_select_column {
  """column name"""
  account_holder_name

  """column name"""
  account_number_last4

  """column name"""
  account_type

  """column name"""
  agency_id

  """column name"""
  bank_code

  """column name"""
  bank_name

  """column name"""
  country

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  email

  """column name"""
  id

  """column name"""
  is_default

  """column name"""
  is_verified

  """column name"""
  last_used_at

  """column name"""
  max_payout_amount

  """column name"""
  metadata

  """column name"""
  min_payout_amount

  """column name"""
  phone_number

  """column name"""
  provider_account_id

  """column name"""
  status

  """column name"""
  stripe_account_id

  """column name"""
  updated_at

  """column name"""
  verification_status

  """column name"""
  verified_at
}

"""
input type for updating data in table "payout_accounts"
"""
input payout_accounts_set_input {
  account_holder_name: String
  account_number_last4: String
  account_type: String
  agency_id: uuid
  bank_code: String
  bank_name: String
  country: String
  created_at: timestamptz
  currency: String
  email: String
  id: uuid
  is_default: Boolean
  is_verified: Boolean
  last_used_at: timestamptz
  max_payout_amount: numeric
  metadata: jsonb
  min_payout_amount: numeric
  phone_number: String
  provider_account_id: String
  status: String
  stripe_account_id: String
  updated_at: timestamptz
  verification_status: String
  verified_at: timestamptz
}

"""aggregate stddev on columns"""
type payout_accounts_stddev_fields {
  max_payout_amount: Float
  min_payout_amount: Float
}

"""aggregate stddev_pop on columns"""
type payout_accounts_stddev_pop_fields {
  max_payout_amount: Float
  min_payout_amount: Float
}

"""aggregate stddev_samp on columns"""
type payout_accounts_stddev_samp_fields {
  max_payout_amount: Float
  min_payout_amount: Float
}

"""
Streaming cursor of the table "payout_accounts"
"""
input payout_accounts_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: payout_accounts_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input payout_accounts_stream_cursor_value_input {
  account_holder_name: String
  account_number_last4: String
  account_type: String
  agency_id: uuid
  bank_code: String
  bank_name: String
  country: String
  created_at: timestamptz
  currency: String
  email: String
  id: uuid
  is_default: Boolean
  is_verified: Boolean
  last_used_at: timestamptz
  max_payout_amount: numeric
  metadata: jsonb
  min_payout_amount: numeric
  phone_number: String
  provider_account_id: String
  status: String
  stripe_account_id: String
  updated_at: timestamptz
  verification_status: String
  verified_at: timestamptz
}

"""aggregate sum on columns"""
type payout_accounts_sum_fields {
  max_payout_amount: numeric
  min_payout_amount: numeric
}

"""
update columns of table "payout_accounts"
"""
enum payout_accounts_update_column {
  """column name"""
  account_holder_name

  """column name"""
  account_number_last4

  """column name"""
  account_type

  """column name"""
  agency_id

  """column name"""
  bank_code

  """column name"""
  bank_name

  """column name"""
  country

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  email

  """column name"""
  id

  """column name"""
  is_default

  """column name"""
  is_verified

  """column name"""
  last_used_at

  """column name"""
  max_payout_amount

  """column name"""
  metadata

  """column name"""
  min_payout_amount

  """column name"""
  phone_number

  """column name"""
  provider_account_id

  """column name"""
  status

  """column name"""
  stripe_account_id

  """column name"""
  updated_at

  """column name"""
  verification_status

  """column name"""
  verified_at
}

input payout_accounts_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: payout_accounts_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: payout_accounts_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: payout_accounts_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: payout_accounts_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: payout_accounts_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: payout_accounts_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: payout_accounts_set_input

  """filter the rows which have to be updated"""
  where: payout_accounts_bool_exp!
}

"""aggregate var_pop on columns"""
type payout_accounts_var_pop_fields {
  max_payout_amount: Float
  min_payout_amount: Float
}

"""aggregate var_samp on columns"""
type payout_accounts_var_samp_fields {
  max_payout_amount: Float
  min_payout_amount: Float
}

"""aggregate variance on columns"""
type payout_accounts_variance_fields {
  max_payout_amount: Float
  min_payout_amount: Float
}

"""Automated payout schedule configuration"""
type payout_schedules {
  agency_id: uuid!
  created_at: timestamptz
  day_of_month: Int
  day_of_week: Int
  frequency: String!
  id: uuid!
  is_active: Boolean
  last_payout_date: date
  minimum_amount: numeric
  next_payout_date: date
  paused_at: timestamptz
  paused_reason: String

  """An object relationship"""
  payout_account: payout_accounts
  payout_account_id: uuid
  updated_at: timestamptz

  """An object relationship"""
  user: auth_users!
}

"""
aggregated selection of "payout_schedules"
"""
type payout_schedules_aggregate {
  aggregate: payout_schedules_aggregate_fields
  nodes: [payout_schedules!]!
}

input payout_schedules_aggregate_bool_exp {
  bool_and: payout_schedules_aggregate_bool_exp_bool_and
  bool_or: payout_schedules_aggregate_bool_exp_bool_or
  count: payout_schedules_aggregate_bool_exp_count
}

input payout_schedules_aggregate_bool_exp_bool_and {
  arguments: payout_schedules_select_column_payout_schedules_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: payout_schedules_bool_exp
  predicate: Boolean_comparison_exp!
}

input payout_schedules_aggregate_bool_exp_bool_or {
  arguments: payout_schedules_select_column_payout_schedules_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: payout_schedules_bool_exp
  predicate: Boolean_comparison_exp!
}

input payout_schedules_aggregate_bool_exp_count {
  arguments: [payout_schedules_select_column!]
  distinct: Boolean
  filter: payout_schedules_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "payout_schedules"
"""
type payout_schedules_aggregate_fields {
  avg: payout_schedules_avg_fields
  count(columns: [payout_schedules_select_column!], distinct: Boolean): Int!
  max: payout_schedules_max_fields
  min: payout_schedules_min_fields
  stddev: payout_schedules_stddev_fields
  stddev_pop: payout_schedules_stddev_pop_fields
  stddev_samp: payout_schedules_stddev_samp_fields
  sum: payout_schedules_sum_fields
  var_pop: payout_schedules_var_pop_fields
  var_samp: payout_schedules_var_samp_fields
  variance: payout_schedules_variance_fields
}

"""
order by aggregate values of table "payout_schedules"
"""
input payout_schedules_aggregate_order_by {
  avg: payout_schedules_avg_order_by
  count: order_by
  max: payout_schedules_max_order_by
  min: payout_schedules_min_order_by
  stddev: payout_schedules_stddev_order_by
  stddev_pop: payout_schedules_stddev_pop_order_by
  stddev_samp: payout_schedules_stddev_samp_order_by
  sum: payout_schedules_sum_order_by
  var_pop: payout_schedules_var_pop_order_by
  var_samp: payout_schedules_var_samp_order_by
  variance: payout_schedules_variance_order_by
}

"""
input type for inserting array relation for remote table "payout_schedules"
"""
input payout_schedules_arr_rel_insert_input {
  data: [payout_schedules_insert_input!]!

  """upsert condition"""
  on_conflict: payout_schedules_on_conflict
}

"""aggregate avg on columns"""
type payout_schedules_avg_fields {
  day_of_month: Float
  day_of_week: Float
  minimum_amount: Float
}

"""
order by avg() on columns of table "payout_schedules"
"""
input payout_schedules_avg_order_by {
  day_of_month: order_by
  day_of_week: order_by
  minimum_amount: order_by
}

"""
Boolean expression to filter rows from the table "payout_schedules". All fields are combined with a logical 'AND'.
"""
input payout_schedules_bool_exp {
  _and: [payout_schedules_bool_exp!]
  _not: payout_schedules_bool_exp
  _or: [payout_schedules_bool_exp!]
  agency_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  day_of_month: Int_comparison_exp
  day_of_week: Int_comparison_exp
  frequency: String_comparison_exp
  id: uuid_comparison_exp
  is_active: Boolean_comparison_exp
  last_payout_date: date_comparison_exp
  minimum_amount: numeric_comparison_exp
  next_payout_date: date_comparison_exp
  paused_at: timestamptz_comparison_exp
  paused_reason: String_comparison_exp
  payout_account: payout_accounts_bool_exp
  payout_account_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
}

"""
unique or primary key constraints on table "payout_schedules"
"""
enum payout_schedules_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  payout_schedules_pkey
}

"""
input type for incrementing numeric columns in table "payout_schedules"
"""
input payout_schedules_inc_input {
  day_of_month: Int
  day_of_week: Int
  minimum_amount: numeric
}

"""
input type for inserting data into table "payout_schedules"
"""
input payout_schedules_insert_input {
  agency_id: uuid
  created_at: timestamptz
  day_of_month: Int
  day_of_week: Int
  frequency: String
  id: uuid
  is_active: Boolean
  last_payout_date: date
  minimum_amount: numeric
  next_payout_date: date
  paused_at: timestamptz
  paused_reason: String
  payout_account: payout_accounts_obj_rel_insert_input
  payout_account_id: uuid
  updated_at: timestamptz
  user: auth_users_obj_rel_insert_input
}

"""aggregate max on columns"""
type payout_schedules_max_fields {
  agency_id: uuid
  created_at: timestamptz
  day_of_month: Int
  day_of_week: Int
  frequency: String
  id: uuid
  last_payout_date: date
  minimum_amount: numeric
  next_payout_date: date
  paused_at: timestamptz
  paused_reason: String
  payout_account_id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "payout_schedules"
"""
input payout_schedules_max_order_by {
  agency_id: order_by
  created_at: order_by
  day_of_month: order_by
  day_of_week: order_by
  frequency: order_by
  id: order_by
  last_payout_date: order_by
  minimum_amount: order_by
  next_payout_date: order_by
  paused_at: order_by
  paused_reason: order_by
  payout_account_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type payout_schedules_min_fields {
  agency_id: uuid
  created_at: timestamptz
  day_of_month: Int
  day_of_week: Int
  frequency: String
  id: uuid
  last_payout_date: date
  minimum_amount: numeric
  next_payout_date: date
  paused_at: timestamptz
  paused_reason: String
  payout_account_id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "payout_schedules"
"""
input payout_schedules_min_order_by {
  agency_id: order_by
  created_at: order_by
  day_of_month: order_by
  day_of_week: order_by
  frequency: order_by
  id: order_by
  last_payout_date: order_by
  minimum_amount: order_by
  next_payout_date: order_by
  paused_at: order_by
  paused_reason: order_by
  payout_account_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "payout_schedules"
"""
type payout_schedules_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payout_schedules!]!
}

"""
on_conflict condition type for table "payout_schedules"
"""
input payout_schedules_on_conflict {
  constraint: payout_schedules_constraint!
  update_columns: [payout_schedules_update_column!]! = []
  where: payout_schedules_bool_exp
}

"""Ordering options when selecting data from "payout_schedules"."""
input payout_schedules_order_by {
  agency_id: order_by
  created_at: order_by
  day_of_month: order_by
  day_of_week: order_by
  frequency: order_by
  id: order_by
  is_active: order_by
  last_payout_date: order_by
  minimum_amount: order_by
  next_payout_date: order_by
  paused_at: order_by
  paused_reason: order_by
  payout_account: payout_accounts_order_by
  payout_account_id: order_by
  updated_at: order_by
  user: auth_users_order_by
}

"""primary key columns input for table: payout_schedules"""
input payout_schedules_pk_columns_input {
  id: uuid!
}

"""
select columns of table "payout_schedules"
"""
enum payout_schedules_select_column {
  """column name"""
  agency_id

  """column name"""
  created_at

  """column name"""
  day_of_month

  """column name"""
  day_of_week

  """column name"""
  frequency

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  last_payout_date

  """column name"""
  minimum_amount

  """column name"""
  next_payout_date

  """column name"""
  paused_at

  """column name"""
  paused_reason

  """column name"""
  payout_account_id

  """column name"""
  updated_at
}

"""
select "payout_schedules_aggregate_bool_exp_bool_and_arguments_columns" columns of table "payout_schedules"
"""
enum payout_schedules_select_column_payout_schedules_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_active
}

"""
select "payout_schedules_aggregate_bool_exp_bool_or_arguments_columns" columns of table "payout_schedules"
"""
enum payout_schedules_select_column_payout_schedules_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_active
}

"""
input type for updating data in table "payout_schedules"
"""
input payout_schedules_set_input {
  agency_id: uuid
  created_at: timestamptz
  day_of_month: Int
  day_of_week: Int
  frequency: String
  id: uuid
  is_active: Boolean
  last_payout_date: date
  minimum_amount: numeric
  next_payout_date: date
  paused_at: timestamptz
  paused_reason: String
  payout_account_id: uuid
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type payout_schedules_stddev_fields {
  day_of_month: Float
  day_of_week: Float
  minimum_amount: Float
}

"""
order by stddev() on columns of table "payout_schedules"
"""
input payout_schedules_stddev_order_by {
  day_of_month: order_by
  day_of_week: order_by
  minimum_amount: order_by
}

"""aggregate stddev_pop on columns"""
type payout_schedules_stddev_pop_fields {
  day_of_month: Float
  day_of_week: Float
  minimum_amount: Float
}

"""
order by stddev_pop() on columns of table "payout_schedules"
"""
input payout_schedules_stddev_pop_order_by {
  day_of_month: order_by
  day_of_week: order_by
  minimum_amount: order_by
}

"""aggregate stddev_samp on columns"""
type payout_schedules_stddev_samp_fields {
  day_of_month: Float
  day_of_week: Float
  minimum_amount: Float
}

"""
order by stddev_samp() on columns of table "payout_schedules"
"""
input payout_schedules_stddev_samp_order_by {
  day_of_month: order_by
  day_of_week: order_by
  minimum_amount: order_by
}

"""
Streaming cursor of the table "payout_schedules"
"""
input payout_schedules_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: payout_schedules_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input payout_schedules_stream_cursor_value_input {
  agency_id: uuid
  created_at: timestamptz
  day_of_month: Int
  day_of_week: Int
  frequency: String
  id: uuid
  is_active: Boolean
  last_payout_date: date
  minimum_amount: numeric
  next_payout_date: date
  paused_at: timestamptz
  paused_reason: String
  payout_account_id: uuid
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type payout_schedules_sum_fields {
  day_of_month: Int
  day_of_week: Int
  minimum_amount: numeric
}

"""
order by sum() on columns of table "payout_schedules"
"""
input payout_schedules_sum_order_by {
  day_of_month: order_by
  day_of_week: order_by
  minimum_amount: order_by
}

"""
update columns of table "payout_schedules"
"""
enum payout_schedules_update_column {
  """column name"""
  agency_id

  """column name"""
  created_at

  """column name"""
  day_of_month

  """column name"""
  day_of_week

  """column name"""
  frequency

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  last_payout_date

  """column name"""
  minimum_amount

  """column name"""
  next_payout_date

  """column name"""
  paused_at

  """column name"""
  paused_reason

  """column name"""
  payout_account_id

  """column name"""
  updated_at
}

input payout_schedules_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: payout_schedules_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: payout_schedules_set_input

  """filter the rows which have to be updated"""
  where: payout_schedules_bool_exp!
}

"""aggregate var_pop on columns"""
type payout_schedules_var_pop_fields {
  day_of_month: Float
  day_of_week: Float
  minimum_amount: Float
}

"""
order by var_pop() on columns of table "payout_schedules"
"""
input payout_schedules_var_pop_order_by {
  day_of_month: order_by
  day_of_week: order_by
  minimum_amount: order_by
}

"""aggregate var_samp on columns"""
type payout_schedules_var_samp_fields {
  day_of_month: Float
  day_of_week: Float
  minimum_amount: Float
}

"""
order by var_samp() on columns of table "payout_schedules"
"""
input payout_schedules_var_samp_order_by {
  day_of_month: order_by
  day_of_week: order_by
  minimum_amount: order_by
}

"""aggregate variance on columns"""
type payout_schedules_variance_fields {
  day_of_month: Float
  day_of_week: Float
  minimum_amount: Float
}

"""
order by variance() on columns of table "payout_schedules"
"""
input payout_schedules_variance_order_by {
  day_of_month: order_by
  day_of_week: order_by
  minimum_amount: order_by
}

"""Audit log for all phone verification attempts"""
type phone_verification_log {
  attempt_type: String!
  created_at: timestamptz
  error_message: String
  id: uuid!
  ip_address: inet
  phone_number: String!
  success: Boolean

  """An object relationship"""
  user: auth_users
  user_agent: String
  user_id: uuid
  verification_code_hash: String
}

"""
aggregated selection of "phone_verification_log"
"""
type phone_verification_log_aggregate {
  aggregate: phone_verification_log_aggregate_fields
  nodes: [phone_verification_log!]!
}

"""
aggregate fields of "phone_verification_log"
"""
type phone_verification_log_aggregate_fields {
  count(columns: [phone_verification_log_select_column!], distinct: Boolean): Int!
  max: phone_verification_log_max_fields
  min: phone_verification_log_min_fields
}

"""
Boolean expression to filter rows from the table "phone_verification_log". All fields are combined with a logical 'AND'.
"""
input phone_verification_log_bool_exp {
  _and: [phone_verification_log_bool_exp!]
  _not: phone_verification_log_bool_exp
  _or: [phone_verification_log_bool_exp!]
  attempt_type: String_comparison_exp
  created_at: timestamptz_comparison_exp
  error_message: String_comparison_exp
  id: uuid_comparison_exp
  ip_address: inet_comparison_exp
  phone_number: String_comparison_exp
  success: Boolean_comparison_exp
  user: auth_users_bool_exp
  user_agent: String_comparison_exp
  user_id: uuid_comparison_exp
  verification_code_hash: String_comparison_exp
}

"""
unique or primary key constraints on table "phone_verification_log"
"""
enum phone_verification_log_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  phone_verification_log_pkey
}

"""
input type for inserting data into table "phone_verification_log"
"""
input phone_verification_log_insert_input {
  attempt_type: String
  created_at: timestamptz
  error_message: String
  id: uuid
  ip_address: inet
  phone_number: String
  success: Boolean
  user: auth_users_obj_rel_insert_input
  user_agent: String
  user_id: uuid
  verification_code_hash: String
}

"""aggregate max on columns"""
type phone_verification_log_max_fields {
  attempt_type: String
  created_at: timestamptz
  error_message: String
  id: uuid
  phone_number: String
  user_agent: String
  user_id: uuid
  verification_code_hash: String
}

"""aggregate min on columns"""
type phone_verification_log_min_fields {
  attempt_type: String
  created_at: timestamptz
  error_message: String
  id: uuid
  phone_number: String
  user_agent: String
  user_id: uuid
  verification_code_hash: String
}

"""
response of any mutation on the table "phone_verification_log"
"""
type phone_verification_log_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [phone_verification_log!]!
}

"""
on_conflict condition type for table "phone_verification_log"
"""
input phone_verification_log_on_conflict {
  constraint: phone_verification_log_constraint!
  update_columns: [phone_verification_log_update_column!]! = []
  where: phone_verification_log_bool_exp
}

"""Ordering options when selecting data from "phone_verification_log"."""
input phone_verification_log_order_by {
  attempt_type: order_by
  created_at: order_by
  error_message: order_by
  id: order_by
  ip_address: order_by
  phone_number: order_by
  success: order_by
  user: auth_users_order_by
  user_agent: order_by
  user_id: order_by
  verification_code_hash: order_by
}

"""primary key columns input for table: phone_verification_log"""
input phone_verification_log_pk_columns_input {
  id: uuid!
}

"""
select columns of table "phone_verification_log"
"""
enum phone_verification_log_select_column {
  """column name"""
  attempt_type

  """column name"""
  created_at

  """column name"""
  error_message

  """column name"""
  id

  """column name"""
  ip_address

  """column name"""
  phone_number

  """column name"""
  success

  """column name"""
  user_agent

  """column name"""
  user_id

  """column name"""
  verification_code_hash
}

"""
input type for updating data in table "phone_verification_log"
"""
input phone_verification_log_set_input {
  attempt_type: String
  created_at: timestamptz
  error_message: String
  id: uuid
  ip_address: inet
  phone_number: String
  success: Boolean
  user_agent: String
  user_id: uuid
  verification_code_hash: String
}

"""
Streaming cursor of the table "phone_verification_log"
"""
input phone_verification_log_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: phone_verification_log_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input phone_verification_log_stream_cursor_value_input {
  attempt_type: String
  created_at: timestamptz
  error_message: String
  id: uuid
  ip_address: inet
  phone_number: String
  success: Boolean
  user_agent: String
  user_id: uuid
  verification_code_hash: String
}

"""
update columns of table "phone_verification_log"
"""
enum phone_verification_log_update_column {
  """column name"""
  attempt_type

  """column name"""
  created_at

  """column name"""
  error_message

  """column name"""
  id

  """column name"""
  ip_address

  """column name"""
  phone_number

  """column name"""
  success

  """column name"""
  user_agent

  """column name"""
  user_id

  """column name"""
  verification_code_hash
}

input phone_verification_log_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: phone_verification_log_set_input

  """filter the rows which have to be updated"""
  where: phone_verification_log_bool_exp!
}

"""Stores phone verification codes securely on the server-side"""
type phone_verifications {
  """Number of failed verification attempts (max 3)"""
  attempts: Int!

  """6-digit verification code"""
  code: String!
  created_at: timestamptz!

  """Expiry timestamp (10 minutes from creation)"""
  expires_at: timestamptz!
  id: uuid!

  """Phone number in E.164 format"""
  phone: String!
  updated_at: timestamptz!

  """Whether the code has been successfully verified"""
  verified: Boolean!

  """Timestamp when verification succeeded"""
  verified_at: timestamptz
}

"""
aggregated selection of "phone_verifications"
"""
type phone_verifications_aggregate {
  aggregate: phone_verifications_aggregate_fields
  nodes: [phone_verifications!]!
}

"""
aggregate fields of "phone_verifications"
"""
type phone_verifications_aggregate_fields {
  avg: phone_verifications_avg_fields
  count(columns: [phone_verifications_select_column!], distinct: Boolean): Int!
  max: phone_verifications_max_fields
  min: phone_verifications_min_fields
  stddev: phone_verifications_stddev_fields
  stddev_pop: phone_verifications_stddev_pop_fields
  stddev_samp: phone_verifications_stddev_samp_fields
  sum: phone_verifications_sum_fields
  var_pop: phone_verifications_var_pop_fields
  var_samp: phone_verifications_var_samp_fields
  variance: phone_verifications_variance_fields
}

"""aggregate avg on columns"""
type phone_verifications_avg_fields {
  """Number of failed verification attempts (max 3)"""
  attempts: Float
}

"""
Boolean expression to filter rows from the table "phone_verifications". All fields are combined with a logical 'AND'.
"""
input phone_verifications_bool_exp {
  _and: [phone_verifications_bool_exp!]
  _not: phone_verifications_bool_exp
  _or: [phone_verifications_bool_exp!]
  attempts: Int_comparison_exp
  code: String_comparison_exp
  created_at: timestamptz_comparison_exp
  expires_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  phone: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  verified: Boolean_comparison_exp
  verified_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "phone_verifications"
"""
enum phone_verifications_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  phone_verifications_pkey
}

"""
input type for incrementing numeric columns in table "phone_verifications"
"""
input phone_verifications_inc_input {
  """Number of failed verification attempts (max 3)"""
  attempts: Int
}

"""
input type for inserting data into table "phone_verifications"
"""
input phone_verifications_insert_input {
  """Number of failed verification attempts (max 3)"""
  attempts: Int

  """6-digit verification code"""
  code: String
  created_at: timestamptz

  """Expiry timestamp (10 minutes from creation)"""
  expires_at: timestamptz
  id: uuid

  """Phone number in E.164 format"""
  phone: String
  updated_at: timestamptz

  """Whether the code has been successfully verified"""
  verified: Boolean

  """Timestamp when verification succeeded"""
  verified_at: timestamptz
}

"""aggregate max on columns"""
type phone_verifications_max_fields {
  """Number of failed verification attempts (max 3)"""
  attempts: Int

  """6-digit verification code"""
  code: String
  created_at: timestamptz

  """Expiry timestamp (10 minutes from creation)"""
  expires_at: timestamptz
  id: uuid

  """Phone number in E.164 format"""
  phone: String
  updated_at: timestamptz

  """Timestamp when verification succeeded"""
  verified_at: timestamptz
}

"""aggregate min on columns"""
type phone_verifications_min_fields {
  """Number of failed verification attempts (max 3)"""
  attempts: Int

  """6-digit verification code"""
  code: String
  created_at: timestamptz

  """Expiry timestamp (10 minutes from creation)"""
  expires_at: timestamptz
  id: uuid

  """Phone number in E.164 format"""
  phone: String
  updated_at: timestamptz

  """Timestamp when verification succeeded"""
  verified_at: timestamptz
}

"""
response of any mutation on the table "phone_verifications"
"""
type phone_verifications_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [phone_verifications!]!
}

"""
on_conflict condition type for table "phone_verifications"
"""
input phone_verifications_on_conflict {
  constraint: phone_verifications_constraint!
  update_columns: [phone_verifications_update_column!]! = []
  where: phone_verifications_bool_exp
}

"""Ordering options when selecting data from "phone_verifications"."""
input phone_verifications_order_by {
  attempts: order_by
  code: order_by
  created_at: order_by
  expires_at: order_by
  id: order_by
  phone: order_by
  updated_at: order_by
  verified: order_by
  verified_at: order_by
}

"""primary key columns input for table: phone_verifications"""
input phone_verifications_pk_columns_input {
  id: uuid!
}

"""
select columns of table "phone_verifications"
"""
enum phone_verifications_select_column {
  """column name"""
  attempts

  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  expires_at

  """column name"""
  id

  """column name"""
  phone

  """column name"""
  updated_at

  """column name"""
  verified

  """column name"""
  verified_at
}

"""
input type for updating data in table "phone_verifications"
"""
input phone_verifications_set_input {
  """Number of failed verification attempts (max 3)"""
  attempts: Int

  """6-digit verification code"""
  code: String
  created_at: timestamptz

  """Expiry timestamp (10 minutes from creation)"""
  expires_at: timestamptz
  id: uuid

  """Phone number in E.164 format"""
  phone: String
  updated_at: timestamptz

  """Whether the code has been successfully verified"""
  verified: Boolean

  """Timestamp when verification succeeded"""
  verified_at: timestamptz
}

"""aggregate stddev on columns"""
type phone_verifications_stddev_fields {
  """Number of failed verification attempts (max 3)"""
  attempts: Float
}

"""aggregate stddev_pop on columns"""
type phone_verifications_stddev_pop_fields {
  """Number of failed verification attempts (max 3)"""
  attempts: Float
}

"""aggregate stddev_samp on columns"""
type phone_verifications_stddev_samp_fields {
  """Number of failed verification attempts (max 3)"""
  attempts: Float
}

"""
Streaming cursor of the table "phone_verifications"
"""
input phone_verifications_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: phone_verifications_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input phone_verifications_stream_cursor_value_input {
  """Number of failed verification attempts (max 3)"""
  attempts: Int

  """6-digit verification code"""
  code: String
  created_at: timestamptz

  """Expiry timestamp (10 minutes from creation)"""
  expires_at: timestamptz
  id: uuid

  """Phone number in E.164 format"""
  phone: String
  updated_at: timestamptz

  """Whether the code has been successfully verified"""
  verified: Boolean

  """Timestamp when verification succeeded"""
  verified_at: timestamptz
}

"""aggregate sum on columns"""
type phone_verifications_sum_fields {
  """Number of failed verification attempts (max 3)"""
  attempts: Int
}

"""
update columns of table "phone_verifications"
"""
enum phone_verifications_update_column {
  """column name"""
  attempts

  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  expires_at

  """column name"""
  id

  """column name"""
  phone

  """column name"""
  updated_at

  """column name"""
  verified

  """column name"""
  verified_at
}

input phone_verifications_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: phone_verifications_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: phone_verifications_set_input

  """filter the rows which have to be updated"""
  where: phone_verifications_bool_exp!
}

"""aggregate var_pop on columns"""
type phone_verifications_var_pop_fields {
  """Number of failed verification attempts (max 3)"""
  attempts: Float
}

"""aggregate var_samp on columns"""
type phone_verifications_var_samp_fields {
  """Number of failed verification attempts (max 3)"""
  attempts: Float
}

"""aggregate variance on columns"""
type phone_verifications_variance_fields {
  """Number of failed verification attempts (max 3)"""
  attempts: Float
}

"""
columns and relationships of "pii_access_log"
"""
type pii_access_log {
  accessed_at: timestamptz
  field_name: String!
  id: uuid!
  ip_address: inet
  operation: String!
  record_id: uuid!
  session_id: String
  table_name: String!

  """An object relationship"""
  user: auth_users
  user_agent: String
  user_id: uuid
}

"""
aggregated selection of "pii_access_log"
"""
type pii_access_log_aggregate {
  aggregate: pii_access_log_aggregate_fields
  nodes: [pii_access_log!]!
}

"""
aggregate fields of "pii_access_log"
"""
type pii_access_log_aggregate_fields {
  count(columns: [pii_access_log_select_column!], distinct: Boolean): Int!
  max: pii_access_log_max_fields
  min: pii_access_log_min_fields
}

"""
Boolean expression to filter rows from the table "pii_access_log". All fields are combined with a logical 'AND'.
"""
input pii_access_log_bool_exp {
  _and: [pii_access_log_bool_exp!]
  _not: pii_access_log_bool_exp
  _or: [pii_access_log_bool_exp!]
  accessed_at: timestamptz_comparison_exp
  field_name: String_comparison_exp
  id: uuid_comparison_exp
  ip_address: inet_comparison_exp
  operation: String_comparison_exp
  record_id: uuid_comparison_exp
  session_id: String_comparison_exp
  table_name: String_comparison_exp
  user: auth_users_bool_exp
  user_agent: String_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "pii_access_log"
"""
enum pii_access_log_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  pii_access_log_pkey
}

"""
input type for inserting data into table "pii_access_log"
"""
input pii_access_log_insert_input {
  accessed_at: timestamptz
  field_name: String
  id: uuid
  ip_address: inet
  operation: String
  record_id: uuid
  session_id: String
  table_name: String
  user: auth_users_obj_rel_insert_input
  user_agent: String
  user_id: uuid
}

"""aggregate max on columns"""
type pii_access_log_max_fields {
  accessed_at: timestamptz
  field_name: String
  id: uuid
  operation: String
  record_id: uuid
  session_id: String
  table_name: String
  user_agent: String
  user_id: uuid
}

"""aggregate min on columns"""
type pii_access_log_min_fields {
  accessed_at: timestamptz
  field_name: String
  id: uuid
  operation: String
  record_id: uuid
  session_id: String
  table_name: String
  user_agent: String
  user_id: uuid
}

"""
response of any mutation on the table "pii_access_log"
"""
type pii_access_log_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [pii_access_log!]!
}

"""
on_conflict condition type for table "pii_access_log"
"""
input pii_access_log_on_conflict {
  constraint: pii_access_log_constraint!
  update_columns: [pii_access_log_update_column!]! = []
  where: pii_access_log_bool_exp
}

"""Ordering options when selecting data from "pii_access_log"."""
input pii_access_log_order_by {
  accessed_at: order_by
  field_name: order_by
  id: order_by
  ip_address: order_by
  operation: order_by
  record_id: order_by
  session_id: order_by
  table_name: order_by
  user: auth_users_order_by
  user_agent: order_by
  user_id: order_by
}

"""primary key columns input for table: pii_access_log"""
input pii_access_log_pk_columns_input {
  id: uuid!
}

"""
select columns of table "pii_access_log"
"""
enum pii_access_log_select_column {
  """column name"""
  accessed_at

  """column name"""
  field_name

  """column name"""
  id

  """column name"""
  ip_address

  """column name"""
  operation

  """column name"""
  record_id

  """column name"""
  session_id

  """column name"""
  table_name

  """column name"""
  user_agent

  """column name"""
  user_id
}

"""
input type for updating data in table "pii_access_log"
"""
input pii_access_log_set_input {
  accessed_at: timestamptz
  field_name: String
  id: uuid
  ip_address: inet
  operation: String
  record_id: uuid
  session_id: String
  table_name: String
  user_agent: String
  user_id: uuid
}

"""
Streaming cursor of the table "pii_access_log"
"""
input pii_access_log_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: pii_access_log_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input pii_access_log_stream_cursor_value_input {
  accessed_at: timestamptz
  field_name: String
  id: uuid
  ip_address: inet
  operation: String
  record_id: uuid
  session_id: String
  table_name: String
  user_agent: String
  user_id: uuid
}

"""
update columns of table "pii_access_log"
"""
enum pii_access_log_update_column {
  """column name"""
  accessed_at

  """column name"""
  field_name

  """column name"""
  id

  """column name"""
  ip_address

  """column name"""
  operation

  """column name"""
  record_id

  """column name"""
  session_id

  """column name"""
  table_name

  """column name"""
  user_agent

  """column name"""
  user_id
}

input pii_access_log_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: pii_access_log_set_input

  """filter the rows which have to be updated"""
  where: pii_access_log_bool_exp!
}

"""Visa and contract tracking for maid placements"""
type placement_contracts {
  agency_id: uuid!

  """An object relationship"""
  agency_placement: agency_placements!

  """An array relationship"""
  client_satisfaction_ratings(
    """distinct select on columns"""
    distinct_on: [client_satisfaction_ratings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_satisfaction_ratings_order_by!]

    """filter the rows returned"""
    where: client_satisfaction_ratings_bool_exp
  ): [client_satisfaction_ratings!]!

  """An aggregate relationship"""
  client_satisfaction_ratings_aggregate(
    """distinct select on columns"""
    distinct_on: [client_satisfaction_ratings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_satisfaction_ratings_order_by!]

    """filter the rows returned"""
    where: client_satisfaction_ratings_bool_exp
  ): client_satisfaction_ratings_aggregate!
  contract_duration_months: Int
  contract_end_date: date
  contract_start_date: date
  contract_status: String
  created_at: timestamptz
  destination_city: String
  destination_country: String
  destination_region: String
  fee_transaction_id: uuid
  id: uuid!
  maid_arrival_date: date
  maid_id: uuid
  maid_return_date: date
  maid_return_reason: String
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  notes: String

  """An object relationship"""
  placement_fee_transaction: placement_fee_transactions
  placement_id: uuid!
  sponsor_id: uuid
  updated_at: timestamptz

  """An object relationship"""
  user: auth_users!
  visa_application_date: date
  visa_approval_date: date
  visa_expiry_date: date
  visa_rejection_date: date
}

"""
aggregated selection of "placement_contracts"
"""
type placement_contracts_aggregate {
  aggregate: placement_contracts_aggregate_fields
  nodes: [placement_contracts!]!
}

input placement_contracts_aggregate_bool_exp {
  count: placement_contracts_aggregate_bool_exp_count
}

input placement_contracts_aggregate_bool_exp_count {
  arguments: [placement_contracts_select_column!]
  distinct: Boolean
  filter: placement_contracts_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "placement_contracts"
"""
type placement_contracts_aggregate_fields {
  avg: placement_contracts_avg_fields
  count(columns: [placement_contracts_select_column!], distinct: Boolean): Int!
  max: placement_contracts_max_fields
  min: placement_contracts_min_fields
  stddev: placement_contracts_stddev_fields
  stddev_pop: placement_contracts_stddev_pop_fields
  stddev_samp: placement_contracts_stddev_samp_fields
  sum: placement_contracts_sum_fields
  var_pop: placement_contracts_var_pop_fields
  var_samp: placement_contracts_var_samp_fields
  variance: placement_contracts_variance_fields
}

"""
order by aggregate values of table "placement_contracts"
"""
input placement_contracts_aggregate_order_by {
  avg: placement_contracts_avg_order_by
  count: order_by
  max: placement_contracts_max_order_by
  min: placement_contracts_min_order_by
  stddev: placement_contracts_stddev_order_by
  stddev_pop: placement_contracts_stddev_pop_order_by
  stddev_samp: placement_contracts_stddev_samp_order_by
  sum: placement_contracts_sum_order_by
  var_pop: placement_contracts_var_pop_order_by
  var_samp: placement_contracts_var_samp_order_by
  variance: placement_contracts_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input placement_contracts_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "placement_contracts"
"""
input placement_contracts_arr_rel_insert_input {
  data: [placement_contracts_insert_input!]!

  """upsert condition"""
  on_conflict: placement_contracts_on_conflict
}

"""aggregate avg on columns"""
type placement_contracts_avg_fields {
  contract_duration_months: Float
}

"""
order by avg() on columns of table "placement_contracts"
"""
input placement_contracts_avg_order_by {
  contract_duration_months: order_by
}

"""
Boolean expression to filter rows from the table "placement_contracts". All fields are combined with a logical 'AND'.
"""
input placement_contracts_bool_exp {
  _and: [placement_contracts_bool_exp!]
  _not: placement_contracts_bool_exp
  _or: [placement_contracts_bool_exp!]
  agency_id: uuid_comparison_exp
  agency_placement: agency_placements_bool_exp
  client_satisfaction_ratings: client_satisfaction_ratings_bool_exp
  client_satisfaction_ratings_aggregate: client_satisfaction_ratings_aggregate_bool_exp
  contract_duration_months: Int_comparison_exp
  contract_end_date: date_comparison_exp
  contract_start_date: date_comparison_exp
  contract_status: String_comparison_exp
  created_at: timestamptz_comparison_exp
  destination_city: String_comparison_exp
  destination_country: String_comparison_exp
  destination_region: String_comparison_exp
  fee_transaction_id: uuid_comparison_exp
  id: uuid_comparison_exp
  maid_arrival_date: date_comparison_exp
  maid_id: uuid_comparison_exp
  maid_return_date: date_comparison_exp
  maid_return_reason: String_comparison_exp
  metadata: jsonb_comparison_exp
  notes: String_comparison_exp
  placement_fee_transaction: placement_fee_transactions_bool_exp
  placement_id: uuid_comparison_exp
  sponsor_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
  visa_application_date: date_comparison_exp
  visa_approval_date: date_comparison_exp
  visa_expiry_date: date_comparison_exp
  visa_rejection_date: date_comparison_exp
}

"""
unique or primary key constraints on table "placement_contracts"
"""
enum placement_contracts_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  placement_contracts_pkey

  """
  unique or primary key constraint on columns "placement_id"
  """
  placement_contracts_placement_id_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input placement_contracts_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input placement_contracts_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input placement_contracts_delete_key_input {
  metadata: String
}

"""
input type for incrementing numeric columns in table "placement_contracts"
"""
input placement_contracts_inc_input {
  contract_duration_months: Int
}

"""
input type for inserting data into table "placement_contracts"
"""
input placement_contracts_insert_input {
  agency_id: uuid
  agency_placement: agency_placements_obj_rel_insert_input
  client_satisfaction_ratings: client_satisfaction_ratings_arr_rel_insert_input
  contract_duration_months: Int
  contract_end_date: date
  contract_start_date: date
  contract_status: String
  created_at: timestamptz
  destination_city: String
  destination_country: String
  destination_region: String
  fee_transaction_id: uuid
  id: uuid
  maid_arrival_date: date
  maid_id: uuid
  maid_return_date: date
  maid_return_reason: String
  metadata: jsonb
  notes: String
  placement_fee_transaction: placement_fee_transactions_obj_rel_insert_input
  placement_id: uuid
  sponsor_id: uuid
  updated_at: timestamptz
  user: auth_users_obj_rel_insert_input
  visa_application_date: date
  visa_approval_date: date
  visa_expiry_date: date
  visa_rejection_date: date
}

"""aggregate max on columns"""
type placement_contracts_max_fields {
  agency_id: uuid
  contract_duration_months: Int
  contract_end_date: date
  contract_start_date: date
  contract_status: String
  created_at: timestamptz
  destination_city: String
  destination_country: String
  destination_region: String
  fee_transaction_id: uuid
  id: uuid
  maid_arrival_date: date
  maid_id: uuid
  maid_return_date: date
  maid_return_reason: String
  notes: String
  placement_id: uuid
  sponsor_id: uuid
  updated_at: timestamptz
  visa_application_date: date
  visa_approval_date: date
  visa_expiry_date: date
  visa_rejection_date: date
}

"""
order by max() on columns of table "placement_contracts"
"""
input placement_contracts_max_order_by {
  agency_id: order_by
  contract_duration_months: order_by
  contract_end_date: order_by
  contract_start_date: order_by
  contract_status: order_by
  created_at: order_by
  destination_city: order_by
  destination_country: order_by
  destination_region: order_by
  fee_transaction_id: order_by
  id: order_by
  maid_arrival_date: order_by
  maid_id: order_by
  maid_return_date: order_by
  maid_return_reason: order_by
  notes: order_by
  placement_id: order_by
  sponsor_id: order_by
  updated_at: order_by
  visa_application_date: order_by
  visa_approval_date: order_by
  visa_expiry_date: order_by
  visa_rejection_date: order_by
}

"""aggregate min on columns"""
type placement_contracts_min_fields {
  agency_id: uuid
  contract_duration_months: Int
  contract_end_date: date
  contract_start_date: date
  contract_status: String
  created_at: timestamptz
  destination_city: String
  destination_country: String
  destination_region: String
  fee_transaction_id: uuid
  id: uuid
  maid_arrival_date: date
  maid_id: uuid
  maid_return_date: date
  maid_return_reason: String
  notes: String
  placement_id: uuid
  sponsor_id: uuid
  updated_at: timestamptz
  visa_application_date: date
  visa_approval_date: date
  visa_expiry_date: date
  visa_rejection_date: date
}

"""
order by min() on columns of table "placement_contracts"
"""
input placement_contracts_min_order_by {
  agency_id: order_by
  contract_duration_months: order_by
  contract_end_date: order_by
  contract_start_date: order_by
  contract_status: order_by
  created_at: order_by
  destination_city: order_by
  destination_country: order_by
  destination_region: order_by
  fee_transaction_id: order_by
  id: order_by
  maid_arrival_date: order_by
  maid_id: order_by
  maid_return_date: order_by
  maid_return_reason: order_by
  notes: order_by
  placement_id: order_by
  sponsor_id: order_by
  updated_at: order_by
  visa_application_date: order_by
  visa_approval_date: order_by
  visa_expiry_date: order_by
  visa_rejection_date: order_by
}

"""
response of any mutation on the table "placement_contracts"
"""
type placement_contracts_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [placement_contracts!]!
}

"""
input type for inserting object relation for remote table "placement_contracts"
"""
input placement_contracts_obj_rel_insert_input {
  data: placement_contracts_insert_input!

  """upsert condition"""
  on_conflict: placement_contracts_on_conflict
}

"""
on_conflict condition type for table "placement_contracts"
"""
input placement_contracts_on_conflict {
  constraint: placement_contracts_constraint!
  update_columns: [placement_contracts_update_column!]! = []
  where: placement_contracts_bool_exp
}

"""Ordering options when selecting data from "placement_contracts"."""
input placement_contracts_order_by {
  agency_id: order_by
  agency_placement: agency_placements_order_by
  client_satisfaction_ratings_aggregate: client_satisfaction_ratings_aggregate_order_by
  contract_duration_months: order_by
  contract_end_date: order_by
  contract_start_date: order_by
  contract_status: order_by
  created_at: order_by
  destination_city: order_by
  destination_country: order_by
  destination_region: order_by
  fee_transaction_id: order_by
  id: order_by
  maid_arrival_date: order_by
  maid_id: order_by
  maid_return_date: order_by
  maid_return_reason: order_by
  metadata: order_by
  notes: order_by
  placement_fee_transaction: placement_fee_transactions_order_by
  placement_id: order_by
  sponsor_id: order_by
  updated_at: order_by
  user: auth_users_order_by
  visa_application_date: order_by
  visa_approval_date: order_by
  visa_expiry_date: order_by
  visa_rejection_date: order_by
}

"""primary key columns input for table: placement_contracts"""
input placement_contracts_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input placement_contracts_prepend_input {
  metadata: jsonb
}

"""
select columns of table "placement_contracts"
"""
enum placement_contracts_select_column {
  """column name"""
  agency_id

  """column name"""
  contract_duration_months

  """column name"""
  contract_end_date

  """column name"""
  contract_start_date

  """column name"""
  contract_status

  """column name"""
  created_at

  """column name"""
  destination_city

  """column name"""
  destination_country

  """column name"""
  destination_region

  """column name"""
  fee_transaction_id

  """column name"""
  id

  """column name"""
  maid_arrival_date

  """column name"""
  maid_id

  """column name"""
  maid_return_date

  """column name"""
  maid_return_reason

  """column name"""
  metadata

  """column name"""
  notes

  """column name"""
  placement_id

  """column name"""
  sponsor_id

  """column name"""
  updated_at

  """column name"""
  visa_application_date

  """column name"""
  visa_approval_date

  """column name"""
  visa_expiry_date

  """column name"""
  visa_rejection_date
}

"""
input type for updating data in table "placement_contracts"
"""
input placement_contracts_set_input {
  agency_id: uuid
  contract_duration_months: Int
  contract_end_date: date
  contract_start_date: date
  contract_status: String
  created_at: timestamptz
  destination_city: String
  destination_country: String
  destination_region: String
  fee_transaction_id: uuid
  id: uuid
  maid_arrival_date: date
  maid_id: uuid
  maid_return_date: date
  maid_return_reason: String
  metadata: jsonb
  notes: String
  placement_id: uuid
  sponsor_id: uuid
  updated_at: timestamptz
  visa_application_date: date
  visa_approval_date: date
  visa_expiry_date: date
  visa_rejection_date: date
}

"""aggregate stddev on columns"""
type placement_contracts_stddev_fields {
  contract_duration_months: Float
}

"""
order by stddev() on columns of table "placement_contracts"
"""
input placement_contracts_stddev_order_by {
  contract_duration_months: order_by
}

"""aggregate stddev_pop on columns"""
type placement_contracts_stddev_pop_fields {
  contract_duration_months: Float
}

"""
order by stddev_pop() on columns of table "placement_contracts"
"""
input placement_contracts_stddev_pop_order_by {
  contract_duration_months: order_by
}

"""aggregate stddev_samp on columns"""
type placement_contracts_stddev_samp_fields {
  contract_duration_months: Float
}

"""
order by stddev_samp() on columns of table "placement_contracts"
"""
input placement_contracts_stddev_samp_order_by {
  contract_duration_months: order_by
}

"""
Streaming cursor of the table "placement_contracts"
"""
input placement_contracts_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: placement_contracts_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input placement_contracts_stream_cursor_value_input {
  agency_id: uuid
  contract_duration_months: Int
  contract_end_date: date
  contract_start_date: date
  contract_status: String
  created_at: timestamptz
  destination_city: String
  destination_country: String
  destination_region: String
  fee_transaction_id: uuid
  id: uuid
  maid_arrival_date: date
  maid_id: uuid
  maid_return_date: date
  maid_return_reason: String
  metadata: jsonb
  notes: String
  placement_id: uuid
  sponsor_id: uuid
  updated_at: timestamptz
  visa_application_date: date
  visa_approval_date: date
  visa_expiry_date: date
  visa_rejection_date: date
}

"""aggregate sum on columns"""
type placement_contracts_sum_fields {
  contract_duration_months: Int
}

"""
order by sum() on columns of table "placement_contracts"
"""
input placement_contracts_sum_order_by {
  contract_duration_months: order_by
}

"""
update columns of table "placement_contracts"
"""
enum placement_contracts_update_column {
  """column name"""
  agency_id

  """column name"""
  contract_duration_months

  """column name"""
  contract_end_date

  """column name"""
  contract_start_date

  """column name"""
  contract_status

  """column name"""
  created_at

  """column name"""
  destination_city

  """column name"""
  destination_country

  """column name"""
  destination_region

  """column name"""
  fee_transaction_id

  """column name"""
  id

  """column name"""
  maid_arrival_date

  """column name"""
  maid_id

  """column name"""
  maid_return_date

  """column name"""
  maid_return_reason

  """column name"""
  metadata

  """column name"""
  notes

  """column name"""
  placement_id

  """column name"""
  sponsor_id

  """column name"""
  updated_at

  """column name"""
  visa_application_date

  """column name"""
  visa_approval_date

  """column name"""
  visa_expiry_date

  """column name"""
  visa_rejection_date
}

input placement_contracts_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: placement_contracts_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: placement_contracts_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: placement_contracts_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: placement_contracts_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: placement_contracts_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: placement_contracts_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: placement_contracts_set_input

  """filter the rows which have to be updated"""
  where: placement_contracts_bool_exp!
}

"""aggregate var_pop on columns"""
type placement_contracts_var_pop_fields {
  contract_duration_months: Float
}

"""
order by var_pop() on columns of table "placement_contracts"
"""
input placement_contracts_var_pop_order_by {
  contract_duration_months: order_by
}

"""aggregate var_samp on columns"""
type placement_contracts_var_samp_fields {
  contract_duration_months: Float
}

"""
order by var_samp() on columns of table "placement_contracts"
"""
input placement_contracts_var_samp_order_by {
  contract_duration_months: order_by
}

"""aggregate variance on columns"""
type placement_contracts_variance_fields {
  contract_duration_months: Float
}

"""
order by variance() on columns of table "placement_contracts"
"""
input placement_contracts_variance_order_by {
  contract_duration_months: order_by
}

"""Tracks 500 AED placement fees from agencies to platform"""
type placement_fee_transactions {
  agency_id: uuid!

  """An object relationship"""
  agency_placement: agency_placements

  """Actual amount deducted from agency bank (fee_amount - credits_applied)"""
  amount_charged: numeric!
  created_at: timestamptz
  credited_at: timestamptz

  """Amount of agency credits used to reduce payment"""
  credits_applied: numeric
  currency: String
  deducted_at: timestamptz
  escrow_until: timestamptz
  fee_amount: numeric!

  """
  escrow (pending visa)  released (visa approved) OR credited (maid returned)
  """
  fee_status: String!
  id: uuid!

  """An object relationship"""
  job: jobs
  job_id: uuid
  maid_id: uuid
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  notes: String
  payment_method: String
  payment_reference: String

  """An array relationship"""
  placement_contracts(
    """distinct select on columns"""
    distinct_on: [placement_contracts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [placement_contracts_order_by!]

    """filter the rows returned"""
    where: placement_contracts_bool_exp
  ): [placement_contracts!]!

  """An aggregate relationship"""
  placement_contracts_aggregate(
    """distinct select on columns"""
    distinct_on: [placement_contracts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [placement_contracts_order_by!]

    """filter the rows returned"""
    where: placement_contracts_bool_exp
  ): placement_contracts_aggregate!
  placement_id: uuid
  refunded_at: timestamptz
  released_at: timestamptz
  sponsor_id: uuid
  updated_at: timestamptz

  """An object relationship"""
  user: auth_users!
  visa_status: String
}

"""
aggregated selection of "placement_fee_transactions"
"""
type placement_fee_transactions_aggregate {
  aggregate: placement_fee_transactions_aggregate_fields
  nodes: [placement_fee_transactions!]!
}

input placement_fee_transactions_aggregate_bool_exp {
  count: placement_fee_transactions_aggregate_bool_exp_count
}

input placement_fee_transactions_aggregate_bool_exp_count {
  arguments: [placement_fee_transactions_select_column!]
  distinct: Boolean
  filter: placement_fee_transactions_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "placement_fee_transactions"
"""
type placement_fee_transactions_aggregate_fields {
  avg: placement_fee_transactions_avg_fields
  count(columns: [placement_fee_transactions_select_column!], distinct: Boolean): Int!
  max: placement_fee_transactions_max_fields
  min: placement_fee_transactions_min_fields
  stddev: placement_fee_transactions_stddev_fields
  stddev_pop: placement_fee_transactions_stddev_pop_fields
  stddev_samp: placement_fee_transactions_stddev_samp_fields
  sum: placement_fee_transactions_sum_fields
  var_pop: placement_fee_transactions_var_pop_fields
  var_samp: placement_fee_transactions_var_samp_fields
  variance: placement_fee_transactions_variance_fields
}

"""
order by aggregate values of table "placement_fee_transactions"
"""
input placement_fee_transactions_aggregate_order_by {
  avg: placement_fee_transactions_avg_order_by
  count: order_by
  max: placement_fee_transactions_max_order_by
  min: placement_fee_transactions_min_order_by
  stddev: placement_fee_transactions_stddev_order_by
  stddev_pop: placement_fee_transactions_stddev_pop_order_by
  stddev_samp: placement_fee_transactions_stddev_samp_order_by
  sum: placement_fee_transactions_sum_order_by
  var_pop: placement_fee_transactions_var_pop_order_by
  var_samp: placement_fee_transactions_var_samp_order_by
  variance: placement_fee_transactions_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input placement_fee_transactions_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "placement_fee_transactions"
"""
input placement_fee_transactions_arr_rel_insert_input {
  data: [placement_fee_transactions_insert_input!]!

  """upsert condition"""
  on_conflict: placement_fee_transactions_on_conflict
}

"""aggregate avg on columns"""
type placement_fee_transactions_avg_fields {
  """Actual amount deducted from agency bank (fee_amount - credits_applied)"""
  amount_charged: Float

  """Amount of agency credits used to reduce payment"""
  credits_applied: Float
  fee_amount: Float
}

"""
order by avg() on columns of table "placement_fee_transactions"
"""
input placement_fee_transactions_avg_order_by {
  """Actual amount deducted from agency bank (fee_amount - credits_applied)"""
  amount_charged: order_by

  """Amount of agency credits used to reduce payment"""
  credits_applied: order_by
  fee_amount: order_by
}

"""
Boolean expression to filter rows from the table "placement_fee_transactions". All fields are combined with a logical 'AND'.
"""
input placement_fee_transactions_bool_exp {
  _and: [placement_fee_transactions_bool_exp!]
  _not: placement_fee_transactions_bool_exp
  _or: [placement_fee_transactions_bool_exp!]
  agency_id: uuid_comparison_exp
  agency_placement: agency_placements_bool_exp
  amount_charged: numeric_comparison_exp
  created_at: timestamptz_comparison_exp
  credited_at: timestamptz_comparison_exp
  credits_applied: numeric_comparison_exp
  currency: String_comparison_exp
  deducted_at: timestamptz_comparison_exp
  escrow_until: timestamptz_comparison_exp
  fee_amount: numeric_comparison_exp
  fee_status: String_comparison_exp
  id: uuid_comparison_exp
  job: jobs_bool_exp
  job_id: uuid_comparison_exp
  maid_id: uuid_comparison_exp
  metadata: jsonb_comparison_exp
  notes: String_comparison_exp
  payment_method: String_comparison_exp
  payment_reference: String_comparison_exp
  placement_contracts: placement_contracts_bool_exp
  placement_contracts_aggregate: placement_contracts_aggregate_bool_exp
  placement_id: uuid_comparison_exp
  refunded_at: timestamptz_comparison_exp
  released_at: timestamptz_comparison_exp
  sponsor_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
  visa_status: String_comparison_exp
}

"""
unique or primary key constraints on table "placement_fee_transactions"
"""
enum placement_fee_transactions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  placement_fee_transactions_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input placement_fee_transactions_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input placement_fee_transactions_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input placement_fee_transactions_delete_key_input {
  metadata: String
}

"""
input type for incrementing numeric columns in table "placement_fee_transactions"
"""
input placement_fee_transactions_inc_input {
  """Actual amount deducted from agency bank (fee_amount - credits_applied)"""
  amount_charged: numeric

  """Amount of agency credits used to reduce payment"""
  credits_applied: numeric
  fee_amount: numeric
}

"""
input type for inserting data into table "placement_fee_transactions"
"""
input placement_fee_transactions_insert_input {
  agency_id: uuid
  agency_placement: agency_placements_obj_rel_insert_input

  """Actual amount deducted from agency bank (fee_amount - credits_applied)"""
  amount_charged: numeric
  created_at: timestamptz
  credited_at: timestamptz

  """Amount of agency credits used to reduce payment"""
  credits_applied: numeric
  currency: String
  deducted_at: timestamptz
  escrow_until: timestamptz
  fee_amount: numeric

  """
  escrow (pending visa)  released (visa approved) OR credited (maid returned)
  """
  fee_status: String
  id: uuid
  job: jobs_obj_rel_insert_input
  job_id: uuid
  maid_id: uuid
  metadata: jsonb
  notes: String
  payment_method: String
  payment_reference: String
  placement_contracts: placement_contracts_arr_rel_insert_input
  placement_id: uuid
  refunded_at: timestamptz
  released_at: timestamptz
  sponsor_id: uuid
  updated_at: timestamptz
  user: auth_users_obj_rel_insert_input
  visa_status: String
}

"""aggregate max on columns"""
type placement_fee_transactions_max_fields {
  agency_id: uuid

  """Actual amount deducted from agency bank (fee_amount - credits_applied)"""
  amount_charged: numeric
  created_at: timestamptz
  credited_at: timestamptz

  """Amount of agency credits used to reduce payment"""
  credits_applied: numeric
  currency: String
  deducted_at: timestamptz
  escrow_until: timestamptz
  fee_amount: numeric

  """
  escrow (pending visa)  released (visa approved) OR credited (maid returned)
  """
  fee_status: String
  id: uuid
  job_id: uuid
  maid_id: uuid
  notes: String
  payment_method: String
  payment_reference: String
  placement_id: uuid
  refunded_at: timestamptz
  released_at: timestamptz
  sponsor_id: uuid
  updated_at: timestamptz
  visa_status: String
}

"""
order by max() on columns of table "placement_fee_transactions"
"""
input placement_fee_transactions_max_order_by {
  agency_id: order_by

  """Actual amount deducted from agency bank (fee_amount - credits_applied)"""
  amount_charged: order_by
  created_at: order_by
  credited_at: order_by

  """Amount of agency credits used to reduce payment"""
  credits_applied: order_by
  currency: order_by
  deducted_at: order_by
  escrow_until: order_by
  fee_amount: order_by

  """
  escrow (pending visa)  released (visa approved) OR credited (maid returned)
  """
  fee_status: order_by
  id: order_by
  job_id: order_by
  maid_id: order_by
  notes: order_by
  payment_method: order_by
  payment_reference: order_by
  placement_id: order_by
  refunded_at: order_by
  released_at: order_by
  sponsor_id: order_by
  updated_at: order_by
  visa_status: order_by
}

"""aggregate min on columns"""
type placement_fee_transactions_min_fields {
  agency_id: uuid

  """Actual amount deducted from agency bank (fee_amount - credits_applied)"""
  amount_charged: numeric
  created_at: timestamptz
  credited_at: timestamptz

  """Amount of agency credits used to reduce payment"""
  credits_applied: numeric
  currency: String
  deducted_at: timestamptz
  escrow_until: timestamptz
  fee_amount: numeric

  """
  escrow (pending visa)  released (visa approved) OR credited (maid returned)
  """
  fee_status: String
  id: uuid
  job_id: uuid
  maid_id: uuid
  notes: String
  payment_method: String
  payment_reference: String
  placement_id: uuid
  refunded_at: timestamptz
  released_at: timestamptz
  sponsor_id: uuid
  updated_at: timestamptz
  visa_status: String
}

"""
order by min() on columns of table "placement_fee_transactions"
"""
input placement_fee_transactions_min_order_by {
  agency_id: order_by

  """Actual amount deducted from agency bank (fee_amount - credits_applied)"""
  amount_charged: order_by
  created_at: order_by
  credited_at: order_by

  """Amount of agency credits used to reduce payment"""
  credits_applied: order_by
  currency: order_by
  deducted_at: order_by
  escrow_until: order_by
  fee_amount: order_by

  """
  escrow (pending visa)  released (visa approved) OR credited (maid returned)
  """
  fee_status: order_by
  id: order_by
  job_id: order_by
  maid_id: order_by
  notes: order_by
  payment_method: order_by
  payment_reference: order_by
  placement_id: order_by
  refunded_at: order_by
  released_at: order_by
  sponsor_id: order_by
  updated_at: order_by
  visa_status: order_by
}

"""
response of any mutation on the table "placement_fee_transactions"
"""
type placement_fee_transactions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [placement_fee_transactions!]!
}

"""
input type for inserting object relation for remote table "placement_fee_transactions"
"""
input placement_fee_transactions_obj_rel_insert_input {
  data: placement_fee_transactions_insert_input!

  """upsert condition"""
  on_conflict: placement_fee_transactions_on_conflict
}

"""
on_conflict condition type for table "placement_fee_transactions"
"""
input placement_fee_transactions_on_conflict {
  constraint: placement_fee_transactions_constraint!
  update_columns: [placement_fee_transactions_update_column!]! = []
  where: placement_fee_transactions_bool_exp
}

"""
Ordering options when selecting data from "placement_fee_transactions".
"""
input placement_fee_transactions_order_by {
  agency_id: order_by
  agency_placement: agency_placements_order_by
  amount_charged: order_by
  created_at: order_by
  credited_at: order_by
  credits_applied: order_by
  currency: order_by
  deducted_at: order_by
  escrow_until: order_by
  fee_amount: order_by
  fee_status: order_by
  id: order_by
  job: jobs_order_by
  job_id: order_by
  maid_id: order_by
  metadata: order_by
  notes: order_by
  payment_method: order_by
  payment_reference: order_by
  placement_contracts_aggregate: placement_contracts_aggregate_order_by
  placement_id: order_by
  refunded_at: order_by
  released_at: order_by
  sponsor_id: order_by
  updated_at: order_by
  user: auth_users_order_by
  visa_status: order_by
}

"""primary key columns input for table: placement_fee_transactions"""
input placement_fee_transactions_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input placement_fee_transactions_prepend_input {
  metadata: jsonb
}

"""
select columns of table "placement_fee_transactions"
"""
enum placement_fee_transactions_select_column {
  """column name"""
  agency_id

  """column name"""
  amount_charged

  """column name"""
  created_at

  """column name"""
  credited_at

  """column name"""
  credits_applied

  """column name"""
  currency

  """column name"""
  deducted_at

  """column name"""
  escrow_until

  """column name"""
  fee_amount

  """column name"""
  fee_status

  """column name"""
  id

  """column name"""
  job_id

  """column name"""
  maid_id

  """column name"""
  metadata

  """column name"""
  notes

  """column name"""
  payment_method

  """column name"""
  payment_reference

  """column name"""
  placement_id

  """column name"""
  refunded_at

  """column name"""
  released_at

  """column name"""
  sponsor_id

  """column name"""
  updated_at

  """column name"""
  visa_status
}

"""
input type for updating data in table "placement_fee_transactions"
"""
input placement_fee_transactions_set_input {
  agency_id: uuid

  """Actual amount deducted from agency bank (fee_amount - credits_applied)"""
  amount_charged: numeric
  created_at: timestamptz
  credited_at: timestamptz

  """Amount of agency credits used to reduce payment"""
  credits_applied: numeric
  currency: String
  deducted_at: timestamptz
  escrow_until: timestamptz
  fee_amount: numeric

  """
  escrow (pending visa)  released (visa approved) OR credited (maid returned)
  """
  fee_status: String
  id: uuid
  job_id: uuid
  maid_id: uuid
  metadata: jsonb
  notes: String
  payment_method: String
  payment_reference: String
  placement_id: uuid
  refunded_at: timestamptz
  released_at: timestamptz
  sponsor_id: uuid
  updated_at: timestamptz
  visa_status: String
}

"""aggregate stddev on columns"""
type placement_fee_transactions_stddev_fields {
  """Actual amount deducted from agency bank (fee_amount - credits_applied)"""
  amount_charged: Float

  """Amount of agency credits used to reduce payment"""
  credits_applied: Float
  fee_amount: Float
}

"""
order by stddev() on columns of table "placement_fee_transactions"
"""
input placement_fee_transactions_stddev_order_by {
  """Actual amount deducted from agency bank (fee_amount - credits_applied)"""
  amount_charged: order_by

  """Amount of agency credits used to reduce payment"""
  credits_applied: order_by
  fee_amount: order_by
}

"""aggregate stddev_pop on columns"""
type placement_fee_transactions_stddev_pop_fields {
  """Actual amount deducted from agency bank (fee_amount - credits_applied)"""
  amount_charged: Float

  """Amount of agency credits used to reduce payment"""
  credits_applied: Float
  fee_amount: Float
}

"""
order by stddev_pop() on columns of table "placement_fee_transactions"
"""
input placement_fee_transactions_stddev_pop_order_by {
  """Actual amount deducted from agency bank (fee_amount - credits_applied)"""
  amount_charged: order_by

  """Amount of agency credits used to reduce payment"""
  credits_applied: order_by
  fee_amount: order_by
}

"""aggregate stddev_samp on columns"""
type placement_fee_transactions_stddev_samp_fields {
  """Actual amount deducted from agency bank (fee_amount - credits_applied)"""
  amount_charged: Float

  """Amount of agency credits used to reduce payment"""
  credits_applied: Float
  fee_amount: Float
}

"""
order by stddev_samp() on columns of table "placement_fee_transactions"
"""
input placement_fee_transactions_stddev_samp_order_by {
  """Actual amount deducted from agency bank (fee_amount - credits_applied)"""
  amount_charged: order_by

  """Amount of agency credits used to reduce payment"""
  credits_applied: order_by
  fee_amount: order_by
}

"""
Streaming cursor of the table "placement_fee_transactions"
"""
input placement_fee_transactions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: placement_fee_transactions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input placement_fee_transactions_stream_cursor_value_input {
  agency_id: uuid

  """Actual amount deducted from agency bank (fee_amount - credits_applied)"""
  amount_charged: numeric
  created_at: timestamptz
  credited_at: timestamptz

  """Amount of agency credits used to reduce payment"""
  credits_applied: numeric
  currency: String
  deducted_at: timestamptz
  escrow_until: timestamptz
  fee_amount: numeric

  """
  escrow (pending visa)  released (visa approved) OR credited (maid returned)
  """
  fee_status: String
  id: uuid
  job_id: uuid
  maid_id: uuid
  metadata: jsonb
  notes: String
  payment_method: String
  payment_reference: String
  placement_id: uuid
  refunded_at: timestamptz
  released_at: timestamptz
  sponsor_id: uuid
  updated_at: timestamptz
  visa_status: String
}

"""aggregate sum on columns"""
type placement_fee_transactions_sum_fields {
  """Actual amount deducted from agency bank (fee_amount - credits_applied)"""
  amount_charged: numeric

  """Amount of agency credits used to reduce payment"""
  credits_applied: numeric
  fee_amount: numeric
}

"""
order by sum() on columns of table "placement_fee_transactions"
"""
input placement_fee_transactions_sum_order_by {
  """Actual amount deducted from agency bank (fee_amount - credits_applied)"""
  amount_charged: order_by

  """Amount of agency credits used to reduce payment"""
  credits_applied: order_by
  fee_amount: order_by
}

"""
update columns of table "placement_fee_transactions"
"""
enum placement_fee_transactions_update_column {
  """column name"""
  agency_id

  """column name"""
  amount_charged

  """column name"""
  created_at

  """column name"""
  credited_at

  """column name"""
  credits_applied

  """column name"""
  currency

  """column name"""
  deducted_at

  """column name"""
  escrow_until

  """column name"""
  fee_amount

  """column name"""
  fee_status

  """column name"""
  id

  """column name"""
  job_id

  """column name"""
  maid_id

  """column name"""
  metadata

  """column name"""
  notes

  """column name"""
  payment_method

  """column name"""
  payment_reference

  """column name"""
  placement_id

  """column name"""
  refunded_at

  """column name"""
  released_at

  """column name"""
  sponsor_id

  """column name"""
  updated_at

  """column name"""
  visa_status
}

input placement_fee_transactions_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: placement_fee_transactions_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: placement_fee_transactions_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: placement_fee_transactions_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: placement_fee_transactions_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: placement_fee_transactions_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: placement_fee_transactions_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: placement_fee_transactions_set_input

  """filter the rows which have to be updated"""
  where: placement_fee_transactions_bool_exp!
}

"""aggregate var_pop on columns"""
type placement_fee_transactions_var_pop_fields {
  """Actual amount deducted from agency bank (fee_amount - credits_applied)"""
  amount_charged: Float

  """Amount of agency credits used to reduce payment"""
  credits_applied: Float
  fee_amount: Float
}

"""
order by var_pop() on columns of table "placement_fee_transactions"
"""
input placement_fee_transactions_var_pop_order_by {
  """Actual amount deducted from agency bank (fee_amount - credits_applied)"""
  amount_charged: order_by

  """Amount of agency credits used to reduce payment"""
  credits_applied: order_by
  fee_amount: order_by
}

"""aggregate var_samp on columns"""
type placement_fee_transactions_var_samp_fields {
  """Actual amount deducted from agency bank (fee_amount - credits_applied)"""
  amount_charged: Float

  """Amount of agency credits used to reduce payment"""
  credits_applied: Float
  fee_amount: Float
}

"""
order by var_samp() on columns of table "placement_fee_transactions"
"""
input placement_fee_transactions_var_samp_order_by {
  """Actual amount deducted from agency bank (fee_amount - credits_applied)"""
  amount_charged: order_by

  """Amount of agency credits used to reduce payment"""
  credits_applied: order_by
  fee_amount: order_by
}

"""aggregate variance on columns"""
type placement_fee_transactions_variance_fields {
  """Actual amount deducted from agency bank (fee_amount - credits_applied)"""
  amount_charged: Float

  """Amount of agency credits used to reduce payment"""
  credits_applied: Float
  fee_amount: Float
}

"""
order by variance() on columns of table "placement_fee_transactions"
"""
input placement_fee_transactions_variance_order_by {
  """Actual amount deducted from agency bank (fee_amount - credits_applied)"""
  amount_charged: order_by

  """Amount of agency credits used to reduce payment"""
  credits_applied: order_by
  fee_amount: order_by
}

"""Platform-specific announcements and updates"""
type platform_announcements {
  color: String
  created_at: timestamptz
  created_by: uuid
  end_date: timestamptz
  icon: String
  id: uuid!
  is_active: Boolean
  message: String!
  priority: Int
  start_date: timestamptz
  target_audience: String
  title: String!
  type: String!
  updated_at: timestamptz
  url: String

  """An object relationship"""
  user: auth_users
}

"""
aggregated selection of "platform_announcements"
"""
type platform_announcements_aggregate {
  aggregate: platform_announcements_aggregate_fields
  nodes: [platform_announcements!]!
}

"""
aggregate fields of "platform_announcements"
"""
type platform_announcements_aggregate_fields {
  avg: platform_announcements_avg_fields
  count(columns: [platform_announcements_select_column!], distinct: Boolean): Int!
  max: platform_announcements_max_fields
  min: platform_announcements_min_fields
  stddev: platform_announcements_stddev_fields
  stddev_pop: platform_announcements_stddev_pop_fields
  stddev_samp: platform_announcements_stddev_samp_fields
  sum: platform_announcements_sum_fields
  var_pop: platform_announcements_var_pop_fields
  var_samp: platform_announcements_var_samp_fields
  variance: platform_announcements_variance_fields
}

"""aggregate avg on columns"""
type platform_announcements_avg_fields {
  priority: Float
}

"""
Boolean expression to filter rows from the table "platform_announcements". All fields are combined with a logical 'AND'.
"""
input platform_announcements_bool_exp {
  _and: [platform_announcements_bool_exp!]
  _not: platform_announcements_bool_exp
  _or: [platform_announcements_bool_exp!]
  color: String_comparison_exp
  created_at: timestamptz_comparison_exp
  created_by: uuid_comparison_exp
  end_date: timestamptz_comparison_exp
  icon: String_comparison_exp
  id: uuid_comparison_exp
  is_active: Boolean_comparison_exp
  message: String_comparison_exp
  priority: Int_comparison_exp
  start_date: timestamptz_comparison_exp
  target_audience: String_comparison_exp
  title: String_comparison_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  url: String_comparison_exp
  user: auth_users_bool_exp
}

"""
unique or primary key constraints on table "platform_announcements"
"""
enum platform_announcements_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  platform_announcements_pkey
}

"""
input type for incrementing numeric columns in table "platform_announcements"
"""
input platform_announcements_inc_input {
  priority: Int
}

"""
input type for inserting data into table "platform_announcements"
"""
input platform_announcements_insert_input {
  color: String
  created_at: timestamptz
  created_by: uuid
  end_date: timestamptz
  icon: String
  id: uuid
  is_active: Boolean
  message: String
  priority: Int
  start_date: timestamptz
  target_audience: String
  title: String
  type: String
  updated_at: timestamptz
  url: String
  user: auth_users_obj_rel_insert_input
}

"""aggregate max on columns"""
type platform_announcements_max_fields {
  color: String
  created_at: timestamptz
  created_by: uuid
  end_date: timestamptz
  icon: String
  id: uuid
  message: String
  priority: Int
  start_date: timestamptz
  target_audience: String
  title: String
  type: String
  updated_at: timestamptz
  url: String
}

"""aggregate min on columns"""
type platform_announcements_min_fields {
  color: String
  created_at: timestamptz
  created_by: uuid
  end_date: timestamptz
  icon: String
  id: uuid
  message: String
  priority: Int
  start_date: timestamptz
  target_audience: String
  title: String
  type: String
  updated_at: timestamptz
  url: String
}

"""
response of any mutation on the table "platform_announcements"
"""
type platform_announcements_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [platform_announcements!]!
}

"""
on_conflict condition type for table "platform_announcements"
"""
input platform_announcements_on_conflict {
  constraint: platform_announcements_constraint!
  update_columns: [platform_announcements_update_column!]! = []
  where: platform_announcements_bool_exp
}

"""Ordering options when selecting data from "platform_announcements"."""
input platform_announcements_order_by {
  color: order_by
  created_at: order_by
  created_by: order_by
  end_date: order_by
  icon: order_by
  id: order_by
  is_active: order_by
  message: order_by
  priority: order_by
  start_date: order_by
  target_audience: order_by
  title: order_by
  type: order_by
  updated_at: order_by
  url: order_by
  user: auth_users_order_by
}

"""primary key columns input for table: platform_announcements"""
input platform_announcements_pk_columns_input {
  id: uuid!
}

"""
select columns of table "platform_announcements"
"""
enum platform_announcements_select_column {
  """column name"""
  color

  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  end_date

  """column name"""
  icon

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  message

  """column name"""
  priority

  """column name"""
  start_date

  """column name"""
  target_audience

  """column name"""
  title

  """column name"""
  type

  """column name"""
  updated_at

  """column name"""
  url
}

"""
input type for updating data in table "platform_announcements"
"""
input platform_announcements_set_input {
  color: String
  created_at: timestamptz
  created_by: uuid
  end_date: timestamptz
  icon: String
  id: uuid
  is_active: Boolean
  message: String
  priority: Int
  start_date: timestamptz
  target_audience: String
  title: String
  type: String
  updated_at: timestamptz
  url: String
}

"""aggregate stddev on columns"""
type platform_announcements_stddev_fields {
  priority: Float
}

"""aggregate stddev_pop on columns"""
type platform_announcements_stddev_pop_fields {
  priority: Float
}

"""aggregate stddev_samp on columns"""
type platform_announcements_stddev_samp_fields {
  priority: Float
}

"""
Streaming cursor of the table "platform_announcements"
"""
input platform_announcements_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: platform_announcements_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input platform_announcements_stream_cursor_value_input {
  color: String
  created_at: timestamptz
  created_by: uuid
  end_date: timestamptz
  icon: String
  id: uuid
  is_active: Boolean
  message: String
  priority: Int
  start_date: timestamptz
  target_audience: String
  title: String
  type: String
  updated_at: timestamptz
  url: String
}

"""aggregate sum on columns"""
type platform_announcements_sum_fields {
  priority: Int
}

"""
update columns of table "platform_announcements"
"""
enum platform_announcements_update_column {
  """column name"""
  color

  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  end_date

  """column name"""
  icon

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  message

  """column name"""
  priority

  """column name"""
  start_date

  """column name"""
  target_audience

  """column name"""
  title

  """column name"""
  type

  """column name"""
  updated_at

  """column name"""
  url
}

input platform_announcements_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: platform_announcements_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: platform_announcements_set_input

  """filter the rows which have to be updated"""
  where: platform_announcements_bool_exp!
}

"""aggregate var_pop on columns"""
type platform_announcements_var_pop_fields {
  priority: Float
}

"""aggregate var_samp on columns"""
type platform_announcements_var_samp_fields {
  priority: Float
}

"""aggregate variance on columns"""
type platform_announcements_variance_fields {
  priority: Float
}

"""Holds platform configuration and settings"""
type platform_settings {
  about_platform: String

  """Claude model to use for AI responses"""
  ai_model: String

  """AI temperature setting (0-1)"""
  ai_temperature: numeric

  """Whitelist of allowed phone numbers (newline-separated)"""
  allowed_numbers: String

  """Auto-send confirmation when booking is confirmed"""
  auto_confirm_bookings: Boolean

  """Automatically respond to incoming messages"""
  auto_response_enabled: Boolean

  """Array of available services"""
  available_services: [String!]

  """Blacklist of blocked phone numbers (newline-separated)"""
  blocked_numbers: String

  """Only respond during working hours"""
  business_hours_only: Boolean

  """Maid availability cache refresh interval in minutes"""
  cache_timeout: Int
  created_at: timestamptz

  """Log detailed information for troubleshooting"""
  debug_mode: Boolean

  """Message sent when an error occurs"""
  error_message: String

  """Default greeting message"""
  greeting_message: String
  id: uuid!

  """Number of previous messages included in AI context (5-50)"""
  max_context_messages: Int

  """Maximum length of AI responses (256-4096)"""
  max_tokens: Int

  """Email address for receiving notifications"""
  notification_email: String

  """Notify when bookings are created/updated"""
  notify_bookings: Boolean

  """Notify when webhook/AI errors occur"""
  notify_errors: Boolean

  """Notify admins of new WhatsApp messages"""
  notify_new_messages: Boolean

  """Message sent when outside business hours"""
  offline_message: String
  platform_name: String

  """Maximum messages per minute per phone number"""
  rate_limit: Int

  """Enable rate limiting per phone number"""
  rate_limiting_enabled: Boolean

  """Request feedback after completed bookings"""
  send_followups: Boolean

  """Send reminders 24 hours before booking"""
  send_reminders: Boolean

  """Save full AI response data for analysis"""
  store_ai_responses: Boolean
  support_email: String
  support_phone: String

  """Custom system prompt appended to base instructions"""
  system_prompt: String

  """Timeout for webhook and AI requests (5-60 seconds)"""
  timeout: Int
  updated_at: timestamptz

  """Verify webhook requests are from Twilio"""
  validate_signature: Boolean
  whatsapp_webhook_url: String
  working_hours: String
}

"""
aggregated selection of "platform_settings"
"""
type platform_settings_aggregate {
  aggregate: platform_settings_aggregate_fields
  nodes: [platform_settings!]!
}

"""
aggregate fields of "platform_settings"
"""
type platform_settings_aggregate_fields {
  avg: platform_settings_avg_fields
  count(columns: [platform_settings_select_column!], distinct: Boolean): Int!
  max: platform_settings_max_fields
  min: platform_settings_min_fields
  stddev: platform_settings_stddev_fields
  stddev_pop: platform_settings_stddev_pop_fields
  stddev_samp: platform_settings_stddev_samp_fields
  sum: platform_settings_sum_fields
  var_pop: platform_settings_var_pop_fields
  var_samp: platform_settings_var_samp_fields
  variance: platform_settings_variance_fields
}

"""aggregate avg on columns"""
type platform_settings_avg_fields {
  """AI temperature setting (0-1)"""
  ai_temperature: Float

  """Maid availability cache refresh interval in minutes"""
  cache_timeout: Float

  """Number of previous messages included in AI context (5-50)"""
  max_context_messages: Float

  """Maximum length of AI responses (256-4096)"""
  max_tokens: Float

  """Maximum messages per minute per phone number"""
  rate_limit: Float

  """Timeout for webhook and AI requests (5-60 seconds)"""
  timeout: Float
}

"""
Boolean expression to filter rows from the table "platform_settings". All fields are combined with a logical 'AND'.
"""
input platform_settings_bool_exp {
  _and: [platform_settings_bool_exp!]
  _not: platform_settings_bool_exp
  _or: [platform_settings_bool_exp!]
  about_platform: String_comparison_exp
  ai_model: String_comparison_exp
  ai_temperature: numeric_comparison_exp
  allowed_numbers: String_comparison_exp
  auto_confirm_bookings: Boolean_comparison_exp
  auto_response_enabled: Boolean_comparison_exp
  available_services: String_array_comparison_exp
  blocked_numbers: String_comparison_exp
  business_hours_only: Boolean_comparison_exp
  cache_timeout: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  debug_mode: Boolean_comparison_exp
  error_message: String_comparison_exp
  greeting_message: String_comparison_exp
  id: uuid_comparison_exp
  max_context_messages: Int_comparison_exp
  max_tokens: Int_comparison_exp
  notification_email: String_comparison_exp
  notify_bookings: Boolean_comparison_exp
  notify_errors: Boolean_comparison_exp
  notify_new_messages: Boolean_comparison_exp
  offline_message: String_comparison_exp
  platform_name: String_comparison_exp
  rate_limit: Int_comparison_exp
  rate_limiting_enabled: Boolean_comparison_exp
  send_followups: Boolean_comparison_exp
  send_reminders: Boolean_comparison_exp
  store_ai_responses: Boolean_comparison_exp
  support_email: String_comparison_exp
  support_phone: String_comparison_exp
  system_prompt: String_comparison_exp
  timeout: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
  validate_signature: Boolean_comparison_exp
  whatsapp_webhook_url: String_comparison_exp
  working_hours: String_comparison_exp
}

"""
unique or primary key constraints on table "platform_settings"
"""
enum platform_settings_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  platform_settings_pkey
}

"""
input type for incrementing numeric columns in table "platform_settings"
"""
input platform_settings_inc_input {
  """AI temperature setting (0-1)"""
  ai_temperature: numeric

  """Maid availability cache refresh interval in minutes"""
  cache_timeout: Int

  """Number of previous messages included in AI context (5-50)"""
  max_context_messages: Int

  """Maximum length of AI responses (256-4096)"""
  max_tokens: Int

  """Maximum messages per minute per phone number"""
  rate_limit: Int

  """Timeout for webhook and AI requests (5-60 seconds)"""
  timeout: Int
}

"""
input type for inserting data into table "platform_settings"
"""
input platform_settings_insert_input {
  about_platform: String

  """Claude model to use for AI responses"""
  ai_model: String

  """AI temperature setting (0-1)"""
  ai_temperature: numeric

  """Whitelist of allowed phone numbers (newline-separated)"""
  allowed_numbers: String

  """Auto-send confirmation when booking is confirmed"""
  auto_confirm_bookings: Boolean

  """Automatically respond to incoming messages"""
  auto_response_enabled: Boolean

  """Array of available services"""
  available_services: [String!]

  """Blacklist of blocked phone numbers (newline-separated)"""
  blocked_numbers: String

  """Only respond during working hours"""
  business_hours_only: Boolean

  """Maid availability cache refresh interval in minutes"""
  cache_timeout: Int
  created_at: timestamptz

  """Log detailed information for troubleshooting"""
  debug_mode: Boolean

  """Message sent when an error occurs"""
  error_message: String

  """Default greeting message"""
  greeting_message: String
  id: uuid

  """Number of previous messages included in AI context (5-50)"""
  max_context_messages: Int

  """Maximum length of AI responses (256-4096)"""
  max_tokens: Int

  """Email address for receiving notifications"""
  notification_email: String

  """Notify when bookings are created/updated"""
  notify_bookings: Boolean

  """Notify when webhook/AI errors occur"""
  notify_errors: Boolean

  """Notify admins of new WhatsApp messages"""
  notify_new_messages: Boolean

  """Message sent when outside business hours"""
  offline_message: String
  platform_name: String

  """Maximum messages per minute per phone number"""
  rate_limit: Int

  """Enable rate limiting per phone number"""
  rate_limiting_enabled: Boolean

  """Request feedback after completed bookings"""
  send_followups: Boolean

  """Send reminders 24 hours before booking"""
  send_reminders: Boolean

  """Save full AI response data for analysis"""
  store_ai_responses: Boolean
  support_email: String
  support_phone: String

  """Custom system prompt appended to base instructions"""
  system_prompt: String

  """Timeout for webhook and AI requests (5-60 seconds)"""
  timeout: Int
  updated_at: timestamptz

  """Verify webhook requests are from Twilio"""
  validate_signature: Boolean
  whatsapp_webhook_url: String
  working_hours: String
}

"""aggregate max on columns"""
type platform_settings_max_fields {
  about_platform: String

  """Claude model to use for AI responses"""
  ai_model: String

  """AI temperature setting (0-1)"""
  ai_temperature: numeric

  """Whitelist of allowed phone numbers (newline-separated)"""
  allowed_numbers: String

  """Array of available services"""
  available_services: [String!]

  """Blacklist of blocked phone numbers (newline-separated)"""
  blocked_numbers: String

  """Maid availability cache refresh interval in minutes"""
  cache_timeout: Int
  created_at: timestamptz

  """Message sent when an error occurs"""
  error_message: String

  """Default greeting message"""
  greeting_message: String
  id: uuid

  """Number of previous messages included in AI context (5-50)"""
  max_context_messages: Int

  """Maximum length of AI responses (256-4096)"""
  max_tokens: Int

  """Email address for receiving notifications"""
  notification_email: String

  """Message sent when outside business hours"""
  offline_message: String
  platform_name: String

  """Maximum messages per minute per phone number"""
  rate_limit: Int
  support_email: String
  support_phone: String

  """Custom system prompt appended to base instructions"""
  system_prompt: String

  """Timeout for webhook and AI requests (5-60 seconds)"""
  timeout: Int
  updated_at: timestamptz
  whatsapp_webhook_url: String
  working_hours: String
}

"""aggregate min on columns"""
type platform_settings_min_fields {
  about_platform: String

  """Claude model to use for AI responses"""
  ai_model: String

  """AI temperature setting (0-1)"""
  ai_temperature: numeric

  """Whitelist of allowed phone numbers (newline-separated)"""
  allowed_numbers: String

  """Array of available services"""
  available_services: [String!]

  """Blacklist of blocked phone numbers (newline-separated)"""
  blocked_numbers: String

  """Maid availability cache refresh interval in minutes"""
  cache_timeout: Int
  created_at: timestamptz

  """Message sent when an error occurs"""
  error_message: String

  """Default greeting message"""
  greeting_message: String
  id: uuid

  """Number of previous messages included in AI context (5-50)"""
  max_context_messages: Int

  """Maximum length of AI responses (256-4096)"""
  max_tokens: Int

  """Email address for receiving notifications"""
  notification_email: String

  """Message sent when outside business hours"""
  offline_message: String
  platform_name: String

  """Maximum messages per minute per phone number"""
  rate_limit: Int
  support_email: String
  support_phone: String

  """Custom system prompt appended to base instructions"""
  system_prompt: String

  """Timeout for webhook and AI requests (5-60 seconds)"""
  timeout: Int
  updated_at: timestamptz
  whatsapp_webhook_url: String
  working_hours: String
}

"""
response of any mutation on the table "platform_settings"
"""
type platform_settings_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [platform_settings!]!
}

"""
on_conflict condition type for table "platform_settings"
"""
input platform_settings_on_conflict {
  constraint: platform_settings_constraint!
  update_columns: [platform_settings_update_column!]! = []
  where: platform_settings_bool_exp
}

"""Ordering options when selecting data from "platform_settings"."""
input platform_settings_order_by {
  about_platform: order_by
  ai_model: order_by
  ai_temperature: order_by
  allowed_numbers: order_by
  auto_confirm_bookings: order_by
  auto_response_enabled: order_by
  available_services: order_by
  blocked_numbers: order_by
  business_hours_only: order_by
  cache_timeout: order_by
  created_at: order_by
  debug_mode: order_by
  error_message: order_by
  greeting_message: order_by
  id: order_by
  max_context_messages: order_by
  max_tokens: order_by
  notification_email: order_by
  notify_bookings: order_by
  notify_errors: order_by
  notify_new_messages: order_by
  offline_message: order_by
  platform_name: order_by
  rate_limit: order_by
  rate_limiting_enabled: order_by
  send_followups: order_by
  send_reminders: order_by
  store_ai_responses: order_by
  support_email: order_by
  support_phone: order_by
  system_prompt: order_by
  timeout: order_by
  updated_at: order_by
  validate_signature: order_by
  whatsapp_webhook_url: order_by
  working_hours: order_by
}

"""primary key columns input for table: platform_settings"""
input platform_settings_pk_columns_input {
  id: uuid!
}

"""
select columns of table "platform_settings"
"""
enum platform_settings_select_column {
  """column name"""
  about_platform

  """column name"""
  ai_model

  """column name"""
  ai_temperature

  """column name"""
  allowed_numbers

  """column name"""
  auto_confirm_bookings

  """column name"""
  auto_response_enabled

  """column name"""
  available_services

  """column name"""
  blocked_numbers

  """column name"""
  business_hours_only

  """column name"""
  cache_timeout

  """column name"""
  created_at

  """column name"""
  debug_mode

  """column name"""
  error_message

  """column name"""
  greeting_message

  """column name"""
  id

  """column name"""
  max_context_messages

  """column name"""
  max_tokens

  """column name"""
  notification_email

  """column name"""
  notify_bookings

  """column name"""
  notify_errors

  """column name"""
  notify_new_messages

  """column name"""
  offline_message

  """column name"""
  platform_name

  """column name"""
  rate_limit

  """column name"""
  rate_limiting_enabled

  """column name"""
  send_followups

  """column name"""
  send_reminders

  """column name"""
  store_ai_responses

  """column name"""
  support_email

  """column name"""
  support_phone

  """column name"""
  system_prompt

  """column name"""
  timeout

  """column name"""
  updated_at

  """column name"""
  validate_signature

  """column name"""
  whatsapp_webhook_url

  """column name"""
  working_hours
}

"""
input type for updating data in table "platform_settings"
"""
input platform_settings_set_input {
  about_platform: String

  """Claude model to use for AI responses"""
  ai_model: String

  """AI temperature setting (0-1)"""
  ai_temperature: numeric

  """Whitelist of allowed phone numbers (newline-separated)"""
  allowed_numbers: String

  """Auto-send confirmation when booking is confirmed"""
  auto_confirm_bookings: Boolean

  """Automatically respond to incoming messages"""
  auto_response_enabled: Boolean

  """Array of available services"""
  available_services: [String!]

  """Blacklist of blocked phone numbers (newline-separated)"""
  blocked_numbers: String

  """Only respond during working hours"""
  business_hours_only: Boolean

  """Maid availability cache refresh interval in minutes"""
  cache_timeout: Int
  created_at: timestamptz

  """Log detailed information for troubleshooting"""
  debug_mode: Boolean

  """Message sent when an error occurs"""
  error_message: String

  """Default greeting message"""
  greeting_message: String
  id: uuid

  """Number of previous messages included in AI context (5-50)"""
  max_context_messages: Int

  """Maximum length of AI responses (256-4096)"""
  max_tokens: Int

  """Email address for receiving notifications"""
  notification_email: String

  """Notify when bookings are created/updated"""
  notify_bookings: Boolean

  """Notify when webhook/AI errors occur"""
  notify_errors: Boolean

  """Notify admins of new WhatsApp messages"""
  notify_new_messages: Boolean

  """Message sent when outside business hours"""
  offline_message: String
  platform_name: String

  """Maximum messages per minute per phone number"""
  rate_limit: Int

  """Enable rate limiting per phone number"""
  rate_limiting_enabled: Boolean

  """Request feedback after completed bookings"""
  send_followups: Boolean

  """Send reminders 24 hours before booking"""
  send_reminders: Boolean

  """Save full AI response data for analysis"""
  store_ai_responses: Boolean
  support_email: String
  support_phone: String

  """Custom system prompt appended to base instructions"""
  system_prompt: String

  """Timeout for webhook and AI requests (5-60 seconds)"""
  timeout: Int
  updated_at: timestamptz

  """Verify webhook requests are from Twilio"""
  validate_signature: Boolean
  whatsapp_webhook_url: String
  working_hours: String
}

"""aggregate stddev on columns"""
type platform_settings_stddev_fields {
  """AI temperature setting (0-1)"""
  ai_temperature: Float

  """Maid availability cache refresh interval in minutes"""
  cache_timeout: Float

  """Number of previous messages included in AI context (5-50)"""
  max_context_messages: Float

  """Maximum length of AI responses (256-4096)"""
  max_tokens: Float

  """Maximum messages per minute per phone number"""
  rate_limit: Float

  """Timeout for webhook and AI requests (5-60 seconds)"""
  timeout: Float
}

"""aggregate stddev_pop on columns"""
type platform_settings_stddev_pop_fields {
  """AI temperature setting (0-1)"""
  ai_temperature: Float

  """Maid availability cache refresh interval in minutes"""
  cache_timeout: Float

  """Number of previous messages included in AI context (5-50)"""
  max_context_messages: Float

  """Maximum length of AI responses (256-4096)"""
  max_tokens: Float

  """Maximum messages per minute per phone number"""
  rate_limit: Float

  """Timeout for webhook and AI requests (5-60 seconds)"""
  timeout: Float
}

"""aggregate stddev_samp on columns"""
type platform_settings_stddev_samp_fields {
  """AI temperature setting (0-1)"""
  ai_temperature: Float

  """Maid availability cache refresh interval in minutes"""
  cache_timeout: Float

  """Number of previous messages included in AI context (5-50)"""
  max_context_messages: Float

  """Maximum length of AI responses (256-4096)"""
  max_tokens: Float

  """Maximum messages per minute per phone number"""
  rate_limit: Float

  """Timeout for webhook and AI requests (5-60 seconds)"""
  timeout: Float
}

"""
Streaming cursor of the table "platform_settings"
"""
input platform_settings_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: platform_settings_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input platform_settings_stream_cursor_value_input {
  about_platform: String

  """Claude model to use for AI responses"""
  ai_model: String

  """AI temperature setting (0-1)"""
  ai_temperature: numeric

  """Whitelist of allowed phone numbers (newline-separated)"""
  allowed_numbers: String

  """Auto-send confirmation when booking is confirmed"""
  auto_confirm_bookings: Boolean

  """Automatically respond to incoming messages"""
  auto_response_enabled: Boolean

  """Array of available services"""
  available_services: [String!]

  """Blacklist of blocked phone numbers (newline-separated)"""
  blocked_numbers: String

  """Only respond during working hours"""
  business_hours_only: Boolean

  """Maid availability cache refresh interval in minutes"""
  cache_timeout: Int
  created_at: timestamptz

  """Log detailed information for troubleshooting"""
  debug_mode: Boolean

  """Message sent when an error occurs"""
  error_message: String

  """Default greeting message"""
  greeting_message: String
  id: uuid

  """Number of previous messages included in AI context (5-50)"""
  max_context_messages: Int

  """Maximum length of AI responses (256-4096)"""
  max_tokens: Int

  """Email address for receiving notifications"""
  notification_email: String

  """Notify when bookings are created/updated"""
  notify_bookings: Boolean

  """Notify when webhook/AI errors occur"""
  notify_errors: Boolean

  """Notify admins of new WhatsApp messages"""
  notify_new_messages: Boolean

  """Message sent when outside business hours"""
  offline_message: String
  platform_name: String

  """Maximum messages per minute per phone number"""
  rate_limit: Int

  """Enable rate limiting per phone number"""
  rate_limiting_enabled: Boolean

  """Request feedback after completed bookings"""
  send_followups: Boolean

  """Send reminders 24 hours before booking"""
  send_reminders: Boolean

  """Save full AI response data for analysis"""
  store_ai_responses: Boolean
  support_email: String
  support_phone: String

  """Custom system prompt appended to base instructions"""
  system_prompt: String

  """Timeout for webhook and AI requests (5-60 seconds)"""
  timeout: Int
  updated_at: timestamptz

  """Verify webhook requests are from Twilio"""
  validate_signature: Boolean
  whatsapp_webhook_url: String
  working_hours: String
}

"""aggregate sum on columns"""
type platform_settings_sum_fields {
  """AI temperature setting (0-1)"""
  ai_temperature: numeric

  """Maid availability cache refresh interval in minutes"""
  cache_timeout: Int

  """Number of previous messages included in AI context (5-50)"""
  max_context_messages: Int

  """Maximum length of AI responses (256-4096)"""
  max_tokens: Int

  """Maximum messages per minute per phone number"""
  rate_limit: Int

  """Timeout for webhook and AI requests (5-60 seconds)"""
  timeout: Int
}

"""
update columns of table "platform_settings"
"""
enum platform_settings_update_column {
  """column name"""
  about_platform

  """column name"""
  ai_model

  """column name"""
  ai_temperature

  """column name"""
  allowed_numbers

  """column name"""
  auto_confirm_bookings

  """column name"""
  auto_response_enabled

  """column name"""
  available_services

  """column name"""
  blocked_numbers

  """column name"""
  business_hours_only

  """column name"""
  cache_timeout

  """column name"""
  created_at

  """column name"""
  debug_mode

  """column name"""
  error_message

  """column name"""
  greeting_message

  """column name"""
  id

  """column name"""
  max_context_messages

  """column name"""
  max_tokens

  """column name"""
  notification_email

  """column name"""
  notify_bookings

  """column name"""
  notify_errors

  """column name"""
  notify_new_messages

  """column name"""
  offline_message

  """column name"""
  platform_name

  """column name"""
  rate_limit

  """column name"""
  rate_limiting_enabled

  """column name"""
  send_followups

  """column name"""
  send_reminders

  """column name"""
  store_ai_responses

  """column name"""
  support_email

  """column name"""
  support_phone

  """column name"""
  system_prompt

  """column name"""
  timeout

  """column name"""
  updated_at

  """column name"""
  validate_signature

  """column name"""
  whatsapp_webhook_url

  """column name"""
  working_hours
}

input platform_settings_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: platform_settings_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: platform_settings_set_input

  """filter the rows which have to be updated"""
  where: platform_settings_bool_exp!
}

"""aggregate var_pop on columns"""
type platform_settings_var_pop_fields {
  """AI temperature setting (0-1)"""
  ai_temperature: Float

  """Maid availability cache refresh interval in minutes"""
  cache_timeout: Float

  """Number of previous messages included in AI context (5-50)"""
  max_context_messages: Float

  """Maximum length of AI responses (256-4096)"""
  max_tokens: Float

  """Maximum messages per minute per phone number"""
  rate_limit: Float

  """Timeout for webhook and AI requests (5-60 seconds)"""
  timeout: Float
}

"""aggregate var_samp on columns"""
type platform_settings_var_samp_fields {
  """AI temperature setting (0-1)"""
  ai_temperature: Float

  """Maid availability cache refresh interval in minutes"""
  cache_timeout: Float

  """Number of previous messages included in AI context (5-50)"""
  max_context_messages: Float

  """Maximum length of AI responses (256-4096)"""
  max_tokens: Float

  """Maximum messages per minute per phone number"""
  rate_limit: Float

  """Timeout for webhook and AI requests (5-60 seconds)"""
  timeout: Float
}

"""aggregate variance on columns"""
type platform_settings_variance_fields {
  """AI temperature setting (0-1)"""
  ai_temperature: Float

  """Maid availability cache refresh interval in minutes"""
  cache_timeout: Float

  """Number of previous messages included in AI context (5-50)"""
  max_context_messages: Float

  """Maximum length of AI responses (256-4096)"""
  max_tokens: Float

  """Maximum messages per minute per phone number"""
  rate_limit: Float

  """Timeout for webhook and AI requests (5-60 seconds)"""
  timeout: Float
}

"""
columns and relationships of "profiles"
"""
type profiles {
  active_requests: Int

  """An object relationship"""
  agency_profile: agency_profiles
  available: Boolean
  avatar_url: String
  country: String
  created_at: timestamptz
  email: String!
  employment_history_length: Int
  hired_maids: Int
  id: String!
  is_active: Boolean
  last_seen: timestamptz
  location: String

  """An object relationship"""
  maid_profile: maid_profiles
  full_name: String
  phone: String
  phone_verification_attempts: Int
  phone_verification_last_attempt: timestamptz
  phone_verified: Boolean
  phone_verified_at: timestamptz
  preferred_language: [String!]

  """Profile completion percentage (0-100)"""
  profile_completion: Int

  """User rating (0-5 stars)"""
  rating: numeric
  registration_complete: Boolean

  """An object relationship"""
  sponsor_profile: sponsor_profiles

  """Subscription tier: basic, premium, or enterprise"""
  subscription_status: String
  total_reviews: Int
  total_spent: numeric

  """Trust score calculated by platform (0-100)"""
  trust_score: Int
  updated_at: timestamptz
  user_type: String!

  """Admin verification status: pending, verified, or rejected"""
  verification_status: String
  years_experience: Int
}

"""
aggregated selection of "profiles"
"""
type profiles_aggregate {
  aggregate: profiles_aggregate_fields
  nodes: [profiles!]!
}

"""
aggregate fields of "profiles"
"""
type profiles_aggregate_fields {
  avg: profiles_avg_fields
  count(columns: [profiles_select_column!], distinct: Boolean): Int!
  max: profiles_max_fields
  min: profiles_min_fields
  stddev: profiles_stddev_fields
  stddev_pop: profiles_stddev_pop_fields
  stddev_samp: profiles_stddev_samp_fields
  sum: profiles_sum_fields
  var_pop: profiles_var_pop_fields
  var_samp: profiles_var_samp_fields
  variance: profiles_variance_fields
}

"""aggregate avg on columns"""
type profiles_avg_fields {
  active_requests: Float
  employment_history_length: Float
  hired_maids: Float
  phone_verification_attempts: Float

  """Profile completion percentage (0-100)"""
  profile_completion: Float

  """User rating (0-5 stars)"""
  rating: Float
  total_reviews: Float
  total_spent: Float

  """Trust score calculated by platform (0-100)"""
  trust_score: Float
  years_experience: Float
}

"""
Boolean expression to filter rows from the table "profiles". All fields are combined with a logical 'AND'.
"""
input profiles_bool_exp {
  _and: [profiles_bool_exp!]
  _not: profiles_bool_exp
  _or: [profiles_bool_exp!]
  active_requests: Int_comparison_exp
  agency_profile: agency_profiles_bool_exp
  available: Boolean_comparison_exp
  avatar_url: String_comparison_exp
  country: String_comparison_exp
  created_at: timestamptz_comparison_exp
  email: String_comparison_exp
  employment_history_length: Int_comparison_exp
  hired_maids: Int_comparison_exp
  id: String_comparison_exp
  is_active: Boolean_comparison_exp
  last_seen: timestamptz_comparison_exp
  location: String_comparison_exp
  maid_profile: maid_profiles_bool_exp
  full_name: String_comparison_exp
  phone: String_comparison_exp
  phone_verification_attempts: Int_comparison_exp
  phone_verification_last_attempt: timestamptz_comparison_exp
  phone_verified: Boolean_comparison_exp
  phone_verified_at: timestamptz_comparison_exp
  preferred_language: String_array_comparison_exp
  profile_completion: Int_comparison_exp
  rating: numeric_comparison_exp
  registration_complete: Boolean_comparison_exp
  sponsor_profile: sponsor_profiles_bool_exp
  subscription_status: String_comparison_exp
  total_reviews: Int_comparison_exp
  total_spent: numeric_comparison_exp
  trust_score: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_type: String_comparison_exp
  verification_status: String_comparison_exp
  years_experience: Int_comparison_exp
}

"""
unique or primary key constraints on table "profiles"
"""
enum profiles_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  profiles_pkey
}

"""
input type for incrementing numeric columns in table "profiles"
"""
input profiles_inc_input {
  active_requests: Int
  employment_history_length: Int
  hired_maids: Int
  phone_verification_attempts: Int

  """Profile completion percentage (0-100)"""
  profile_completion: Int

  """User rating (0-5 stars)"""
  rating: numeric
  total_reviews: Int
  total_spent: numeric

  """Trust score calculated by platform (0-100)"""
  trust_score: Int
  years_experience: Int
}

"""
input type for inserting data into table "profiles"
"""
input profiles_insert_input {
  active_requests: Int
  agency_profile: agency_profiles_obj_rel_insert_input
  available: Boolean
  avatar_url: String
  country: String
  created_at: timestamptz
  email: String
  employment_history_length: Int
  hired_maids: Int
  id: String
  is_active: Boolean
  last_seen: timestamptz
  location: String
  maid_profile: maid_profiles_obj_rel_insert_input
  full_name: String
  phone: String
  phone_verification_attempts: Int
  phone_verification_last_attempt: timestamptz
  phone_verified: Boolean
  phone_verified_at: timestamptz
  preferred_language: [String!]

  """Profile completion percentage (0-100)"""
  profile_completion: Int

  """User rating (0-5 stars)"""
  rating: numeric
  registration_complete: Boolean
  sponsor_profile: sponsor_profiles_obj_rel_insert_input

  """Subscription tier: basic, premium, or enterprise"""
  subscription_status: String
  total_reviews: Int
  total_spent: numeric

  """Trust score calculated by platform (0-100)"""
  trust_score: Int
  updated_at: timestamptz
  user_type: String

  """Admin verification status: pending, verified, or rejected"""
  verification_status: String
  years_experience: Int
}

"""aggregate max on columns"""
type profiles_max_fields {
  active_requests: Int
  avatar_url: String
  country: String
  created_at: timestamptz
  email: String
  employment_history_length: Int
  hired_maids: Int
  id: String
  last_seen: timestamptz
  location: String
  name: String
  phone: String
  phone_verification_attempts: Int
  phone_verification_last_attempt: timestamptz
  phone_verified_at: timestamptz
  preferred_language: [String!]

  """Profile completion percentage (0-100)"""
  profile_completion: Int

  """User rating (0-5 stars)"""
  rating: numeric

  """Subscription tier: basic, premium, or enterprise"""
  subscription_status: String
  total_reviews: Int
  total_spent: numeric

  """Trust score calculated by platform (0-100)"""
  trust_score: Int
  updated_at: timestamptz
  user_type: String

  """Admin verification status: pending, verified, or rejected"""
  verification_status: String
  years_experience: Int
}

"""aggregate min on columns"""
type profiles_min_fields {
  active_requests: Int
  avatar_url: String
  country: String
  created_at: timestamptz
  email: String
  employment_history_length: Int
  hired_maids: Int
  id: String
  last_seen: timestamptz
  location: String
  name: String
  phone: String
  phone_verification_attempts: Int
  phone_verification_last_attempt: timestamptz
  phone_verified_at: timestamptz
  preferred_language: [String!]

  """Profile completion percentage (0-100)"""
  profile_completion: Int

  """User rating (0-5 stars)"""
  rating: numeric

  """Subscription tier: basic, premium, or enterprise"""
  subscription_status: String
  total_reviews: Int
  total_spent: numeric

  """Trust score calculated by platform (0-100)"""
  trust_score: Int
  updated_at: timestamptz
  user_type: String

  """Admin verification status: pending, verified, or rejected"""
  verification_status: String
  years_experience: Int
}

"""
response of any mutation on the table "profiles"
"""
type profiles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [profiles!]!
}

"""
input type for inserting object relation for remote table "profiles"
"""
input profiles_obj_rel_insert_input {
  data: profiles_insert_input!

  """upsert condition"""
  on_conflict: profiles_on_conflict
}

"""
on_conflict condition type for table "profiles"
"""
input profiles_on_conflict {
  constraint: profiles_constraint!
  update_columns: [profiles_update_column!]! = []
  where: profiles_bool_exp
}

"""Ordering options when selecting data from "profiles"."""
input profiles_order_by {
  active_requests: order_by
  agency_profile: agency_profiles_order_by
  available: order_by
  avatar_url: order_by
  country: order_by
  created_at: order_by
  email: order_by
  employment_history_length: order_by
  hired_maids: order_by
  id: order_by
  is_active: order_by
  last_seen: order_by
  location: order_by
  maid_profile: maid_profiles_order_by
  full_name: order_by
  phone: order_by
  phone_verification_attempts: order_by
  phone_verification_last_attempt: order_by
  phone_verified: order_by
  phone_verified_at: order_by
  preferred_language: order_by
  profile_completion: order_by
  rating: order_by
  registration_complete: order_by
  sponsor_profile: sponsor_profiles_order_by
  subscription_status: order_by
  total_reviews: order_by
  total_spent: order_by
  trust_score: order_by
  updated_at: order_by
  user_type: order_by
  verification_status: order_by
  years_experience: order_by
}

"""primary key columns input for table: profiles"""
input profiles_pk_columns_input {
  id: String!
}

"""
select columns of table "profiles"
"""
enum profiles_select_column {
  """column name"""
  active_requests

  """column name"""
  available

  """column name"""
  avatar_url

  """column name"""
  country

  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  employment_history_length

  """column name"""
  hired_maids

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  last_seen

  """column name"""
  location

  """column name"""
  full_name

  """column name"""
  phone

  """column name"""
  phone_verification_attempts

  """column name"""
  phone_verification_last_attempt

  """column name"""
  phone_verified

  """column name"""
  phone_verified_at

  """column name"""
  preferred_language

  """column name"""
  profile_completion

  """column name"""
  rating

  """column name"""
  registration_complete

  """column name"""
  subscription_status

  """column name"""
  total_reviews

  """column name"""
  total_spent

  """column name"""
  trust_score

  """column name"""
  updated_at

  """column name"""
  user_type

  """column name"""
  verification_status

  """column name"""
  years_experience
}

"""
input type for updating data in table "profiles"
"""
input profiles_set_input {
  active_requests: Int
  available: Boolean
  avatar_url: String
  country: String
  created_at: timestamptz
  email: String
  employment_history_length: Int
  hired_maids: Int
  id: String
  is_active: Boolean
  last_seen: timestamptz
  location: String
  full_name: String
  phone: String
  phone_verification_attempts: Int
  phone_verification_last_attempt: timestamptz
  phone_verified: Boolean
  phone_verified_at: timestamptz
  preferred_language: [String!]

  """Profile completion percentage (0-100)"""
  profile_completion: Int

  """User rating (0-5 stars)"""
  rating: numeric
  registration_complete: Boolean

  """Subscription tier: basic, premium, or enterprise"""
  subscription_status: String
  total_reviews: Int
  total_spent: numeric

  """Trust score calculated by platform (0-100)"""
  trust_score: Int
  updated_at: timestamptz
  user_type: String

  """Admin verification status: pending, verified, or rejected"""
  verification_status: String
  years_experience: Int
}

"""aggregate stddev on columns"""
type profiles_stddev_fields {
  active_requests: Float
  employment_history_length: Float
  hired_maids: Float
  phone_verification_attempts: Float

  """Profile completion percentage (0-100)"""
  profile_completion: Float

  """User rating (0-5 stars)"""
  rating: Float
  total_reviews: Float
  total_spent: Float

  """Trust score calculated by platform (0-100)"""
  trust_score: Float
  years_experience: Float
}

"""aggregate stddev_pop on columns"""
type profiles_stddev_pop_fields {
  active_requests: Float
  employment_history_length: Float
  hired_maids: Float
  phone_verification_attempts: Float

  """Profile completion percentage (0-100)"""
  profile_completion: Float

  """User rating (0-5 stars)"""
  rating: Float
  total_reviews: Float
  total_spent: Float

  """Trust score calculated by platform (0-100)"""
  trust_score: Float
  years_experience: Float
}

"""aggregate stddev_samp on columns"""
type profiles_stddev_samp_fields {
  active_requests: Float
  employment_history_length: Float
  hired_maids: Float
  phone_verification_attempts: Float

  """Profile completion percentage (0-100)"""
  profile_completion: Float

  """User rating (0-5 stars)"""
  rating: Float
  total_reviews: Float
  total_spent: Float

  """Trust score calculated by platform (0-100)"""
  trust_score: Float
  years_experience: Float
}

"""
Streaming cursor of the table "profiles"
"""
input profiles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: profiles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input profiles_stream_cursor_value_input {
  active_requests: Int
  available: Boolean
  avatar_url: String
  country: String
  created_at: timestamptz
  email: String
  employment_history_length: Int
  hired_maids: Int
  id: String
  is_active: Boolean
  last_seen: timestamptz
  location: String
  name: String
  phone: String
  phone_verification_attempts: Int
  phone_verification_last_attempt: timestamptz
  phone_verified: Boolean
  phone_verified_at: timestamptz
  preferred_language: [String!]

  """Profile completion percentage (0-100)"""
  profile_completion: Int

  """User rating (0-5 stars)"""
  rating: numeric
  registration_complete: Boolean

  """Subscription tier: basic, premium, or enterprise"""
  subscription_status: String
  total_reviews: Int
  total_spent: numeric

  """Trust score calculated by platform (0-100)"""
  trust_score: Int
  updated_at: timestamptz
  user_type: String

  """Admin verification status: pending, verified, or rejected"""
  verification_status: String
  years_experience: Int
}

"""aggregate sum on columns"""
type profiles_sum_fields {
  active_requests: Int
  employment_history_length: Int
  hired_maids: Int
  phone_verification_attempts: Int

  """Profile completion percentage (0-100)"""
  profile_completion: Int

  """User rating (0-5 stars)"""
  rating: numeric
  total_reviews: Int
  total_spent: numeric

  """Trust score calculated by platform (0-100)"""
  trust_score: Int
  years_experience: Int
}

"""
update columns of table "profiles"
"""
enum profiles_update_column {
  """column name"""
  active_requests

  """column name"""
  available

  """column name"""
  avatar_url

  """column name"""
  country

  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  employment_history_length

  """column name"""
  hired_maids

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  last_seen

  """column name"""
  location

  """column name"""
  full_name

  """column name"""
  phone

  """column name"""
  phone_verification_attempts

  """column name"""
  phone_verification_last_attempt

  """column name"""
  phone_verified

  """column name"""
  phone_verified_at

  """column name"""
  preferred_language

  """column name"""
  profile_completion

  """column name"""
  rating

  """column name"""
  registration_complete

  """column name"""
  subscription_status

  """column name"""
  total_reviews

  """column name"""
  total_spent

  """column name"""
  trust_score

  """column name"""
  updated_at

  """column name"""
  user_type

  """column name"""
  verification_status

  """column name"""
  years_experience
}

input profiles_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: profiles_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: profiles_set_input

  """filter the rows which have to be updated"""
  where: profiles_bool_exp!
}

"""aggregate var_pop on columns"""
type profiles_var_pop_fields {
  active_requests: Float
  employment_history_length: Float
  hired_maids: Float
  phone_verification_attempts: Float

  """Profile completion percentage (0-100)"""
  profile_completion: Float

  """User rating (0-5 stars)"""
  rating: Float
  total_reviews: Float
  total_spent: Float

  """Trust score calculated by platform (0-100)"""
  trust_score: Float
  years_experience: Float
}

"""aggregate var_samp on columns"""
type profiles_var_samp_fields {
  active_requests: Float
  employment_history_length: Float
  hired_maids: Float
  phone_verification_attempts: Float

  """Profile completion percentage (0-100)"""
  profile_completion: Float

  """User rating (0-5 stars)"""
  rating: Float
  total_reviews: Float
  total_spent: Float

  """Trust score calculated by platform (0-100)"""
  trust_score: Float
  years_experience: Float
}

"""aggregate variance on columns"""
type profiles_variance_fields {
  active_requests: Float
  employment_history_length: Float
  hired_maids: Float
  phone_verification_attempts: Float

  """Profile completion percentage (0-100)"""
  profile_completion: Float

  """User rating (0-5 stars)"""
  rating: Float
  total_reviews: Float
  total_spent: Float

  """Trust score calculated by platform (0-100)"""
  trust_score: Float
  years_experience: Float
}

type query_root {
  """
  fetch data from the table: "activity_announcements"
  """
  activity_announcements(
    """distinct select on columns"""
    distinct_on: [activity_announcements_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [activity_announcements_order_by!]

    """filter the rows returned"""
    where: activity_announcements_bool_exp
  ): [activity_announcements!]!

  """
  fetch aggregated fields from the table: "activity_announcements"
  """
  activity_announcements_aggregate(
    """distinct select on columns"""
    distinct_on: [activity_announcements_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [activity_announcements_order_by!]

    """filter the rows returned"""
    where: activity_announcements_bool_exp
  ): activity_announcements_aggregate!

  """
  fetch data from the table: "activity_announcements" using primary key columns
  """
  activity_announcements_by_pk(id: uuid!): activity_announcements

  """
  fetch data from the table: "activity_log"
  """
  activity_log(
    """distinct select on columns"""
    distinct_on: [activity_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [activity_log_order_by!]

    """filter the rows returned"""
    where: activity_log_bool_exp
  ): [activity_log!]!

  """
  fetch aggregated fields from the table: "activity_log"
  """
  activity_log_aggregate(
    """distinct select on columns"""
    distinct_on: [activity_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [activity_log_order_by!]

    """filter the rows returned"""
    where: activity_log_bool_exp
  ): activity_log_aggregate!

  """fetch data from the table: "activity_log" using primary key columns"""
  activity_log_by_pk(id: uuid!): activity_log

  """An array relationship"""
  admin_activity_logs(
    """distinct select on columns"""
    distinct_on: [admin_activity_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_activity_logs_order_by!]

    """filter the rows returned"""
    where: admin_activity_logs_bool_exp
  ): [admin_activity_logs!]!

  """An aggregate relationship"""
  admin_activity_logs_aggregate(
    """distinct select on columns"""
    distinct_on: [admin_activity_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_activity_logs_order_by!]

    """filter the rows returned"""
    where: admin_activity_logs_bool_exp
  ): admin_activity_logs_aggregate!

  """
  fetch data from the table: "admin_activity_logs" using primary key columns
  """
  admin_activity_logs_by_pk(id: uuid!): admin_activity_logs

  """An array relationship"""
  admin_users(
    """distinct select on columns"""
    distinct_on: [admin_users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_users_order_by!]

    """filter the rows returned"""
    where: admin_users_bool_exp
  ): [admin_users!]!

  """An aggregate relationship"""
  admin_users_aggregate(
    """distinct select on columns"""
    distinct_on: [admin_users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_users_order_by!]

    """filter the rows returned"""
    where: admin_users_bool_exp
  ): admin_users_aggregate!

  """fetch data from the table: "admin_users" using primary key columns"""
  admin_users_by_pk(id: uuid!): admin_users

  """
  fetch data from the table: "agency_audit_logs"
  """
  agency_audit_logs(
    """distinct select on columns"""
    distinct_on: [agency_audit_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_audit_logs_order_by!]

    """filter the rows returned"""
    where: agency_audit_logs_bool_exp
  ): [agency_audit_logs!]!

  """
  fetch aggregated fields from the table: "agency_audit_logs"
  """
  agency_audit_logs_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_audit_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_audit_logs_order_by!]

    """filter the rows returned"""
    where: agency_audit_logs_bool_exp
  ): agency_audit_logs_aggregate!

  """
  fetch data from the table: "agency_audit_logs" using primary key columns
  """
  agency_audit_logs_by_pk(id: uuid!): agency_audit_logs

  """
  fetch data from the table: "agency_credits"
  """
  agency_credits(
    """distinct select on columns"""
    distinct_on: [agency_credits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_credits_order_by!]

    """filter the rows returned"""
    where: agency_credits_bool_exp
  ): [agency_credits!]!

  """
  fetch aggregated fields from the table: "agency_credits"
  """
  agency_credits_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_credits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_credits_order_by!]

    """filter the rows returned"""
    where: agency_credits_bool_exp
  ): agency_credits_aggregate!

  """fetch data from the table: "agency_credits" using primary key columns"""
  agency_credits_by_pk(id: uuid!): agency_credits

  """
  fetch data from the table: "agency_disputes"
  """
  agency_disputes(
    """distinct select on columns"""
    distinct_on: [agency_disputes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_disputes_order_by!]

    """filter the rows returned"""
    where: agency_disputes_bool_exp
  ): [agency_disputes!]!

  """
  fetch aggregated fields from the table: "agency_disputes"
  """
  agency_disputes_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_disputes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_disputes_order_by!]

    """filter the rows returned"""
    where: agency_disputes_bool_exp
  ): agency_disputes_aggregate!

  """fetch data from the table: "agency_disputes" using primary key columns"""
  agency_disputes_by_pk(id: uuid!): agency_disputes

  """
  fetch data from the table: "agency_document_requirements"
  """
  agency_document_requirements(
    """distinct select on columns"""
    distinct_on: [agency_document_requirements_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_document_requirements_order_by!]

    """filter the rows returned"""
    where: agency_document_requirements_bool_exp
  ): [agency_document_requirements!]!

  """
  fetch aggregated fields from the table: "agency_document_requirements"
  """
  agency_document_requirements_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_document_requirements_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_document_requirements_order_by!]

    """filter the rows returned"""
    where: agency_document_requirements_bool_exp
  ): agency_document_requirements_aggregate!

  """
  fetch data from the table: "agency_document_requirements" using primary key columns
  """
  agency_document_requirements_by_pk(id: uuid!): agency_document_requirements

  """
  fetch data from the table: "agency_documents"
  """
  agency_documents(
    """distinct select on columns"""
    distinct_on: [agency_documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_documents_order_by!]

    """filter the rows returned"""
    where: agency_documents_bool_exp
  ): [agency_documents!]!

  """
  fetch aggregated fields from the table: "agency_documents"
  """
  agency_documents_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_documents_order_by!]

    """filter the rows returned"""
    where: agency_documents_bool_exp
  ): agency_documents_aggregate!

  """
  fetch data from the table: "agency_documents" using primary key columns
  """
  agency_documents_by_pk(id: uuid!): agency_documents

  """An array relationship"""
  agency_earnings(
    """distinct select on columns"""
    distinct_on: [agency_earnings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_earnings_order_by!]

    """filter the rows returned"""
    where: agency_earnings_bool_exp
  ): [agency_earnings!]!

  """An aggregate relationship"""
  agency_earnings_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_earnings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_earnings_order_by!]

    """filter the rows returned"""
    where: agency_earnings_bool_exp
  ): agency_earnings_aggregate!

  """fetch data from the table: "agency_earnings" using primary key columns"""
  agency_earnings_by_pk(id: uuid!): agency_earnings

  """An array relationship"""
  agency_interviews(
    """distinct select on columns"""
    distinct_on: [agency_interviews_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_interviews_order_by!]

    """filter the rows returned"""
    where: agency_interviews_bool_exp
  ): [agency_interviews!]!

  """An aggregate relationship"""
  agency_interviews_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_interviews_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_interviews_order_by!]

    """filter the rows returned"""
    where: agency_interviews_bool_exp
  ): agency_interviews_aggregate!

  """
  fetch data from the table: "agency_interviews" using primary key columns
  """
  agency_interviews_by_pk(id: uuid!): agency_interviews

  """
  fetch data from the table: "agency_jobs"
  """
  agency_jobs(
    """distinct select on columns"""
    distinct_on: [agency_jobs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_jobs_order_by!]

    """filter the rows returned"""
    where: agency_jobs_bool_exp
  ): [agency_jobs!]!

  """
  fetch aggregated fields from the table: "agency_jobs"
  """
  agency_jobs_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_jobs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_jobs_order_by!]

    """filter the rows returned"""
    where: agency_jobs_bool_exp
  ): agency_jobs_aggregate!

  """fetch data from the table: "agency_jobs" using primary key columns"""
  agency_jobs_by_pk(id: uuid!): agency_jobs

  """
  fetch data from the table: "agency_kyb_audit_log"
  """
  agency_kyb_audit_log(
    """distinct select on columns"""
    distinct_on: [agency_kyb_audit_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_kyb_audit_log_order_by!]

    """filter the rows returned"""
    where: agency_kyb_audit_log_bool_exp
  ): [agency_kyb_audit_log!]!

  """
  fetch aggregated fields from the table: "agency_kyb_audit_log"
  """
  agency_kyb_audit_log_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_kyb_audit_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_kyb_audit_log_order_by!]

    """filter the rows returned"""
    where: agency_kyb_audit_log_bool_exp
  ): agency_kyb_audit_log_aggregate!

  """
  fetch data from the table: "agency_kyb_audit_log" using primary key columns
  """
  agency_kyb_audit_log_by_pk(id: uuid!): agency_kyb_audit_log

  """An array relationship"""
  agency_kyb_documents(
    """distinct select on columns"""
    distinct_on: [agency_kyb_documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_kyb_documents_order_by!]

    """filter the rows returned"""
    where: agency_kyb_documents_bool_exp
  ): [agency_kyb_documents!]!

  """An aggregate relationship"""
  agency_kyb_documents_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_kyb_documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_kyb_documents_order_by!]

    """filter the rows returned"""
    where: agency_kyb_documents_bool_exp
  ): agency_kyb_documents_aggregate!

  """
  fetch data from the table: "agency_kyb_documents" using primary key columns
  """
  agency_kyb_documents_by_pk(id: uuid!): agency_kyb_documents

  """
  fetch data from the table: "agency_kyb_verification"
  """
  agency_kyb_verification(
    """distinct select on columns"""
    distinct_on: [agency_kyb_verification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_kyb_verification_order_by!]

    """filter the rows returned"""
    where: agency_kyb_verification_bool_exp
  ): [agency_kyb_verification!]!

  """
  fetch aggregated fields from the table: "agency_kyb_verification"
  """
  agency_kyb_verification_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_kyb_verification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_kyb_verification_order_by!]

    """filter the rows returned"""
    where: agency_kyb_verification_bool_exp
  ): agency_kyb_verification_aggregate!

  """
  fetch data from the table: "agency_kyb_verification" using primary key columns
  """
  agency_kyb_verification_by_pk(id: uuid!): agency_kyb_verification

  """
  fetch data from the table: "agency_payment_failures"
  """
  agency_payment_failures(
    """distinct select on columns"""
    distinct_on: [agency_payment_failures_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_payment_failures_order_by!]

    """filter the rows returned"""
    where: agency_payment_failures_bool_exp
  ): [agency_payment_failures!]!

  """
  fetch aggregated fields from the table: "agency_payment_failures"
  """
  agency_payment_failures_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_payment_failures_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_payment_failures_order_by!]

    """filter the rows returned"""
    where: agency_payment_failures_bool_exp
  ): agency_payment_failures_aggregate!

  """
  fetch data from the table: "agency_payment_failures" using primary key columns
  """
  agency_payment_failures_by_pk(id: uuid!): agency_payment_failures

  """
  fetch data from the table: "agency_payouts"
  """
  agency_payouts(
    """distinct select on columns"""
    distinct_on: [agency_payouts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_payouts_order_by!]

    """filter the rows returned"""
    where: agency_payouts_bool_exp
  ): [agency_payouts!]!

  """
  fetch aggregated fields from the table: "agency_payouts"
  """
  agency_payouts_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_payouts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_payouts_order_by!]

    """filter the rows returned"""
    where: agency_payouts_bool_exp
  ): agency_payouts_aggregate!

  """fetch data from the table: "agency_payouts" using primary key columns"""
  agency_payouts_by_pk(id: uuid!): agency_payouts

  """An array relationship"""
  agency_placements(
    """distinct select on columns"""
    distinct_on: [agency_placements_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_placements_order_by!]

    """filter the rows returned"""
    where: agency_placements_bool_exp
  ): [agency_placements!]!

  """An aggregate relationship"""
  agency_placements_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_placements_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_placements_order_by!]

    """filter the rows returned"""
    where: agency_placements_bool_exp
  ): agency_placements_aggregate!

  """
  fetch data from the table: "agency_placements" using primary key columns
  """
  agency_placements_by_pk(id: uuid!): agency_placements

  """
  fetch data from the table: "agency_profiles"
  """
  agency_profiles(
    """distinct select on columns"""
    distinct_on: [agency_profiles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_profiles_order_by!]

    """filter the rows returned"""
    where: agency_profiles_bool_exp
  ): [agency_profiles!]!

  """
  fetch aggregated fields from the table: "agency_profiles"
  """
  agency_profiles_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_profiles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_profiles_order_by!]

    """filter the rows returned"""
    where: agency_profiles_bool_exp
  ): agency_profiles_aggregate!

  """fetch data from the table: "agency_profiles" using primary key columns"""
  agency_profiles_by_pk(id: String!): agency_profiles

  """
  fetch data from the table: "agency_tasks"
  """
  agency_tasks(
    """distinct select on columns"""
    distinct_on: [agency_tasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_tasks_order_by!]

    """filter the rows returned"""
    where: agency_tasks_bool_exp
  ): [agency_tasks!]!

  """
  fetch aggregated fields from the table: "agency_tasks"
  """
  agency_tasks_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_tasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_tasks_order_by!]

    """filter the rows returned"""
    where: agency_tasks_bool_exp
  ): agency_tasks_aggregate!

  """fetch data from the table: "agency_tasks" using primary key columns"""
  agency_tasks_by_pk(id: uuid!): agency_tasks

  """
  fetch data from the table: "agency_team_members"
  """
  agency_team_members(
    """distinct select on columns"""
    distinct_on: [agency_team_members_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_team_members_order_by!]

    """filter the rows returned"""
    where: agency_team_members_bool_exp
  ): [agency_team_members!]!

  """
  fetch aggregated fields from the table: "agency_team_members"
  """
  agency_team_members_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_team_members_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_team_members_order_by!]

    """filter the rows returned"""
    where: agency_team_members_bool_exp
  ): agency_team_members_aggregate!

  """
  fetch data from the table: "agency_team_members" using primary key columns
  """
  agency_team_members_by_pk(id: uuid!): agency_team_members

  """
  fetch data from the table: "analytics_cache"
  """
  analytics_cache(
    """distinct select on columns"""
    distinct_on: [analytics_cache_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [analytics_cache_order_by!]

    """filter the rows returned"""
    where: analytics_cache_bool_exp
  ): [analytics_cache!]!

  """
  fetch aggregated fields from the table: "analytics_cache"
  """
  analytics_cache_aggregate(
    """distinct select on columns"""
    distinct_on: [analytics_cache_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [analytics_cache_order_by!]

    """filter the rows returned"""
    where: analytics_cache_bool_exp
  ): analytics_cache_aggregate!

  """fetch data from the table: "analytics_cache" using primary key columns"""
  analytics_cache_by_pk(id: uuid!): analytics_cache

  """
  fetch data from the table: "announcement_views"
  """
  announcement_views(
    """distinct select on columns"""
    distinct_on: [announcement_views_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [announcement_views_order_by!]

    """filter the rows returned"""
    where: announcement_views_bool_exp
  ): [announcement_views!]!

  """
  fetch aggregated fields from the table: "announcement_views"
  """
  announcement_views_aggregate(
    """distinct select on columns"""
    distinct_on: [announcement_views_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [announcement_views_order_by!]

    """filter the rows returned"""
    where: announcement_views_bool_exp
  ): announcement_views_aggregate!

  """
  fetch data from the table: "announcement_views" using primary key columns
  """
  announcement_views_by_pk(id: uuid!): announcement_views

  """An array relationship"""
  applications(
    """distinct select on columns"""
    distinct_on: [applications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [applications_order_by!]

    """filter the rows returned"""
    where: applications_bool_exp
  ): [applications!]!

  """An aggregate relationship"""
  applications_aggregate(
    """distinct select on columns"""
    distinct_on: [applications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [applications_order_by!]

    """filter the rows returned"""
    where: applications_bool_exp
  ): applications_aggregate!

  """fetch data from the table: "applications" using primary key columns"""
  applications_by_pk(id: uuid!): applications

  """
  fetch data from the table: "audit_logs"
  """
  audit_logs(
    """distinct select on columns"""
    distinct_on: [audit_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [audit_logs_order_by!]

    """filter the rows returned"""
    where: audit_logs_bool_exp
  ): [audit_logs!]!

  """
  fetch aggregated fields from the table: "audit_logs"
  """
  audit_logs_aggregate(
    """distinct select on columns"""
    distinct_on: [audit_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [audit_logs_order_by!]

    """filter the rows returned"""
    where: audit_logs_bool_exp
  ): audit_logs_aggregate!

  """fetch data from the table: "audit_logs" using primary key columns"""
  audit_logs_by_pk(id: uuid!): audit_logs

  """
  fetch data from the table: "auth.audit_log_entries"
  """
  auth_audit_log_entries(
    """distinct select on columns"""
    distinct_on: [auth_audit_log_entries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_audit_log_entries_order_by!]

    """filter the rows returned"""
    where: auth_audit_log_entries_bool_exp
  ): [auth_audit_log_entries!]!

  """
  fetch aggregated fields from the table: "auth.audit_log_entries"
  """
  auth_audit_log_entries_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_audit_log_entries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_audit_log_entries_order_by!]

    """filter the rows returned"""
    where: auth_audit_log_entries_bool_exp
  ): auth_audit_log_entries_aggregate!

  """
  fetch data from the table: "auth.audit_log_entries" using primary key columns
  """
  auth_audit_log_entries_by_pk(id: uuid!): auth_audit_log_entries

  """
  fetch data from the table: "auth.flow_state"
  """
  auth_flow_state(
    """distinct select on columns"""
    distinct_on: [auth_flow_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_flow_state_order_by!]

    """filter the rows returned"""
    where: auth_flow_state_bool_exp
  ): [auth_flow_state!]!

  """
  fetch aggregated fields from the table: "auth.flow_state"
  """
  auth_flow_state_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_flow_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_flow_state_order_by!]

    """filter the rows returned"""
    where: auth_flow_state_bool_exp
  ): auth_flow_state_aggregate!

  """fetch data from the table: "auth.flow_state" using primary key columns"""
  auth_flow_state_by_pk(id: uuid!): auth_flow_state

  """
  fetch data from the table: "auth.identities"
  """
  auth_identities(
    """distinct select on columns"""
    distinct_on: [auth_identities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_identities_order_by!]

    """filter the rows returned"""
    where: auth_identities_bool_exp
  ): [auth_identities!]!

  """
  fetch aggregated fields from the table: "auth.identities"
  """
  auth_identities_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_identities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_identities_order_by!]

    """filter the rows returned"""
    where: auth_identities_bool_exp
  ): auth_identities_aggregate!

  """fetch data from the table: "auth.identities" using primary key columns"""
  auth_identities_by_pk(id: uuid!): auth_identities

  """
  fetch data from the table: "auth.instances"
  """
  auth_instances(
    """distinct select on columns"""
    distinct_on: [auth_instances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_instances_order_by!]

    """filter the rows returned"""
    where: auth_instances_bool_exp
  ): [auth_instances!]!

  """
  fetch aggregated fields from the table: "auth.instances"
  """
  auth_instances_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_instances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_instances_order_by!]

    """filter the rows returned"""
    where: auth_instances_bool_exp
  ): auth_instances_aggregate!

  """fetch data from the table: "auth.instances" using primary key columns"""
  auth_instances_by_pk(id: uuid!): auth_instances

  """
  fetch data from the table: "auth.mfa_amr_claims"
  """
  auth_mfa_amr_claims(
    """distinct select on columns"""
    distinct_on: [auth_mfa_amr_claims_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_mfa_amr_claims_order_by!]

    """filter the rows returned"""
    where: auth_mfa_amr_claims_bool_exp
  ): [auth_mfa_amr_claims!]!

  """
  fetch aggregated fields from the table: "auth.mfa_amr_claims"
  """
  auth_mfa_amr_claims_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_mfa_amr_claims_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_mfa_amr_claims_order_by!]

    """filter the rows returned"""
    where: auth_mfa_amr_claims_bool_exp
  ): auth_mfa_amr_claims_aggregate!

  """
  fetch data from the table: "auth.mfa_amr_claims" using primary key columns
  """
  auth_mfa_amr_claims_by_pk(id: uuid!): auth_mfa_amr_claims

  """
  fetch data from the table: "auth.mfa_challenges"
  """
  auth_mfa_challenges(
    """distinct select on columns"""
    distinct_on: [auth_mfa_challenges_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_mfa_challenges_order_by!]

    """filter the rows returned"""
    where: auth_mfa_challenges_bool_exp
  ): [auth_mfa_challenges!]!

  """
  fetch aggregated fields from the table: "auth.mfa_challenges"
  """
  auth_mfa_challenges_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_mfa_challenges_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_mfa_challenges_order_by!]

    """filter the rows returned"""
    where: auth_mfa_challenges_bool_exp
  ): auth_mfa_challenges_aggregate!

  """
  fetch data from the table: "auth.mfa_challenges" using primary key columns
  """
  auth_mfa_challenges_by_pk(id: uuid!): auth_mfa_challenges

  """
  fetch data from the table: "auth.mfa_factors"
  """
  auth_mfa_factors(
    """distinct select on columns"""
    distinct_on: [auth_mfa_factors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_mfa_factors_order_by!]

    """filter the rows returned"""
    where: auth_mfa_factors_bool_exp
  ): [auth_mfa_factors!]!

  """
  fetch aggregated fields from the table: "auth.mfa_factors"
  """
  auth_mfa_factors_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_mfa_factors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_mfa_factors_order_by!]

    """filter the rows returned"""
    where: auth_mfa_factors_bool_exp
  ): auth_mfa_factors_aggregate!

  """
  fetch data from the table: "auth.mfa_factors" using primary key columns
  """
  auth_mfa_factors_by_pk(id: uuid!): auth_mfa_factors

  """
  fetch data from the table: "auth.oauth_authorizations"
  """
  auth_oauth_authorizations(
    """distinct select on columns"""
    distinct_on: [auth_oauth_authorizations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_oauth_authorizations_order_by!]

    """filter the rows returned"""
    where: auth_oauth_authorizations_bool_exp
  ): [auth_oauth_authorizations!]!

  """
  fetch aggregated fields from the table: "auth.oauth_authorizations"
  """
  auth_oauth_authorizations_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_oauth_authorizations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_oauth_authorizations_order_by!]

    """filter the rows returned"""
    where: auth_oauth_authorizations_bool_exp
  ): auth_oauth_authorizations_aggregate!

  """
  fetch data from the table: "auth.oauth_authorizations" using primary key columns
  """
  auth_oauth_authorizations_by_pk(id: uuid!): auth_oauth_authorizations

  """
  fetch data from the table: "auth.oauth_clients"
  """
  auth_oauth_clients(
    """distinct select on columns"""
    distinct_on: [auth_oauth_clients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_oauth_clients_order_by!]

    """filter the rows returned"""
    where: auth_oauth_clients_bool_exp
  ): [auth_oauth_clients!]!

  """
  fetch aggregated fields from the table: "auth.oauth_clients"
  """
  auth_oauth_clients_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_oauth_clients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_oauth_clients_order_by!]

    """filter the rows returned"""
    where: auth_oauth_clients_bool_exp
  ): auth_oauth_clients_aggregate!

  """
  fetch data from the table: "auth.oauth_clients" using primary key columns
  """
  auth_oauth_clients_by_pk(id: uuid!): auth_oauth_clients

  """
  fetch data from the table: "auth.oauth_consents"
  """
  auth_oauth_consents(
    """distinct select on columns"""
    distinct_on: [auth_oauth_consents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_oauth_consents_order_by!]

    """filter the rows returned"""
    where: auth_oauth_consents_bool_exp
  ): [auth_oauth_consents!]!

  """
  fetch aggregated fields from the table: "auth.oauth_consents"
  """
  auth_oauth_consents_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_oauth_consents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_oauth_consents_order_by!]

    """filter the rows returned"""
    where: auth_oauth_consents_bool_exp
  ): auth_oauth_consents_aggregate!

  """
  fetch data from the table: "auth.oauth_consents" using primary key columns
  """
  auth_oauth_consents_by_pk(id: uuid!): auth_oauth_consents

  """
  fetch data from the table: "auth.one_time_tokens"
  """
  auth_one_time_tokens(
    """distinct select on columns"""
    distinct_on: [auth_one_time_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_one_time_tokens_order_by!]

    """filter the rows returned"""
    where: auth_one_time_tokens_bool_exp
  ): [auth_one_time_tokens!]!

  """
  fetch aggregated fields from the table: "auth.one_time_tokens"
  """
  auth_one_time_tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_one_time_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_one_time_tokens_order_by!]

    """filter the rows returned"""
    where: auth_one_time_tokens_bool_exp
  ): auth_one_time_tokens_aggregate!

  """
  fetch data from the table: "auth.one_time_tokens" using primary key columns
  """
  auth_one_time_tokens_by_pk(id: uuid!): auth_one_time_tokens

  """
  fetch data from the table: "auth.refresh_tokens"
  """
  auth_refresh_tokens(
    """distinct select on columns"""
    distinct_on: [auth_refresh_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_refresh_tokens_order_by!]

    """filter the rows returned"""
    where: auth_refresh_tokens_bool_exp
  ): [auth_refresh_tokens!]!

  """
  fetch aggregated fields from the table: "auth.refresh_tokens"
  """
  auth_refresh_tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_refresh_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_refresh_tokens_order_by!]

    """filter the rows returned"""
    where: auth_refresh_tokens_bool_exp
  ): auth_refresh_tokens_aggregate!

  """
  fetch data from the table: "auth.refresh_tokens" using primary key columns
  """
  auth_refresh_tokens_by_pk(id: bigint!): auth_refresh_tokens

  """
  fetch data from the table: "auth.saml_providers"
  """
  auth_saml_providers(
    """distinct select on columns"""
    distinct_on: [auth_saml_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_saml_providers_order_by!]

    """filter the rows returned"""
    where: auth_saml_providers_bool_exp
  ): [auth_saml_providers!]!

  """
  fetch aggregated fields from the table: "auth.saml_providers"
  """
  auth_saml_providers_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_saml_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_saml_providers_order_by!]

    """filter the rows returned"""
    where: auth_saml_providers_bool_exp
  ): auth_saml_providers_aggregate!

  """
  fetch data from the table: "auth.saml_providers" using primary key columns
  """
  auth_saml_providers_by_pk(id: uuid!): auth_saml_providers

  """
  fetch data from the table: "auth.saml_relay_states"
  """
  auth_saml_relay_states(
    """distinct select on columns"""
    distinct_on: [auth_saml_relay_states_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_saml_relay_states_order_by!]

    """filter the rows returned"""
    where: auth_saml_relay_states_bool_exp
  ): [auth_saml_relay_states!]!

  """
  fetch aggregated fields from the table: "auth.saml_relay_states"
  """
  auth_saml_relay_states_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_saml_relay_states_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_saml_relay_states_order_by!]

    """filter the rows returned"""
    where: auth_saml_relay_states_bool_exp
  ): auth_saml_relay_states_aggregate!

  """
  fetch data from the table: "auth.saml_relay_states" using primary key columns
  """
  auth_saml_relay_states_by_pk(id: uuid!): auth_saml_relay_states

  """
  fetch data from the table: "auth.sessions"
  """
  auth_sessions(
    """distinct select on columns"""
    distinct_on: [auth_sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_sessions_order_by!]

    """filter the rows returned"""
    where: auth_sessions_bool_exp
  ): [auth_sessions!]!

  """
  fetch aggregated fields from the table: "auth.sessions"
  """
  auth_sessions_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_sessions_order_by!]

    """filter the rows returned"""
    where: auth_sessions_bool_exp
  ): auth_sessions_aggregate!

  """fetch data from the table: "auth.sessions" using primary key columns"""
  auth_sessions_by_pk(id: uuid!): auth_sessions

  """
  fetch data from the table: "auth.sso_domains"
  """
  auth_sso_domains(
    """distinct select on columns"""
    distinct_on: [auth_sso_domains_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_sso_domains_order_by!]

    """filter the rows returned"""
    where: auth_sso_domains_bool_exp
  ): [auth_sso_domains!]!

  """
  fetch aggregated fields from the table: "auth.sso_domains"
  """
  auth_sso_domains_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_sso_domains_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_sso_domains_order_by!]

    """filter the rows returned"""
    where: auth_sso_domains_bool_exp
  ): auth_sso_domains_aggregate!

  """
  fetch data from the table: "auth.sso_domains" using primary key columns
  """
  auth_sso_domains_by_pk(id: uuid!): auth_sso_domains

  """
  fetch data from the table: "auth.sso_providers"
  """
  auth_sso_providers(
    """distinct select on columns"""
    distinct_on: [auth_sso_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_sso_providers_order_by!]

    """filter the rows returned"""
    where: auth_sso_providers_bool_exp
  ): [auth_sso_providers!]!

  """
  fetch aggregated fields from the table: "auth.sso_providers"
  """
  auth_sso_providers_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_sso_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_sso_providers_order_by!]

    """filter the rows returned"""
    where: auth_sso_providers_bool_exp
  ): auth_sso_providers_aggregate!

  """
  fetch data from the table: "auth.sso_providers" using primary key columns
  """
  auth_sso_providers_by_pk(id: uuid!): auth_sso_providers

  """
  fetch data from the table: "auth.users"
  """
  auth_users(
    """distinct select on columns"""
    distinct_on: [auth_users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_users_order_by!]

    """filter the rows returned"""
    where: auth_users_bool_exp
  ): [auth_users!]!

  """
  fetch aggregated fields from the table: "auth.users"
  """
  auth_users_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_users_order_by!]

    """filter the rows returned"""
    where: auth_users_bool_exp
  ): auth_users_aggregate!

  """fetch data from the table: "auth.users" using primary key columns"""
  auth_users_by_pk(id: uuid!): auth_users

  """
  fetch data from the table: "booking_requests"
  """
  booking_requests(
    """distinct select on columns"""
    distinct_on: [booking_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_requests_order_by!]

    """filter the rows returned"""
    where: booking_requests_bool_exp
  ): [booking_requests!]!

  """
  fetch aggregated fields from the table: "booking_requests"
  """
  booking_requests_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_requests_order_by!]

    """filter the rows returned"""
    where: booking_requests_bool_exp
  ): booking_requests_aggregate!

  """
  fetch data from the table: "booking_requests" using primary key columns
  """
  booking_requests_by_pk(id: uuid!): booking_requests

  """An array relationship"""
  bookings(
    """distinct select on columns"""
    distinct_on: [bookings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookings_order_by!]

    """filter the rows returned"""
    where: bookings_bool_exp
  ): [bookings!]!

  """An aggregate relationship"""
  bookings_aggregate(
    """distinct select on columns"""
    distinct_on: [bookings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookings_order_by!]

    """filter the rows returned"""
    where: bookings_bool_exp
  ): bookings_aggregate!

  """fetch data from the table: "bookings" using primary key columns"""
  bookings_by_pk(id: uuid!): bookings

  """
  fetch data from the table: "calendar_events"
  """
  calendar_events(
    """distinct select on columns"""
    distinct_on: [calendar_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [calendar_events_order_by!]

    """filter the rows returned"""
    where: calendar_events_bool_exp
  ): [calendar_events!]!

  """
  fetch aggregated fields from the table: "calendar_events"
  """
  calendar_events_aggregate(
    """distinct select on columns"""
    distinct_on: [calendar_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [calendar_events_order_by!]

    """filter the rows returned"""
    where: calendar_events_bool_exp
  ): calendar_events_aggregate!

  """fetch data from the table: "calendar_events" using primary key columns"""
  calendar_events_by_pk(id: uuid!): calendar_events

  """An array relationship"""
  client_satisfaction_ratings(
    """distinct select on columns"""
    distinct_on: [client_satisfaction_ratings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_satisfaction_ratings_order_by!]

    """filter the rows returned"""
    where: client_satisfaction_ratings_bool_exp
  ): [client_satisfaction_ratings!]!

  """An aggregate relationship"""
  client_satisfaction_ratings_aggregate(
    """distinct select on columns"""
    distinct_on: [client_satisfaction_ratings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_satisfaction_ratings_order_by!]

    """filter the rows returned"""
    where: client_satisfaction_ratings_bool_exp
  ): client_satisfaction_ratings_aggregate!

  """
  fetch data from the table: "client_satisfaction_ratings" using primary key columns
  """
  client_satisfaction_ratings_by_pk(id: uuid!): client_satisfaction_ratings

  """
  fetch data from the table: "compliance_categories"
  """
  compliance_categories(
    """distinct select on columns"""
    distinct_on: [compliance_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [compliance_categories_order_by!]

    """filter the rows returned"""
    where: compliance_categories_bool_exp
  ): [compliance_categories!]!

  """
  fetch aggregated fields from the table: "compliance_categories"
  """
  compliance_categories_aggregate(
    """distinct select on columns"""
    distinct_on: [compliance_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [compliance_categories_order_by!]

    """filter the rows returned"""
    where: compliance_categories_bool_exp
  ): compliance_categories_aggregate!

  """
  fetch data from the table: "compliance_categories" using primary key columns
  """
  compliance_categories_by_pk(id: uuid!): compliance_categories

  """An array relationship"""
  compliance_items(
    """distinct select on columns"""
    distinct_on: [compliance_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [compliance_items_order_by!]

    """filter the rows returned"""
    where: compliance_items_bool_exp
  ): [compliance_items!]!

  """An aggregate relationship"""
  compliance_items_aggregate(
    """distinct select on columns"""
    distinct_on: [compliance_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [compliance_items_order_by!]

    """filter the rows returned"""
    where: compliance_items_bool_exp
  ): compliance_items_aggregate!

  """
  fetch data from the table: "compliance_items" using primary key columns
  """
  compliance_items_by_pk(id: uuid!): compliance_items

  """An array relationship"""
  contact_fees(
    """distinct select on columns"""
    distinct_on: [contact_fees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [contact_fees_order_by!]

    """filter the rows returned"""
    where: contact_fees_bool_exp
  ): [contact_fees!]!

  """An aggregate relationship"""
  contact_fees_aggregate(
    """distinct select on columns"""
    distinct_on: [contact_fees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [contact_fees_order_by!]

    """filter the rows returned"""
    where: contact_fees_bool_exp
  ): contact_fees_aggregate!

  """fetch data from the table: "contact_fees" using primary key columns"""
  contact_fees_by_pk(id: uuid!): contact_fees

  """An array relationship"""
  content_moderation_flags(
    """distinct select on columns"""
    distinct_on: [content_moderation_flags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [content_moderation_flags_order_by!]

    """filter the rows returned"""
    where: content_moderation_flags_bool_exp
  ): [content_moderation_flags!]!

  """An aggregate relationship"""
  content_moderation_flags_aggregate(
    """distinct select on columns"""
    distinct_on: [content_moderation_flags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [content_moderation_flags_order_by!]

    """filter the rows returned"""
    where: content_moderation_flags_bool_exp
  ): content_moderation_flags_aggregate!

  """
  fetch data from the table: "content_moderation_flags" using primary key columns
  """
  content_moderation_flags_by_pk(id: uuid!): content_moderation_flags

  """
  fetch data from the table: "conversations"
  """
  conversations(
    """distinct select on columns"""
    distinct_on: [conversations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversations_order_by!]

    """filter the rows returned"""
    where: conversations_bool_exp
  ): [conversations!]!

  """
  fetch aggregated fields from the table: "conversations"
  """
  conversations_aggregate(
    """distinct select on columns"""
    distinct_on: [conversations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversations_order_by!]

    """filter the rows returned"""
    where: conversations_bool_exp
  ): conversations_aggregate!

  """fetch data from the table: "conversations" using primary key columns"""
  conversations_by_pk(id: uuid!): conversations

  """An array relationship"""
  conversion_events(
    """distinct select on columns"""
    distinct_on: [conversion_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversion_events_order_by!]

    """filter the rows returned"""
    where: conversion_events_bool_exp
  ): [conversion_events!]!

  """An aggregate relationship"""
  conversion_events_aggregate(
    """distinct select on columns"""
    distinct_on: [conversion_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversion_events_order_by!]

    """filter the rows returned"""
    where: conversion_events_bool_exp
  ): conversion_events_aggregate!

  """
  fetch data from the table: "conversion_events" using primary key columns
  """
  conversion_events_by_pk(id: uuid!): conversion_events

  """
  fetch data from the table: "countries"
  """
  countries(
    """distinct select on columns"""
    distinct_on: [countries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [countries_order_by!]

    """filter the rows returned"""
    where: countries_bool_exp
  ): [countries!]!

  """
  fetch aggregated fields from the table: "countries"
  """
  countries_aggregate(
    """distinct select on columns"""
    distinct_on: [countries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [countries_order_by!]

    """filter the rows returned"""
    where: countries_bool_exp
  ): countries_aggregate!

  """fetch data from the table: "countries" using primary key columns"""
  countries_by_pk(id: Int!): countries

  """
  fetch data from the table: "country_codes"
  """
  country_codes(
    """distinct select on columns"""
    distinct_on: [country_codes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [country_codes_order_by!]

    """filter the rows returned"""
    where: country_codes_bool_exp
  ): [country_codes!]!

  """
  fetch aggregated fields from the table: "country_codes"
  """
  country_codes_aggregate(
    """distinct select on columns"""
    distinct_on: [country_codes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [country_codes_order_by!]

    """filter the rows returned"""
    where: country_codes_bool_exp
  ): country_codes_aggregate!

  """fetch data from the table: "country_codes" using primary key columns"""
  country_codes_by_pk(id: Int!): country_codes

  """An array relationship"""
  credit_transactions(
    """distinct select on columns"""
    distinct_on: [credit_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [credit_transactions_order_by!]

    """filter the rows returned"""
    where: credit_transactions_bool_exp
  ): [credit_transactions!]!

  """An aggregate relationship"""
  credit_transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [credit_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [credit_transactions_order_by!]

    """filter the rows returned"""
    where: credit_transactions_bool_exp
  ): credit_transactions_aggregate!

  """
  fetch data from the table: "credit_transactions" using primary key columns
  """
  credit_transactions_by_pk(id: uuid!): credit_transactions

  """
  fetch data from the table: "dispute_evidence"
  """
  dispute_evidence(
    """distinct select on columns"""
    distinct_on: [dispute_evidence_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dispute_evidence_order_by!]

    """filter the rows returned"""
    where: dispute_evidence_bool_exp
  ): [dispute_evidence!]!

  """
  fetch aggregated fields from the table: "dispute_evidence"
  """
  dispute_evidence_aggregate(
    """distinct select on columns"""
    distinct_on: [dispute_evidence_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dispute_evidence_order_by!]

    """filter the rows returned"""
    where: dispute_evidence_bool_exp
  ): dispute_evidence_aggregate!

  """
  fetch data from the table: "dispute_evidence" using primary key columns
  """
  dispute_evidence_by_pk(id: uuid!): dispute_evidence

  """An array relationship"""
  dispute_messages(
    """distinct select on columns"""
    distinct_on: [dispute_messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dispute_messages_order_by!]

    """filter the rows returned"""
    where: dispute_messages_bool_exp
  ): [dispute_messages!]!

  """An aggregate relationship"""
  dispute_messages_aggregate(
    """distinct select on columns"""
    distinct_on: [dispute_messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dispute_messages_order_by!]

    """filter the rows returned"""
    where: dispute_messages_bool_exp
  ): dispute_messages_aggregate!

  """
  fetch data from the table: "dispute_messages" using primary key columns
  """
  dispute_messages_by_pk(id: uuid!): dispute_messages

  """An array relationship"""
  dispute_parties(
    """distinct select on columns"""
    distinct_on: [dispute_parties_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dispute_parties_order_by!]

    """filter the rows returned"""
    where: dispute_parties_bool_exp
  ): [dispute_parties!]!

  """An aggregate relationship"""
  dispute_parties_aggregate(
    """distinct select on columns"""
    distinct_on: [dispute_parties_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dispute_parties_order_by!]

    """filter the rows returned"""
    where: dispute_parties_bool_exp
  ): dispute_parties_aggregate!

  """fetch data from the table: "dispute_parties" using primary key columns"""
  dispute_parties_by_pk(id: uuid!): dispute_parties

  """An array relationship"""
  disputes(
    """distinct select on columns"""
    distinct_on: [disputes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [disputes_order_by!]

    """filter the rows returned"""
    where: disputes_bool_exp
  ): [disputes!]!

  """An aggregate relationship"""
  disputes_aggregate(
    """distinct select on columns"""
    distinct_on: [disputes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [disputes_order_by!]

    """filter the rows returned"""
    where: disputes_bool_exp
  ): disputes_aggregate!

  """fetch data from the table: "disputes" using primary key columns"""
  disputes_by_pk(id: uuid!): disputes

  """
  fetch data from the table: "favorites"
  """
  favorites(
    """distinct select on columns"""
    distinct_on: [favorites_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [favorites_order_by!]

    """filter the rows returned"""
    where: favorites_bool_exp
  ): [favorites!]!

  """
  fetch aggregated fields from the table: "favorites"
  """
  favorites_aggregate(
    """distinct select on columns"""
    distinct_on: [favorites_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [favorites_order_by!]

    """filter the rows returned"""
    where: favorites_bool_exp
  ): favorites_aggregate!

  """fetch data from the table: "favorites" using primary key columns"""
  favorites_by_pk(id: uuid!): favorites

  """An array relationship"""
  interview_notifications(
    """distinct select on columns"""
    distinct_on: [interview_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [interview_notifications_order_by!]

    """filter the rows returned"""
    where: interview_notifications_bool_exp
  ): [interview_notifications!]!

  """An aggregate relationship"""
  interview_notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [interview_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [interview_notifications_order_by!]

    """filter the rows returned"""
    where: interview_notifications_bool_exp
  ): interview_notifications_aggregate!

  """
  fetch data from the table: "interview_notifications" using primary key columns
  """
  interview_notifications_by_pk(id: uuid!): interview_notifications

  """
  fetch data from the table: "interview_platform_templates"
  """
  interview_platform_templates(
    """distinct select on columns"""
    distinct_on: [interview_platform_templates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [interview_platform_templates_order_by!]

    """filter the rows returned"""
    where: interview_platform_templates_bool_exp
  ): [interview_platform_templates!]!

  """
  fetch aggregated fields from the table: "interview_platform_templates"
  """
  interview_platform_templates_aggregate(
    """distinct select on columns"""
    distinct_on: [interview_platform_templates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [interview_platform_templates_order_by!]

    """filter the rows returned"""
    where: interview_platform_templates_bool_exp
  ): interview_platform_templates_aggregate!

  """
  fetch data from the table: "interview_platform_templates" using primary key columns
  """
  interview_platform_templates_by_pk(id: uuid!): interview_platform_templates

  """
  fetch data from the table: "job_applications"
  """
  job_applications(
    """distinct select on columns"""
    distinct_on: [job_applications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [job_applications_order_by!]

    """filter the rows returned"""
    where: job_applications_bool_exp
  ): [job_applications!]!

  """
  fetch aggregated fields from the table: "job_applications"
  """
  job_applications_aggregate(
    """distinct select on columns"""
    distinct_on: [job_applications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [job_applications_order_by!]

    """filter the rows returned"""
    where: job_applications_bool_exp
  ): job_applications_aggregate!

  """
  fetch data from the table: "job_applications" using primary key columns
  """
  job_applications_by_pk(id: uuid!): job_applications

  """
  fetch data from the table: "job_postings"
  """
  job_postings(
    """distinct select on columns"""
    distinct_on: [job_postings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [job_postings_order_by!]

    """filter the rows returned"""
    where: job_postings_bool_exp
  ): [job_postings!]!

  """
  fetch aggregated fields from the table: "job_postings"
  """
  job_postings_aggregate(
    """distinct select on columns"""
    distinct_on: [job_postings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [job_postings_order_by!]

    """filter the rows returned"""
    where: job_postings_bool_exp
  ): job_postings_aggregate!

  """
  fetch data from the table: "jobs"
  """
  jobs(
    """distinct select on columns"""
    distinct_on: [jobs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [jobs_order_by!]

    """filter the rows returned"""
    where: jobs_bool_exp
  ): [jobs!]!

  """
  fetch aggregated fields from the table: "jobs"
  """
  jobs_aggregate(
    """distinct select on columns"""
    distinct_on: [jobs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [jobs_order_by!]

    """filter the rows returned"""
    where: jobs_bool_exp
  ): jobs_aggregate!

  """fetch data from the table: "jobs" using primary key columns"""
  jobs_by_pk(id: uuid!): jobs

  """
  fetch data from the table: "maid_bookings"
  """
  maid_bookings(
    """distinct select on columns"""
    distinct_on: [maid_bookings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [maid_bookings_order_by!]

    """filter the rows returned"""
    where: maid_bookings_bool_exp
  ): [maid_bookings!]!

  """
  fetch aggregated fields from the table: "maid_bookings"
  """
  maid_bookings_aggregate(
    """distinct select on columns"""
    distinct_on: [maid_bookings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [maid_bookings_order_by!]

    """filter the rows returned"""
    where: maid_bookings_bool_exp
  ): maid_bookings_aggregate!

  """fetch data from the table: "maid_bookings" using primary key columns"""
  maid_bookings_by_pk(id: uuid!): maid_bookings

  """
  fetch data from the table: "maid_documents"
  """
  maid_documents(
    """distinct select on columns"""
    distinct_on: [maid_documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [maid_documents_order_by!]

    """filter the rows returned"""
    where: maid_documents_bool_exp
  ): [maid_documents!]!

  """
  fetch aggregated fields from the table: "maid_documents"
  """
  maid_documents_aggregate(
    """distinct select on columns"""
    distinct_on: [maid_documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [maid_documents_order_by!]

    """filter the rows returned"""
    where: maid_documents_bool_exp
  ): maid_documents_aggregate!

  """fetch data from the table: "maid_documents" using primary key columns"""
  maid_documents_by_pk(id: uuid!): maid_documents

  """
  fetch data from the table: "maid_images"
  """
  maid_images(
    """distinct select on columns"""
    distinct_on: [maid_images_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [maid_images_order_by!]

    """filter the rows returned"""
    where: maid_images_bool_exp
  ): [maid_images!]!

  """
  fetch aggregated fields from the table: "maid_images"
  """
  maid_images_aggregate(
    """distinct select on columns"""
    distinct_on: [maid_images_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [maid_images_order_by!]

    """filter the rows returned"""
    where: maid_images_bool_exp
  ): maid_images_aggregate!

  """fetch data from the table: "maid_images" using primary key columns"""
  maid_images_by_pk(id: uuid!): maid_images

  """
  fetch data from the table: "maid_profiles"
  """
  maid_profiles(
    """distinct select on columns"""
    distinct_on: [maid_profiles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [maid_profiles_order_by!]

    """filter the rows returned"""
    where: maid_profiles_bool_exp
  ): [maid_profiles!]!

  """
  fetch aggregated fields from the table: "maid_profiles"
  """
  maid_profiles_aggregate(
    """distinct select on columns"""
    distinct_on: [maid_profiles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [maid_profiles_order_by!]

    """filter the rows returned"""
    where: maid_profiles_bool_exp
  ): maid_profiles_aggregate!

  """fetch data from the table: "maid_profiles" using primary key columns"""
  maid_profiles_by_pk(id: String!): maid_profiles

  """
  fetch data from the table: "maid_videos"
  """
  maid_videos(
    """distinct select on columns"""
    distinct_on: [maid_videos_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [maid_videos_order_by!]

    """filter the rows returned"""
    where: maid_videos_bool_exp
  ): [maid_videos!]!

  """
  fetch aggregated fields from the table: "maid_videos"
  """
  maid_videos_aggregate(
    """distinct select on columns"""
    distinct_on: [maid_videos_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [maid_videos_order_by!]

    """filter the rows returned"""
    where: maid_videos_bool_exp
  ): maid_videos_aggregate!

  """fetch data from the table: "maid_videos" using primary key columns"""
  maid_videos_by_pk(id: uuid!): maid_videos

  """
  fetch data from the table: "message_templates"
  """
  message_templates(
    """distinct select on columns"""
    distinct_on: [message_templates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_templates_order_by!]

    """filter the rows returned"""
    where: message_templates_bool_exp
  ): [message_templates!]!

  """
  fetch aggregated fields from the table: "message_templates"
  """
  message_templates_aggregate(
    """distinct select on columns"""
    distinct_on: [message_templates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_templates_order_by!]

    """filter the rows returned"""
    where: message_templates_bool_exp
  ): message_templates_aggregate!

  """
  fetch data from the table: "message_templates" using primary key columns
  """
  message_templates_by_pk(id: uuid!): message_templates

  """An array relationship"""
  messages(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): [messages!]!

  """An aggregate relationship"""
  messages_aggregate(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): messages_aggregate!

  """fetch data from the table: "messages" using primary key columns"""
  messages_by_pk(id: uuid!): messages

  """
  fetch data from the table: "mv_agency_analytics_summary"
  """
  mv_agency_analytics_summary(
    """distinct select on columns"""
    distinct_on: [mv_agency_analytics_summary_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mv_agency_analytics_summary_order_by!]

    """filter the rows returned"""
    where: mv_agency_analytics_summary_bool_exp
  ): [mv_agency_analytics_summary!]!

  """
  fetch aggregated fields from the table: "mv_agency_analytics_summary"
  """
  mv_agency_analytics_summary_aggregate(
    """distinct select on columns"""
    distinct_on: [mv_agency_analytics_summary_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mv_agency_analytics_summary_order_by!]

    """filter the rows returned"""
    where: mv_agency_analytics_summary_bool_exp
  ): mv_agency_analytics_summary_aggregate!

  """An array relationship"""
  news_items(
    """distinct select on columns"""
    distinct_on: [news_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [news_items_order_by!]

    """filter the rows returned"""
    where: news_items_bool_exp
  ): [news_items!]!

  """An aggregate relationship"""
  news_items_aggregate(
    """distinct select on columns"""
    distinct_on: [news_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [news_items_order_by!]

    """filter the rows returned"""
    where: news_items_bool_exp
  ): news_items_aggregate!

  """fetch data from the table: "news_items" using primary key columns"""
  news_items_by_pk(id: uuid!): news_items

  """
  fetch data from the table: "news_sources"
  """
  news_sources(
    """distinct select on columns"""
    distinct_on: [news_sources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [news_sources_order_by!]

    """filter the rows returned"""
    where: news_sources_bool_exp
  ): [news_sources!]!

  """
  fetch aggregated fields from the table: "news_sources"
  """
  news_sources_aggregate(
    """distinct select on columns"""
    distinct_on: [news_sources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [news_sources_order_by!]

    """filter the rows returned"""
    where: news_sources_bool_exp
  ): news_sources_aggregate!

  """fetch data from the table: "news_sources" using primary key columns"""
  news_sources_by_pk(id: uuid!): news_sources

  """
  fetch data from the table: "notifications"
  """
  notifications(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): [notifications!]!

  """
  fetch aggregated fields from the table: "notifications"
  """
  notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): notifications_aggregate!

  """fetch data from the table: "notifications" using primary key columns"""
  notifications_by_pk(id: uuid!): notifications

  """
  fetch data from the table: "page_views"
  """
  page_views(
    """distinct select on columns"""
    distinct_on: [page_views_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [page_views_order_by!]

    """filter the rows returned"""
    where: page_views_bool_exp
  ): [page_views!]!

  """
  fetch aggregated fields from the table: "page_views"
  """
  page_views_aggregate(
    """distinct select on columns"""
    distinct_on: [page_views_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [page_views_order_by!]

    """filter the rows returned"""
    where: page_views_bool_exp
  ): page_views_aggregate!

  """fetch data from the table: "page_views" using primary key columns"""
  page_views_by_pk(id: uuid!): page_views

  """
  fetch data from the table: "password_resets"
  """
  password_resets(
    """distinct select on columns"""
    distinct_on: [password_resets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [password_resets_order_by!]

    """filter the rows returned"""
    where: password_resets_bool_exp
  ): [password_resets!]!

  """
  fetch aggregated fields from the table: "password_resets"
  """
  password_resets_aggregate(
    """distinct select on columns"""
    distinct_on: [password_resets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [password_resets_order_by!]

    """filter the rows returned"""
    where: password_resets_bool_exp
  ): password_resets_aggregate!

  """fetch data from the table: "password_resets" using primary key columns"""
  password_resets_by_pk(
    """Unique identifier for the password reset request"""
    id: uuid!
  ): password_resets

  """
  fetch data from the table: "payment_idempotency"
  """
  payment_idempotency(
    """distinct select on columns"""
    distinct_on: [payment_idempotency_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_idempotency_order_by!]

    """filter the rows returned"""
    where: payment_idempotency_bool_exp
  ): [payment_idempotency!]!

  """
  fetch aggregated fields from the table: "payment_idempotency"
  """
  payment_idempotency_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_idempotency_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_idempotency_order_by!]

    """filter the rows returned"""
    where: payment_idempotency_bool_exp
  ): payment_idempotency_aggregate!

  """
  fetch data from the table: "payment_idempotency" using primary key columns
  """
  payment_idempotency_by_pk(id: uuid!): payment_idempotency

  """
  fetch data from the table: "payment_methods"
  """
  payment_methods(
    """distinct select on columns"""
    distinct_on: [payment_methods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_methods_order_by!]

    """filter the rows returned"""
    where: payment_methods_bool_exp
  ): [payment_methods!]!

  """
  fetch aggregated fields from the table: "payment_methods"
  """
  payment_methods_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_methods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_methods_order_by!]

    """filter the rows returned"""
    where: payment_methods_bool_exp
  ): payment_methods_aggregate!

  """fetch data from the table: "payment_methods" using primary key columns"""
  payment_methods_by_pk(id: uuid!): payment_methods

  """An array relationship"""
  payments(
    """distinct select on columns"""
    distinct_on: [payments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_order_by!]

    """filter the rows returned"""
    where: payments_bool_exp
  ): [payments!]!

  """An aggregate relationship"""
  payments_aggregate(
    """distinct select on columns"""
    distinct_on: [payments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_order_by!]

    """filter the rows returned"""
    where: payments_bool_exp
  ): payments_aggregate!

  """fetch data from the table: "payments" using primary key columns"""
  payments_by_pk(id: uuid!): payments

  """
  fetch data from the table: "payout_accounts"
  """
  payout_accounts(
    """distinct select on columns"""
    distinct_on: [payout_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payout_accounts_order_by!]

    """filter the rows returned"""
    where: payout_accounts_bool_exp
  ): [payout_accounts!]!

  """
  fetch aggregated fields from the table: "payout_accounts"
  """
  payout_accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [payout_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payout_accounts_order_by!]

    """filter the rows returned"""
    where: payout_accounts_bool_exp
  ): payout_accounts_aggregate!

  """fetch data from the table: "payout_accounts" using primary key columns"""
  payout_accounts_by_pk(id: uuid!): payout_accounts

  """An array relationship"""
  payout_schedules(
    """distinct select on columns"""
    distinct_on: [payout_schedules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payout_schedules_order_by!]

    """filter the rows returned"""
    where: payout_schedules_bool_exp
  ): [payout_schedules!]!

  """An aggregate relationship"""
  payout_schedules_aggregate(
    """distinct select on columns"""
    distinct_on: [payout_schedules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payout_schedules_order_by!]

    """filter the rows returned"""
    where: payout_schedules_bool_exp
  ): payout_schedules_aggregate!

  """
  fetch data from the table: "payout_schedules" using primary key columns
  """
  payout_schedules_by_pk(id: uuid!): payout_schedules

  """
  fetch data from the table: "phone_verification_log"
  """
  phone_verification_log(
    """distinct select on columns"""
    distinct_on: [phone_verification_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [phone_verification_log_order_by!]

    """filter the rows returned"""
    where: phone_verification_log_bool_exp
  ): [phone_verification_log!]!

  """
  fetch aggregated fields from the table: "phone_verification_log"
  """
  phone_verification_log_aggregate(
    """distinct select on columns"""
    distinct_on: [phone_verification_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [phone_verification_log_order_by!]

    """filter the rows returned"""
    where: phone_verification_log_bool_exp
  ): phone_verification_log_aggregate!

  """
  fetch data from the table: "phone_verification_log" using primary key columns
  """
  phone_verification_log_by_pk(id: uuid!): phone_verification_log

  """
  fetch data from the table: "phone_verifications"
  """
  phone_verifications(
    """distinct select on columns"""
    distinct_on: [phone_verifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [phone_verifications_order_by!]

    """filter the rows returned"""
    where: phone_verifications_bool_exp
  ): [phone_verifications!]!

  """
  fetch aggregated fields from the table: "phone_verifications"
  """
  phone_verifications_aggregate(
    """distinct select on columns"""
    distinct_on: [phone_verifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [phone_verifications_order_by!]

    """filter the rows returned"""
    where: phone_verifications_bool_exp
  ): phone_verifications_aggregate!

  """
  fetch data from the table: "phone_verifications" using primary key columns
  """
  phone_verifications_by_pk(id: uuid!): phone_verifications

  """
  fetch data from the table: "pii_access_log"
  """
  pii_access_log(
    """distinct select on columns"""
    distinct_on: [pii_access_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pii_access_log_order_by!]

    """filter the rows returned"""
    where: pii_access_log_bool_exp
  ): [pii_access_log!]!

  """
  fetch aggregated fields from the table: "pii_access_log"
  """
  pii_access_log_aggregate(
    """distinct select on columns"""
    distinct_on: [pii_access_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pii_access_log_order_by!]

    """filter the rows returned"""
    where: pii_access_log_bool_exp
  ): pii_access_log_aggregate!

  """fetch data from the table: "pii_access_log" using primary key columns"""
  pii_access_log_by_pk(id: uuid!): pii_access_log

  """An array relationship"""
  placement_contracts(
    """distinct select on columns"""
    distinct_on: [placement_contracts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [placement_contracts_order_by!]

    """filter the rows returned"""
    where: placement_contracts_bool_exp
  ): [placement_contracts!]!

  """An aggregate relationship"""
  placement_contracts_aggregate(
    """distinct select on columns"""
    distinct_on: [placement_contracts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [placement_contracts_order_by!]

    """filter the rows returned"""
    where: placement_contracts_bool_exp
  ): placement_contracts_aggregate!

  """
  fetch data from the table: "placement_contracts" using primary key columns
  """
  placement_contracts_by_pk(id: uuid!): placement_contracts

  """An array relationship"""
  placement_fee_transactions(
    """distinct select on columns"""
    distinct_on: [placement_fee_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [placement_fee_transactions_order_by!]

    """filter the rows returned"""
    where: placement_fee_transactions_bool_exp
  ): [placement_fee_transactions!]!

  """An aggregate relationship"""
  placement_fee_transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [placement_fee_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [placement_fee_transactions_order_by!]

    """filter the rows returned"""
    where: placement_fee_transactions_bool_exp
  ): placement_fee_transactions_aggregate!

  """
  fetch data from the table: "placement_fee_transactions" using primary key columns
  """
  placement_fee_transactions_by_pk(id: uuid!): placement_fee_transactions

  """
  fetch data from the table: "platform_announcements"
  """
  platform_announcements(
    """distinct select on columns"""
    distinct_on: [platform_announcements_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [platform_announcements_order_by!]

    """filter the rows returned"""
    where: platform_announcements_bool_exp
  ): [platform_announcements!]!

  """
  fetch aggregated fields from the table: "platform_announcements"
  """
  platform_announcements_aggregate(
    """distinct select on columns"""
    distinct_on: [platform_announcements_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [platform_announcements_order_by!]

    """filter the rows returned"""
    where: platform_announcements_bool_exp
  ): platform_announcements_aggregate!

  """
  fetch data from the table: "platform_announcements" using primary key columns
  """
  platform_announcements_by_pk(id: uuid!): platform_announcements

  """
  fetch data from the table: "platform_settings"
  """
  platform_settings(
    """distinct select on columns"""
    distinct_on: [platform_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [platform_settings_order_by!]

    """filter the rows returned"""
    where: platform_settings_bool_exp
  ): [platform_settings!]!

  """
  fetch aggregated fields from the table: "platform_settings"
  """
  platform_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [platform_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [platform_settings_order_by!]

    """filter the rows returned"""
    where: platform_settings_bool_exp
  ): platform_settings_aggregate!

  """
  fetch data from the table: "platform_settings" using primary key columns
  """
  platform_settings_by_pk(id: uuid!): platform_settings

  """
  fetch data from the table: "profiles"
  """
  profiles(
    """distinct select on columns"""
    distinct_on: [profiles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [profiles_order_by!]

    """filter the rows returned"""
    where: profiles_bool_exp
  ): [profiles!]!

  """
  fetch aggregated fields from the table: "profiles"
  """
  profiles_aggregate(
    """distinct select on columns"""
    distinct_on: [profiles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [profiles_order_by!]

    """filter the rows returned"""
    where: profiles_bool_exp
  ): profiles_aggregate!

  """fetch data from the table: "profiles" using primary key columns"""
  profiles_by_pk(id: String!): profiles

  """
  fetch data from the table: "realtime.messages"
  """
  realtime_messages(
    """distinct select on columns"""
    distinct_on: [realtime_messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [realtime_messages_order_by!]

    """filter the rows returned"""
    where: realtime_messages_bool_exp
  ): [realtime_messages!]!

  """
  fetch aggregated fields from the table: "realtime.messages"
  """
  realtime_messages_aggregate(
    """distinct select on columns"""
    distinct_on: [realtime_messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [realtime_messages_order_by!]

    """filter the rows returned"""
    where: realtime_messages_bool_exp
  ): realtime_messages_aggregate!

  """
  fetch data from the table: "realtime.messages" using primary key columns
  """
  realtime_messages_by_pk(id: uuid!, inserted_at: timestamp!): realtime_messages

  """
  fetch data from the table: "realtime.subscription"
  """
  realtime_subscription(
    """distinct select on columns"""
    distinct_on: [realtime_subscription_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [realtime_subscription_order_by!]

    """filter the rows returned"""
    where: realtime_subscription_bool_exp
  ): [realtime_subscription!]!

  """
  fetch aggregated fields from the table: "realtime.subscription"
  """
  realtime_subscription_aggregate(
    """distinct select on columns"""
    distinct_on: [realtime_subscription_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [realtime_subscription_order_by!]

    """filter the rows returned"""
    where: realtime_subscription_bool_exp
  ): realtime_subscription_aggregate!

  """
  fetch data from the table: "realtime.subscription" using primary key columns
  """
  realtime_subscription_by_pk(id: bigint!): realtime_subscription

  """
  fetch data from the table: "reviews"
  """
  reviews(
    """distinct select on columns"""
    distinct_on: [reviews_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reviews_order_by!]

    """filter the rows returned"""
    where: reviews_bool_exp
  ): [reviews!]!

  """
  fetch aggregated fields from the table: "reviews"
  """
  reviews_aggregate(
    """distinct select on columns"""
    distinct_on: [reviews_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reviews_order_by!]

    """filter the rows returned"""
    where: reviews_bool_exp
  ): reviews_aggregate!

  """fetch data from the table: "reviews" using primary key columns"""
  reviews_by_pk(id: uuid!): reviews

  """An array relationship"""
  security_events(
    """distinct select on columns"""
    distinct_on: [security_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [security_events_order_by!]

    """filter the rows returned"""
    where: security_events_bool_exp
  ): [security_events!]!

  """An aggregate relationship"""
  security_events_aggregate(
    """distinct select on columns"""
    distinct_on: [security_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [security_events_order_by!]

    """filter the rows returned"""
    where: security_events_bool_exp
  ): security_events_aggregate!

  """fetch data from the table: "security_events" using primary key columns"""
  security_events_by_pk(id: uuid!): security_events

  """An array relationship"""
  shortlist_candidates(
    """distinct select on columns"""
    distinct_on: [shortlist_candidates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shortlist_candidates_order_by!]

    """filter the rows returned"""
    where: shortlist_candidates_bool_exp
  ): [shortlist_candidates!]!

  """An aggregate relationship"""
  shortlist_candidates_aggregate(
    """distinct select on columns"""
    distinct_on: [shortlist_candidates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shortlist_candidates_order_by!]

    """filter the rows returned"""
    where: shortlist_candidates_bool_exp
  ): shortlist_candidates_aggregate!

  """
  fetch data from the table: "shortlist_candidates" using primary key columns
  """
  shortlist_candidates_by_pk(id: uuid!): shortlist_candidates

  """An array relationship"""
  shortlists(
    """distinct select on columns"""
    distinct_on: [shortlists_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shortlists_order_by!]

    """filter the rows returned"""
    where: shortlists_bool_exp
  ): [shortlists!]!

  """An aggregate relationship"""
  shortlists_aggregate(
    """distinct select on columns"""
    distinct_on: [shortlists_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shortlists_order_by!]

    """filter the rows returned"""
    where: shortlists_bool_exp
  ): shortlists_aggregate!

  """fetch data from the table: "shortlists" using primary key columns"""
  shortlists_by_pk(id: uuid!): shortlists

  """
  fetch data from the table: "skills"
  """
  skills(
    """distinct select on columns"""
    distinct_on: [skills_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [skills_order_by!]

    """filter the rows returned"""
    where: skills_bool_exp
  ): [skills!]!

  """
  fetch aggregated fields from the table: "skills"
  """
  skills_aggregate(
    """distinct select on columns"""
    distinct_on: [skills_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [skills_order_by!]

    """filter the rows returned"""
    where: skills_bool_exp
  ): skills_aggregate!

  """fetch data from the table: "skills" using primary key columns"""
  skills_by_pk(id: Int!): skills

  """
  fetch data from the table: "sponsor_document_verification"
  """
  sponsor_document_verification(
    """distinct select on columns"""
    distinct_on: [sponsor_document_verification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sponsor_document_verification_order_by!]

    """filter the rows returned"""
    where: sponsor_document_verification_bool_exp
  ): [sponsor_document_verification!]!

  """
  fetch aggregated fields from the table: "sponsor_document_verification"
  """
  sponsor_document_verification_aggregate(
    """distinct select on columns"""
    distinct_on: [sponsor_document_verification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sponsor_document_verification_order_by!]

    """filter the rows returned"""
    where: sponsor_document_verification_bool_exp
  ): sponsor_document_verification_aggregate!

  """
  fetch data from the table: "sponsor_document_verification" using primary key columns
  """
  sponsor_document_verification_by_pk(id: uuid!): sponsor_document_verification

  """An array relationship"""
  sponsor_jobs(
    """distinct select on columns"""
    distinct_on: [sponsor_jobs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sponsor_jobs_order_by!]

    """filter the rows returned"""
    where: sponsor_jobs_bool_exp
  ): [sponsor_jobs!]!

  """An aggregate relationship"""
  sponsor_jobs_aggregate(
    """distinct select on columns"""
    distinct_on: [sponsor_jobs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sponsor_jobs_order_by!]

    """filter the rows returned"""
    where: sponsor_jobs_bool_exp
  ): sponsor_jobs_aggregate!

  """fetch data from the table: "sponsor_jobs" using primary key columns"""
  sponsor_jobs_by_pk(id: uuid!): sponsor_jobs

  """
  fetch data from the table: "sponsor_profiles"
  """
  sponsor_profiles(
    """distinct select on columns"""
    distinct_on: [sponsor_profiles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sponsor_profiles_order_by!]

    """filter the rows returned"""
    where: sponsor_profiles_bool_exp
  ): [sponsor_profiles!]!

  """
  fetch aggregated fields from the table: "sponsor_profiles"
  """
  sponsor_profiles_aggregate(
    """distinct select on columns"""
    distinct_on: [sponsor_profiles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sponsor_profiles_order_by!]

    """filter the rows returned"""
    where: sponsor_profiles_bool_exp
  ): sponsor_profiles_aggregate!

  """
  fetch data from the table: "sponsor_profiles" using primary key columns
  """
  sponsor_profiles_by_pk(id: String!): sponsor_profiles

  """
  fetch data from the table: "sponsors"
  """
  sponsors(
    """distinct select on columns"""
    distinct_on: [sponsors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sponsors_order_by!]

    """filter the rows returned"""
    where: sponsors_bool_exp
  ): [sponsors!]!

  """
  fetch aggregated fields from the table: "sponsors"
  """
  sponsors_aggregate(
    """distinct select on columns"""
    distinct_on: [sponsors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sponsors_order_by!]

    """filter the rows returned"""
    where: sponsors_bool_exp
  ): sponsors_aggregate!

  """fetch data from the table: "sponsors" using primary key columns"""
  sponsors_by_pk(id: uuid!): sponsors

  """
  fetch data from the table: "storage.buckets"
  """
  storage_buckets(
    """distinct select on columns"""
    distinct_on: [storage_buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_buckets_order_by!]

    """filter the rows returned"""
    where: storage_buckets_bool_exp
  ): [storage_buckets!]!

  """
  fetch aggregated fields from the table: "storage.buckets"
  """
  storage_buckets_aggregate(
    """distinct select on columns"""
    distinct_on: [storage_buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_buckets_order_by!]

    """filter the rows returned"""
    where: storage_buckets_bool_exp
  ): storage_buckets_aggregate!

  """
  fetch data from the table: "storage.buckets_analytics"
  """
  storage_buckets_analytics(
    """distinct select on columns"""
    distinct_on: [storage_buckets_analytics_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_buckets_analytics_order_by!]

    """filter the rows returned"""
    where: storage_buckets_analytics_bool_exp
  ): [storage_buckets_analytics!]!

  """
  fetch aggregated fields from the table: "storage.buckets_analytics"
  """
  storage_buckets_analytics_aggregate(
    """distinct select on columns"""
    distinct_on: [storage_buckets_analytics_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_buckets_analytics_order_by!]

    """filter the rows returned"""
    where: storage_buckets_analytics_bool_exp
  ): storage_buckets_analytics_aggregate!

  """
  fetch data from the table: "storage.buckets_analytics" using primary key columns
  """
  storage_buckets_analytics_by_pk(id: uuid!): storage_buckets_analytics

  """fetch data from the table: "storage.buckets" using primary key columns"""
  storage_buckets_by_pk(id: String!): storage_buckets

  """
  fetch data from the table: "storage.migrations"
  """
  storage_migrations(
    """distinct select on columns"""
    distinct_on: [storage_migrations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_migrations_order_by!]

    """filter the rows returned"""
    where: storage_migrations_bool_exp
  ): [storage_migrations!]!

  """
  fetch aggregated fields from the table: "storage.migrations"
  """
  storage_migrations_aggregate(
    """distinct select on columns"""
    distinct_on: [storage_migrations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_migrations_order_by!]

    """filter the rows returned"""
    where: storage_migrations_bool_exp
  ): storage_migrations_aggregate!

  """
  fetch data from the table: "storage.migrations" using primary key columns
  """
  storage_migrations_by_pk(id: Int!): storage_migrations

  """
  fetch data from the table: "storage.objects"
  """
  storage_objects(
    """distinct select on columns"""
    distinct_on: [storage_objects_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_objects_order_by!]

    """filter the rows returned"""
    where: storage_objects_bool_exp
  ): [storage_objects!]!

  """
  fetch aggregated fields from the table: "storage.objects"
  """
  storage_objects_aggregate(
    """distinct select on columns"""
    distinct_on: [storage_objects_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_objects_order_by!]

    """filter the rows returned"""
    where: storage_objects_bool_exp
  ): storage_objects_aggregate!

  """fetch data from the table: "storage.objects" using primary key columns"""
  storage_objects_by_pk(id: uuid!): storage_objects

  """
  fetch data from the table: "storage.prefixes"
  """
  storage_prefixes(
    """distinct select on columns"""
    distinct_on: [storage_prefixes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_prefixes_order_by!]

    """filter the rows returned"""
    where: storage_prefixes_bool_exp
  ): [storage_prefixes!]!

  """
  fetch aggregated fields from the table: "storage.prefixes"
  """
  storage_prefixes_aggregate(
    """distinct select on columns"""
    distinct_on: [storage_prefixes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_prefixes_order_by!]

    """filter the rows returned"""
    where: storage_prefixes_bool_exp
  ): storage_prefixes_aggregate!

  """
  fetch data from the table: "storage.prefixes" using primary key columns
  """
  storage_prefixes_by_pk(bucket_id: String!, level: Int!, name: String!): storage_prefixes

  """
  fetch data from the table: "storage.s3_multipart_uploads"
  """
  storage_s3_multipart_uploads(
    """distinct select on columns"""
    distinct_on: [storage_s3_multipart_uploads_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_s3_multipart_uploads_order_by!]

    """filter the rows returned"""
    where: storage_s3_multipart_uploads_bool_exp
  ): [storage_s3_multipart_uploads!]!

  """
  fetch aggregated fields from the table: "storage.s3_multipart_uploads"
  """
  storage_s3_multipart_uploads_aggregate(
    """distinct select on columns"""
    distinct_on: [storage_s3_multipart_uploads_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_s3_multipart_uploads_order_by!]

    """filter the rows returned"""
    where: storage_s3_multipart_uploads_bool_exp
  ): storage_s3_multipart_uploads_aggregate!

  """
  fetch data from the table: "storage.s3_multipart_uploads" using primary key columns
  """
  storage_s3_multipart_uploads_by_pk(id: String!): storage_s3_multipart_uploads

  """
  fetch data from the table: "storage.s3_multipart_uploads_parts"
  """
  storage_s3_multipart_uploads_parts(
    """distinct select on columns"""
    distinct_on: [storage_s3_multipart_uploads_parts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_s3_multipart_uploads_parts_order_by!]

    """filter the rows returned"""
    where: storage_s3_multipart_uploads_parts_bool_exp
  ): [storage_s3_multipart_uploads_parts!]!

  """
  fetch aggregated fields from the table: "storage.s3_multipart_uploads_parts"
  """
  storage_s3_multipart_uploads_parts_aggregate(
    """distinct select on columns"""
    distinct_on: [storage_s3_multipart_uploads_parts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_s3_multipart_uploads_parts_order_by!]

    """filter the rows returned"""
    where: storage_s3_multipart_uploads_parts_bool_exp
  ): storage_s3_multipart_uploads_parts_aggregate!

  """
  fetch data from the table: "storage.s3_multipart_uploads_parts" using primary key columns
  """
  storage_s3_multipart_uploads_parts_by_pk(id: uuid!): storage_s3_multipart_uploads_parts

  """
  fetch data from the table: "subscription_limits"
  """
  subscription_limits(
    """distinct select on columns"""
    distinct_on: [subscription_limits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscription_limits_order_by!]

    """filter the rows returned"""
    where: subscription_limits_bool_exp
  ): [subscription_limits!]!

  """
  fetch aggregated fields from the table: "subscription_limits"
  """
  subscription_limits_aggregate(
    """distinct select on columns"""
    distinct_on: [subscription_limits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscription_limits_order_by!]

    """filter the rows returned"""
    where: subscription_limits_bool_exp
  ): subscription_limits_aggregate!

  """
  fetch data from the table: "subscription_limits" using primary key columns
  """
  subscription_limits_by_pk(id: uuid!): subscription_limits

  """
  fetch data from the table: "subscription_status_log"
  """
  subscription_status_log(
    """distinct select on columns"""
    distinct_on: [subscription_status_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscription_status_log_order_by!]

    """filter the rows returned"""
    where: subscription_status_log_bool_exp
  ): [subscription_status_log!]!

  """
  fetch aggregated fields from the table: "subscription_status_log"
  """
  subscription_status_log_aggregate(
    """distinct select on columns"""
    distinct_on: [subscription_status_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscription_status_log_order_by!]

    """filter the rows returned"""
    where: subscription_status_log_bool_exp
  ): subscription_status_log_aggregate!

  """
  fetch data from the table: "subscription_status_log" using primary key columns
  """
  subscription_status_log_by_pk(id: uuid!): subscription_status_log

  """
  fetch data from the table: "subscription_usage"
  """
  subscription_usage(
    """distinct select on columns"""
    distinct_on: [subscription_usage_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscription_usage_order_by!]

    """filter the rows returned"""
    where: subscription_usage_bool_exp
  ): [subscription_usage!]!

  """
  fetch aggregated fields from the table: "subscription_usage"
  """
  subscription_usage_aggregate(
    """distinct select on columns"""
    distinct_on: [subscription_usage_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscription_usage_order_by!]

    """filter the rows returned"""
    where: subscription_usage_bool_exp
  ): subscription_usage_aggregate!

  """
  fetch data from the table: "subscription_usage" using primary key columns
  """
  subscription_usage_by_pk(id: uuid!): subscription_usage

  """
  fetch data from the table: "subscriptions"
  """
  subscriptions(
    """distinct select on columns"""
    distinct_on: [subscriptions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscriptions_order_by!]

    """filter the rows returned"""
    where: subscriptions_bool_exp
  ): [subscriptions!]!

  """
  fetch aggregated fields from the table: "subscriptions"
  """
  subscriptions_aggregate(
    """distinct select on columns"""
    distinct_on: [subscriptions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscriptions_order_by!]

    """filter the rows returned"""
    where: subscriptions_bool_exp
  ): subscriptions_aggregate!

  """fetch data from the table: "subscriptions" using primary key columns"""
  subscriptions_by_pk(id: uuid!): subscriptions

  """
  fetch data from the table: "supabase_migrations.schema_migrations"
  """
  supabase_migrations_schema_migrations(
    """distinct select on columns"""
    distinct_on: [supabase_migrations_schema_migrations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [supabase_migrations_schema_migrations_order_by!]

    """filter the rows returned"""
    where: supabase_migrations_schema_migrations_bool_exp
  ): [supabase_migrations_schema_migrations!]!

  """
  fetch aggregated fields from the table: "supabase_migrations.schema_migrations"
  """
  supabase_migrations_schema_migrations_aggregate(
    """distinct select on columns"""
    distinct_on: [supabase_migrations_schema_migrations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [supabase_migrations_schema_migrations_order_by!]

    """filter the rows returned"""
    where: supabase_migrations_schema_migrations_bool_exp
  ): supabase_migrations_schema_migrations_aggregate!

  """
  fetch data from the table: "supabase_migrations.schema_migrations" using primary key columns
  """
  supabase_migrations_schema_migrations_by_pk(version: String!): supabase_migrations_schema_migrations

  """
  fetch data from the table: "supabase_migrations.seed_files"
  """
  supabase_migrations_seed_files(
    """distinct select on columns"""
    distinct_on: [supabase_migrations_seed_files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [supabase_migrations_seed_files_order_by!]

    """filter the rows returned"""
    where: supabase_migrations_seed_files_bool_exp
  ): [supabase_migrations_seed_files!]!

  """
  fetch aggregated fields from the table: "supabase_migrations.seed_files"
  """
  supabase_migrations_seed_files_aggregate(
    """distinct select on columns"""
    distinct_on: [supabase_migrations_seed_files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [supabase_migrations_seed_files_order_by!]

    """filter the rows returned"""
    where: supabase_migrations_seed_files_bool_exp
  ): supabase_migrations_seed_files_aggregate!

  """
  fetch data from the table: "supabase_migrations.seed_files" using primary key columns
  """
  supabase_migrations_seed_files_by_pk(path: String!): supabase_migrations_seed_files

  """
  fetch data from the table: "support_agents"
  """
  support_agents(
    """distinct select on columns"""
    distinct_on: [support_agents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [support_agents_order_by!]

    """filter the rows returned"""
    where: support_agents_bool_exp
  ): [support_agents!]!

  """
  fetch aggregated fields from the table: "support_agents"
  """
  support_agents_aggregate(
    """distinct select on columns"""
    distinct_on: [support_agents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [support_agents_order_by!]

    """filter the rows returned"""
    where: support_agents_bool_exp
  ): support_agents_aggregate!

  """fetch data from the table: "support_agents" using primary key columns"""
  support_agents_by_pk(id: uuid!): support_agents

  """
  fetch data from the table: "support_interactions"
  """
  support_interactions(
    """distinct select on columns"""
    distinct_on: [support_interactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [support_interactions_order_by!]

    """filter the rows returned"""
    where: support_interactions_bool_exp
  ): [support_interactions!]!

  """
  fetch aggregated fields from the table: "support_interactions"
  """
  support_interactions_aggregate(
    """distinct select on columns"""
    distinct_on: [support_interactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [support_interactions_order_by!]

    """filter the rows returned"""
    where: support_interactions_bool_exp
  ): support_interactions_aggregate!

  """
  fetch data from the table: "support_interactions" using primary key columns
  """
  support_interactions_by_pk(id: uuid!): support_interactions

  """An array relationship"""
  support_messages(
    """distinct select on columns"""
    distinct_on: [support_messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [support_messages_order_by!]

    """filter the rows returned"""
    where: support_messages_bool_exp
  ): [support_messages!]!

  """An aggregate relationship"""
  support_messages_aggregate(
    """distinct select on columns"""
    distinct_on: [support_messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [support_messages_order_by!]

    """filter the rows returned"""
    where: support_messages_bool_exp
  ): support_messages_aggregate!

  """
  fetch data from the table: "support_messages" using primary key columns
  """
  support_messages_by_pk(id: uuid!): support_messages

  """
  fetch data from the table: "support_tickets"
  """
  support_tickets(
    """distinct select on columns"""
    distinct_on: [support_tickets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [support_tickets_order_by!]

    """filter the rows returned"""
    where: support_tickets_bool_exp
  ): [support_tickets!]!

  """
  fetch aggregated fields from the table: "support_tickets"
  """
  support_tickets_aggregate(
    """distinct select on columns"""
    distinct_on: [support_tickets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [support_tickets_order_by!]

    """filter the rows returned"""
    where: support_tickets_bool_exp
  ): support_tickets_aggregate!

  """fetch data from the table: "support_tickets" using primary key columns"""
  support_tickets_by_pk(id: uuid!): support_tickets

  """An array relationship"""
  system_settings(
    """distinct select on columns"""
    distinct_on: [system_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [system_settings_order_by!]

    """filter the rows returned"""
    where: system_settings_bool_exp
  ): [system_settings!]!

  """An aggregate relationship"""
  system_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [system_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [system_settings_order_by!]

    """filter the rows returned"""
    where: system_settings_bool_exp
  ): system_settings_aggregate!

  """fetch data from the table: "system_settings" using primary key columns"""
  system_settings_by_pk(id: uuid!): system_settings

  """
  fetch data from the table: "team_member_performance"
  """
  team_member_performance(
    """distinct select on columns"""
    distinct_on: [team_member_performance_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_member_performance_order_by!]

    """filter the rows returned"""
    where: team_member_performance_bool_exp
  ): [team_member_performance!]!

  """
  fetch aggregated fields from the table: "team_member_performance"
  """
  team_member_performance_aggregate(
    """distinct select on columns"""
    distinct_on: [team_member_performance_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_member_performance_order_by!]

    """filter the rows returned"""
    where: team_member_performance_bool_exp
  ): team_member_performance_aggregate!

  """
  fetch data from the table: "team_member_performance" using primary key columns
  """
  team_member_performance_by_pk(id: uuid!): team_member_performance

  """
  fetch data from the table: "two_factor_backup_codes"
  """
  two_factor_backup_codes(
    """distinct select on columns"""
    distinct_on: [two_factor_backup_codes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [two_factor_backup_codes_order_by!]

    """filter the rows returned"""
    where: two_factor_backup_codes_bool_exp
  ): [two_factor_backup_codes!]!

  """
  fetch aggregated fields from the table: "two_factor_backup_codes"
  """
  two_factor_backup_codes_aggregate(
    """distinct select on columns"""
    distinct_on: [two_factor_backup_codes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [two_factor_backup_codes_order_by!]

    """filter the rows returned"""
    where: two_factor_backup_codes_bool_exp
  ): two_factor_backup_codes_aggregate!

  """
  fetch data from the table: "two_factor_backup_codes" using primary key columns
  """
  two_factor_backup_codes_by_pk(id: uuid!): two_factor_backup_codes

  """
  fetch data from the table: "user_credits"
  """
  user_credits(
    """distinct select on columns"""
    distinct_on: [user_credits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_credits_order_by!]

    """filter the rows returned"""
    where: user_credits_bool_exp
  ): [user_credits!]!

  """
  fetch aggregated fields from the table: "user_credits"
  """
  user_credits_aggregate(
    """distinct select on columns"""
    distinct_on: [user_credits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_credits_order_by!]

    """filter the rows returned"""
    where: user_credits_bool_exp
  ): user_credits_aggregate!

  """fetch data from the table: "user_credits" using primary key columns"""
  user_credits_by_pk(id: uuid!): user_credits

  """
  fetch data from the table: "user_events"
  """
  user_events(
    """distinct select on columns"""
    distinct_on: [user_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_events_order_by!]

    """filter the rows returned"""
    where: user_events_bool_exp
  ): [user_events!]!

  """
  fetch aggregated fields from the table: "user_events"
  """
  user_events_aggregate(
    """distinct select on columns"""
    distinct_on: [user_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_events_order_by!]

    """filter the rows returned"""
    where: user_events_bool_exp
  ): user_events_aggregate!

  """fetch data from the table: "user_events" using primary key columns"""
  user_events_by_pk(id: uuid!): user_events

  """
  fetch data from the table: "user_sessions"
  """
  user_sessions(
    """distinct select on columns"""
    distinct_on: [user_sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_sessions_order_by!]

    """filter the rows returned"""
    where: user_sessions_bool_exp
  ): [user_sessions!]!

  """
  fetch aggregated fields from the table: "user_sessions"
  """
  user_sessions_aggregate(
    """distinct select on columns"""
    distinct_on: [user_sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_sessions_order_by!]

    """filter the rows returned"""
    where: user_sessions_bool_exp
  ): user_sessions_aggregate!

  """fetch data from the table: "user_sessions" using primary key columns"""
  user_sessions_by_pk(id: uuid!): user_sessions

  """An array relationship"""
  video_interviews(
    """distinct select on columns"""
    distinct_on: [video_interviews_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [video_interviews_order_by!]

    """filter the rows returned"""
    where: video_interviews_bool_exp
  ): [video_interviews!]!

  """An aggregate relationship"""
  video_interviews_aggregate(
    """distinct select on columns"""
    distinct_on: [video_interviews_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [video_interviews_order_by!]

    """filter the rows returned"""
    where: video_interviews_bool_exp
  ): video_interviews_aggregate!

  """
  fetch data from the table: "video_interviews" using primary key columns
  """
  video_interviews_by_pk(id: uuid!): video_interviews

  """An array relationship"""
  webhook_event_logs(
    """distinct select on columns"""
    distinct_on: [webhook_event_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [webhook_event_logs_order_by!]

    """filter the rows returned"""
    where: webhook_event_logs_bool_exp
  ): [webhook_event_logs!]!

  """An aggregate relationship"""
  webhook_event_logs_aggregate(
    """distinct select on columns"""
    distinct_on: [webhook_event_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [webhook_event_logs_order_by!]

    """filter the rows returned"""
    where: webhook_event_logs_bool_exp
  ): webhook_event_logs_aggregate!

  """
  fetch data from the table: "webhook_event_logs" using primary key columns
  """
  webhook_event_logs_by_pk(id: uuid!): webhook_event_logs

  """
  fetch data from the table: "whatsapp_messages"
  """
  whatsapp_messages(
    """distinct select on columns"""
    distinct_on: [whatsapp_messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [whatsapp_messages_order_by!]

    """filter the rows returned"""
    where: whatsapp_messages_bool_exp
  ): [whatsapp_messages!]!

  """
  fetch aggregated fields from the table: "whatsapp_messages"
  """
  whatsapp_messages_aggregate(
    """distinct select on columns"""
    distinct_on: [whatsapp_messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [whatsapp_messages_order_by!]

    """filter the rows returned"""
    where: whatsapp_messages_bool_exp
  ): whatsapp_messages_aggregate!

  """
  fetch data from the table: "whatsapp_messages" using primary key columns
  """
  whatsapp_messages_by_pk(id: uuid!): whatsapp_messages

  """
  fetch data from the table: "work_experience"
  """
  work_experience(
    """distinct select on columns"""
    distinct_on: [work_experience_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [work_experience_order_by!]

    """filter the rows returned"""
    where: work_experience_bool_exp
  ): [work_experience!]!

  """
  fetch aggregated fields from the table: "work_experience"
  """
  work_experience_aggregate(
    """distinct select on columns"""
    distinct_on: [work_experience_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [work_experience_order_by!]

    """filter the rows returned"""
    where: work_experience_bool_exp
  ): work_experience_aggregate!

  """fetch data from the table: "work_experience" using primary key columns"""
  work_experience_by_pk(id: uuid!): work_experience
}

"""
columns and relationships of "realtime.messages"
"""
type realtime_messages {
  event: String
  extension: String!
  id: uuid!
  inserted_at: timestamp!
  payload(
    """JSON select path"""
    path: String
  ): jsonb
  private: Boolean
  topic: String!
  updated_at: timestamp!
}

"""
aggregated selection of "realtime.messages"
"""
type realtime_messages_aggregate {
  aggregate: realtime_messages_aggregate_fields
  nodes: [realtime_messages!]!
}

"""
aggregate fields of "realtime.messages"
"""
type realtime_messages_aggregate_fields {
  count(columns: [realtime_messages_select_column!], distinct: Boolean): Int!
  max: realtime_messages_max_fields
  min: realtime_messages_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input realtime_messages_append_input {
  payload: jsonb
}

"""
Boolean expression to filter rows from the table "realtime.messages". All fields are combined with a logical 'AND'.
"""
input realtime_messages_bool_exp {
  _and: [realtime_messages_bool_exp!]
  _not: realtime_messages_bool_exp
  _or: [realtime_messages_bool_exp!]
  event: String_comparison_exp
  extension: String_comparison_exp
  id: uuid_comparison_exp
  inserted_at: timestamp_comparison_exp
  payload: jsonb_comparison_exp
  private: Boolean_comparison_exp
  topic: String_comparison_exp
  updated_at: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "realtime.messages"
"""
enum realtime_messages_constraint {
  """
  unique or primary key constraint on columns "id", "inserted_at"
  """
  messages_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input realtime_messages_delete_at_path_input {
  payload: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input realtime_messages_delete_elem_input {
  payload: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input realtime_messages_delete_key_input {
  payload: String
}

"""
input type for inserting data into table "realtime.messages"
"""
input realtime_messages_insert_input {
  event: String
  extension: String
  id: uuid
  inserted_at: timestamp
  payload: jsonb
  private: Boolean
  topic: String
  updated_at: timestamp
}

"""aggregate max on columns"""
type realtime_messages_max_fields {
  event: String
  extension: String
  id: uuid
  inserted_at: timestamp
  topic: String
  updated_at: timestamp
}

"""aggregate min on columns"""
type realtime_messages_min_fields {
  event: String
  extension: String
  id: uuid
  inserted_at: timestamp
  topic: String
  updated_at: timestamp
}

"""
response of any mutation on the table "realtime.messages"
"""
type realtime_messages_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [realtime_messages!]!
}

"""
on_conflict condition type for table "realtime.messages"
"""
input realtime_messages_on_conflict {
  constraint: realtime_messages_constraint!
  update_columns: [realtime_messages_update_column!]! = []
  where: realtime_messages_bool_exp
}

"""Ordering options when selecting data from "realtime.messages"."""
input realtime_messages_order_by {
  event: order_by
  extension: order_by
  id: order_by
  inserted_at: order_by
  payload: order_by
  private: order_by
  topic: order_by
  updated_at: order_by
}

"""primary key columns input for table: realtime.messages"""
input realtime_messages_pk_columns_input {
  id: uuid!
  inserted_at: timestamp!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input realtime_messages_prepend_input {
  payload: jsonb
}

"""
select columns of table "realtime.messages"
"""
enum realtime_messages_select_column {
  """column name"""
  event

  """column name"""
  extension

  """column name"""
  id

  """column name"""
  inserted_at

  """column name"""
  payload

  """column name"""
  private

  """column name"""
  topic

  """column name"""
  updated_at
}

"""
input type for updating data in table "realtime.messages"
"""
input realtime_messages_set_input {
  event: String
  extension: String
  id: uuid
  inserted_at: timestamp
  payload: jsonb
  private: Boolean
  topic: String
  updated_at: timestamp
}

"""
Streaming cursor of the table "realtime_messages"
"""
input realtime_messages_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: realtime_messages_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input realtime_messages_stream_cursor_value_input {
  event: String
  extension: String
  id: uuid
  inserted_at: timestamp
  payload: jsonb
  private: Boolean
  topic: String
  updated_at: timestamp
}

"""
update columns of table "realtime.messages"
"""
enum realtime_messages_update_column {
  """column name"""
  event

  """column name"""
  extension

  """column name"""
  id

  """column name"""
  inserted_at

  """column name"""
  payload

  """column name"""
  private

  """column name"""
  topic

  """column name"""
  updated_at
}

input realtime_messages_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: realtime_messages_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: realtime_messages_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: realtime_messages_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: realtime_messages_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: realtime_messages_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: realtime_messages_set_input

  """filter the rows which have to be updated"""
  where: realtime_messages_bool_exp!
}

"""
columns and relationships of "realtime.subscription"
"""
type realtime_subscription {
  claims(
    """JSON select path"""
    path: String
  ): jsonb!
  claims_role: regrole!
  created_at: timestamp!
  entity: regclass!
  filters: [user_defined_filter!]!
  id: bigint!
  subscription_id: uuid!
}

"""
aggregated selection of "realtime.subscription"
"""
type realtime_subscription_aggregate {
  aggregate: realtime_subscription_aggregate_fields
  nodes: [realtime_subscription!]!
}

"""
aggregate fields of "realtime.subscription"
"""
type realtime_subscription_aggregate_fields {
  avg: realtime_subscription_avg_fields
  count(columns: [realtime_subscription_select_column!], distinct: Boolean): Int!
  max: realtime_subscription_max_fields
  min: realtime_subscription_min_fields
  stddev: realtime_subscription_stddev_fields
  stddev_pop: realtime_subscription_stddev_pop_fields
  stddev_samp: realtime_subscription_stddev_samp_fields
  sum: realtime_subscription_sum_fields
  var_pop: realtime_subscription_var_pop_fields
  var_samp: realtime_subscription_var_samp_fields
  variance: realtime_subscription_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input realtime_subscription_append_input {
  claims: jsonb
}

"""aggregate avg on columns"""
type realtime_subscription_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "realtime.subscription". All fields are combined with a logical 'AND'.
"""
input realtime_subscription_bool_exp {
  _and: [realtime_subscription_bool_exp!]
  _not: realtime_subscription_bool_exp
  _or: [realtime_subscription_bool_exp!]
  claims: jsonb_comparison_exp
  claims_role: regrole_comparison_exp
  created_at: timestamp_comparison_exp
  entity: regclass_comparison_exp
  filters: user_defined_filter_array_comparison_exp
  id: bigint_comparison_exp
  subscription_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "realtime.subscription"
"""
enum realtime_subscription_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  pk_subscription

  """
  unique or primary key constraint on columns "subscription_id", "entity", "filters"
  """
  subscription_subscription_id_entity_filters_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input realtime_subscription_delete_at_path_input {
  claims: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input realtime_subscription_delete_elem_input {
  claims: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input realtime_subscription_delete_key_input {
  claims: String
}

"""
input type for inserting data into table "realtime.subscription"
"""
input realtime_subscription_insert_input {
  claims: jsonb
  created_at: timestamp
  entity: regclass
  filters: [user_defined_filter!]
  subscription_id: uuid
}

"""aggregate max on columns"""
type realtime_subscription_max_fields {
  created_at: timestamp
  filters: [user_defined_filter!]
  id: bigint
  subscription_id: uuid
}

"""aggregate min on columns"""
type realtime_subscription_min_fields {
  created_at: timestamp
  filters: [user_defined_filter!]
  id: bigint
  subscription_id: uuid
}

"""
response of any mutation on the table "realtime.subscription"
"""
type realtime_subscription_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [realtime_subscription!]!
}

"""
on_conflict condition type for table "realtime.subscription"
"""
input realtime_subscription_on_conflict {
  constraint: realtime_subscription_constraint!
  update_columns: [realtime_subscription_update_column!]! = []
  where: realtime_subscription_bool_exp
}

"""Ordering options when selecting data from "realtime.subscription"."""
input realtime_subscription_order_by {
  claims: order_by
  claims_role: order_by
  created_at: order_by
  entity: order_by
  filters: order_by
  id: order_by
  subscription_id: order_by
}

"""primary key columns input for table: realtime.subscription"""
input realtime_subscription_pk_columns_input {
  id: bigint!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input realtime_subscription_prepend_input {
  claims: jsonb
}

"""
select columns of table "realtime.subscription"
"""
enum realtime_subscription_select_column {
  """column name"""
  claims

  """column name"""
  claims_role

  """column name"""
  created_at

  """column name"""
  entity

  """column name"""
  filters

  """column name"""
  id

  """column name"""
  subscription_id
}

"""
input type for updating data in table "realtime.subscription"
"""
input realtime_subscription_set_input {
  claims: jsonb
  created_at: timestamp
  entity: regclass
  filters: [user_defined_filter!]
  subscription_id: uuid
}

"""aggregate stddev on columns"""
type realtime_subscription_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type realtime_subscription_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type realtime_subscription_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "realtime_subscription"
"""
input realtime_subscription_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: realtime_subscription_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input realtime_subscription_stream_cursor_value_input {
  claims: jsonb
  claims_role: regrole
  created_at: timestamp
  entity: regclass
  filters: [user_defined_filter!]
  id: bigint
  subscription_id: uuid
}

"""aggregate sum on columns"""
type realtime_subscription_sum_fields {
  id: bigint
}

"""
update columns of table "realtime.subscription"
"""
enum realtime_subscription_update_column {
  """column name"""
  claims

  """column name"""
  created_at

  """column name"""
  entity

  """column name"""
  filters

  """column name"""
  subscription_id
}

input realtime_subscription_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: realtime_subscription_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: realtime_subscription_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: realtime_subscription_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: realtime_subscription_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: realtime_subscription_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: realtime_subscription_set_input

  """filter the rows which have to be updated"""
  where: realtime_subscription_bool_exp!
}

"""aggregate var_pop on columns"""
type realtime_subscription_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type realtime_subscription_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type realtime_subscription_variance_fields {
  id: Float
}

scalar regclass

"""
Boolean expression to compare columns of type "regclass". All fields are combined with logical 'AND'.
"""
input regclass_comparison_exp {
  _eq: regclass
  _gt: regclass
  _gte: regclass
  _in: [regclass!]
  _is_null: Boolean
  _lt: regclass
  _lte: regclass
  _neq: regclass
  _nin: [regclass!]
}

scalar regrole

"""
Boolean expression to compare columns of type "regrole". All fields are combined with logical 'AND'.
"""
input regrole_comparison_exp {
  _eq: regrole
  _gt: regrole
  _gte: regrole
  _in: [regrole!]
  _is_null: Boolean
  _lt: regrole
  _lte: regrole
  _neq: regrole
  _nin: [regrole!]
}

"""
columns and relationships of "reviews"
"""
type reviews {
  comment: String
  created_at: timestamptz
  id: uuid!
  maid_id: uuid
  rating: Int
  sponsor_id: uuid
}

"""
aggregated selection of "reviews"
"""
type reviews_aggregate {
  aggregate: reviews_aggregate_fields
  nodes: [reviews!]!
}

"""
aggregate fields of "reviews"
"""
type reviews_aggregate_fields {
  avg: reviews_avg_fields
  count(columns: [reviews_select_column!], distinct: Boolean): Int!
  max: reviews_max_fields
  min: reviews_min_fields
  stddev: reviews_stddev_fields
  stddev_pop: reviews_stddev_pop_fields
  stddev_samp: reviews_stddev_samp_fields
  sum: reviews_sum_fields
  var_pop: reviews_var_pop_fields
  var_samp: reviews_var_samp_fields
  variance: reviews_variance_fields
}

"""aggregate avg on columns"""
type reviews_avg_fields {
  rating: Float
}

"""
Boolean expression to filter rows from the table "reviews". All fields are combined with a logical 'AND'.
"""
input reviews_bool_exp {
  _and: [reviews_bool_exp!]
  _not: reviews_bool_exp
  _or: [reviews_bool_exp!]
  comment: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  maid_id: uuid_comparison_exp
  rating: Int_comparison_exp
  sponsor_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "reviews"
"""
enum reviews_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  reviews_pkey
}

"""
input type for incrementing numeric columns in table "reviews"
"""
input reviews_inc_input {
  rating: Int
}

"""
input type for inserting data into table "reviews"
"""
input reviews_insert_input {
  comment: String
  created_at: timestamptz
  id: uuid
  maid_id: uuid
  rating: Int
  sponsor_id: uuid
}

"""aggregate max on columns"""
type reviews_max_fields {
  comment: String
  created_at: timestamptz
  id: uuid
  maid_id: uuid
  rating: Int
  sponsor_id: uuid
}

"""aggregate min on columns"""
type reviews_min_fields {
  comment: String
  created_at: timestamptz
  id: uuid
  maid_id: uuid
  rating: Int
  sponsor_id: uuid
}

"""
response of any mutation on the table "reviews"
"""
type reviews_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [reviews!]!
}

"""
on_conflict condition type for table "reviews"
"""
input reviews_on_conflict {
  constraint: reviews_constraint!
  update_columns: [reviews_update_column!]! = []
  where: reviews_bool_exp
}

"""Ordering options when selecting data from "reviews"."""
input reviews_order_by {
  comment: order_by
  created_at: order_by
  id: order_by
  maid_id: order_by
  rating: order_by
  sponsor_id: order_by
}

"""primary key columns input for table: reviews"""
input reviews_pk_columns_input {
  id: uuid!
}

"""
select columns of table "reviews"
"""
enum reviews_select_column {
  """column name"""
  comment

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  maid_id

  """column name"""
  rating

  """column name"""
  sponsor_id
}

"""
input type for updating data in table "reviews"
"""
input reviews_set_input {
  comment: String
  created_at: timestamptz
  id: uuid
  maid_id: uuid
  rating: Int
  sponsor_id: uuid
}

"""aggregate stddev on columns"""
type reviews_stddev_fields {
  rating: Float
}

"""aggregate stddev_pop on columns"""
type reviews_stddev_pop_fields {
  rating: Float
}

"""aggregate stddev_samp on columns"""
type reviews_stddev_samp_fields {
  rating: Float
}

"""
Streaming cursor of the table "reviews"
"""
input reviews_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: reviews_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input reviews_stream_cursor_value_input {
  comment: String
  created_at: timestamptz
  id: uuid
  maid_id: uuid
  rating: Int
  sponsor_id: uuid
}

"""aggregate sum on columns"""
type reviews_sum_fields {
  rating: Int
}

"""
update columns of table "reviews"
"""
enum reviews_update_column {
  """column name"""
  comment

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  maid_id

  """column name"""
  rating

  """column name"""
  sponsor_id
}

input reviews_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: reviews_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: reviews_set_input

  """filter the rows which have to be updated"""
  where: reviews_bool_exp!
}

"""aggregate var_pop on columns"""
type reviews_var_pop_fields {
  rating: Float
}

"""aggregate var_samp on columns"""
type reviews_var_samp_fields {
  rating: Float
}

"""aggregate variance on columns"""
type reviews_variance_fields {
  rating: Float
}

"""
columns and relationships of "security_events"
"""
type security_events {
  """An object relationship"""
  admin_user: admin_users
  created_at: timestamptz
  details(
    """JSON select path"""
    path: String
  ): jsonb!
  event_type: String!
  handled: Boolean
  handled_at: timestamptz
  handled_by: uuid
  id: uuid!
  requires_action: Boolean
  severity: String!
}

"""
aggregated selection of "security_events"
"""
type security_events_aggregate {
  aggregate: security_events_aggregate_fields
  nodes: [security_events!]!
}

input security_events_aggregate_bool_exp {
  bool_and: security_events_aggregate_bool_exp_bool_and
  bool_or: security_events_aggregate_bool_exp_bool_or
  count: security_events_aggregate_bool_exp_count
}

input security_events_aggregate_bool_exp_bool_and {
  arguments: security_events_select_column_security_events_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: security_events_bool_exp
  predicate: Boolean_comparison_exp!
}

input security_events_aggregate_bool_exp_bool_or {
  arguments: security_events_select_column_security_events_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: security_events_bool_exp
  predicate: Boolean_comparison_exp!
}

input security_events_aggregate_bool_exp_count {
  arguments: [security_events_select_column!]
  distinct: Boolean
  filter: security_events_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "security_events"
"""
type security_events_aggregate_fields {
  count(columns: [security_events_select_column!], distinct: Boolean): Int!
  max: security_events_max_fields
  min: security_events_min_fields
}

"""
order by aggregate values of table "security_events"
"""
input security_events_aggregate_order_by {
  count: order_by
  max: security_events_max_order_by
  min: security_events_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input security_events_append_input {
  details: jsonb
}

"""
input type for inserting array relation for remote table "security_events"
"""
input security_events_arr_rel_insert_input {
  data: [security_events_insert_input!]!

  """upsert condition"""
  on_conflict: security_events_on_conflict
}

"""
Boolean expression to filter rows from the table "security_events". All fields are combined with a logical 'AND'.
"""
input security_events_bool_exp {
  _and: [security_events_bool_exp!]
  _not: security_events_bool_exp
  _or: [security_events_bool_exp!]
  admin_user: admin_users_bool_exp
  created_at: timestamptz_comparison_exp
  details: jsonb_comparison_exp
  event_type: String_comparison_exp
  handled: Boolean_comparison_exp
  handled_at: timestamptz_comparison_exp
  handled_by: uuid_comparison_exp
  id: uuid_comparison_exp
  requires_action: Boolean_comparison_exp
  severity: String_comparison_exp
}

"""
unique or primary key constraints on table "security_events"
"""
enum security_events_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  security_events_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input security_events_delete_at_path_input {
  details: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input security_events_delete_elem_input {
  details: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input security_events_delete_key_input {
  details: String
}

"""
input type for inserting data into table "security_events"
"""
input security_events_insert_input {
  admin_user: admin_users_obj_rel_insert_input
  created_at: timestamptz
  details: jsonb
  event_type: String
  handled: Boolean
  handled_at: timestamptz
  handled_by: uuid
  id: uuid
  requires_action: Boolean
  severity: String
}

"""aggregate max on columns"""
type security_events_max_fields {
  created_at: timestamptz
  event_type: String
  handled_at: timestamptz
  handled_by: uuid
  id: uuid
  severity: String
}

"""
order by max() on columns of table "security_events"
"""
input security_events_max_order_by {
  created_at: order_by
  event_type: order_by
  handled_at: order_by
  handled_by: order_by
  id: order_by
  severity: order_by
}

"""aggregate min on columns"""
type security_events_min_fields {
  created_at: timestamptz
  event_type: String
  handled_at: timestamptz
  handled_by: uuid
  id: uuid
  severity: String
}

"""
order by min() on columns of table "security_events"
"""
input security_events_min_order_by {
  created_at: order_by
  event_type: order_by
  handled_at: order_by
  handled_by: order_by
  id: order_by
  severity: order_by
}

"""
response of any mutation on the table "security_events"
"""
type security_events_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [security_events!]!
}

"""
on_conflict condition type for table "security_events"
"""
input security_events_on_conflict {
  constraint: security_events_constraint!
  update_columns: [security_events_update_column!]! = []
  where: security_events_bool_exp
}

"""Ordering options when selecting data from "security_events"."""
input security_events_order_by {
  admin_user: admin_users_order_by
  created_at: order_by
  details: order_by
  event_type: order_by
  handled: order_by
  handled_at: order_by
  handled_by: order_by
  id: order_by
  requires_action: order_by
  severity: order_by
}

"""primary key columns input for table: security_events"""
input security_events_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input security_events_prepend_input {
  details: jsonb
}

"""
select columns of table "security_events"
"""
enum security_events_select_column {
  """column name"""
  created_at

  """column name"""
  details

  """column name"""
  event_type

  """column name"""
  handled

  """column name"""
  handled_at

  """column name"""
  handled_by

  """column name"""
  id

  """column name"""
  requires_action

  """column name"""
  severity
}

"""
select "security_events_aggregate_bool_exp_bool_and_arguments_columns" columns of table "security_events"
"""
enum security_events_select_column_security_events_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  handled

  """column name"""
  requires_action
}

"""
select "security_events_aggregate_bool_exp_bool_or_arguments_columns" columns of table "security_events"
"""
enum security_events_select_column_security_events_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  handled

  """column name"""
  requires_action
}

"""
input type for updating data in table "security_events"
"""
input security_events_set_input {
  created_at: timestamptz
  details: jsonb
  event_type: String
  handled: Boolean
  handled_at: timestamptz
  handled_by: uuid
  id: uuid
  requires_action: Boolean
  severity: String
}

"""
Streaming cursor of the table "security_events"
"""
input security_events_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: security_events_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input security_events_stream_cursor_value_input {
  created_at: timestamptz
  details: jsonb
  event_type: String
  handled: Boolean
  handled_at: timestamptz
  handled_by: uuid
  id: uuid
  requires_action: Boolean
  severity: String
}

"""
update columns of table "security_events"
"""
enum security_events_update_column {
  """column name"""
  created_at

  """column name"""
  details

  """column name"""
  event_type

  """column name"""
  handled

  """column name"""
  handled_at

  """column name"""
  handled_by

  """column name"""
  id

  """column name"""
  requires_action

  """column name"""
  severity
}

input security_events_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: security_events_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: security_events_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: security_events_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: security_events_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: security_events_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: security_events_set_input

  """filter the rows which have to be updated"""
  where: security_events_bool_exp!
}

"""Junction table linking shortlists to maid profiles"""
type shortlist_candidates {
  added_at: timestamptz
  added_by: uuid
  id: uuid!
  maid_id: uuid!
  match_score: Int
  notes: String

  """An object relationship"""
  shortlist: shortlists!
  shortlist_id: uuid!
}

"""
aggregated selection of "shortlist_candidates"
"""
type shortlist_candidates_aggregate {
  aggregate: shortlist_candidates_aggregate_fields
  nodes: [shortlist_candidates!]!
}

input shortlist_candidates_aggregate_bool_exp {
  count: shortlist_candidates_aggregate_bool_exp_count
}

input shortlist_candidates_aggregate_bool_exp_count {
  arguments: [shortlist_candidates_select_column!]
  distinct: Boolean
  filter: shortlist_candidates_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "shortlist_candidates"
"""
type shortlist_candidates_aggregate_fields {
  avg: shortlist_candidates_avg_fields
  count(columns: [shortlist_candidates_select_column!], distinct: Boolean): Int!
  max: shortlist_candidates_max_fields
  min: shortlist_candidates_min_fields
  stddev: shortlist_candidates_stddev_fields
  stddev_pop: shortlist_candidates_stddev_pop_fields
  stddev_samp: shortlist_candidates_stddev_samp_fields
  sum: shortlist_candidates_sum_fields
  var_pop: shortlist_candidates_var_pop_fields
  var_samp: shortlist_candidates_var_samp_fields
  variance: shortlist_candidates_variance_fields
}

"""
order by aggregate values of table "shortlist_candidates"
"""
input shortlist_candidates_aggregate_order_by {
  avg: shortlist_candidates_avg_order_by
  count: order_by
  max: shortlist_candidates_max_order_by
  min: shortlist_candidates_min_order_by
  stddev: shortlist_candidates_stddev_order_by
  stddev_pop: shortlist_candidates_stddev_pop_order_by
  stddev_samp: shortlist_candidates_stddev_samp_order_by
  sum: shortlist_candidates_sum_order_by
  var_pop: shortlist_candidates_var_pop_order_by
  var_samp: shortlist_candidates_var_samp_order_by
  variance: shortlist_candidates_variance_order_by
}

"""
input type for inserting array relation for remote table "shortlist_candidates"
"""
input shortlist_candidates_arr_rel_insert_input {
  data: [shortlist_candidates_insert_input!]!

  """upsert condition"""
  on_conflict: shortlist_candidates_on_conflict
}

"""aggregate avg on columns"""
type shortlist_candidates_avg_fields {
  match_score: Float
}

"""
order by avg() on columns of table "shortlist_candidates"
"""
input shortlist_candidates_avg_order_by {
  match_score: order_by
}

"""
Boolean expression to filter rows from the table "shortlist_candidates". All fields are combined with a logical 'AND'.
"""
input shortlist_candidates_bool_exp {
  _and: [shortlist_candidates_bool_exp!]
  _not: shortlist_candidates_bool_exp
  _or: [shortlist_candidates_bool_exp!]
  added_at: timestamptz_comparison_exp
  added_by: uuid_comparison_exp
  id: uuid_comparison_exp
  maid_id: uuid_comparison_exp
  match_score: Int_comparison_exp
  notes: String_comparison_exp
  shortlist: shortlists_bool_exp
  shortlist_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "shortlist_candidates"
"""
enum shortlist_candidates_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  shortlist_candidates_pkey

  """
  unique or primary key constraint on columns "maid_id", "shortlist_id"
  """
  shortlist_candidates_shortlist_id_maid_id_key
}

"""
input type for incrementing numeric columns in table "shortlist_candidates"
"""
input shortlist_candidates_inc_input {
  match_score: Int
}

"""
input type for inserting data into table "shortlist_candidates"
"""
input shortlist_candidates_insert_input {
  added_at: timestamptz
  added_by: uuid
  id: uuid
  maid_id: uuid
  match_score: Int
  notes: String
  shortlist: shortlists_obj_rel_insert_input
  shortlist_id: uuid
}

"""aggregate max on columns"""
type shortlist_candidates_max_fields {
  added_at: timestamptz
  added_by: uuid
  id: uuid
  maid_id: uuid
  match_score: Int
  notes: String
  shortlist_id: uuid
}

"""
order by max() on columns of table "shortlist_candidates"
"""
input shortlist_candidates_max_order_by {
  added_at: order_by
  added_by: order_by
  id: order_by
  maid_id: order_by
  match_score: order_by
  notes: order_by
  shortlist_id: order_by
}

"""aggregate min on columns"""
type shortlist_candidates_min_fields {
  added_at: timestamptz
  added_by: uuid
  id: uuid
  maid_id: uuid
  match_score: Int
  notes: String
  shortlist_id: uuid
}

"""
order by min() on columns of table "shortlist_candidates"
"""
input shortlist_candidates_min_order_by {
  added_at: order_by
  added_by: order_by
  id: order_by
  maid_id: order_by
  match_score: order_by
  notes: order_by
  shortlist_id: order_by
}

"""
response of any mutation on the table "shortlist_candidates"
"""
type shortlist_candidates_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [shortlist_candidates!]!
}

"""
on_conflict condition type for table "shortlist_candidates"
"""
input shortlist_candidates_on_conflict {
  constraint: shortlist_candidates_constraint!
  update_columns: [shortlist_candidates_update_column!]! = []
  where: shortlist_candidates_bool_exp
}

"""Ordering options when selecting data from "shortlist_candidates"."""
input shortlist_candidates_order_by {
  added_at: order_by
  added_by: order_by
  id: order_by
  maid_id: order_by
  match_score: order_by
  notes: order_by
  shortlist: shortlists_order_by
  shortlist_id: order_by
}

"""primary key columns input for table: shortlist_candidates"""
input shortlist_candidates_pk_columns_input {
  id: uuid!
}

"""
select columns of table "shortlist_candidates"
"""
enum shortlist_candidates_select_column {
  """column name"""
  added_at

  """column name"""
  added_by

  """column name"""
  id

  """column name"""
  maid_id

  """column name"""
  match_score

  """column name"""
  notes

  """column name"""
  shortlist_id
}

"""
input type for updating data in table "shortlist_candidates"
"""
input shortlist_candidates_set_input {
  added_at: timestamptz
  added_by: uuid
  id: uuid
  maid_id: uuid
  match_score: Int
  notes: String
  shortlist_id: uuid
}

"""aggregate stddev on columns"""
type shortlist_candidates_stddev_fields {
  match_score: Float
}

"""
order by stddev() on columns of table "shortlist_candidates"
"""
input shortlist_candidates_stddev_order_by {
  match_score: order_by
}

"""aggregate stddev_pop on columns"""
type shortlist_candidates_stddev_pop_fields {
  match_score: Float
}

"""
order by stddev_pop() on columns of table "shortlist_candidates"
"""
input shortlist_candidates_stddev_pop_order_by {
  match_score: order_by
}

"""aggregate stddev_samp on columns"""
type shortlist_candidates_stddev_samp_fields {
  match_score: Float
}

"""
order by stddev_samp() on columns of table "shortlist_candidates"
"""
input shortlist_candidates_stddev_samp_order_by {
  match_score: order_by
}

"""
Streaming cursor of the table "shortlist_candidates"
"""
input shortlist_candidates_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: shortlist_candidates_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input shortlist_candidates_stream_cursor_value_input {
  added_at: timestamptz
  added_by: uuid
  id: uuid
  maid_id: uuid
  match_score: Int
  notes: String
  shortlist_id: uuid
}

"""aggregate sum on columns"""
type shortlist_candidates_sum_fields {
  match_score: Int
}

"""
order by sum() on columns of table "shortlist_candidates"
"""
input shortlist_candidates_sum_order_by {
  match_score: order_by
}

"""
update columns of table "shortlist_candidates"
"""
enum shortlist_candidates_update_column {
  """column name"""
  added_at

  """column name"""
  added_by

  """column name"""
  id

  """column name"""
  maid_id

  """column name"""
  match_score

  """column name"""
  notes

  """column name"""
  shortlist_id
}

input shortlist_candidates_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: shortlist_candidates_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: shortlist_candidates_set_input

  """filter the rows which have to be updated"""
  where: shortlist_candidates_bool_exp!
}

"""aggregate var_pop on columns"""
type shortlist_candidates_var_pop_fields {
  match_score: Float
}

"""
order by var_pop() on columns of table "shortlist_candidates"
"""
input shortlist_candidates_var_pop_order_by {
  match_score: order_by
}

"""aggregate var_samp on columns"""
type shortlist_candidates_var_samp_fields {
  match_score: Float
}

"""
order by var_samp() on columns of table "shortlist_candidates"
"""
input shortlist_candidates_var_samp_order_by {
  match_score: order_by
}

"""aggregate variance on columns"""
type shortlist_candidates_variance_fields {
  match_score: Float
}

"""
order by variance() on columns of table "shortlist_candidates"
"""
input shortlist_candidates_variance_order_by {
  match_score: order_by
}

"""Stores agency-created shortlists for organizing top candidates"""
type shortlists {
  agency_id: uuid!
  created_at: timestamptz
  created_by: uuid
  description: String
  id: uuid!

  """An object relationship"""
  job: jobs
  job_id: uuid
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  name: String!

  """Priority level of the shortlist (low, normal, high, urgent)"""
  priority: String

  """An array relationship"""
  shortlist_candidates(
    """distinct select on columns"""
    distinct_on: [shortlist_candidates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shortlist_candidates_order_by!]

    """filter the rows returned"""
    where: shortlist_candidates_bool_exp
  ): [shortlist_candidates!]!

  """An aggregate relationship"""
  shortlist_candidates_aggregate(
    """distinct select on columns"""
    distinct_on: [shortlist_candidates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shortlist_candidates_order_by!]

    """filter the rows returned"""
    where: shortlist_candidates_bool_exp
  ): shortlist_candidates_aggregate!

  """Current status of the shortlist (active, archived, shared)"""
  status: String

  """Array of tags for categorizing shortlists"""
  tags: [String!]
  updated_at: timestamptz
}

"""
aggregated selection of "shortlists"
"""
type shortlists_aggregate {
  aggregate: shortlists_aggregate_fields
  nodes: [shortlists!]!
}

input shortlists_aggregate_bool_exp {
  count: shortlists_aggregate_bool_exp_count
}

input shortlists_aggregate_bool_exp_count {
  arguments: [shortlists_select_column!]
  distinct: Boolean
  filter: shortlists_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "shortlists"
"""
type shortlists_aggregate_fields {
  count(columns: [shortlists_select_column!], distinct: Boolean): Int!
  max: shortlists_max_fields
  min: shortlists_min_fields
}

"""
order by aggregate values of table "shortlists"
"""
input shortlists_aggregate_order_by {
  count: order_by
  max: shortlists_max_order_by
  min: shortlists_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input shortlists_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "shortlists"
"""
input shortlists_arr_rel_insert_input {
  data: [shortlists_insert_input!]!

  """upsert condition"""
  on_conflict: shortlists_on_conflict
}

"""
Boolean expression to filter rows from the table "shortlists". All fields are combined with a logical 'AND'.
"""
input shortlists_bool_exp {
  _and: [shortlists_bool_exp!]
  _not: shortlists_bool_exp
  _or: [shortlists_bool_exp!]
  agency_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  created_by: uuid_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  job: jobs_bool_exp
  job_id: uuid_comparison_exp
  metadata: jsonb_comparison_exp
  name: String_comparison_exp
  priority: String_comparison_exp
  shortlist_candidates: shortlist_candidates_bool_exp
  shortlist_candidates_aggregate: shortlist_candidates_aggregate_bool_exp
  status: String_comparison_exp
  tags: String_array_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "shortlists"
"""
enum shortlists_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  shortlists_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input shortlists_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input shortlists_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input shortlists_delete_key_input {
  metadata: String
}

"""
input type for inserting data into table "shortlists"
"""
input shortlists_insert_input {
  agency_id: uuid
  created_at: timestamptz
  created_by: uuid
  description: String
  id: uuid
  job: jobs_obj_rel_insert_input
  job_id: uuid
  metadata: jsonb
  name: String

  """Priority level of the shortlist (low, normal, high, urgent)"""
  priority: String
  shortlist_candidates: shortlist_candidates_arr_rel_insert_input

  """Current status of the shortlist (active, archived, shared)"""
  status: String

  """Array of tags for categorizing shortlists"""
  tags: [String!]
  updated_at: timestamptz
}

"""aggregate max on columns"""
type shortlists_max_fields {
  agency_id: uuid
  created_at: timestamptz
  created_by: uuid
  description: String
  id: uuid
  job_id: uuid
  name: String

  """Priority level of the shortlist (low, normal, high, urgent)"""
  priority: String

  """Current status of the shortlist (active, archived, shared)"""
  status: String

  """Array of tags for categorizing shortlists"""
  tags: [String!]
  updated_at: timestamptz
}

"""
order by max() on columns of table "shortlists"
"""
input shortlists_max_order_by {
  agency_id: order_by
  created_at: order_by
  created_by: order_by
  description: order_by
  id: order_by
  job_id: order_by
  name: order_by

  """Priority level of the shortlist (low, normal, high, urgent)"""
  priority: order_by

  """Current status of the shortlist (active, archived, shared)"""
  status: order_by

  """Array of tags for categorizing shortlists"""
  tags: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type shortlists_min_fields {
  agency_id: uuid
  created_at: timestamptz
  created_by: uuid
  description: String
  id: uuid
  job_id: uuid
  name: String

  """Priority level of the shortlist (low, normal, high, urgent)"""
  priority: String

  """Current status of the shortlist (active, archived, shared)"""
  status: String

  """Array of tags for categorizing shortlists"""
  tags: [String!]
  updated_at: timestamptz
}

"""
order by min() on columns of table "shortlists"
"""
input shortlists_min_order_by {
  agency_id: order_by
  created_at: order_by
  created_by: order_by
  description: order_by
  id: order_by
  job_id: order_by
  name: order_by

  """Priority level of the shortlist (low, normal, high, urgent)"""
  priority: order_by

  """Current status of the shortlist (active, archived, shared)"""
  status: order_by

  """Array of tags for categorizing shortlists"""
  tags: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "shortlists"
"""
type shortlists_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [shortlists!]!
}

"""
input type for inserting object relation for remote table "shortlists"
"""
input shortlists_obj_rel_insert_input {
  data: shortlists_insert_input!

  """upsert condition"""
  on_conflict: shortlists_on_conflict
}

"""
on_conflict condition type for table "shortlists"
"""
input shortlists_on_conflict {
  constraint: shortlists_constraint!
  update_columns: [shortlists_update_column!]! = []
  where: shortlists_bool_exp
}

"""Ordering options when selecting data from "shortlists"."""
input shortlists_order_by {
  agency_id: order_by
  created_at: order_by
  created_by: order_by
  description: order_by
  id: order_by
  job: jobs_order_by
  job_id: order_by
  metadata: order_by
  name: order_by
  priority: order_by
  shortlist_candidates_aggregate: shortlist_candidates_aggregate_order_by
  status: order_by
  tags: order_by
  updated_at: order_by
}

"""primary key columns input for table: shortlists"""
input shortlists_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input shortlists_prepend_input {
  metadata: jsonb
}

"""
select columns of table "shortlists"
"""
enum shortlists_select_column {
  """column name"""
  agency_id

  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  description

  """column name"""
  id

  """column name"""
  job_id

  """column name"""
  metadata

  """column name"""
  name

  """column name"""
  priority

  """column name"""
  status

  """column name"""
  tags

  """column name"""
  updated_at
}

"""
input type for updating data in table "shortlists"
"""
input shortlists_set_input {
  agency_id: uuid
  created_at: timestamptz
  created_by: uuid
  description: String
  id: uuid
  job_id: uuid
  metadata: jsonb
  name: String

  """Priority level of the shortlist (low, normal, high, urgent)"""
  priority: String

  """Current status of the shortlist (active, archived, shared)"""
  status: String

  """Array of tags for categorizing shortlists"""
  tags: [String!]
  updated_at: timestamptz
}

"""
Streaming cursor of the table "shortlists"
"""
input shortlists_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: shortlists_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input shortlists_stream_cursor_value_input {
  agency_id: uuid
  created_at: timestamptz
  created_by: uuid
  description: String
  id: uuid
  job_id: uuid
  metadata: jsonb
  name: String

  """Priority level of the shortlist (low, normal, high, urgent)"""
  priority: String

  """Current status of the shortlist (active, archived, shared)"""
  status: String

  """Array of tags for categorizing shortlists"""
  tags: [String!]
  updated_at: timestamptz
}

"""
update columns of table "shortlists"
"""
enum shortlists_update_column {
  """column name"""
  agency_id

  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  description

  """column name"""
  id

  """column name"""
  job_id

  """column name"""
  metadata

  """column name"""
  name

  """column name"""
  priority

  """column name"""
  status

  """column name"""
  tags

  """column name"""
  updated_at
}

input shortlists_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: shortlists_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: shortlists_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: shortlists_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: shortlists_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: shortlists_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: shortlists_set_input

  """filter the rows which have to be updated"""
  where: shortlists_bool_exp!
}

"""
columns and relationships of "skills"
"""
type skills {
  category: String!
  created_at: timestamptz
  description: String
  id: Int!
  name: String!
  updated_at: timestamptz
}

"""
aggregated selection of "skills"
"""
type skills_aggregate {
  aggregate: skills_aggregate_fields
  nodes: [skills!]!
}

"""
aggregate fields of "skills"
"""
type skills_aggregate_fields {
  avg: skills_avg_fields
  count(columns: [skills_select_column!], distinct: Boolean): Int!
  max: skills_max_fields
  min: skills_min_fields
  stddev: skills_stddev_fields
  stddev_pop: skills_stddev_pop_fields
  stddev_samp: skills_stddev_samp_fields
  sum: skills_sum_fields
  var_pop: skills_var_pop_fields
  var_samp: skills_var_samp_fields
  variance: skills_variance_fields
}

"""aggregate avg on columns"""
type skills_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "skills". All fields are combined with a logical 'AND'.
"""
input skills_bool_exp {
  _and: [skills_bool_exp!]
  _not: skills_bool_exp
  _or: [skills_bool_exp!]
  category: String_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "skills"
"""
enum skills_constraint {
  """
  unique or primary key constraint on columns "category", "name"
  """
  skills_name_category_key

  """
  unique or primary key constraint on columns "id"
  """
  skills_pkey
}

"""
input type for incrementing numeric columns in table "skills"
"""
input skills_inc_input {
  id: Int
}

"""
input type for inserting data into table "skills"
"""
input skills_insert_input {
  category: String
  created_at: timestamptz
  description: String
  id: Int
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type skills_max_fields {
  category: String
  created_at: timestamptz
  description: String
  id: Int
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type skills_min_fields {
  category: String
  created_at: timestamptz
  description: String
  id: Int
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "skills"
"""
type skills_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [skills!]!
}

"""
on_conflict condition type for table "skills"
"""
input skills_on_conflict {
  constraint: skills_constraint!
  update_columns: [skills_update_column!]! = []
  where: skills_bool_exp
}

"""Ordering options when selecting data from "skills"."""
input skills_order_by {
  category: order_by
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: skills"""
input skills_pk_columns_input {
  id: Int!
}

"""
select columns of table "skills"
"""
enum skills_select_column {
  """column name"""
  category

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "skills"
"""
input skills_set_input {
  category: String
  created_at: timestamptz
  description: String
  id: Int
  name: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type skills_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type skills_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type skills_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "skills"
"""
input skills_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: skills_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input skills_stream_cursor_value_input {
  category: String
  created_at: timestamptz
  description: String
  id: Int
  name: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type skills_sum_fields {
  id: Int
}

"""
update columns of table "skills"
"""
enum skills_update_column {
  """column name"""
  category

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

input skills_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: skills_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: skills_set_input

  """filter the rows which have to be updated"""
  where: skills_bool_exp!
}

"""aggregate var_pop on columns"""
type skills_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type skills_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type skills_variance_fields {
  id: Float
}

scalar smallint

"""
Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'.
"""
input smallint_comparison_exp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _is_null: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

"""Document verification data for sponsor accounts"""
type sponsor_document_verification {
  contact_phone: String!
  created_at: timestamptz
  employment_proof_mime_type: String
  employment_proof_name: String
  employment_proof_size: Int
  employment_proof_type: String!
  employment_proof_url: String
  id: uuid!
  id_file_back_mime_type: String
  id_file_back_name: String
  id_file_back_size: Int
  id_file_back_url: String
  id_file_front_mime_type: String
  id_file_front_name: String
  id_file_front_size: Int
  id_file_front_url: String
  id_number: String!
  id_type: String!
  last_submission_at: timestamptz
  residence_country: String!
  sponsor_id: uuid!

  """Number of times documents have been submitted"""
  submission_count: Int
  updated_at: timestamptz
  verification_notes: String

  """Current status of document verification process"""
  verification_status: String
  verified_at: timestamptz
  verified_by: uuid
}

"""
aggregated selection of "sponsor_document_verification"
"""
type sponsor_document_verification_aggregate {
  aggregate: sponsor_document_verification_aggregate_fields
  nodes: [sponsor_document_verification!]!
}

"""
aggregate fields of "sponsor_document_verification"
"""
type sponsor_document_verification_aggregate_fields {
  avg: sponsor_document_verification_avg_fields
  count(columns: [sponsor_document_verification_select_column!], distinct: Boolean): Int!
  max: sponsor_document_verification_max_fields
  min: sponsor_document_verification_min_fields
  stddev: sponsor_document_verification_stddev_fields
  stddev_pop: sponsor_document_verification_stddev_pop_fields
  stddev_samp: sponsor_document_verification_stddev_samp_fields
  sum: sponsor_document_verification_sum_fields
  var_pop: sponsor_document_verification_var_pop_fields
  var_samp: sponsor_document_verification_var_samp_fields
  variance: sponsor_document_verification_variance_fields
}

"""aggregate avg on columns"""
type sponsor_document_verification_avg_fields {
  employment_proof_size: Float
  id_file_back_size: Float
  id_file_front_size: Float

  """Number of times documents have been submitted"""
  submission_count: Float
}

"""
Boolean expression to filter rows from the table "sponsor_document_verification". All fields are combined with a logical 'AND'.
"""
input sponsor_document_verification_bool_exp {
  _and: [sponsor_document_verification_bool_exp!]
  _not: sponsor_document_verification_bool_exp
  _or: [sponsor_document_verification_bool_exp!]
  contact_phone: String_comparison_exp
  created_at: timestamptz_comparison_exp
  employment_proof_mime_type: String_comparison_exp
  employment_proof_name: String_comparison_exp
  employment_proof_size: Int_comparison_exp
  employment_proof_type: String_comparison_exp
  employment_proof_url: String_comparison_exp
  id: uuid_comparison_exp
  id_file_back_mime_type: String_comparison_exp
  id_file_back_name: String_comparison_exp
  id_file_back_size: Int_comparison_exp
  id_file_back_url: String_comparison_exp
  id_file_front_mime_type: String_comparison_exp
  id_file_front_name: String_comparison_exp
  id_file_front_size: Int_comparison_exp
  id_file_front_url: String_comparison_exp
  id_number: String_comparison_exp
  id_type: String_comparison_exp
  last_submission_at: timestamptz_comparison_exp
  residence_country: String_comparison_exp
  sponsor_id: uuid_comparison_exp
  submission_count: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
  verification_notes: String_comparison_exp
  verification_status: String_comparison_exp
  verified_at: timestamptz_comparison_exp
  verified_by: uuid_comparison_exp
}

"""
unique or primary key constraints on table "sponsor_document_verification"
"""
enum sponsor_document_verification_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  sponsor_document_verification_pkey

  """
  unique or primary key constraint on columns "sponsor_id"
  """
  unique_sponsor_verification
}

"""
input type for incrementing numeric columns in table "sponsor_document_verification"
"""
input sponsor_document_verification_inc_input {
  employment_proof_size: Int
  id_file_back_size: Int
  id_file_front_size: Int

  """Number of times documents have been submitted"""
  submission_count: Int
}

"""
input type for inserting data into table "sponsor_document_verification"
"""
input sponsor_document_verification_insert_input {
  contact_phone: String
  created_at: timestamptz
  employment_proof_mime_type: String
  employment_proof_name: String
  employment_proof_size: Int
  employment_proof_type: String
  employment_proof_url: String
  id: uuid
  id_file_back_mime_type: String
  id_file_back_name: String
  id_file_back_size: Int
  id_file_back_url: String
  id_file_front_mime_type: String
  id_file_front_name: String
  id_file_front_size: Int
  id_file_front_url: String
  id_number: String
  id_type: String
  last_submission_at: timestamptz
  residence_country: String
  sponsor_id: uuid

  """Number of times documents have been submitted"""
  submission_count: Int
  updated_at: timestamptz
  verification_notes: String

  """Current status of document verification process"""
  verification_status: String
  verified_at: timestamptz
  verified_by: uuid
}

"""aggregate max on columns"""
type sponsor_document_verification_max_fields {
  contact_phone: String
  created_at: timestamptz
  employment_proof_mime_type: String
  employment_proof_name: String
  employment_proof_size: Int
  employment_proof_type: String
  employment_proof_url: String
  id: uuid
  id_file_back_mime_type: String
  id_file_back_name: String
  id_file_back_size: Int
  id_file_back_url: String
  id_file_front_mime_type: String
  id_file_front_name: String
  id_file_front_size: Int
  id_file_front_url: String
  id_number: String
  id_type: String
  last_submission_at: timestamptz
  residence_country: String
  sponsor_id: uuid

  """Number of times documents have been submitted"""
  submission_count: Int
  updated_at: timestamptz
  verification_notes: String

  """Current status of document verification process"""
  verification_status: String
  verified_at: timestamptz
  verified_by: uuid
}

"""aggregate min on columns"""
type sponsor_document_verification_min_fields {
  contact_phone: String
  created_at: timestamptz
  employment_proof_mime_type: String
  employment_proof_name: String
  employment_proof_size: Int
  employment_proof_type: String
  employment_proof_url: String
  id: uuid
  id_file_back_mime_type: String
  id_file_back_name: String
  id_file_back_size: Int
  id_file_back_url: String
  id_file_front_mime_type: String
  id_file_front_name: String
  id_file_front_size: Int
  id_file_front_url: String
  id_number: String
  id_type: String
  last_submission_at: timestamptz
  residence_country: String
  sponsor_id: uuid

  """Number of times documents have been submitted"""
  submission_count: Int
  updated_at: timestamptz
  verification_notes: String

  """Current status of document verification process"""
  verification_status: String
  verified_at: timestamptz
  verified_by: uuid
}

"""
response of any mutation on the table "sponsor_document_verification"
"""
type sponsor_document_verification_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [sponsor_document_verification!]!
}

"""
on_conflict condition type for table "sponsor_document_verification"
"""
input sponsor_document_verification_on_conflict {
  constraint: sponsor_document_verification_constraint!
  update_columns: [sponsor_document_verification_update_column!]! = []
  where: sponsor_document_verification_bool_exp
}

"""
Ordering options when selecting data from "sponsor_document_verification".
"""
input sponsor_document_verification_order_by {
  contact_phone: order_by
  created_at: order_by
  employment_proof_mime_type: order_by
  employment_proof_name: order_by
  employment_proof_size: order_by
  employment_proof_type: order_by
  employment_proof_url: order_by
  id: order_by
  id_file_back_mime_type: order_by
  id_file_back_name: order_by
  id_file_back_size: order_by
  id_file_back_url: order_by
  id_file_front_mime_type: order_by
  id_file_front_name: order_by
  id_file_front_size: order_by
  id_file_front_url: order_by
  id_number: order_by
  id_type: order_by
  last_submission_at: order_by
  residence_country: order_by
  sponsor_id: order_by
  submission_count: order_by
  updated_at: order_by
  verification_notes: order_by
  verification_status: order_by
  verified_at: order_by
  verified_by: order_by
}

"""primary key columns input for table: sponsor_document_verification"""
input sponsor_document_verification_pk_columns_input {
  id: uuid!
}

"""
select columns of table "sponsor_document_verification"
"""
enum sponsor_document_verification_select_column {
  """column name"""
  contact_phone

  """column name"""
  created_at

  """column name"""
  employment_proof_mime_type

  """column name"""
  employment_proof_name

  """column name"""
  employment_proof_size

  """column name"""
  employment_proof_type

  """column name"""
  employment_proof_url

  """column name"""
  id

  """column name"""
  id_file_back_mime_type

  """column name"""
  id_file_back_name

  """column name"""
  id_file_back_size

  """column name"""
  id_file_back_url

  """column name"""
  id_file_front_mime_type

  """column name"""
  id_file_front_name

  """column name"""
  id_file_front_size

  """column name"""
  id_file_front_url

  """column name"""
  id_number

  """column name"""
  id_type

  """column name"""
  last_submission_at

  """column name"""
  residence_country

  """column name"""
  sponsor_id

  """column name"""
  submission_count

  """column name"""
  updated_at

  """column name"""
  verification_notes

  """column name"""
  verification_status

  """column name"""
  verified_at

  """column name"""
  verified_by
}

"""
input type for updating data in table "sponsor_document_verification"
"""
input sponsor_document_verification_set_input {
  contact_phone: String
  created_at: timestamptz
  employment_proof_mime_type: String
  employment_proof_name: String
  employment_proof_size: Int
  employment_proof_type: String
  employment_proof_url: String
  id: uuid
  id_file_back_mime_type: String
  id_file_back_name: String
  id_file_back_size: Int
  id_file_back_url: String
  id_file_front_mime_type: String
  id_file_front_name: String
  id_file_front_size: Int
  id_file_front_url: String
  id_number: String
  id_type: String
  last_submission_at: timestamptz
  residence_country: String
  sponsor_id: uuid

  """Number of times documents have been submitted"""
  submission_count: Int
  updated_at: timestamptz
  verification_notes: String

  """Current status of document verification process"""
  verification_status: String
  verified_at: timestamptz
  verified_by: uuid
}

"""aggregate stddev on columns"""
type sponsor_document_verification_stddev_fields {
  employment_proof_size: Float
  id_file_back_size: Float
  id_file_front_size: Float

  """Number of times documents have been submitted"""
  submission_count: Float
}

"""aggregate stddev_pop on columns"""
type sponsor_document_verification_stddev_pop_fields {
  employment_proof_size: Float
  id_file_back_size: Float
  id_file_front_size: Float

  """Number of times documents have been submitted"""
  submission_count: Float
}

"""aggregate stddev_samp on columns"""
type sponsor_document_verification_stddev_samp_fields {
  employment_proof_size: Float
  id_file_back_size: Float
  id_file_front_size: Float

  """Number of times documents have been submitted"""
  submission_count: Float
}

"""
Streaming cursor of the table "sponsor_document_verification"
"""
input sponsor_document_verification_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: sponsor_document_verification_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input sponsor_document_verification_stream_cursor_value_input {
  contact_phone: String
  created_at: timestamptz
  employment_proof_mime_type: String
  employment_proof_name: String
  employment_proof_size: Int
  employment_proof_type: String
  employment_proof_url: String
  id: uuid
  id_file_back_mime_type: String
  id_file_back_name: String
  id_file_back_size: Int
  id_file_back_url: String
  id_file_front_mime_type: String
  id_file_front_name: String
  id_file_front_size: Int
  id_file_front_url: String
  id_number: String
  id_type: String
  last_submission_at: timestamptz
  residence_country: String
  sponsor_id: uuid

  """Number of times documents have been submitted"""
  submission_count: Int
  updated_at: timestamptz
  verification_notes: String

  """Current status of document verification process"""
  verification_status: String
  verified_at: timestamptz
  verified_by: uuid
}

"""aggregate sum on columns"""
type sponsor_document_verification_sum_fields {
  employment_proof_size: Int
  id_file_back_size: Int
  id_file_front_size: Int

  """Number of times documents have been submitted"""
  submission_count: Int
}

"""
update columns of table "sponsor_document_verification"
"""
enum sponsor_document_verification_update_column {
  """column name"""
  contact_phone

  """column name"""
  created_at

  """column name"""
  employment_proof_mime_type

  """column name"""
  employment_proof_name

  """column name"""
  employment_proof_size

  """column name"""
  employment_proof_type

  """column name"""
  employment_proof_url

  """column name"""
  id

  """column name"""
  id_file_back_mime_type

  """column name"""
  id_file_back_name

  """column name"""
  id_file_back_size

  """column name"""
  id_file_back_url

  """column name"""
  id_file_front_mime_type

  """column name"""
  id_file_front_name

  """column name"""
  id_file_front_size

  """column name"""
  id_file_front_url

  """column name"""
  id_number

  """column name"""
  id_type

  """column name"""
  last_submission_at

  """column name"""
  residence_country

  """column name"""
  sponsor_id

  """column name"""
  submission_count

  """column name"""
  updated_at

  """column name"""
  verification_notes

  """column name"""
  verification_status

  """column name"""
  verified_at

  """column name"""
  verified_by
}

input sponsor_document_verification_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: sponsor_document_verification_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: sponsor_document_verification_set_input

  """filter the rows which have to be updated"""
  where: sponsor_document_verification_bool_exp!
}

"""aggregate var_pop on columns"""
type sponsor_document_verification_var_pop_fields {
  employment_proof_size: Float
  id_file_back_size: Float
  id_file_front_size: Float

  """Number of times documents have been submitted"""
  submission_count: Float
}

"""aggregate var_samp on columns"""
type sponsor_document_verification_var_samp_fields {
  employment_proof_size: Float
  id_file_back_size: Float
  id_file_front_size: Float

  """Number of times documents have been submitted"""
  submission_count: Float
}

"""aggregate variance on columns"""
type sponsor_document_verification_variance_fields {
  employment_proof_size: Float
  id_file_back_size: Float
  id_file_front_size: Float

  """Number of times documents have been submitted"""
  submission_count: Float
}

"""Junction table linking sponsors to their job postings"""
type sponsor_jobs {
  completed_at: timestamptz
  created_at: timestamptz
  id: uuid!

  """An object relationship"""
  job: jobs
  job_id: uuid

  """An object relationship"""
  sponsor: sponsors!
  sponsor_id: uuid!
  status: String
}

"""
aggregated selection of "sponsor_jobs"
"""
type sponsor_jobs_aggregate {
  aggregate: sponsor_jobs_aggregate_fields
  nodes: [sponsor_jobs!]!
}

input sponsor_jobs_aggregate_bool_exp {
  count: sponsor_jobs_aggregate_bool_exp_count
}

input sponsor_jobs_aggregate_bool_exp_count {
  arguments: [sponsor_jobs_select_column!]
  distinct: Boolean
  filter: sponsor_jobs_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "sponsor_jobs"
"""
type sponsor_jobs_aggregate_fields {
  count(columns: [sponsor_jobs_select_column!], distinct: Boolean): Int!
  max: sponsor_jobs_max_fields
  min: sponsor_jobs_min_fields
}

"""
order by aggregate values of table "sponsor_jobs"
"""
input sponsor_jobs_aggregate_order_by {
  count: order_by
  max: sponsor_jobs_max_order_by
  min: sponsor_jobs_min_order_by
}

"""
input type for inserting array relation for remote table "sponsor_jobs"
"""
input sponsor_jobs_arr_rel_insert_input {
  data: [sponsor_jobs_insert_input!]!

  """upsert condition"""
  on_conflict: sponsor_jobs_on_conflict
}

"""
Boolean expression to filter rows from the table "sponsor_jobs". All fields are combined with a logical 'AND'.
"""
input sponsor_jobs_bool_exp {
  _and: [sponsor_jobs_bool_exp!]
  _not: sponsor_jobs_bool_exp
  _or: [sponsor_jobs_bool_exp!]
  completed_at: timestamptz_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  job: jobs_bool_exp
  job_id: uuid_comparison_exp
  sponsor: sponsors_bool_exp
  sponsor_id: uuid_comparison_exp
  status: String_comparison_exp
}

"""
unique or primary key constraints on table "sponsor_jobs"
"""
enum sponsor_jobs_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  sponsor_jobs_pkey

  """
  unique or primary key constraint on columns "job_id", "sponsor_id"
  """
  sponsor_jobs_sponsor_id_job_id_key
}

"""
input type for inserting data into table "sponsor_jobs"
"""
input sponsor_jobs_insert_input {
  completed_at: timestamptz
  created_at: timestamptz
  id: uuid
  job: jobs_obj_rel_insert_input
  job_id: uuid
  sponsor: sponsors_obj_rel_insert_input
  sponsor_id: uuid
  status: String
}

"""aggregate max on columns"""
type sponsor_jobs_max_fields {
  completed_at: timestamptz
  created_at: timestamptz
  id: uuid
  job_id: uuid
  sponsor_id: uuid
  status: String
}

"""
order by max() on columns of table "sponsor_jobs"
"""
input sponsor_jobs_max_order_by {
  completed_at: order_by
  created_at: order_by
  id: order_by
  job_id: order_by
  sponsor_id: order_by
  status: order_by
}

"""aggregate min on columns"""
type sponsor_jobs_min_fields {
  completed_at: timestamptz
  created_at: timestamptz
  id: uuid
  job_id: uuid
  sponsor_id: uuid
  status: String
}

"""
order by min() on columns of table "sponsor_jobs"
"""
input sponsor_jobs_min_order_by {
  completed_at: order_by
  created_at: order_by
  id: order_by
  job_id: order_by
  sponsor_id: order_by
  status: order_by
}

"""
response of any mutation on the table "sponsor_jobs"
"""
type sponsor_jobs_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [sponsor_jobs!]!
}

"""
on_conflict condition type for table "sponsor_jobs"
"""
input sponsor_jobs_on_conflict {
  constraint: sponsor_jobs_constraint!
  update_columns: [sponsor_jobs_update_column!]! = []
  where: sponsor_jobs_bool_exp
}

"""Ordering options when selecting data from "sponsor_jobs"."""
input sponsor_jobs_order_by {
  completed_at: order_by
  created_at: order_by
  id: order_by
  job: jobs_order_by
  job_id: order_by
  sponsor: sponsors_order_by
  sponsor_id: order_by
  status: order_by
}

"""primary key columns input for table: sponsor_jobs"""
input sponsor_jobs_pk_columns_input {
  id: uuid!
}

"""
select columns of table "sponsor_jobs"
"""
enum sponsor_jobs_select_column {
  """column name"""
  completed_at

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  job_id

  """column name"""
  sponsor_id

  """column name"""
  status
}

"""
input type for updating data in table "sponsor_jobs"
"""
input sponsor_jobs_set_input {
  completed_at: timestamptz
  created_at: timestamptz
  id: uuid
  job_id: uuid
  sponsor_id: uuid
  status: String
}

"""
Streaming cursor of the table "sponsor_jobs"
"""
input sponsor_jobs_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: sponsor_jobs_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input sponsor_jobs_stream_cursor_value_input {
  completed_at: timestamptz
  created_at: timestamptz
  id: uuid
  job_id: uuid
  sponsor_id: uuid
  status: String
}

"""
update columns of table "sponsor_jobs"
"""
enum sponsor_jobs_update_column {
  """column name"""
  completed_at

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  job_id

  """column name"""
  sponsor_id

  """column name"""
  status
}

input sponsor_jobs_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: sponsor_jobs_set_input

  """filter the rows which have to be updated"""
  where: sponsor_jobs_bool_exp!
}

"""
columns and relationships of "sponsor_profiles"
"""
type sponsor_profiles {
  accommodation_type: String
  active_job_postings: Int
  additional_benefits: [String!]
  address: String
  avatar_url: String
  average_rating: numeric
  background_check_completed: Boolean
  children_ages: [Int!]
  city: String
  country: String
  created_at: timestamptz
  currency: String
  days_off_per_week: Int
  elderly_care_needed: Boolean
  full_name: String!
  household_size: Int
  id: String!
  identity_verified: Boolean
  live_in_required: Boolean
  number_of_children: Int
  onboarding_completed: Boolean
  onboarding_completed_at: timestamptz
  overtime_available: Boolean
  pet_types: [String!]
  pets: Boolean
  phone_number: String
  phone_verified: Boolean
  phone_verified_at: timestamptz
  preferred_experience_years: Int
  preferred_languages: [String!]
  preferred_nationality: [String!]

  """An object relationship"""
  profile: profiles!
  profile_completed: Boolean
  profile_completed_at: timestamptz
  religion: String
  required_skills: [String!]
  salary_budget_max: Int
  salary_budget_min: Int
  total_hires: Int
  two_factor_enabled: Boolean
  two_factor_method: String
  updated_at: timestamptz
  working_hours_per_day: Int
}

"""
aggregated selection of "sponsor_profiles"
"""
type sponsor_profiles_aggregate {
  aggregate: sponsor_profiles_aggregate_fields
  nodes: [sponsor_profiles!]!
}

"""
aggregate fields of "sponsor_profiles"
"""
type sponsor_profiles_aggregate_fields {
  avg: sponsor_profiles_avg_fields
  count(columns: [sponsor_profiles_select_column!], distinct: Boolean): Int!
  max: sponsor_profiles_max_fields
  min: sponsor_profiles_min_fields
  stddev: sponsor_profiles_stddev_fields
  stddev_pop: sponsor_profiles_stddev_pop_fields
  stddev_samp: sponsor_profiles_stddev_samp_fields
  sum: sponsor_profiles_sum_fields
  var_pop: sponsor_profiles_var_pop_fields
  var_samp: sponsor_profiles_var_samp_fields
  variance: sponsor_profiles_variance_fields
}

"""aggregate avg on columns"""
type sponsor_profiles_avg_fields {
  active_job_postings: Float
  average_rating: Float
  days_off_per_week: Float
  household_size: Float
  number_of_children: Float
  preferred_experience_years: Float
  salary_budget_max: Float
  salary_budget_min: Float
  total_hires: Float
  working_hours_per_day: Float
}

"""
Boolean expression to filter rows from the table "sponsor_profiles". All fields are combined with a logical 'AND'.
"""
input sponsor_profiles_bool_exp {
  _and: [sponsor_profiles_bool_exp!]
  _not: sponsor_profiles_bool_exp
  _or: [sponsor_profiles_bool_exp!]
  accommodation_type: String_comparison_exp
  active_job_postings: Int_comparison_exp
  additional_benefits: String_array_comparison_exp
  address: String_comparison_exp
  avatar_url: String_comparison_exp
  average_rating: numeric_comparison_exp
  background_check_completed: Boolean_comparison_exp
  children_ages: Int_array_comparison_exp
  city: String_comparison_exp
  country: String_comparison_exp
  created_at: timestamptz_comparison_exp
  currency: String_comparison_exp
  days_off_per_week: Int_comparison_exp
  elderly_care_needed: Boolean_comparison_exp
  full_name: String_comparison_exp
  household_size: Int_comparison_exp
  id: String_comparison_exp
  identity_verified: Boolean_comparison_exp
  live_in_required: Boolean_comparison_exp
  number_of_children: Int_comparison_exp
  onboarding_completed: Boolean_comparison_exp
  onboarding_completed_at: timestamptz_comparison_exp
  overtime_available: Boolean_comparison_exp
  pet_types: String_array_comparison_exp
  pets: Boolean_comparison_exp
  phone_number: String_comparison_exp
  phone_verified: Boolean_comparison_exp
  phone_verified_at: timestamptz_comparison_exp
  preferred_experience_years: Int_comparison_exp
  preferred_languages: String_array_comparison_exp
  preferred_nationality: String_array_comparison_exp
  profile: profiles_bool_exp
  profile_completed: Boolean_comparison_exp
  profile_completed_at: timestamptz_comparison_exp
  religion: String_comparison_exp
  required_skills: String_array_comparison_exp
  salary_budget_max: Int_comparison_exp
  salary_budget_min: Int_comparison_exp
  total_hires: Int_comparison_exp
  two_factor_enabled: Boolean_comparison_exp
  two_factor_method: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  working_hours_per_day: Int_comparison_exp
}

"""
unique or primary key constraints on table "sponsor_profiles"
"""
enum sponsor_profiles_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  sponsor_profiles_pkey
}

"""
input type for incrementing numeric columns in table "sponsor_profiles"
"""
input sponsor_profiles_inc_input {
  active_job_postings: Int
  average_rating: numeric
  days_off_per_week: Int
  household_size: Int
  number_of_children: Int
  preferred_experience_years: Int
  salary_budget_max: Int
  salary_budget_min: Int
  total_hires: Int
  working_hours_per_day: Int
}

"""
input type for inserting data into table "sponsor_profiles"
"""
input sponsor_profiles_insert_input {
  accommodation_type: String
  active_job_postings: Int
  additional_benefits: [String!]
  address: String
  avatar_url: String
  average_rating: numeric
  background_check_completed: Boolean
  children_ages: [Int!]
  city: String
  country: String
  created_at: timestamptz
  currency: String
  days_off_per_week: Int
  elderly_care_needed: Boolean
  full_name: String
  household_size: Int
  id: String
  identity_verified: Boolean
  live_in_required: Boolean
  number_of_children: Int
  onboarding_completed: Boolean
  onboarding_completed_at: timestamptz
  overtime_available: Boolean
  pet_types: [String!]
  pets: Boolean
  phone_number: String
  phone_verified: Boolean
  phone_verified_at: timestamptz
  preferred_experience_years: Int
  preferred_languages: [String!]
  preferred_nationality: [String!]
  profile: profiles_obj_rel_insert_input
  profile_completed: Boolean
  profile_completed_at: timestamptz
  religion: String
  required_skills: [String!]
  salary_budget_max: Int
  salary_budget_min: Int
  total_hires: Int
  two_factor_enabled: Boolean
  two_factor_method: String
  updated_at: timestamptz
  working_hours_per_day: Int
}

"""aggregate max on columns"""
type sponsor_profiles_max_fields {
  accommodation_type: String
  active_job_postings: Int
  additional_benefits: [String!]
  address: String
  avatar_url: String
  average_rating: numeric
  children_ages: [Int!]
  city: String
  country: String
  created_at: timestamptz
  currency: String
  days_off_per_week: Int
  full_name: String
  household_size: Int
  id: String
  number_of_children: Int
  onboarding_completed_at: timestamptz
  pet_types: [String!]
  phone_number: String
  phone_verified_at: timestamptz
  preferred_experience_years: Int
  preferred_languages: [String!]
  preferred_nationality: [String!]
  profile_completed_at: timestamptz
  religion: String
  required_skills: [String!]
  salary_budget_max: Int
  salary_budget_min: Int
  total_hires: Int
  two_factor_method: String
  updated_at: timestamptz
  working_hours_per_day: Int
}

"""aggregate min on columns"""
type sponsor_profiles_min_fields {
  accommodation_type: String
  active_job_postings: Int
  additional_benefits: [String!]
  address: String
  avatar_url: String
  average_rating: numeric
  children_ages: [Int!]
  city: String
  country: String
  created_at: timestamptz
  currency: String
  days_off_per_week: Int
  full_name: String
  household_size: Int
  id: String
  number_of_children: Int
  onboarding_completed_at: timestamptz
  pet_types: [String!]
  phone_number: String
  phone_verified_at: timestamptz
  preferred_experience_years: Int
  preferred_languages: [String!]
  preferred_nationality: [String!]
  profile_completed_at: timestamptz
  religion: String
  required_skills: [String!]
  salary_budget_max: Int
  salary_budget_min: Int
  total_hires: Int
  two_factor_method: String
  updated_at: timestamptz
  working_hours_per_day: Int
}

"""
response of any mutation on the table "sponsor_profiles"
"""
type sponsor_profiles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [sponsor_profiles!]!
}

"""
input type for inserting object relation for remote table "sponsor_profiles"
"""
input sponsor_profiles_obj_rel_insert_input {
  data: sponsor_profiles_insert_input!

  """upsert condition"""
  on_conflict: sponsor_profiles_on_conflict
}

"""
on_conflict condition type for table "sponsor_profiles"
"""
input sponsor_profiles_on_conflict {
  constraint: sponsor_profiles_constraint!
  update_columns: [sponsor_profiles_update_column!]! = []
  where: sponsor_profiles_bool_exp
}

"""Ordering options when selecting data from "sponsor_profiles"."""
input sponsor_profiles_order_by {
  accommodation_type: order_by
  active_job_postings: order_by
  additional_benefits: order_by
  address: order_by
  avatar_url: order_by
  average_rating: order_by
  background_check_completed: order_by
  children_ages: order_by
  city: order_by
  country: order_by
  created_at: order_by
  currency: order_by
  days_off_per_week: order_by
  elderly_care_needed: order_by
  full_name: order_by
  household_size: order_by
  id: order_by
  identity_verified: order_by
  live_in_required: order_by
  number_of_children: order_by
  onboarding_completed: order_by
  onboarding_completed_at: order_by
  overtime_available: order_by
  pet_types: order_by
  pets: order_by
  phone_number: order_by
  phone_verified: order_by
  phone_verified_at: order_by
  preferred_experience_years: order_by
  preferred_languages: order_by
  preferred_nationality: order_by
  profile: profiles_order_by
  profile_completed: order_by
  profile_completed_at: order_by
  religion: order_by
  required_skills: order_by
  salary_budget_max: order_by
  salary_budget_min: order_by
  total_hires: order_by
  two_factor_enabled: order_by
  two_factor_method: order_by
  updated_at: order_by
  working_hours_per_day: order_by
}

"""primary key columns input for table: sponsor_profiles"""
input sponsor_profiles_pk_columns_input {
  id: String!
}

"""
select columns of table "sponsor_profiles"
"""
enum sponsor_profiles_select_column {
  """column name"""
  accommodation_type

  """column name"""
  active_job_postings

  """column name"""
  additional_benefits

  """column name"""
  address

  """column name"""
  avatar_url

  """column name"""
  average_rating

  """column name"""
  background_check_completed

  """column name"""
  children_ages

  """column name"""
  city

  """column name"""
  country

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  days_off_per_week

  """column name"""
  elderly_care_needed

  """column name"""
  full_name

  """column name"""
  household_size

  """column name"""
  id

  """column name"""
  identity_verified

  """column name"""
  live_in_required

  """column name"""
  number_of_children

  """column name"""
  onboarding_completed

  """column name"""
  onboarding_completed_at

  """column name"""
  overtime_available

  """column name"""
  pet_types

  """column name"""
  pets

  """column name"""
  phone_number

  """column name"""
  phone_verified

  """column name"""
  phone_verified_at

  """column name"""
  preferred_experience_years

  """column name"""
  preferred_languages

  """column name"""
  preferred_nationality

  """column name"""
  profile_completed

  """column name"""
  profile_completed_at

  """column name"""
  religion

  """column name"""
  required_skills

  """column name"""
  salary_budget_max

  """column name"""
  salary_budget_min

  """column name"""
  total_hires

  """column name"""
  two_factor_enabled

  """column name"""
  two_factor_method

  """column name"""
  updated_at

  """column name"""
  working_hours_per_day
}

"""
input type for updating data in table "sponsor_profiles"
"""
input sponsor_profiles_set_input {
  accommodation_type: String
  active_job_postings: Int
  additional_benefits: [String!]
  address: String
  avatar_url: String
  average_rating: numeric
  background_check_completed: Boolean
  children_ages: [Int!]
  city: String
  country: String
  created_at: timestamptz
  currency: String
  days_off_per_week: Int
  elderly_care_needed: Boolean
  full_name: String
  household_size: Int
  id: String
  identity_verified: Boolean
  live_in_required: Boolean
  number_of_children: Int
  onboarding_completed: Boolean
  onboarding_completed_at: timestamptz
  overtime_available: Boolean
  pet_types: [String!]
  pets: Boolean
  phone_number: String
  phone_verified: Boolean
  phone_verified_at: timestamptz
  preferred_experience_years: Int
  preferred_languages: [String!]
  preferred_nationality: [String!]
  profile_completed: Boolean
  profile_completed_at: timestamptz
  religion: String
  required_skills: [String!]
  salary_budget_max: Int
  salary_budget_min: Int
  total_hires: Int
  two_factor_enabled: Boolean
  two_factor_method: String
  updated_at: timestamptz
  working_hours_per_day: Int
}

"""aggregate stddev on columns"""
type sponsor_profiles_stddev_fields {
  active_job_postings: Float
  average_rating: Float
  days_off_per_week: Float
  household_size: Float
  number_of_children: Float
  preferred_experience_years: Float
  salary_budget_max: Float
  salary_budget_min: Float
  total_hires: Float
  working_hours_per_day: Float
}

"""aggregate stddev_pop on columns"""
type sponsor_profiles_stddev_pop_fields {
  active_job_postings: Float
  average_rating: Float
  days_off_per_week: Float
  household_size: Float
  number_of_children: Float
  preferred_experience_years: Float
  salary_budget_max: Float
  salary_budget_min: Float
  total_hires: Float
  working_hours_per_day: Float
}

"""aggregate stddev_samp on columns"""
type sponsor_profiles_stddev_samp_fields {
  active_job_postings: Float
  average_rating: Float
  days_off_per_week: Float
  household_size: Float
  number_of_children: Float
  preferred_experience_years: Float
  salary_budget_max: Float
  salary_budget_min: Float
  total_hires: Float
  working_hours_per_day: Float
}

"""
Streaming cursor of the table "sponsor_profiles"
"""
input sponsor_profiles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: sponsor_profiles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input sponsor_profiles_stream_cursor_value_input {
  accommodation_type: String
  active_job_postings: Int
  additional_benefits: [String!]
  address: String
  avatar_url: String
  average_rating: numeric
  background_check_completed: Boolean
  children_ages: [Int!]
  city: String
  country: String
  created_at: timestamptz
  currency: String
  days_off_per_week: Int
  elderly_care_needed: Boolean
  full_name: String
  household_size: Int
  id: String
  identity_verified: Boolean
  live_in_required: Boolean
  number_of_children: Int
  onboarding_completed: Boolean
  onboarding_completed_at: timestamptz
  overtime_available: Boolean
  pet_types: [String!]
  pets: Boolean
  phone_number: String
  phone_verified: Boolean
  phone_verified_at: timestamptz
  preferred_experience_years: Int
  preferred_languages: [String!]
  preferred_nationality: [String!]
  profile_completed: Boolean
  profile_completed_at: timestamptz
  religion: String
  required_skills: [String!]
  salary_budget_max: Int
  salary_budget_min: Int
  total_hires: Int
  two_factor_enabled: Boolean
  two_factor_method: String
  updated_at: timestamptz
  working_hours_per_day: Int
}

"""aggregate sum on columns"""
type sponsor_profiles_sum_fields {
  active_job_postings: Int
  average_rating: numeric
  days_off_per_week: Int
  household_size: Int
  number_of_children: Int
  preferred_experience_years: Int
  salary_budget_max: Int
  salary_budget_min: Int
  total_hires: Int
  working_hours_per_day: Int
}

"""
update columns of table "sponsor_profiles"
"""
enum sponsor_profiles_update_column {
  """column name"""
  accommodation_type

  """column name"""
  active_job_postings

  """column name"""
  additional_benefits

  """column name"""
  address

  """column name"""
  avatar_url

  """column name"""
  average_rating

  """column name"""
  background_check_completed

  """column name"""
  children_ages

  """column name"""
  city

  """column name"""
  country

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  days_off_per_week

  """column name"""
  elderly_care_needed

  """column name"""
  full_name

  """column name"""
  household_size

  """column name"""
  id

  """column name"""
  identity_verified

  """column name"""
  live_in_required

  """column name"""
  number_of_children

  """column name"""
  onboarding_completed

  """column name"""
  onboarding_completed_at

  """column name"""
  overtime_available

  """column name"""
  pet_types

  """column name"""
  pets

  """column name"""
  phone_number

  """column name"""
  phone_verified

  """column name"""
  phone_verified_at

  """column name"""
  preferred_experience_years

  """column name"""
  preferred_languages

  """column name"""
  preferred_nationality

  """column name"""
  profile_completed

  """column name"""
  profile_completed_at

  """column name"""
  religion

  """column name"""
  required_skills

  """column name"""
  salary_budget_max

  """column name"""
  salary_budget_min

  """column name"""
  total_hires

  """column name"""
  two_factor_enabled

  """column name"""
  two_factor_method

  """column name"""
  updated_at

  """column name"""
  working_hours_per_day
}

input sponsor_profiles_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: sponsor_profiles_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: sponsor_profiles_set_input

  """filter the rows which have to be updated"""
  where: sponsor_profiles_bool_exp!
}

"""aggregate var_pop on columns"""
type sponsor_profiles_var_pop_fields {
  active_job_postings: Float
  average_rating: Float
  days_off_per_week: Float
  household_size: Float
  number_of_children: Float
  preferred_experience_years: Float
  salary_budget_max: Float
  salary_budget_min: Float
  total_hires: Float
  working_hours_per_day: Float
}

"""aggregate var_samp on columns"""
type sponsor_profiles_var_samp_fields {
  active_job_postings: Float
  average_rating: Float
  days_off_per_week: Float
  household_size: Float
  number_of_children: Float
  preferred_experience_years: Float
  salary_budget_max: Float
  salary_budget_min: Float
  total_hires: Float
  working_hours_per_day: Float
}

"""aggregate variance on columns"""
type sponsor_profiles_variance_fields {
  active_job_postings: Float
  average_rating: Float
  days_off_per_week: Float
  household_size: Float
  number_of_children: Float
  preferred_experience_years: Float
  salary_budget_max: Float
  salary_budget_min: Float
  total_hires: Float
  working_hours_per_day: Float
}

"""Stores sponsor/client information for agencies"""
type sponsors {
  active_jobs: Int
  agency_id: uuid!
  budget_range: String
  company_name: String
  company_registration: String
  completed_jobs: Int
  created_at: timestamptz
  email: String
  hired_maids: Int
  household_size: Int
  id: uuid!
  last_contact_date: timestamptz
  location: String
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  name: String
  notes: String
  phone: String
  preferred_contact_method: String
  preferred_language: String
  preferred_maid_type: String
  profile_id: uuid
  profile_image: String
  rating: numeric
  special_requirements: String

  """An array relationship"""
  sponsor_jobs(
    """distinct select on columns"""
    distinct_on: [sponsor_jobs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sponsor_jobs_order_by!]

    """filter the rows returned"""
    where: sponsor_jobs_bool_exp
  ): [sponsor_jobs!]!

  """An aggregate relationship"""
  sponsor_jobs_aggregate(
    """distinct select on columns"""
    distinct_on: [sponsor_jobs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sponsor_jobs_order_by!]

    """filter the rows returned"""
    where: sponsor_jobs_bool_exp
  ): sponsor_jobs_aggregate!

  """Type of sponsor: individual, company, family, or organization"""
  sponsor_type: String

  """Current status: active, pending, suspended, or inactive"""
  status: String
  total_jobs: Int
  total_reviews: Int
  total_spent: numeric
  updated_at: timestamptz

  """Document verification status"""
  verification_status: String
}

"""
aggregated selection of "sponsors"
"""
type sponsors_aggregate {
  aggregate: sponsors_aggregate_fields
  nodes: [sponsors!]!
}

"""
aggregate fields of "sponsors"
"""
type sponsors_aggregate_fields {
  avg: sponsors_avg_fields
  count(columns: [sponsors_select_column!], distinct: Boolean): Int!
  max: sponsors_max_fields
  min: sponsors_min_fields
  stddev: sponsors_stddev_fields
  stddev_pop: sponsors_stddev_pop_fields
  stddev_samp: sponsors_stddev_samp_fields
  sum: sponsors_sum_fields
  var_pop: sponsors_var_pop_fields
  var_samp: sponsors_var_samp_fields
  variance: sponsors_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input sponsors_append_input {
  metadata: jsonb
}

"""aggregate avg on columns"""
type sponsors_avg_fields {
  active_jobs: Float
  completed_jobs: Float
  hired_maids: Float
  household_size: Float
  rating: Float
  total_jobs: Float
  total_reviews: Float
  total_spent: Float
}

"""
Boolean expression to filter rows from the table "sponsors". All fields are combined with a logical 'AND'.
"""
input sponsors_bool_exp {
  _and: [sponsors_bool_exp!]
  _not: sponsors_bool_exp
  _or: [sponsors_bool_exp!]
  active_jobs: Int_comparison_exp
  agency_id: uuid_comparison_exp
  budget_range: String_comparison_exp
  company_name: String_comparison_exp
  company_registration: String_comparison_exp
  completed_jobs: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  email: String_comparison_exp
  hired_maids: Int_comparison_exp
  household_size: Int_comparison_exp
  id: uuid_comparison_exp
  last_contact_date: timestamptz_comparison_exp
  location: String_comparison_exp
  metadata: jsonb_comparison_exp
  name: String_comparison_exp
  notes: String_comparison_exp
  phone: String_comparison_exp
  preferred_contact_method: String_comparison_exp
  preferred_language: String_comparison_exp
  preferred_maid_type: String_comparison_exp
  profile_id: uuid_comparison_exp
  profile_image: String_comparison_exp
  rating: numeric_comparison_exp
  special_requirements: String_comparison_exp
  sponsor_jobs: sponsor_jobs_bool_exp
  sponsor_jobs_aggregate: sponsor_jobs_aggregate_bool_exp
  sponsor_type: String_comparison_exp
  status: String_comparison_exp
  total_jobs: Int_comparison_exp
  total_reviews: Int_comparison_exp
  total_spent: numeric_comparison_exp
  updated_at: timestamptz_comparison_exp
  verification_status: String_comparison_exp
}

"""
unique or primary key constraints on table "sponsors"
"""
enum sponsors_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  sponsors_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input sponsors_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input sponsors_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input sponsors_delete_key_input {
  metadata: String
}

"""
input type for incrementing numeric columns in table "sponsors"
"""
input sponsors_inc_input {
  active_jobs: Int
  completed_jobs: Int
  hired_maids: Int
  household_size: Int
  rating: numeric
  total_jobs: Int
  total_reviews: Int
  total_spent: numeric
}

"""
input type for inserting data into table "sponsors"
"""
input sponsors_insert_input {
  active_jobs: Int
  agency_id: uuid
  budget_range: String
  company_name: String
  company_registration: String
  completed_jobs: Int
  created_at: timestamptz
  email: String
  hired_maids: Int
  household_size: Int
  id: uuid
  last_contact_date: timestamptz
  location: String
  metadata: jsonb
  name: String
  notes: String
  phone: String
  preferred_contact_method: String
  preferred_language: String
  preferred_maid_type: String
  profile_id: uuid
  profile_image: String
  rating: numeric
  special_requirements: String
  sponsor_jobs: sponsor_jobs_arr_rel_insert_input

  """Type of sponsor: individual, company, family, or organization"""
  sponsor_type: String

  """Current status: active, pending, suspended, or inactive"""
  status: String
  total_jobs: Int
  total_reviews: Int
  total_spent: numeric
  updated_at: timestamptz

  """Document verification status"""
  verification_status: String
}

"""aggregate max on columns"""
type sponsors_max_fields {
  active_jobs: Int
  agency_id: uuid
  budget_range: String
  company_name: String
  company_registration: String
  completed_jobs: Int
  created_at: timestamptz
  email: String
  hired_maids: Int
  household_size: Int
  id: uuid
  last_contact_date: timestamptz
  location: String
  name: String
  notes: String
  phone: String
  preferred_contact_method: String
  preferred_language: String
  preferred_maid_type: String
  profile_id: uuid
  profile_image: String
  rating: numeric
  special_requirements: String

  """Type of sponsor: individual, company, family, or organization"""
  sponsor_type: String

  """Current status: active, pending, suspended, or inactive"""
  status: String
  total_jobs: Int
  total_reviews: Int
  total_spent: numeric
  updated_at: timestamptz

  """Document verification status"""
  verification_status: String
}

"""aggregate min on columns"""
type sponsors_min_fields {
  active_jobs: Int
  agency_id: uuid
  budget_range: String
  company_name: String
  company_registration: String
  completed_jobs: Int
  created_at: timestamptz
  email: String
  hired_maids: Int
  household_size: Int
  id: uuid
  last_contact_date: timestamptz
  location: String
  name: String
  notes: String
  phone: String
  preferred_contact_method: String
  preferred_language: String
  preferred_maid_type: String
  profile_id: uuid
  profile_image: String
  rating: numeric
  special_requirements: String

  """Type of sponsor: individual, company, family, or organization"""
  sponsor_type: String

  """Current status: active, pending, suspended, or inactive"""
  status: String
  total_jobs: Int
  total_reviews: Int
  total_spent: numeric
  updated_at: timestamptz

  """Document verification status"""
  verification_status: String
}

"""
response of any mutation on the table "sponsors"
"""
type sponsors_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [sponsors!]!
}

"""
input type for inserting object relation for remote table "sponsors"
"""
input sponsors_obj_rel_insert_input {
  data: sponsors_insert_input!

  """upsert condition"""
  on_conflict: sponsors_on_conflict
}

"""
on_conflict condition type for table "sponsors"
"""
input sponsors_on_conflict {
  constraint: sponsors_constraint!
  update_columns: [sponsors_update_column!]! = []
  where: sponsors_bool_exp
}

"""Ordering options when selecting data from "sponsors"."""
input sponsors_order_by {
  active_jobs: order_by
  agency_id: order_by
  budget_range: order_by
  company_name: order_by
  company_registration: order_by
  completed_jobs: order_by
  created_at: order_by
  email: order_by
  hired_maids: order_by
  household_size: order_by
  id: order_by
  last_contact_date: order_by
  location: order_by
  metadata: order_by
  name: order_by
  notes: order_by
  phone: order_by
  preferred_contact_method: order_by
  preferred_language: order_by
  preferred_maid_type: order_by
  profile_id: order_by
  profile_image: order_by
  rating: order_by
  special_requirements: order_by
  sponsor_jobs_aggregate: sponsor_jobs_aggregate_order_by
  sponsor_type: order_by
  status: order_by
  total_jobs: order_by
  total_reviews: order_by
  total_spent: order_by
  updated_at: order_by
  verification_status: order_by
}

"""primary key columns input for table: sponsors"""
input sponsors_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input sponsors_prepend_input {
  metadata: jsonb
}

"""
select columns of table "sponsors"
"""
enum sponsors_select_column {
  """column name"""
  active_jobs

  """column name"""
  agency_id

  """column name"""
  budget_range

  """column name"""
  company_name

  """column name"""
  company_registration

  """column name"""
  completed_jobs

  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  hired_maids

  """column name"""
  household_size

  """column name"""
  id

  """column name"""
  last_contact_date

  """column name"""
  location

  """column name"""
  metadata

  """column name"""
  name

  """column name"""
  notes

  """column name"""
  phone

  """column name"""
  preferred_contact_method

  """column name"""
  preferred_language

  """column name"""
  preferred_maid_type

  """column name"""
  profile_id

  """column name"""
  profile_image

  """column name"""
  rating

  """column name"""
  special_requirements

  """column name"""
  sponsor_type

  """column name"""
  status

  """column name"""
  total_jobs

  """column name"""
  total_reviews

  """column name"""
  total_spent

  """column name"""
  updated_at

  """column name"""
  verification_status
}

"""
input type for updating data in table "sponsors"
"""
input sponsors_set_input {
  active_jobs: Int
  agency_id: uuid
  budget_range: String
  company_name: String
  company_registration: String
  completed_jobs: Int
  created_at: timestamptz
  email: String
  hired_maids: Int
  household_size: Int
  id: uuid
  last_contact_date: timestamptz
  location: String
  metadata: jsonb
  name: String
  notes: String
  phone: String
  preferred_contact_method: String
  preferred_language: String
  preferred_maid_type: String
  profile_id: uuid
  profile_image: String
  rating: numeric
  special_requirements: String

  """Type of sponsor: individual, company, family, or organization"""
  sponsor_type: String

  """Current status: active, pending, suspended, or inactive"""
  status: String
  total_jobs: Int
  total_reviews: Int
  total_spent: numeric
  updated_at: timestamptz

  """Document verification status"""
  verification_status: String
}

"""aggregate stddev on columns"""
type sponsors_stddev_fields {
  active_jobs: Float
  completed_jobs: Float
  hired_maids: Float
  household_size: Float
  rating: Float
  total_jobs: Float
  total_reviews: Float
  total_spent: Float
}

"""aggregate stddev_pop on columns"""
type sponsors_stddev_pop_fields {
  active_jobs: Float
  completed_jobs: Float
  hired_maids: Float
  household_size: Float
  rating: Float
  total_jobs: Float
  total_reviews: Float
  total_spent: Float
}

"""aggregate stddev_samp on columns"""
type sponsors_stddev_samp_fields {
  active_jobs: Float
  completed_jobs: Float
  hired_maids: Float
  household_size: Float
  rating: Float
  total_jobs: Float
  total_reviews: Float
  total_spent: Float
}

"""
Streaming cursor of the table "sponsors"
"""
input sponsors_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: sponsors_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input sponsors_stream_cursor_value_input {
  active_jobs: Int
  agency_id: uuid
  budget_range: String
  company_name: String
  company_registration: String
  completed_jobs: Int
  created_at: timestamptz
  email: String
  hired_maids: Int
  household_size: Int
  id: uuid
  last_contact_date: timestamptz
  location: String
  metadata: jsonb
  name: String
  notes: String
  phone: String
  preferred_contact_method: String
  preferred_language: String
  preferred_maid_type: String
  profile_id: uuid
  profile_image: String
  rating: numeric
  special_requirements: String

  """Type of sponsor: individual, company, family, or organization"""
  sponsor_type: String

  """Current status: active, pending, suspended, or inactive"""
  status: String
  total_jobs: Int
  total_reviews: Int
  total_spent: numeric
  updated_at: timestamptz

  """Document verification status"""
  verification_status: String
}

"""aggregate sum on columns"""
type sponsors_sum_fields {
  active_jobs: Int
  completed_jobs: Int
  hired_maids: Int
  household_size: Int
  rating: numeric
  total_jobs: Int
  total_reviews: Int
  total_spent: numeric
}

"""
update columns of table "sponsors"
"""
enum sponsors_update_column {
  """column name"""
  active_jobs

  """column name"""
  agency_id

  """column name"""
  budget_range

  """column name"""
  company_name

  """column name"""
  company_registration

  """column name"""
  completed_jobs

  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  hired_maids

  """column name"""
  household_size

  """column name"""
  id

  """column name"""
  last_contact_date

  """column name"""
  location

  """column name"""
  metadata

  """column name"""
  name

  """column name"""
  notes

  """column name"""
  phone

  """column name"""
  preferred_contact_method

  """column name"""
  preferred_language

  """column name"""
  preferred_maid_type

  """column name"""
  profile_id

  """column name"""
  profile_image

  """column name"""
  rating

  """column name"""
  special_requirements

  """column name"""
  sponsor_type

  """column name"""
  status

  """column name"""
  total_jobs

  """column name"""
  total_reviews

  """column name"""
  total_spent

  """column name"""
  updated_at

  """column name"""
  verification_status
}

input sponsors_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: sponsors_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: sponsors_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: sponsors_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: sponsors_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: sponsors_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: sponsors_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: sponsors_set_input

  """filter the rows which have to be updated"""
  where: sponsors_bool_exp!
}

"""aggregate var_pop on columns"""
type sponsors_var_pop_fields {
  active_jobs: Float
  completed_jobs: Float
  hired_maids: Float
  household_size: Float
  rating: Float
  total_jobs: Float
  total_reviews: Float
  total_spent: Float
}

"""aggregate var_samp on columns"""
type sponsors_var_samp_fields {
  active_jobs: Float
  completed_jobs: Float
  hired_maids: Float
  household_size: Float
  rating: Float
  total_jobs: Float
  total_reviews: Float
  total_spent: Float
}

"""aggregate variance on columns"""
type sponsors_variance_fields {
  active_jobs: Float
  completed_jobs: Float
  hired_maids: Float
  household_size: Float
  rating: Float
  total_jobs: Float
  total_reviews: Float
  total_spent: Float
}

"""
columns and relationships of "storage.buckets"
"""
type storage_buckets {
  allowed_mime_types: [String!]
  avif_autodetection: Boolean
  created_at: timestamptz
  file_size_limit: bigint
  id: String!
  name: String!

  """An array relationship"""
  objects(
    """distinct select on columns"""
    distinct_on: [storage_objects_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_objects_order_by!]

    """filter the rows returned"""
    where: storage_objects_bool_exp
  ): [storage_objects!]!

  """An aggregate relationship"""
  objects_aggregate(
    """distinct select on columns"""
    distinct_on: [storage_objects_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_objects_order_by!]

    """filter the rows returned"""
    where: storage_objects_bool_exp
  ): storage_objects_aggregate!

  """Field is deprecated, use owner_id instead"""
  owner: uuid
  owner_id: String

  """An array relationship"""
  prefixes(
    """distinct select on columns"""
    distinct_on: [storage_prefixes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_prefixes_order_by!]

    """filter the rows returned"""
    where: storage_prefixes_bool_exp
  ): [storage_prefixes!]!

  """An aggregate relationship"""
  prefixes_aggregate(
    """distinct select on columns"""
    distinct_on: [storage_prefixes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_prefixes_order_by!]

    """filter the rows returned"""
    where: storage_prefixes_bool_exp
  ): storage_prefixes_aggregate!
  public: Boolean

  """An array relationship"""
  s3_multipart_uploads(
    """distinct select on columns"""
    distinct_on: [storage_s3_multipart_uploads_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_s3_multipart_uploads_order_by!]

    """filter the rows returned"""
    where: storage_s3_multipart_uploads_bool_exp
  ): [storage_s3_multipart_uploads!]!

  """An aggregate relationship"""
  s3_multipart_uploads_aggregate(
    """distinct select on columns"""
    distinct_on: [storage_s3_multipart_uploads_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_s3_multipart_uploads_order_by!]

    """filter the rows returned"""
    where: storage_s3_multipart_uploads_bool_exp
  ): storage_s3_multipart_uploads_aggregate!

  """An array relationship"""
  s3_multipart_uploads_parts(
    """distinct select on columns"""
    distinct_on: [storage_s3_multipart_uploads_parts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_s3_multipart_uploads_parts_order_by!]

    """filter the rows returned"""
    where: storage_s3_multipart_uploads_parts_bool_exp
  ): [storage_s3_multipart_uploads_parts!]!

  """An aggregate relationship"""
  s3_multipart_uploads_parts_aggregate(
    """distinct select on columns"""
    distinct_on: [storage_s3_multipart_uploads_parts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_s3_multipart_uploads_parts_order_by!]

    """filter the rows returned"""
    where: storage_s3_multipart_uploads_parts_bool_exp
  ): storage_s3_multipart_uploads_parts_aggregate!
  type: buckettype!
  updated_at: timestamptz
}

"""
aggregated selection of "storage.buckets"
"""
type storage_buckets_aggregate {
  aggregate: storage_buckets_aggregate_fields
  nodes: [storage_buckets!]!
}

"""
aggregate fields of "storage.buckets"
"""
type storage_buckets_aggregate_fields {
  avg: storage_buckets_avg_fields
  count(columns: [storage_buckets_select_column!], distinct: Boolean): Int!
  max: storage_buckets_max_fields
  min: storage_buckets_min_fields
  stddev: storage_buckets_stddev_fields
  stddev_pop: storage_buckets_stddev_pop_fields
  stddev_samp: storage_buckets_stddev_samp_fields
  sum: storage_buckets_sum_fields
  var_pop: storage_buckets_var_pop_fields
  var_samp: storage_buckets_var_samp_fields
  variance: storage_buckets_variance_fields
}

"""
columns and relationships of "storage.buckets_analytics"
"""
type storage_buckets_analytics {
  created_at: timestamptz!
  deleted_at: timestamptz
  format: String!
  id: uuid!
  name: String!
  type: buckettype!
  updated_at: timestamptz!
}

"""
aggregated selection of "storage.buckets_analytics"
"""
type storage_buckets_analytics_aggregate {
  aggregate: storage_buckets_analytics_aggregate_fields
  nodes: [storage_buckets_analytics!]!
}

"""
aggregate fields of "storage.buckets_analytics"
"""
type storage_buckets_analytics_aggregate_fields {
  count(columns: [storage_buckets_analytics_select_column!], distinct: Boolean): Int!
  max: storage_buckets_analytics_max_fields
  min: storage_buckets_analytics_min_fields
}

"""
Boolean expression to filter rows from the table "storage.buckets_analytics". All fields are combined with a logical 'AND'.
"""
input storage_buckets_analytics_bool_exp {
  _and: [storage_buckets_analytics_bool_exp!]
  _not: storage_buckets_analytics_bool_exp
  _or: [storage_buckets_analytics_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  format: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  type: buckettype_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "storage.buckets_analytics"
"""
enum storage_buckets_analytics_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  buckets_analytics_pkey

  """
  unique or primary key constraint on columns "name"
  """
  buckets_analytics_unique_name_idx
}

"""
input type for inserting data into table "storage.buckets_analytics"
"""
input storage_buckets_analytics_insert_input {
  created_at: timestamptz
  deleted_at: timestamptz
  format: String
  id: uuid
  name: String
  type: buckettype
  updated_at: timestamptz
}

"""aggregate max on columns"""
type storage_buckets_analytics_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  format: String
  id: uuid
  name: String
  type: buckettype
  updated_at: timestamptz
}

"""aggregate min on columns"""
type storage_buckets_analytics_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  format: String
  id: uuid
  name: String
  type: buckettype
  updated_at: timestamptz
}

"""
response of any mutation on the table "storage.buckets_analytics"
"""
type storage_buckets_analytics_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [storage_buckets_analytics!]!
}

"""
on_conflict condition type for table "storage.buckets_analytics"
"""
input storage_buckets_analytics_on_conflict {
  constraint: storage_buckets_analytics_constraint!
  update_columns: [storage_buckets_analytics_update_column!]! = []
  where: storage_buckets_analytics_bool_exp
}

"""Ordering options when selecting data from "storage.buckets_analytics"."""
input storage_buckets_analytics_order_by {
  created_at: order_by
  deleted_at: order_by
  format: order_by
  id: order_by
  name: order_by
  type: order_by
  updated_at: order_by
}

"""primary key columns input for table: storage.buckets_analytics"""
input storage_buckets_analytics_pk_columns_input {
  id: uuid!
}

"""
select columns of table "storage.buckets_analytics"
"""
enum storage_buckets_analytics_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  format

  """column name"""
  id

  """column name"""
  name

  """column name"""
  type

  """column name"""
  updated_at
}

"""
input type for updating data in table "storage.buckets_analytics"
"""
input storage_buckets_analytics_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  format: String
  id: uuid
  name: String
  type: buckettype
  updated_at: timestamptz
}

"""
Streaming cursor of the table "storage_buckets_analytics"
"""
input storage_buckets_analytics_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: storage_buckets_analytics_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input storage_buckets_analytics_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  format: String
  id: uuid
  name: String
  type: buckettype
  updated_at: timestamptz
}

"""
update columns of table "storage.buckets_analytics"
"""
enum storage_buckets_analytics_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  format

  """column name"""
  id

  """column name"""
  name

  """column name"""
  type

  """column name"""
  updated_at
}

input storage_buckets_analytics_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: storage_buckets_analytics_set_input

  """filter the rows which have to be updated"""
  where: storage_buckets_analytics_bool_exp!
}

"""aggregate avg on columns"""
type storage_buckets_avg_fields {
  file_size_limit: Float
}

"""
Boolean expression to filter rows from the table "storage.buckets". All fields are combined with a logical 'AND'.
"""
input storage_buckets_bool_exp {
  _and: [storage_buckets_bool_exp!]
  _not: storage_buckets_bool_exp
  _or: [storage_buckets_bool_exp!]
  allowed_mime_types: String_array_comparison_exp
  avif_autodetection: Boolean_comparison_exp
  created_at: timestamptz_comparison_exp
  file_size_limit: bigint_comparison_exp
  id: String_comparison_exp
  name: String_comparison_exp
  objects: storage_objects_bool_exp
  objects_aggregate: storage_objects_aggregate_bool_exp
  owner: uuid_comparison_exp
  owner_id: String_comparison_exp
  prefixes: storage_prefixes_bool_exp
  prefixes_aggregate: storage_prefixes_aggregate_bool_exp
  public: Boolean_comparison_exp
  s3_multipart_uploads: storage_s3_multipart_uploads_bool_exp
  s3_multipart_uploads_aggregate: storage_s3_multipart_uploads_aggregate_bool_exp
  s3_multipart_uploads_parts: storage_s3_multipart_uploads_parts_bool_exp
  s3_multipart_uploads_parts_aggregate: storage_s3_multipart_uploads_parts_aggregate_bool_exp
  type: buckettype_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "storage.buckets"
"""
enum storage_buckets_constraint {
  """
  unique or primary key constraint on columns "name"
  """
  bname

  """
  unique or primary key constraint on columns "id"
  """
  buckets_pkey
}

"""
input type for incrementing numeric columns in table "storage.buckets"
"""
input storage_buckets_inc_input {
  file_size_limit: bigint
}

"""
input type for inserting data into table "storage.buckets"
"""
input storage_buckets_insert_input {
  allowed_mime_types: [String!]
  avif_autodetection: Boolean
  created_at: timestamptz
  file_size_limit: bigint
  id: String
  name: String
  objects: storage_objects_arr_rel_insert_input

  """Field is deprecated, use owner_id instead"""
  owner: uuid
  owner_id: String
  prefixes: storage_prefixes_arr_rel_insert_input
  public: Boolean
  s3_multipart_uploads: storage_s3_multipart_uploads_arr_rel_insert_input
  s3_multipart_uploads_parts: storage_s3_multipart_uploads_parts_arr_rel_insert_input
  type: buckettype
  updated_at: timestamptz
}

"""aggregate max on columns"""
type storage_buckets_max_fields {
  allowed_mime_types: [String!]
  created_at: timestamptz
  file_size_limit: bigint
  id: String
  name: String

  """Field is deprecated, use owner_id instead"""
  owner: uuid
  owner_id: String
  type: buckettype
  updated_at: timestamptz
}

"""aggregate min on columns"""
type storage_buckets_min_fields {
  allowed_mime_types: [String!]
  created_at: timestamptz
  file_size_limit: bigint
  id: String
  name: String

  """Field is deprecated, use owner_id instead"""
  owner: uuid
  owner_id: String
  type: buckettype
  updated_at: timestamptz
}

"""
response of any mutation on the table "storage.buckets"
"""
type storage_buckets_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [storage_buckets!]!
}

"""
input type for inserting object relation for remote table "storage.buckets"
"""
input storage_buckets_obj_rel_insert_input {
  data: storage_buckets_insert_input!

  """upsert condition"""
  on_conflict: storage_buckets_on_conflict
}

"""
on_conflict condition type for table "storage.buckets"
"""
input storage_buckets_on_conflict {
  constraint: storage_buckets_constraint!
  update_columns: [storage_buckets_update_column!]! = []
  where: storage_buckets_bool_exp
}

"""Ordering options when selecting data from "storage.buckets"."""
input storage_buckets_order_by {
  allowed_mime_types: order_by
  avif_autodetection: order_by
  created_at: order_by
  file_size_limit: order_by
  id: order_by
  name: order_by
  objects_aggregate: storage_objects_aggregate_order_by
  owner: order_by
  owner_id: order_by
  prefixes_aggregate: storage_prefixes_aggregate_order_by
  public: order_by
  s3_multipart_uploads_aggregate: storage_s3_multipart_uploads_aggregate_order_by
  s3_multipart_uploads_parts_aggregate: storage_s3_multipart_uploads_parts_aggregate_order_by
  type: order_by
  updated_at: order_by
}

"""primary key columns input for table: storage.buckets"""
input storage_buckets_pk_columns_input {
  id: String!
}

"""
select columns of table "storage.buckets"
"""
enum storage_buckets_select_column {
  """column name"""
  allowed_mime_types

  """column name"""
  avif_autodetection

  """column name"""
  created_at

  """column name"""
  file_size_limit

  """column name"""
  id

  """column name"""
  name

  """column name"""
  owner

  """column name"""
  owner_id

  """column name"""
  public

  """column name"""
  type

  """column name"""
  updated_at
}

"""
input type for updating data in table "storage.buckets"
"""
input storage_buckets_set_input {
  allowed_mime_types: [String!]
  avif_autodetection: Boolean
  created_at: timestamptz
  file_size_limit: bigint
  id: String
  name: String

  """Field is deprecated, use owner_id instead"""
  owner: uuid
  owner_id: String
  public: Boolean
  type: buckettype
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type storage_buckets_stddev_fields {
  file_size_limit: Float
}

"""aggregate stddev_pop on columns"""
type storage_buckets_stddev_pop_fields {
  file_size_limit: Float
}

"""aggregate stddev_samp on columns"""
type storage_buckets_stddev_samp_fields {
  file_size_limit: Float
}

"""
Streaming cursor of the table "storage_buckets"
"""
input storage_buckets_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: storage_buckets_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input storage_buckets_stream_cursor_value_input {
  allowed_mime_types: [String!]
  avif_autodetection: Boolean
  created_at: timestamptz
  file_size_limit: bigint
  id: String
  name: String

  """Field is deprecated, use owner_id instead"""
  owner: uuid
  owner_id: String
  public: Boolean
  type: buckettype
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type storage_buckets_sum_fields {
  file_size_limit: bigint
}

"""
update columns of table "storage.buckets"
"""
enum storage_buckets_update_column {
  """column name"""
  allowed_mime_types

  """column name"""
  avif_autodetection

  """column name"""
  created_at

  """column name"""
  file_size_limit

  """column name"""
  id

  """column name"""
  name

  """column name"""
  owner

  """column name"""
  owner_id

  """column name"""
  public

  """column name"""
  type

  """column name"""
  updated_at
}

input storage_buckets_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: storage_buckets_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: storage_buckets_set_input

  """filter the rows which have to be updated"""
  where: storage_buckets_bool_exp!
}

"""aggregate var_pop on columns"""
type storage_buckets_var_pop_fields {
  file_size_limit: Float
}

"""aggregate var_samp on columns"""
type storage_buckets_var_samp_fields {
  file_size_limit: Float
}

"""aggregate variance on columns"""
type storage_buckets_variance_fields {
  file_size_limit: Float
}

"""
columns and relationships of "storage.migrations"
"""
type storage_migrations {
  executed_at: timestamp
  hash: String!
  id: Int!
  name: String!
}

"""
aggregated selection of "storage.migrations"
"""
type storage_migrations_aggregate {
  aggregate: storage_migrations_aggregate_fields
  nodes: [storage_migrations!]!
}

"""
aggregate fields of "storage.migrations"
"""
type storage_migrations_aggregate_fields {
  avg: storage_migrations_avg_fields
  count(columns: [storage_migrations_select_column!], distinct: Boolean): Int!
  max: storage_migrations_max_fields
  min: storage_migrations_min_fields
  stddev: storage_migrations_stddev_fields
  stddev_pop: storage_migrations_stddev_pop_fields
  stddev_samp: storage_migrations_stddev_samp_fields
  sum: storage_migrations_sum_fields
  var_pop: storage_migrations_var_pop_fields
  var_samp: storage_migrations_var_samp_fields
  variance: storage_migrations_variance_fields
}

"""aggregate avg on columns"""
type storage_migrations_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "storage.migrations". All fields are combined with a logical 'AND'.
"""
input storage_migrations_bool_exp {
  _and: [storage_migrations_bool_exp!]
  _not: storage_migrations_bool_exp
  _or: [storage_migrations_bool_exp!]
  executed_at: timestamp_comparison_exp
  hash: String_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "storage.migrations"
"""
enum storage_migrations_constraint {
  """
  unique or primary key constraint on columns "name"
  """
  migrations_name_key

  """
  unique or primary key constraint on columns "id"
  """
  migrations_pkey
}

"""
input type for incrementing numeric columns in table "storage.migrations"
"""
input storage_migrations_inc_input {
  id: Int
}

"""
input type for inserting data into table "storage.migrations"
"""
input storage_migrations_insert_input {
  executed_at: timestamp
  hash: String
  id: Int
  name: String
}

"""aggregate max on columns"""
type storage_migrations_max_fields {
  executed_at: timestamp
  hash: String
  id: Int
  name: String
}

"""aggregate min on columns"""
type storage_migrations_min_fields {
  executed_at: timestamp
  hash: String
  id: Int
  name: String
}

"""
response of any mutation on the table "storage.migrations"
"""
type storage_migrations_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [storage_migrations!]!
}

"""
on_conflict condition type for table "storage.migrations"
"""
input storage_migrations_on_conflict {
  constraint: storage_migrations_constraint!
  update_columns: [storage_migrations_update_column!]! = []
  where: storage_migrations_bool_exp
}

"""Ordering options when selecting data from "storage.migrations"."""
input storage_migrations_order_by {
  executed_at: order_by
  hash: order_by
  id: order_by
  name: order_by
}

"""primary key columns input for table: storage.migrations"""
input storage_migrations_pk_columns_input {
  id: Int!
}

"""
select columns of table "storage.migrations"
"""
enum storage_migrations_select_column {
  """column name"""
  executed_at

  """column name"""
  hash

  """column name"""
  id

  """column name"""
  name
}

"""
input type for updating data in table "storage.migrations"
"""
input storage_migrations_set_input {
  executed_at: timestamp
  hash: String
  id: Int
  name: String
}

"""aggregate stddev on columns"""
type storage_migrations_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type storage_migrations_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type storage_migrations_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "storage_migrations"
"""
input storage_migrations_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: storage_migrations_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input storage_migrations_stream_cursor_value_input {
  executed_at: timestamp
  hash: String
  id: Int
  name: String
}

"""aggregate sum on columns"""
type storage_migrations_sum_fields {
  id: Int
}

"""
update columns of table "storage.migrations"
"""
enum storage_migrations_update_column {
  """column name"""
  executed_at

  """column name"""
  hash

  """column name"""
  id

  """column name"""
  name
}

input storage_migrations_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: storage_migrations_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: storage_migrations_set_input

  """filter the rows which have to be updated"""
  where: storage_migrations_bool_exp!
}

"""aggregate var_pop on columns"""
type storage_migrations_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type storage_migrations_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type storage_migrations_variance_fields {
  id: Float
}

"""
columns and relationships of "storage.objects"
"""
type storage_objects {
  """An object relationship"""
  bucket: storage_buckets
  bucket_id: String
  created_at: timestamptz
  id: uuid!
  last_accessed_at: timestamptz
  level: Int
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  name: String

  """Field is deprecated, use owner_id instead"""
  owner: uuid
  owner_id: String
  path_tokens: [String!]
  updated_at: timestamptz
  user_metadata(
    """JSON select path"""
    path: String
  ): jsonb
  version: String
}

"""
aggregated selection of "storage.objects"
"""
type storage_objects_aggregate {
  aggregate: storage_objects_aggregate_fields
  nodes: [storage_objects!]!
}

input storage_objects_aggregate_bool_exp {
  count: storage_objects_aggregate_bool_exp_count
}

input storage_objects_aggregate_bool_exp_count {
  arguments: [storage_objects_select_column!]
  distinct: Boolean
  filter: storage_objects_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "storage.objects"
"""
type storage_objects_aggregate_fields {
  avg: storage_objects_avg_fields
  count(columns: [storage_objects_select_column!], distinct: Boolean): Int!
  max: storage_objects_max_fields
  min: storage_objects_min_fields
  stddev: storage_objects_stddev_fields
  stddev_pop: storage_objects_stddev_pop_fields
  stddev_samp: storage_objects_stddev_samp_fields
  sum: storage_objects_sum_fields
  var_pop: storage_objects_var_pop_fields
  var_samp: storage_objects_var_samp_fields
  variance: storage_objects_variance_fields
}

"""
order by aggregate values of table "storage.objects"
"""
input storage_objects_aggregate_order_by {
  avg: storage_objects_avg_order_by
  count: order_by
  max: storage_objects_max_order_by
  min: storage_objects_min_order_by
  stddev: storage_objects_stddev_order_by
  stddev_pop: storage_objects_stddev_pop_order_by
  stddev_samp: storage_objects_stddev_samp_order_by
  sum: storage_objects_sum_order_by
  var_pop: storage_objects_var_pop_order_by
  var_samp: storage_objects_var_samp_order_by
  variance: storage_objects_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input storage_objects_append_input {
  metadata: jsonb
  user_metadata: jsonb
}

"""
input type for inserting array relation for remote table "storage.objects"
"""
input storage_objects_arr_rel_insert_input {
  data: [storage_objects_insert_input!]!

  """upsert condition"""
  on_conflict: storage_objects_on_conflict
}

"""aggregate avg on columns"""
type storage_objects_avg_fields {
  level: Float
}

"""
order by avg() on columns of table "storage.objects"
"""
input storage_objects_avg_order_by {
  level: order_by
}

"""
Boolean expression to filter rows from the table "storage.objects". All fields are combined with a logical 'AND'.
"""
input storage_objects_bool_exp {
  _and: [storage_objects_bool_exp!]
  _not: storage_objects_bool_exp
  _or: [storage_objects_bool_exp!]
  bucket: storage_buckets_bool_exp
  bucket_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  last_accessed_at: timestamptz_comparison_exp
  level: Int_comparison_exp
  metadata: jsonb_comparison_exp
  name: String_comparison_exp
  owner: uuid_comparison_exp
  owner_id: String_comparison_exp
  path_tokens: String_array_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_metadata: jsonb_comparison_exp
  version: String_comparison_exp
}

"""
unique or primary key constraints on table "storage.objects"
"""
enum storage_objects_constraint {
  """
  unique or primary key constraint on columns "bucket_id", "name"
  """
  bucketid_objname

  """
  unique or primary key constraint on columns "bucket_id", "level", "name"
  """
  idx_name_bucket_level_unique

  """
  unique or primary key constraint on columns "bucket_id", "level", "name"
  """
  objects_bucket_id_level_idx

  """
  unique or primary key constraint on columns "id"
  """
  objects_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input storage_objects_delete_at_path_input {
  metadata: [String!]
  user_metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input storage_objects_delete_elem_input {
  metadata: Int
  user_metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input storage_objects_delete_key_input {
  metadata: String
  user_metadata: String
}

"""
input type for incrementing numeric columns in table "storage.objects"
"""
input storage_objects_inc_input {
  level: Int
}

"""
input type for inserting data into table "storage.objects"
"""
input storage_objects_insert_input {
  bucket: storage_buckets_obj_rel_insert_input
  bucket_id: String
  created_at: timestamptz
  id: uuid
  last_accessed_at: timestamptz
  level: Int
  metadata: jsonb
  name: String

  """Field is deprecated, use owner_id instead"""
  owner: uuid
  owner_id: String
  updated_at: timestamptz
  user_metadata: jsonb
  version: String
}

"""aggregate max on columns"""
type storage_objects_max_fields {
  bucket_id: String
  created_at: timestamptz
  id: uuid
  last_accessed_at: timestamptz
  level: Int
  name: String

  """Field is deprecated, use owner_id instead"""
  owner: uuid
  owner_id: String
  path_tokens: [String!]
  updated_at: timestamptz
  version: String
}

"""
order by max() on columns of table "storage.objects"
"""
input storage_objects_max_order_by {
  bucket_id: order_by
  created_at: order_by
  id: order_by
  last_accessed_at: order_by
  level: order_by
  name: order_by

  """Field is deprecated, use owner_id instead"""
  owner: order_by
  owner_id: order_by
  path_tokens: order_by
  updated_at: order_by
  version: order_by
}

"""aggregate min on columns"""
type storage_objects_min_fields {
  bucket_id: String
  created_at: timestamptz
  id: uuid
  last_accessed_at: timestamptz
  level: Int
  name: String

  """Field is deprecated, use owner_id instead"""
  owner: uuid
  owner_id: String
  path_tokens: [String!]
  updated_at: timestamptz
  version: String
}

"""
order by min() on columns of table "storage.objects"
"""
input storage_objects_min_order_by {
  bucket_id: order_by
  created_at: order_by
  id: order_by
  last_accessed_at: order_by
  level: order_by
  name: order_by

  """Field is deprecated, use owner_id instead"""
  owner: order_by
  owner_id: order_by
  path_tokens: order_by
  updated_at: order_by
  version: order_by
}

"""
response of any mutation on the table "storage.objects"
"""
type storage_objects_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [storage_objects!]!
}

"""
on_conflict condition type for table "storage.objects"
"""
input storage_objects_on_conflict {
  constraint: storage_objects_constraint!
  update_columns: [storage_objects_update_column!]! = []
  where: storage_objects_bool_exp
}

"""Ordering options when selecting data from "storage.objects"."""
input storage_objects_order_by {
  bucket: storage_buckets_order_by
  bucket_id: order_by
  created_at: order_by
  id: order_by
  last_accessed_at: order_by
  level: order_by
  metadata: order_by
  name: order_by
  owner: order_by
  owner_id: order_by
  path_tokens: order_by
  updated_at: order_by
  user_metadata: order_by
  version: order_by
}

"""primary key columns input for table: storage.objects"""
input storage_objects_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input storage_objects_prepend_input {
  metadata: jsonb
  user_metadata: jsonb
}

"""
select columns of table "storage.objects"
"""
enum storage_objects_select_column {
  """column name"""
  bucket_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  last_accessed_at

  """column name"""
  level

  """column name"""
  metadata

  """column name"""
  name

  """column name"""
  owner

  """column name"""
  owner_id

  """column name"""
  path_tokens

  """column name"""
  updated_at

  """column name"""
  user_metadata

  """column name"""
  version
}

"""
input type for updating data in table "storage.objects"
"""
input storage_objects_set_input {
  bucket_id: String
  created_at: timestamptz
  id: uuid
  last_accessed_at: timestamptz
  level: Int
  metadata: jsonb
  name: String

  """Field is deprecated, use owner_id instead"""
  owner: uuid
  owner_id: String
  updated_at: timestamptz
  user_metadata: jsonb
  version: String
}

"""aggregate stddev on columns"""
type storage_objects_stddev_fields {
  level: Float
}

"""
order by stddev() on columns of table "storage.objects"
"""
input storage_objects_stddev_order_by {
  level: order_by
}

"""aggregate stddev_pop on columns"""
type storage_objects_stddev_pop_fields {
  level: Float
}

"""
order by stddev_pop() on columns of table "storage.objects"
"""
input storage_objects_stddev_pop_order_by {
  level: order_by
}

"""aggregate stddev_samp on columns"""
type storage_objects_stddev_samp_fields {
  level: Float
}

"""
order by stddev_samp() on columns of table "storage.objects"
"""
input storage_objects_stddev_samp_order_by {
  level: order_by
}

"""
Streaming cursor of the table "storage_objects"
"""
input storage_objects_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: storage_objects_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input storage_objects_stream_cursor_value_input {
  bucket_id: String
  created_at: timestamptz
  id: uuid
  last_accessed_at: timestamptz
  level: Int
  metadata: jsonb
  name: String

  """Field is deprecated, use owner_id instead"""
  owner: uuid
  owner_id: String
  path_tokens: [String!]
  updated_at: timestamptz
  user_metadata: jsonb
  version: String
}

"""aggregate sum on columns"""
type storage_objects_sum_fields {
  level: Int
}

"""
order by sum() on columns of table "storage.objects"
"""
input storage_objects_sum_order_by {
  level: order_by
}

"""
update columns of table "storage.objects"
"""
enum storage_objects_update_column {
  """column name"""
  bucket_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  last_accessed_at

  """column name"""
  level

  """column name"""
  metadata

  """column name"""
  name

  """column name"""
  owner

  """column name"""
  owner_id

  """column name"""
  updated_at

  """column name"""
  user_metadata

  """column name"""
  version
}

input storage_objects_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: storage_objects_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: storage_objects_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: storage_objects_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: storage_objects_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: storage_objects_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: storage_objects_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: storage_objects_set_input

  """filter the rows which have to be updated"""
  where: storage_objects_bool_exp!
}

"""aggregate var_pop on columns"""
type storage_objects_var_pop_fields {
  level: Float
}

"""
order by var_pop() on columns of table "storage.objects"
"""
input storage_objects_var_pop_order_by {
  level: order_by
}

"""aggregate var_samp on columns"""
type storage_objects_var_samp_fields {
  level: Float
}

"""
order by var_samp() on columns of table "storage.objects"
"""
input storage_objects_var_samp_order_by {
  level: order_by
}

"""aggregate variance on columns"""
type storage_objects_variance_fields {
  level: Float
}

"""
order by variance() on columns of table "storage.objects"
"""
input storage_objects_variance_order_by {
  level: order_by
}

"""
columns and relationships of "storage.prefixes"
"""
type storage_prefixes {
  """An object relationship"""
  bucket: storage_buckets!
  bucket_id: String!
  created_at: timestamptz
  level: Int!
  name: String!
  updated_at: timestamptz
}

"""
aggregated selection of "storage.prefixes"
"""
type storage_prefixes_aggregate {
  aggregate: storage_prefixes_aggregate_fields
  nodes: [storage_prefixes!]!
}

input storage_prefixes_aggregate_bool_exp {
  count: storage_prefixes_aggregate_bool_exp_count
}

input storage_prefixes_aggregate_bool_exp_count {
  arguments: [storage_prefixes_select_column!]
  distinct: Boolean
  filter: storage_prefixes_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "storage.prefixes"
"""
type storage_prefixes_aggregate_fields {
  avg: storage_prefixes_avg_fields
  count(columns: [storage_prefixes_select_column!], distinct: Boolean): Int!
  max: storage_prefixes_max_fields
  min: storage_prefixes_min_fields
  stddev: storage_prefixes_stddev_fields
  stddev_pop: storage_prefixes_stddev_pop_fields
  stddev_samp: storage_prefixes_stddev_samp_fields
  sum: storage_prefixes_sum_fields
  var_pop: storage_prefixes_var_pop_fields
  var_samp: storage_prefixes_var_samp_fields
  variance: storage_prefixes_variance_fields
}

"""
order by aggregate values of table "storage.prefixes"
"""
input storage_prefixes_aggregate_order_by {
  avg: storage_prefixes_avg_order_by
  count: order_by
  max: storage_prefixes_max_order_by
  min: storage_prefixes_min_order_by
  stddev: storage_prefixes_stddev_order_by
  stddev_pop: storage_prefixes_stddev_pop_order_by
  stddev_samp: storage_prefixes_stddev_samp_order_by
  sum: storage_prefixes_sum_order_by
  var_pop: storage_prefixes_var_pop_order_by
  var_samp: storage_prefixes_var_samp_order_by
  variance: storage_prefixes_variance_order_by
}

"""
input type for inserting array relation for remote table "storage.prefixes"
"""
input storage_prefixes_arr_rel_insert_input {
  data: [storage_prefixes_insert_input!]!

  """upsert condition"""
  on_conflict: storage_prefixes_on_conflict
}

"""aggregate avg on columns"""
type storage_prefixes_avg_fields {
  level: Float
}

"""
order by avg() on columns of table "storage.prefixes"
"""
input storage_prefixes_avg_order_by {
  level: order_by
}

"""
Boolean expression to filter rows from the table "storage.prefixes". All fields are combined with a logical 'AND'.
"""
input storage_prefixes_bool_exp {
  _and: [storage_prefixes_bool_exp!]
  _not: storage_prefixes_bool_exp
  _or: [storage_prefixes_bool_exp!]
  bucket: storage_buckets_bool_exp
  bucket_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  level: Int_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "storage.prefixes"
"""
enum storage_prefixes_constraint {
  """
  unique or primary key constraint on columns "bucket_id", "level", "name"
  """
  prefixes_pkey
}

"""
input type for inserting data into table "storage.prefixes"
"""
input storage_prefixes_insert_input {
  bucket: storage_buckets_obj_rel_insert_input
  bucket_id: String
  created_at: timestamptz
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type storage_prefixes_max_fields {
  bucket_id: String
  created_at: timestamptz
  level: Int
  name: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "storage.prefixes"
"""
input storage_prefixes_max_order_by {
  bucket_id: order_by
  created_at: order_by
  level: order_by
  name: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type storage_prefixes_min_fields {
  bucket_id: String
  created_at: timestamptz
  level: Int
  name: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "storage.prefixes"
"""
input storage_prefixes_min_order_by {
  bucket_id: order_by
  created_at: order_by
  level: order_by
  name: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "storage.prefixes"
"""
type storage_prefixes_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [storage_prefixes!]!
}

"""
on_conflict condition type for table "storage.prefixes"
"""
input storage_prefixes_on_conflict {
  constraint: storage_prefixes_constraint!
  update_columns: [storage_prefixes_update_column!]! = []
  where: storage_prefixes_bool_exp
}

"""Ordering options when selecting data from "storage.prefixes"."""
input storage_prefixes_order_by {
  bucket: storage_buckets_order_by
  bucket_id: order_by
  created_at: order_by
  level: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: storage.prefixes"""
input storage_prefixes_pk_columns_input {
  bucket_id: String!
  level: Int!
  name: String!
}

"""
select columns of table "storage.prefixes"
"""
enum storage_prefixes_select_column {
  """column name"""
  bucket_id

  """column name"""
  created_at

  """column name"""
  level

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "storage.prefixes"
"""
input storage_prefixes_set_input {
  bucket_id: String
  created_at: timestamptz
  name: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type storage_prefixes_stddev_fields {
  level: Float
}

"""
order by stddev() on columns of table "storage.prefixes"
"""
input storage_prefixes_stddev_order_by {
  level: order_by
}

"""aggregate stddev_pop on columns"""
type storage_prefixes_stddev_pop_fields {
  level: Float
}

"""
order by stddev_pop() on columns of table "storage.prefixes"
"""
input storage_prefixes_stddev_pop_order_by {
  level: order_by
}

"""aggregate stddev_samp on columns"""
type storage_prefixes_stddev_samp_fields {
  level: Float
}

"""
order by stddev_samp() on columns of table "storage.prefixes"
"""
input storage_prefixes_stddev_samp_order_by {
  level: order_by
}

"""
Streaming cursor of the table "storage_prefixes"
"""
input storage_prefixes_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: storage_prefixes_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input storage_prefixes_stream_cursor_value_input {
  bucket_id: String
  created_at: timestamptz
  level: Int
  name: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type storage_prefixes_sum_fields {
  level: Int
}

"""
order by sum() on columns of table "storage.prefixes"
"""
input storage_prefixes_sum_order_by {
  level: order_by
}

"""
update columns of table "storage.prefixes"
"""
enum storage_prefixes_update_column {
  """column name"""
  bucket_id

  """column name"""
  created_at

  """column name"""
  name

  """column name"""
  updated_at
}

input storage_prefixes_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: storage_prefixes_set_input

  """filter the rows which have to be updated"""
  where: storage_prefixes_bool_exp!
}

"""aggregate var_pop on columns"""
type storage_prefixes_var_pop_fields {
  level: Float
}

"""
order by var_pop() on columns of table "storage.prefixes"
"""
input storage_prefixes_var_pop_order_by {
  level: order_by
}

"""aggregate var_samp on columns"""
type storage_prefixes_var_samp_fields {
  level: Float
}

"""
order by var_samp() on columns of table "storage.prefixes"
"""
input storage_prefixes_var_samp_order_by {
  level: order_by
}

"""aggregate variance on columns"""
type storage_prefixes_variance_fields {
  level: Float
}

"""
order by variance() on columns of table "storage.prefixes"
"""
input storage_prefixes_variance_order_by {
  level: order_by
}

"""
columns and relationships of "storage.s3_multipart_uploads"
"""
type storage_s3_multipart_uploads {
  """An object relationship"""
  bucket: storage_buckets!
  bucket_id: String!
  created_at: timestamptz!
  id: String!
  in_progress_size: bigint!
  key: String!
  owner_id: String

  """An array relationship"""
  s3_multipart_uploads_parts(
    """distinct select on columns"""
    distinct_on: [storage_s3_multipart_uploads_parts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_s3_multipart_uploads_parts_order_by!]

    """filter the rows returned"""
    where: storage_s3_multipart_uploads_parts_bool_exp
  ): [storage_s3_multipart_uploads_parts!]!

  """An aggregate relationship"""
  s3_multipart_uploads_parts_aggregate(
    """distinct select on columns"""
    distinct_on: [storage_s3_multipart_uploads_parts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_s3_multipart_uploads_parts_order_by!]

    """filter the rows returned"""
    where: storage_s3_multipart_uploads_parts_bool_exp
  ): storage_s3_multipart_uploads_parts_aggregate!
  upload_signature: String!
  user_metadata(
    """JSON select path"""
    path: String
  ): jsonb
  version: String!
}

"""
aggregated selection of "storage.s3_multipart_uploads"
"""
type storage_s3_multipart_uploads_aggregate {
  aggregate: storage_s3_multipart_uploads_aggregate_fields
  nodes: [storage_s3_multipart_uploads!]!
}

input storage_s3_multipart_uploads_aggregate_bool_exp {
  count: storage_s3_multipart_uploads_aggregate_bool_exp_count
}

input storage_s3_multipart_uploads_aggregate_bool_exp_count {
  arguments: [storage_s3_multipart_uploads_select_column!]
  distinct: Boolean
  filter: storage_s3_multipart_uploads_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "storage.s3_multipart_uploads"
"""
type storage_s3_multipart_uploads_aggregate_fields {
  avg: storage_s3_multipart_uploads_avg_fields
  count(columns: [storage_s3_multipart_uploads_select_column!], distinct: Boolean): Int!
  max: storage_s3_multipart_uploads_max_fields
  min: storage_s3_multipart_uploads_min_fields
  stddev: storage_s3_multipart_uploads_stddev_fields
  stddev_pop: storage_s3_multipart_uploads_stddev_pop_fields
  stddev_samp: storage_s3_multipart_uploads_stddev_samp_fields
  sum: storage_s3_multipart_uploads_sum_fields
  var_pop: storage_s3_multipart_uploads_var_pop_fields
  var_samp: storage_s3_multipart_uploads_var_samp_fields
  variance: storage_s3_multipart_uploads_variance_fields
}

"""
order by aggregate values of table "storage.s3_multipart_uploads"
"""
input storage_s3_multipart_uploads_aggregate_order_by {
  avg: storage_s3_multipart_uploads_avg_order_by
  count: order_by
  max: storage_s3_multipart_uploads_max_order_by
  min: storage_s3_multipart_uploads_min_order_by
  stddev: storage_s3_multipart_uploads_stddev_order_by
  stddev_pop: storage_s3_multipart_uploads_stddev_pop_order_by
  stddev_samp: storage_s3_multipart_uploads_stddev_samp_order_by
  sum: storage_s3_multipart_uploads_sum_order_by
  var_pop: storage_s3_multipart_uploads_var_pop_order_by
  var_samp: storage_s3_multipart_uploads_var_samp_order_by
  variance: storage_s3_multipart_uploads_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input storage_s3_multipart_uploads_append_input {
  user_metadata: jsonb
}

"""
input type for inserting array relation for remote table "storage.s3_multipart_uploads"
"""
input storage_s3_multipart_uploads_arr_rel_insert_input {
  data: [storage_s3_multipart_uploads_insert_input!]!

  """upsert condition"""
  on_conflict: storage_s3_multipart_uploads_on_conflict
}

"""aggregate avg on columns"""
type storage_s3_multipart_uploads_avg_fields {
  in_progress_size: Float
}

"""
order by avg() on columns of table "storage.s3_multipart_uploads"
"""
input storage_s3_multipart_uploads_avg_order_by {
  in_progress_size: order_by
}

"""
Boolean expression to filter rows from the table "storage.s3_multipart_uploads". All fields are combined with a logical 'AND'.
"""
input storage_s3_multipart_uploads_bool_exp {
  _and: [storage_s3_multipart_uploads_bool_exp!]
  _not: storage_s3_multipart_uploads_bool_exp
  _or: [storage_s3_multipart_uploads_bool_exp!]
  bucket: storage_buckets_bool_exp
  bucket_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: String_comparison_exp
  in_progress_size: bigint_comparison_exp
  key: String_comparison_exp
  owner_id: String_comparison_exp
  s3_multipart_uploads_parts: storage_s3_multipart_uploads_parts_bool_exp
  s3_multipart_uploads_parts_aggregate: storage_s3_multipart_uploads_parts_aggregate_bool_exp
  upload_signature: String_comparison_exp
  user_metadata: jsonb_comparison_exp
  version: String_comparison_exp
}

"""
unique or primary key constraints on table "storage.s3_multipart_uploads"
"""
enum storage_s3_multipart_uploads_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  s3_multipart_uploads_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input storage_s3_multipart_uploads_delete_at_path_input {
  user_metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input storage_s3_multipart_uploads_delete_elem_input {
  user_metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input storage_s3_multipart_uploads_delete_key_input {
  user_metadata: String
}

"""
input type for incrementing numeric columns in table "storage.s3_multipart_uploads"
"""
input storage_s3_multipart_uploads_inc_input {
  in_progress_size: bigint
}

"""
input type for inserting data into table "storage.s3_multipart_uploads"
"""
input storage_s3_multipart_uploads_insert_input {
  bucket: storage_buckets_obj_rel_insert_input
  bucket_id: String
  created_at: timestamptz
  id: String
  in_progress_size: bigint
  key: String
  owner_id: String
  s3_multipart_uploads_parts: storage_s3_multipart_uploads_parts_arr_rel_insert_input
  upload_signature: String
  user_metadata: jsonb
  version: String
}

"""aggregate max on columns"""
type storage_s3_multipart_uploads_max_fields {
  bucket_id: String
  created_at: timestamptz
  id: String
  in_progress_size: bigint
  key: String
  owner_id: String
  upload_signature: String
  version: String
}

"""
order by max() on columns of table "storage.s3_multipart_uploads"
"""
input storage_s3_multipart_uploads_max_order_by {
  bucket_id: order_by
  created_at: order_by
  id: order_by
  in_progress_size: order_by
  key: order_by
  owner_id: order_by
  upload_signature: order_by
  version: order_by
}

"""aggregate min on columns"""
type storage_s3_multipart_uploads_min_fields {
  bucket_id: String
  created_at: timestamptz
  id: String
  in_progress_size: bigint
  key: String
  owner_id: String
  upload_signature: String
  version: String
}

"""
order by min() on columns of table "storage.s3_multipart_uploads"
"""
input storage_s3_multipart_uploads_min_order_by {
  bucket_id: order_by
  created_at: order_by
  id: order_by
  in_progress_size: order_by
  key: order_by
  owner_id: order_by
  upload_signature: order_by
  version: order_by
}

"""
response of any mutation on the table "storage.s3_multipart_uploads"
"""
type storage_s3_multipart_uploads_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [storage_s3_multipart_uploads!]!
}

"""
input type for inserting object relation for remote table "storage.s3_multipart_uploads"
"""
input storage_s3_multipart_uploads_obj_rel_insert_input {
  data: storage_s3_multipart_uploads_insert_input!

  """upsert condition"""
  on_conflict: storage_s3_multipart_uploads_on_conflict
}

"""
on_conflict condition type for table "storage.s3_multipart_uploads"
"""
input storage_s3_multipart_uploads_on_conflict {
  constraint: storage_s3_multipart_uploads_constraint!
  update_columns: [storage_s3_multipart_uploads_update_column!]! = []
  where: storage_s3_multipart_uploads_bool_exp
}

"""
Ordering options when selecting data from "storage.s3_multipart_uploads".
"""
input storage_s3_multipart_uploads_order_by {
  bucket: storage_buckets_order_by
  bucket_id: order_by
  created_at: order_by
  id: order_by
  in_progress_size: order_by
  key: order_by
  owner_id: order_by
  s3_multipart_uploads_parts_aggregate: storage_s3_multipart_uploads_parts_aggregate_order_by
  upload_signature: order_by
  user_metadata: order_by
  version: order_by
}

"""
columns and relationships of "storage.s3_multipart_uploads_parts"
"""
type storage_s3_multipart_uploads_parts {
  """An object relationship"""
  bucket: storage_buckets!
  bucket_id: String!
  created_at: timestamptz!
  etag: String!
  id: uuid!
  key: String!
  owner_id: String
  part_number: Int!

  """An object relationship"""
  s3_multipart_upload: storage_s3_multipart_uploads!
  size: bigint!
  upload_id: String!
  version: String!
}

"""
aggregated selection of "storage.s3_multipart_uploads_parts"
"""
type storage_s3_multipart_uploads_parts_aggregate {
  aggregate: storage_s3_multipart_uploads_parts_aggregate_fields
  nodes: [storage_s3_multipart_uploads_parts!]!
}

input storage_s3_multipart_uploads_parts_aggregate_bool_exp {
  count: storage_s3_multipart_uploads_parts_aggregate_bool_exp_count
}

input storage_s3_multipart_uploads_parts_aggregate_bool_exp_count {
  arguments: [storage_s3_multipart_uploads_parts_select_column!]
  distinct: Boolean
  filter: storage_s3_multipart_uploads_parts_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "storage.s3_multipart_uploads_parts"
"""
type storage_s3_multipart_uploads_parts_aggregate_fields {
  avg: storage_s3_multipart_uploads_parts_avg_fields
  count(columns: [storage_s3_multipart_uploads_parts_select_column!], distinct: Boolean): Int!
  max: storage_s3_multipart_uploads_parts_max_fields
  min: storage_s3_multipart_uploads_parts_min_fields
  stddev: storage_s3_multipart_uploads_parts_stddev_fields
  stddev_pop: storage_s3_multipart_uploads_parts_stddev_pop_fields
  stddev_samp: storage_s3_multipart_uploads_parts_stddev_samp_fields
  sum: storage_s3_multipart_uploads_parts_sum_fields
  var_pop: storage_s3_multipart_uploads_parts_var_pop_fields
  var_samp: storage_s3_multipart_uploads_parts_var_samp_fields
  variance: storage_s3_multipart_uploads_parts_variance_fields
}

"""
order by aggregate values of table "storage.s3_multipart_uploads_parts"
"""
input storage_s3_multipart_uploads_parts_aggregate_order_by {
  avg: storage_s3_multipart_uploads_parts_avg_order_by
  count: order_by
  max: storage_s3_multipart_uploads_parts_max_order_by
  min: storage_s3_multipart_uploads_parts_min_order_by
  stddev: storage_s3_multipart_uploads_parts_stddev_order_by
  stddev_pop: storage_s3_multipart_uploads_parts_stddev_pop_order_by
  stddev_samp: storage_s3_multipart_uploads_parts_stddev_samp_order_by
  sum: storage_s3_multipart_uploads_parts_sum_order_by
  var_pop: storage_s3_multipart_uploads_parts_var_pop_order_by
  var_samp: storage_s3_multipart_uploads_parts_var_samp_order_by
  variance: storage_s3_multipart_uploads_parts_variance_order_by
}

"""
input type for inserting array relation for remote table "storage.s3_multipart_uploads_parts"
"""
input storage_s3_multipart_uploads_parts_arr_rel_insert_input {
  data: [storage_s3_multipart_uploads_parts_insert_input!]!

  """upsert condition"""
  on_conflict: storage_s3_multipart_uploads_parts_on_conflict
}

"""aggregate avg on columns"""
type storage_s3_multipart_uploads_parts_avg_fields {
  part_number: Float
  size: Float
}

"""
order by avg() on columns of table "storage.s3_multipart_uploads_parts"
"""
input storage_s3_multipart_uploads_parts_avg_order_by {
  part_number: order_by
  size: order_by
}

"""
Boolean expression to filter rows from the table "storage.s3_multipart_uploads_parts". All fields are combined with a logical 'AND'.
"""
input storage_s3_multipart_uploads_parts_bool_exp {
  _and: [storage_s3_multipart_uploads_parts_bool_exp!]
  _not: storage_s3_multipart_uploads_parts_bool_exp
  _or: [storage_s3_multipart_uploads_parts_bool_exp!]
  bucket: storage_buckets_bool_exp
  bucket_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  etag: String_comparison_exp
  id: uuid_comparison_exp
  key: String_comparison_exp
  owner_id: String_comparison_exp
  part_number: Int_comparison_exp
  s3_multipart_upload: storage_s3_multipart_uploads_bool_exp
  size: bigint_comparison_exp
  upload_id: String_comparison_exp
  version: String_comparison_exp
}

"""
unique or primary key constraints on table "storage.s3_multipart_uploads_parts"
"""
enum storage_s3_multipart_uploads_parts_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  s3_multipart_uploads_parts_pkey
}

"""
input type for incrementing numeric columns in table "storage.s3_multipart_uploads_parts"
"""
input storage_s3_multipart_uploads_parts_inc_input {
  part_number: Int
  size: bigint
}

"""
input type for inserting data into table "storage.s3_multipart_uploads_parts"
"""
input storage_s3_multipart_uploads_parts_insert_input {
  bucket: storage_buckets_obj_rel_insert_input
  bucket_id: String
  created_at: timestamptz
  etag: String
  id: uuid
  key: String
  owner_id: String
  part_number: Int
  s3_multipart_upload: storage_s3_multipart_uploads_obj_rel_insert_input
  size: bigint
  upload_id: String
  version: String
}

"""aggregate max on columns"""
type storage_s3_multipart_uploads_parts_max_fields {
  bucket_id: String
  created_at: timestamptz
  etag: String
  id: uuid
  key: String
  owner_id: String
  part_number: Int
  size: bigint
  upload_id: String
  version: String
}

"""
order by max() on columns of table "storage.s3_multipart_uploads_parts"
"""
input storage_s3_multipart_uploads_parts_max_order_by {
  bucket_id: order_by
  created_at: order_by
  etag: order_by
  id: order_by
  key: order_by
  owner_id: order_by
  part_number: order_by
  size: order_by
  upload_id: order_by
  version: order_by
}

"""aggregate min on columns"""
type storage_s3_multipart_uploads_parts_min_fields {
  bucket_id: String
  created_at: timestamptz
  etag: String
  id: uuid
  key: String
  owner_id: String
  part_number: Int
  size: bigint
  upload_id: String
  version: String
}

"""
order by min() on columns of table "storage.s3_multipart_uploads_parts"
"""
input storage_s3_multipart_uploads_parts_min_order_by {
  bucket_id: order_by
  created_at: order_by
  etag: order_by
  id: order_by
  key: order_by
  owner_id: order_by
  part_number: order_by
  size: order_by
  upload_id: order_by
  version: order_by
}

"""
response of any mutation on the table "storage.s3_multipart_uploads_parts"
"""
type storage_s3_multipart_uploads_parts_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [storage_s3_multipart_uploads_parts!]!
}

"""
on_conflict condition type for table "storage.s3_multipart_uploads_parts"
"""
input storage_s3_multipart_uploads_parts_on_conflict {
  constraint: storage_s3_multipart_uploads_parts_constraint!
  update_columns: [storage_s3_multipart_uploads_parts_update_column!]! = []
  where: storage_s3_multipart_uploads_parts_bool_exp
}

"""
Ordering options when selecting data from "storage.s3_multipart_uploads_parts".
"""
input storage_s3_multipart_uploads_parts_order_by {
  bucket: storage_buckets_order_by
  bucket_id: order_by
  created_at: order_by
  etag: order_by
  id: order_by
  key: order_by
  owner_id: order_by
  part_number: order_by
  s3_multipart_upload: storage_s3_multipart_uploads_order_by
  size: order_by
  upload_id: order_by
  version: order_by
}

"""
primary key columns input for table: storage.s3_multipart_uploads_parts
"""
input storage_s3_multipart_uploads_parts_pk_columns_input {
  id: uuid!
}

"""
select columns of table "storage.s3_multipart_uploads_parts"
"""
enum storage_s3_multipart_uploads_parts_select_column {
  """column name"""
  bucket_id

  """column name"""
  created_at

  """column name"""
  etag

  """column name"""
  id

  """column name"""
  key

  """column name"""
  owner_id

  """column name"""
  part_number

  """column name"""
  size

  """column name"""
  upload_id

  """column name"""
  version
}

"""
input type for updating data in table "storage.s3_multipart_uploads_parts"
"""
input storage_s3_multipart_uploads_parts_set_input {
  bucket_id: String
  created_at: timestamptz
  etag: String
  id: uuid
  key: String
  owner_id: String
  part_number: Int
  size: bigint
  upload_id: String
  version: String
}

"""aggregate stddev on columns"""
type storage_s3_multipart_uploads_parts_stddev_fields {
  part_number: Float
  size: Float
}

"""
order by stddev() on columns of table "storage.s3_multipart_uploads_parts"
"""
input storage_s3_multipart_uploads_parts_stddev_order_by {
  part_number: order_by
  size: order_by
}

"""aggregate stddev_pop on columns"""
type storage_s3_multipart_uploads_parts_stddev_pop_fields {
  part_number: Float
  size: Float
}

"""
order by stddev_pop() on columns of table "storage.s3_multipart_uploads_parts"
"""
input storage_s3_multipart_uploads_parts_stddev_pop_order_by {
  part_number: order_by
  size: order_by
}

"""aggregate stddev_samp on columns"""
type storage_s3_multipart_uploads_parts_stddev_samp_fields {
  part_number: Float
  size: Float
}

"""
order by stddev_samp() on columns of table "storage.s3_multipart_uploads_parts"
"""
input storage_s3_multipart_uploads_parts_stddev_samp_order_by {
  part_number: order_by
  size: order_by
}

"""
Streaming cursor of the table "storage_s3_multipart_uploads_parts"
"""
input storage_s3_multipart_uploads_parts_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: storage_s3_multipart_uploads_parts_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input storage_s3_multipart_uploads_parts_stream_cursor_value_input {
  bucket_id: String
  created_at: timestamptz
  etag: String
  id: uuid
  key: String
  owner_id: String
  part_number: Int
  size: bigint
  upload_id: String
  version: String
}

"""aggregate sum on columns"""
type storage_s3_multipart_uploads_parts_sum_fields {
  part_number: Int
  size: bigint
}

"""
order by sum() on columns of table "storage.s3_multipart_uploads_parts"
"""
input storage_s3_multipart_uploads_parts_sum_order_by {
  part_number: order_by
  size: order_by
}

"""
update columns of table "storage.s3_multipart_uploads_parts"
"""
enum storage_s3_multipart_uploads_parts_update_column {
  """column name"""
  bucket_id

  """column name"""
  created_at

  """column name"""
  etag

  """column name"""
  id

  """column name"""
  key

  """column name"""
  owner_id

  """column name"""
  part_number

  """column name"""
  size

  """column name"""
  upload_id

  """column name"""
  version
}

input storage_s3_multipart_uploads_parts_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: storage_s3_multipart_uploads_parts_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: storage_s3_multipart_uploads_parts_set_input

  """filter the rows which have to be updated"""
  where: storage_s3_multipart_uploads_parts_bool_exp!
}

"""aggregate var_pop on columns"""
type storage_s3_multipart_uploads_parts_var_pop_fields {
  part_number: Float
  size: Float
}

"""
order by var_pop() on columns of table "storage.s3_multipart_uploads_parts"
"""
input storage_s3_multipart_uploads_parts_var_pop_order_by {
  part_number: order_by
  size: order_by
}

"""aggregate var_samp on columns"""
type storage_s3_multipart_uploads_parts_var_samp_fields {
  part_number: Float
  size: Float
}

"""
order by var_samp() on columns of table "storage.s3_multipart_uploads_parts"
"""
input storage_s3_multipart_uploads_parts_var_samp_order_by {
  part_number: order_by
  size: order_by
}

"""aggregate variance on columns"""
type storage_s3_multipart_uploads_parts_variance_fields {
  part_number: Float
  size: Float
}

"""
order by variance() on columns of table "storage.s3_multipart_uploads_parts"
"""
input storage_s3_multipart_uploads_parts_variance_order_by {
  part_number: order_by
  size: order_by
}

"""primary key columns input for table: storage.s3_multipart_uploads"""
input storage_s3_multipart_uploads_pk_columns_input {
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input storage_s3_multipart_uploads_prepend_input {
  user_metadata: jsonb
}

"""
select columns of table "storage.s3_multipart_uploads"
"""
enum storage_s3_multipart_uploads_select_column {
  """column name"""
  bucket_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  in_progress_size

  """column name"""
  key

  """column name"""
  owner_id

  """column name"""
  upload_signature

  """column name"""
  user_metadata

  """column name"""
  version
}

"""
input type for updating data in table "storage.s3_multipart_uploads"
"""
input storage_s3_multipart_uploads_set_input {
  bucket_id: String
  created_at: timestamptz
  id: String
  in_progress_size: bigint
  key: String
  owner_id: String
  upload_signature: String
  user_metadata: jsonb
  version: String
}

"""aggregate stddev on columns"""
type storage_s3_multipart_uploads_stddev_fields {
  in_progress_size: Float
}

"""
order by stddev() on columns of table "storage.s3_multipart_uploads"
"""
input storage_s3_multipart_uploads_stddev_order_by {
  in_progress_size: order_by
}

"""aggregate stddev_pop on columns"""
type storage_s3_multipart_uploads_stddev_pop_fields {
  in_progress_size: Float
}

"""
order by stddev_pop() on columns of table "storage.s3_multipart_uploads"
"""
input storage_s3_multipart_uploads_stddev_pop_order_by {
  in_progress_size: order_by
}

"""aggregate stddev_samp on columns"""
type storage_s3_multipart_uploads_stddev_samp_fields {
  in_progress_size: Float
}

"""
order by stddev_samp() on columns of table "storage.s3_multipart_uploads"
"""
input storage_s3_multipart_uploads_stddev_samp_order_by {
  in_progress_size: order_by
}

"""
Streaming cursor of the table "storage_s3_multipart_uploads"
"""
input storage_s3_multipart_uploads_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: storage_s3_multipart_uploads_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input storage_s3_multipart_uploads_stream_cursor_value_input {
  bucket_id: String
  created_at: timestamptz
  id: String
  in_progress_size: bigint
  key: String
  owner_id: String
  upload_signature: String
  user_metadata: jsonb
  version: String
}

"""aggregate sum on columns"""
type storage_s3_multipart_uploads_sum_fields {
  in_progress_size: bigint
}

"""
order by sum() on columns of table "storage.s3_multipart_uploads"
"""
input storage_s3_multipart_uploads_sum_order_by {
  in_progress_size: order_by
}

"""
update columns of table "storage.s3_multipart_uploads"
"""
enum storage_s3_multipart_uploads_update_column {
  """column name"""
  bucket_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  in_progress_size

  """column name"""
  key

  """column name"""
  owner_id

  """column name"""
  upload_signature

  """column name"""
  user_metadata

  """column name"""
  version
}

input storage_s3_multipart_uploads_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: storage_s3_multipart_uploads_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: storage_s3_multipart_uploads_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: storage_s3_multipart_uploads_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: storage_s3_multipart_uploads_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: storage_s3_multipart_uploads_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: storage_s3_multipart_uploads_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: storage_s3_multipart_uploads_set_input

  """filter the rows which have to be updated"""
  where: storage_s3_multipart_uploads_bool_exp!
}

"""aggregate var_pop on columns"""
type storage_s3_multipart_uploads_var_pop_fields {
  in_progress_size: Float
}

"""
order by var_pop() on columns of table "storage.s3_multipart_uploads"
"""
input storage_s3_multipart_uploads_var_pop_order_by {
  in_progress_size: order_by
}

"""aggregate var_samp on columns"""
type storage_s3_multipart_uploads_var_samp_fields {
  in_progress_size: Float
}

"""
order by var_samp() on columns of table "storage.s3_multipart_uploads"
"""
input storage_s3_multipart_uploads_var_samp_order_by {
  in_progress_size: order_by
}

"""aggregate variance on columns"""
type storage_s3_multipart_uploads_variance_fields {
  in_progress_size: Float
}

"""
order by variance() on columns of table "storage.s3_multipart_uploads"
"""
input storage_s3_multipart_uploads_variance_order_by {
  in_progress_size: order_by
}

"""
Defines usage limits and feature flags for each plan type and user type combination
"""
type subscription_limits {
  bulk_uploads_limit: Int
  candidate_searches_limit: Int
  candidates_saved_limit: Int
  created_at: timestamptz
  has_analytics: Boolean
  has_api_access: Boolean
  has_priority_support: Boolean
  has_verification_badge: Boolean
  has_white_label: Boolean
  id: uuid!
  job_applications_limit: Int
  job_postings_limit: Int
  maid_listings_limit: Int
  message_threads_limit: Int
  messages_per_day_limit: Int
  plan_type: String!
  profile_views_limit: Int
  sponsor_connections_limit: Int
  updated_at: timestamptz
  user_type: String!
}

"""
aggregated selection of "subscription_limits"
"""
type subscription_limits_aggregate {
  aggregate: subscription_limits_aggregate_fields
  nodes: [subscription_limits!]!
}

"""
aggregate fields of "subscription_limits"
"""
type subscription_limits_aggregate_fields {
  avg: subscription_limits_avg_fields
  count(columns: [subscription_limits_select_column!], distinct: Boolean): Int!
  max: subscription_limits_max_fields
  min: subscription_limits_min_fields
  stddev: subscription_limits_stddev_fields
  stddev_pop: subscription_limits_stddev_pop_fields
  stddev_samp: subscription_limits_stddev_samp_fields
  sum: subscription_limits_sum_fields
  var_pop: subscription_limits_var_pop_fields
  var_samp: subscription_limits_var_samp_fields
  variance: subscription_limits_variance_fields
}

"""aggregate avg on columns"""
type subscription_limits_avg_fields {
  bulk_uploads_limit: Float
  candidate_searches_limit: Float
  candidates_saved_limit: Float
  job_applications_limit: Float
  job_postings_limit: Float
  maid_listings_limit: Float
  message_threads_limit: Float
  messages_per_day_limit: Float
  profile_views_limit: Float
  sponsor_connections_limit: Float
}

"""
Boolean expression to filter rows from the table "subscription_limits". All fields are combined with a logical 'AND'.
"""
input subscription_limits_bool_exp {
  _and: [subscription_limits_bool_exp!]
  _not: subscription_limits_bool_exp
  _or: [subscription_limits_bool_exp!]
  bulk_uploads_limit: Int_comparison_exp
  candidate_searches_limit: Int_comparison_exp
  candidates_saved_limit: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  has_analytics: Boolean_comparison_exp
  has_api_access: Boolean_comparison_exp
  has_priority_support: Boolean_comparison_exp
  has_verification_badge: Boolean_comparison_exp
  has_white_label: Boolean_comparison_exp
  id: uuid_comparison_exp
  job_applications_limit: Int_comparison_exp
  job_postings_limit: Int_comparison_exp
  maid_listings_limit: Int_comparison_exp
  message_threads_limit: Int_comparison_exp
  messages_per_day_limit: Int_comparison_exp
  plan_type: String_comparison_exp
  profile_views_limit: Int_comparison_exp
  sponsor_connections_limit: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_type: String_comparison_exp
}

"""
unique or primary key constraints on table "subscription_limits"
"""
enum subscription_limits_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  subscription_limits_pkey

  """
  unique or primary key constraint on columns "user_type", "plan_type"
  """
  unique_plan_user_type
}

"""
input type for incrementing numeric columns in table "subscription_limits"
"""
input subscription_limits_inc_input {
  bulk_uploads_limit: Int
  candidate_searches_limit: Int
  candidates_saved_limit: Int
  job_applications_limit: Int
  job_postings_limit: Int
  maid_listings_limit: Int
  message_threads_limit: Int
  messages_per_day_limit: Int
  profile_views_limit: Int
  sponsor_connections_limit: Int
}

"""
input type for inserting data into table "subscription_limits"
"""
input subscription_limits_insert_input {
  bulk_uploads_limit: Int
  candidate_searches_limit: Int
  candidates_saved_limit: Int
  created_at: timestamptz
  has_analytics: Boolean
  has_api_access: Boolean
  has_priority_support: Boolean
  has_verification_badge: Boolean
  has_white_label: Boolean
  id: uuid
  job_applications_limit: Int
  job_postings_limit: Int
  maid_listings_limit: Int
  message_threads_limit: Int
  messages_per_day_limit: Int
  plan_type: String
  profile_views_limit: Int
  sponsor_connections_limit: Int
  updated_at: timestamptz
  user_type: String
}

"""aggregate max on columns"""
type subscription_limits_max_fields {
  bulk_uploads_limit: Int
  candidate_searches_limit: Int
  candidates_saved_limit: Int
  created_at: timestamptz
  id: uuid
  job_applications_limit: Int
  job_postings_limit: Int
  maid_listings_limit: Int
  message_threads_limit: Int
  messages_per_day_limit: Int
  plan_type: String
  profile_views_limit: Int
  sponsor_connections_limit: Int
  updated_at: timestamptz
  user_type: String
}

"""aggregate min on columns"""
type subscription_limits_min_fields {
  bulk_uploads_limit: Int
  candidate_searches_limit: Int
  candidates_saved_limit: Int
  created_at: timestamptz
  id: uuid
  job_applications_limit: Int
  job_postings_limit: Int
  maid_listings_limit: Int
  message_threads_limit: Int
  messages_per_day_limit: Int
  plan_type: String
  profile_views_limit: Int
  sponsor_connections_limit: Int
  updated_at: timestamptz
  user_type: String
}

"""
response of any mutation on the table "subscription_limits"
"""
type subscription_limits_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [subscription_limits!]!
}

"""
on_conflict condition type for table "subscription_limits"
"""
input subscription_limits_on_conflict {
  constraint: subscription_limits_constraint!
  update_columns: [subscription_limits_update_column!]! = []
  where: subscription_limits_bool_exp
}

"""Ordering options when selecting data from "subscription_limits"."""
input subscription_limits_order_by {
  bulk_uploads_limit: order_by
  candidate_searches_limit: order_by
  candidates_saved_limit: order_by
  created_at: order_by
  has_analytics: order_by
  has_api_access: order_by
  has_priority_support: order_by
  has_verification_badge: order_by
  has_white_label: order_by
  id: order_by
  job_applications_limit: order_by
  job_postings_limit: order_by
  maid_listings_limit: order_by
  message_threads_limit: order_by
  messages_per_day_limit: order_by
  plan_type: order_by
  profile_views_limit: order_by
  sponsor_connections_limit: order_by
  updated_at: order_by
  user_type: order_by
}

"""primary key columns input for table: subscription_limits"""
input subscription_limits_pk_columns_input {
  id: uuid!
}

"""
select columns of table "subscription_limits"
"""
enum subscription_limits_select_column {
  """column name"""
  bulk_uploads_limit

  """column name"""
  candidate_searches_limit

  """column name"""
  candidates_saved_limit

  """column name"""
  created_at

  """column name"""
  has_analytics

  """column name"""
  has_api_access

  """column name"""
  has_priority_support

  """column name"""
  has_verification_badge

  """column name"""
  has_white_label

  """column name"""
  id

  """column name"""
  job_applications_limit

  """column name"""
  job_postings_limit

  """column name"""
  maid_listings_limit

  """column name"""
  message_threads_limit

  """column name"""
  messages_per_day_limit

  """column name"""
  plan_type

  """column name"""
  profile_views_limit

  """column name"""
  sponsor_connections_limit

  """column name"""
  updated_at

  """column name"""
  user_type
}

"""
input type for updating data in table "subscription_limits"
"""
input subscription_limits_set_input {
  bulk_uploads_limit: Int
  candidate_searches_limit: Int
  candidates_saved_limit: Int
  created_at: timestamptz
  has_analytics: Boolean
  has_api_access: Boolean
  has_priority_support: Boolean
  has_verification_badge: Boolean
  has_white_label: Boolean
  id: uuid
  job_applications_limit: Int
  job_postings_limit: Int
  maid_listings_limit: Int
  message_threads_limit: Int
  messages_per_day_limit: Int
  plan_type: String
  profile_views_limit: Int
  sponsor_connections_limit: Int
  updated_at: timestamptz
  user_type: String
}

"""aggregate stddev on columns"""
type subscription_limits_stddev_fields {
  bulk_uploads_limit: Float
  candidate_searches_limit: Float
  candidates_saved_limit: Float
  job_applications_limit: Float
  job_postings_limit: Float
  maid_listings_limit: Float
  message_threads_limit: Float
  messages_per_day_limit: Float
  profile_views_limit: Float
  sponsor_connections_limit: Float
}

"""aggregate stddev_pop on columns"""
type subscription_limits_stddev_pop_fields {
  bulk_uploads_limit: Float
  candidate_searches_limit: Float
  candidates_saved_limit: Float
  job_applications_limit: Float
  job_postings_limit: Float
  maid_listings_limit: Float
  message_threads_limit: Float
  messages_per_day_limit: Float
  profile_views_limit: Float
  sponsor_connections_limit: Float
}

"""aggregate stddev_samp on columns"""
type subscription_limits_stddev_samp_fields {
  bulk_uploads_limit: Float
  candidate_searches_limit: Float
  candidates_saved_limit: Float
  job_applications_limit: Float
  job_postings_limit: Float
  maid_listings_limit: Float
  message_threads_limit: Float
  messages_per_day_limit: Float
  profile_views_limit: Float
  sponsor_connections_limit: Float
}

"""
Streaming cursor of the table "subscription_limits"
"""
input subscription_limits_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: subscription_limits_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input subscription_limits_stream_cursor_value_input {
  bulk_uploads_limit: Int
  candidate_searches_limit: Int
  candidates_saved_limit: Int
  created_at: timestamptz
  has_analytics: Boolean
  has_api_access: Boolean
  has_priority_support: Boolean
  has_verification_badge: Boolean
  has_white_label: Boolean
  id: uuid
  job_applications_limit: Int
  job_postings_limit: Int
  maid_listings_limit: Int
  message_threads_limit: Int
  messages_per_day_limit: Int
  plan_type: String
  profile_views_limit: Int
  sponsor_connections_limit: Int
  updated_at: timestamptz
  user_type: String
}

"""aggregate sum on columns"""
type subscription_limits_sum_fields {
  bulk_uploads_limit: Int
  candidate_searches_limit: Int
  candidates_saved_limit: Int
  job_applications_limit: Int
  job_postings_limit: Int
  maid_listings_limit: Int
  message_threads_limit: Int
  messages_per_day_limit: Int
  profile_views_limit: Int
  sponsor_connections_limit: Int
}

"""
update columns of table "subscription_limits"
"""
enum subscription_limits_update_column {
  """column name"""
  bulk_uploads_limit

  """column name"""
  candidate_searches_limit

  """column name"""
  candidates_saved_limit

  """column name"""
  created_at

  """column name"""
  has_analytics

  """column name"""
  has_api_access

  """column name"""
  has_priority_support

  """column name"""
  has_verification_badge

  """column name"""
  has_white_label

  """column name"""
  id

  """column name"""
  job_applications_limit

  """column name"""
  job_postings_limit

  """column name"""
  maid_listings_limit

  """column name"""
  message_threads_limit

  """column name"""
  messages_per_day_limit

  """column name"""
  plan_type

  """column name"""
  profile_views_limit

  """column name"""
  sponsor_connections_limit

  """column name"""
  updated_at

  """column name"""
  user_type
}

input subscription_limits_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: subscription_limits_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: subscription_limits_set_input

  """filter the rows which have to be updated"""
  where: subscription_limits_bool_exp!
}

"""aggregate var_pop on columns"""
type subscription_limits_var_pop_fields {
  bulk_uploads_limit: Float
  candidate_searches_limit: Float
  candidates_saved_limit: Float
  job_applications_limit: Float
  job_postings_limit: Float
  maid_listings_limit: Float
  message_threads_limit: Float
  messages_per_day_limit: Float
  profile_views_limit: Float
  sponsor_connections_limit: Float
}

"""aggregate var_samp on columns"""
type subscription_limits_var_samp_fields {
  bulk_uploads_limit: Float
  candidate_searches_limit: Float
  candidates_saved_limit: Float
  job_applications_limit: Float
  job_postings_limit: Float
  maid_listings_limit: Float
  message_threads_limit: Float
  messages_per_day_limit: Float
  profile_views_limit: Float
  sponsor_connections_limit: Float
}

"""aggregate variance on columns"""
type subscription_limits_variance_fields {
  bulk_uploads_limit: Float
  candidate_searches_limit: Float
  candidates_saved_limit: Float
  job_applications_limit: Float
  job_postings_limit: Float
  maid_listings_limit: Float
  message_threads_limit: Float
  messages_per_day_limit: Float
  profile_views_limit: Float
  sponsor_connections_limit: Float
}

type subscription_root {
  """
  fetch data from the table: "activity_announcements"
  """
  activity_announcements(
    """distinct select on columns"""
    distinct_on: [activity_announcements_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [activity_announcements_order_by!]

    """filter the rows returned"""
    where: activity_announcements_bool_exp
  ): [activity_announcements!]!

  """
  fetch aggregated fields from the table: "activity_announcements"
  """
  activity_announcements_aggregate(
    """distinct select on columns"""
    distinct_on: [activity_announcements_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [activity_announcements_order_by!]

    """filter the rows returned"""
    where: activity_announcements_bool_exp
  ): activity_announcements_aggregate!

  """
  fetch data from the table: "activity_announcements" using primary key columns
  """
  activity_announcements_by_pk(id: uuid!): activity_announcements

  """
  fetch data from the table in a streaming manner: "activity_announcements"
  """
  activity_announcements_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [activity_announcements_stream_cursor_input]!

    """filter the rows returned"""
    where: activity_announcements_bool_exp
  ): [activity_announcements!]!

  """
  fetch data from the table: "activity_log"
  """
  activity_log(
    """distinct select on columns"""
    distinct_on: [activity_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [activity_log_order_by!]

    """filter the rows returned"""
    where: activity_log_bool_exp
  ): [activity_log!]!

  """
  fetch aggregated fields from the table: "activity_log"
  """
  activity_log_aggregate(
    """distinct select on columns"""
    distinct_on: [activity_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [activity_log_order_by!]

    """filter the rows returned"""
    where: activity_log_bool_exp
  ): activity_log_aggregate!

  """fetch data from the table: "activity_log" using primary key columns"""
  activity_log_by_pk(id: uuid!): activity_log

  """
  fetch data from the table in a streaming manner: "activity_log"
  """
  activity_log_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [activity_log_stream_cursor_input]!

    """filter the rows returned"""
    where: activity_log_bool_exp
  ): [activity_log!]!

  """An array relationship"""
  admin_activity_logs(
    """distinct select on columns"""
    distinct_on: [admin_activity_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_activity_logs_order_by!]

    """filter the rows returned"""
    where: admin_activity_logs_bool_exp
  ): [admin_activity_logs!]!

  """An aggregate relationship"""
  admin_activity_logs_aggregate(
    """distinct select on columns"""
    distinct_on: [admin_activity_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_activity_logs_order_by!]

    """filter the rows returned"""
    where: admin_activity_logs_bool_exp
  ): admin_activity_logs_aggregate!

  """
  fetch data from the table: "admin_activity_logs" using primary key columns
  """
  admin_activity_logs_by_pk(id: uuid!): admin_activity_logs

  """
  fetch data from the table in a streaming manner: "admin_activity_logs"
  """
  admin_activity_logs_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [admin_activity_logs_stream_cursor_input]!

    """filter the rows returned"""
    where: admin_activity_logs_bool_exp
  ): [admin_activity_logs!]!

  """An array relationship"""
  admin_users(
    """distinct select on columns"""
    distinct_on: [admin_users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_users_order_by!]

    """filter the rows returned"""
    where: admin_users_bool_exp
  ): [admin_users!]!

  """An aggregate relationship"""
  admin_users_aggregate(
    """distinct select on columns"""
    distinct_on: [admin_users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_users_order_by!]

    """filter the rows returned"""
    where: admin_users_bool_exp
  ): admin_users_aggregate!

  """fetch data from the table: "admin_users" using primary key columns"""
  admin_users_by_pk(id: uuid!): admin_users

  """
  fetch data from the table in a streaming manner: "admin_users"
  """
  admin_users_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [admin_users_stream_cursor_input]!

    """filter the rows returned"""
    where: admin_users_bool_exp
  ): [admin_users!]!

  """
  fetch data from the table: "agency_audit_logs"
  """
  agency_audit_logs(
    """distinct select on columns"""
    distinct_on: [agency_audit_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_audit_logs_order_by!]

    """filter the rows returned"""
    where: agency_audit_logs_bool_exp
  ): [agency_audit_logs!]!

  """
  fetch aggregated fields from the table: "agency_audit_logs"
  """
  agency_audit_logs_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_audit_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_audit_logs_order_by!]

    """filter the rows returned"""
    where: agency_audit_logs_bool_exp
  ): agency_audit_logs_aggregate!

  """
  fetch data from the table: "agency_audit_logs" using primary key columns
  """
  agency_audit_logs_by_pk(id: uuid!): agency_audit_logs

  """
  fetch data from the table in a streaming manner: "agency_audit_logs"
  """
  agency_audit_logs_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [agency_audit_logs_stream_cursor_input]!

    """filter the rows returned"""
    where: agency_audit_logs_bool_exp
  ): [agency_audit_logs!]!

  """
  fetch data from the table: "agency_credits"
  """
  agency_credits(
    """distinct select on columns"""
    distinct_on: [agency_credits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_credits_order_by!]

    """filter the rows returned"""
    where: agency_credits_bool_exp
  ): [agency_credits!]!

  """
  fetch aggregated fields from the table: "agency_credits"
  """
  agency_credits_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_credits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_credits_order_by!]

    """filter the rows returned"""
    where: agency_credits_bool_exp
  ): agency_credits_aggregate!

  """fetch data from the table: "agency_credits" using primary key columns"""
  agency_credits_by_pk(id: uuid!): agency_credits

  """
  fetch data from the table in a streaming manner: "agency_credits"
  """
  agency_credits_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [agency_credits_stream_cursor_input]!

    """filter the rows returned"""
    where: agency_credits_bool_exp
  ): [agency_credits!]!

  """
  fetch data from the table: "agency_disputes"
  """
  agency_disputes(
    """distinct select on columns"""
    distinct_on: [agency_disputes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_disputes_order_by!]

    """filter the rows returned"""
    where: agency_disputes_bool_exp
  ): [agency_disputes!]!

  """
  fetch aggregated fields from the table: "agency_disputes"
  """
  agency_disputes_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_disputes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_disputes_order_by!]

    """filter the rows returned"""
    where: agency_disputes_bool_exp
  ): agency_disputes_aggregate!

  """fetch data from the table: "agency_disputes" using primary key columns"""
  agency_disputes_by_pk(id: uuid!): agency_disputes

  """
  fetch data from the table in a streaming manner: "agency_disputes"
  """
  agency_disputes_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [agency_disputes_stream_cursor_input]!

    """filter the rows returned"""
    where: agency_disputes_bool_exp
  ): [agency_disputes!]!

  """
  fetch data from the table: "agency_document_requirements"
  """
  agency_document_requirements(
    """distinct select on columns"""
    distinct_on: [agency_document_requirements_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_document_requirements_order_by!]

    """filter the rows returned"""
    where: agency_document_requirements_bool_exp
  ): [agency_document_requirements!]!

  """
  fetch aggregated fields from the table: "agency_document_requirements"
  """
  agency_document_requirements_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_document_requirements_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_document_requirements_order_by!]

    """filter the rows returned"""
    where: agency_document_requirements_bool_exp
  ): agency_document_requirements_aggregate!

  """
  fetch data from the table: "agency_document_requirements" using primary key columns
  """
  agency_document_requirements_by_pk(id: uuid!): agency_document_requirements

  """
  fetch data from the table in a streaming manner: "agency_document_requirements"
  """
  agency_document_requirements_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [agency_document_requirements_stream_cursor_input]!

    """filter the rows returned"""
    where: agency_document_requirements_bool_exp
  ): [agency_document_requirements!]!

  """
  fetch data from the table: "agency_documents"
  """
  agency_documents(
    """distinct select on columns"""
    distinct_on: [agency_documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_documents_order_by!]

    """filter the rows returned"""
    where: agency_documents_bool_exp
  ): [agency_documents!]!

  """
  fetch aggregated fields from the table: "agency_documents"
  """
  agency_documents_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_documents_order_by!]

    """filter the rows returned"""
    where: agency_documents_bool_exp
  ): agency_documents_aggregate!

  """
  fetch data from the table: "agency_documents" using primary key columns
  """
  agency_documents_by_pk(id: uuid!): agency_documents

  """
  fetch data from the table in a streaming manner: "agency_documents"
  """
  agency_documents_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [agency_documents_stream_cursor_input]!

    """filter the rows returned"""
    where: agency_documents_bool_exp
  ): [agency_documents!]!

  """An array relationship"""
  agency_earnings(
    """distinct select on columns"""
    distinct_on: [agency_earnings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_earnings_order_by!]

    """filter the rows returned"""
    where: agency_earnings_bool_exp
  ): [agency_earnings!]!

  """An aggregate relationship"""
  agency_earnings_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_earnings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_earnings_order_by!]

    """filter the rows returned"""
    where: agency_earnings_bool_exp
  ): agency_earnings_aggregate!

  """fetch data from the table: "agency_earnings" using primary key columns"""
  agency_earnings_by_pk(id: uuid!): agency_earnings

  """
  fetch data from the table in a streaming manner: "agency_earnings"
  """
  agency_earnings_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [agency_earnings_stream_cursor_input]!

    """filter the rows returned"""
    where: agency_earnings_bool_exp
  ): [agency_earnings!]!

  """An array relationship"""
  agency_interviews(
    """distinct select on columns"""
    distinct_on: [agency_interviews_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_interviews_order_by!]

    """filter the rows returned"""
    where: agency_interviews_bool_exp
  ): [agency_interviews!]!

  """An aggregate relationship"""
  agency_interviews_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_interviews_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_interviews_order_by!]

    """filter the rows returned"""
    where: agency_interviews_bool_exp
  ): agency_interviews_aggregate!

  """
  fetch data from the table: "agency_interviews" using primary key columns
  """
  agency_interviews_by_pk(id: uuid!): agency_interviews

  """
  fetch data from the table in a streaming manner: "agency_interviews"
  """
  agency_interviews_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [agency_interviews_stream_cursor_input]!

    """filter the rows returned"""
    where: agency_interviews_bool_exp
  ): [agency_interviews!]!

  """
  fetch data from the table: "agency_jobs"
  """
  agency_jobs(
    """distinct select on columns"""
    distinct_on: [agency_jobs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_jobs_order_by!]

    """filter the rows returned"""
    where: agency_jobs_bool_exp
  ): [agency_jobs!]!

  """
  fetch aggregated fields from the table: "agency_jobs"
  """
  agency_jobs_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_jobs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_jobs_order_by!]

    """filter the rows returned"""
    where: agency_jobs_bool_exp
  ): agency_jobs_aggregate!

  """fetch data from the table: "agency_jobs" using primary key columns"""
  agency_jobs_by_pk(id: uuid!): agency_jobs

  """
  fetch data from the table in a streaming manner: "agency_jobs"
  """
  agency_jobs_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [agency_jobs_stream_cursor_input]!

    """filter the rows returned"""
    where: agency_jobs_bool_exp
  ): [agency_jobs!]!

  """
  fetch data from the table: "agency_kyb_audit_log"
  """
  agency_kyb_audit_log(
    """distinct select on columns"""
    distinct_on: [agency_kyb_audit_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_kyb_audit_log_order_by!]

    """filter the rows returned"""
    where: agency_kyb_audit_log_bool_exp
  ): [agency_kyb_audit_log!]!

  """
  fetch aggregated fields from the table: "agency_kyb_audit_log"
  """
  agency_kyb_audit_log_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_kyb_audit_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_kyb_audit_log_order_by!]

    """filter the rows returned"""
    where: agency_kyb_audit_log_bool_exp
  ): agency_kyb_audit_log_aggregate!

  """
  fetch data from the table: "agency_kyb_audit_log" using primary key columns
  """
  agency_kyb_audit_log_by_pk(id: uuid!): agency_kyb_audit_log

  """
  fetch data from the table in a streaming manner: "agency_kyb_audit_log"
  """
  agency_kyb_audit_log_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [agency_kyb_audit_log_stream_cursor_input]!

    """filter the rows returned"""
    where: agency_kyb_audit_log_bool_exp
  ): [agency_kyb_audit_log!]!

  """An array relationship"""
  agency_kyb_documents(
    """distinct select on columns"""
    distinct_on: [agency_kyb_documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_kyb_documents_order_by!]

    """filter the rows returned"""
    where: agency_kyb_documents_bool_exp
  ): [agency_kyb_documents!]!

  """An aggregate relationship"""
  agency_kyb_documents_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_kyb_documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_kyb_documents_order_by!]

    """filter the rows returned"""
    where: agency_kyb_documents_bool_exp
  ): agency_kyb_documents_aggregate!

  """
  fetch data from the table: "agency_kyb_documents" using primary key columns
  """
  agency_kyb_documents_by_pk(id: uuid!): agency_kyb_documents

  """
  fetch data from the table in a streaming manner: "agency_kyb_documents"
  """
  agency_kyb_documents_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [agency_kyb_documents_stream_cursor_input]!

    """filter the rows returned"""
    where: agency_kyb_documents_bool_exp
  ): [agency_kyb_documents!]!

  """
  fetch data from the table: "agency_kyb_verification"
  """
  agency_kyb_verification(
    """distinct select on columns"""
    distinct_on: [agency_kyb_verification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_kyb_verification_order_by!]

    """filter the rows returned"""
    where: agency_kyb_verification_bool_exp
  ): [agency_kyb_verification!]!

  """
  fetch aggregated fields from the table: "agency_kyb_verification"
  """
  agency_kyb_verification_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_kyb_verification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_kyb_verification_order_by!]

    """filter the rows returned"""
    where: agency_kyb_verification_bool_exp
  ): agency_kyb_verification_aggregate!

  """
  fetch data from the table: "agency_kyb_verification" using primary key columns
  """
  agency_kyb_verification_by_pk(id: uuid!): agency_kyb_verification

  """
  fetch data from the table in a streaming manner: "agency_kyb_verification"
  """
  agency_kyb_verification_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [agency_kyb_verification_stream_cursor_input]!

    """filter the rows returned"""
    where: agency_kyb_verification_bool_exp
  ): [agency_kyb_verification!]!

  """
  fetch data from the table: "agency_payment_failures"
  """
  agency_payment_failures(
    """distinct select on columns"""
    distinct_on: [agency_payment_failures_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_payment_failures_order_by!]

    """filter the rows returned"""
    where: agency_payment_failures_bool_exp
  ): [agency_payment_failures!]!

  """
  fetch aggregated fields from the table: "agency_payment_failures"
  """
  agency_payment_failures_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_payment_failures_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_payment_failures_order_by!]

    """filter the rows returned"""
    where: agency_payment_failures_bool_exp
  ): agency_payment_failures_aggregate!

  """
  fetch data from the table: "agency_payment_failures" using primary key columns
  """
  agency_payment_failures_by_pk(id: uuid!): agency_payment_failures

  """
  fetch data from the table in a streaming manner: "agency_payment_failures"
  """
  agency_payment_failures_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [agency_payment_failures_stream_cursor_input]!

    """filter the rows returned"""
    where: agency_payment_failures_bool_exp
  ): [agency_payment_failures!]!

  """
  fetch data from the table: "agency_payouts"
  """
  agency_payouts(
    """distinct select on columns"""
    distinct_on: [agency_payouts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_payouts_order_by!]

    """filter the rows returned"""
    where: agency_payouts_bool_exp
  ): [agency_payouts!]!

  """
  fetch aggregated fields from the table: "agency_payouts"
  """
  agency_payouts_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_payouts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_payouts_order_by!]

    """filter the rows returned"""
    where: agency_payouts_bool_exp
  ): agency_payouts_aggregate!

  """fetch data from the table: "agency_payouts" using primary key columns"""
  agency_payouts_by_pk(id: uuid!): agency_payouts

  """
  fetch data from the table in a streaming manner: "agency_payouts"
  """
  agency_payouts_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [agency_payouts_stream_cursor_input]!

    """filter the rows returned"""
    where: agency_payouts_bool_exp
  ): [agency_payouts!]!

  """An array relationship"""
  agency_placements(
    """distinct select on columns"""
    distinct_on: [agency_placements_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_placements_order_by!]

    """filter the rows returned"""
    where: agency_placements_bool_exp
  ): [agency_placements!]!

  """An aggregate relationship"""
  agency_placements_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_placements_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_placements_order_by!]

    """filter the rows returned"""
    where: agency_placements_bool_exp
  ): agency_placements_aggregate!

  """
  fetch data from the table: "agency_placements" using primary key columns
  """
  agency_placements_by_pk(id: uuid!): agency_placements

  """
  fetch data from the table in a streaming manner: "agency_placements"
  """
  agency_placements_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [agency_placements_stream_cursor_input]!

    """filter the rows returned"""
    where: agency_placements_bool_exp
  ): [agency_placements!]!

  """
  fetch data from the table: "agency_profiles"
  """
  agency_profiles(
    """distinct select on columns"""
    distinct_on: [agency_profiles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_profiles_order_by!]

    """filter the rows returned"""
    where: agency_profiles_bool_exp
  ): [agency_profiles!]!

  """
  fetch aggregated fields from the table: "agency_profiles"
  """
  agency_profiles_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_profiles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_profiles_order_by!]

    """filter the rows returned"""
    where: agency_profiles_bool_exp
  ): agency_profiles_aggregate!

  """fetch data from the table: "agency_profiles" using primary key columns"""
  agency_profiles_by_pk(id: String!): agency_profiles

  """
  fetch data from the table in a streaming manner: "agency_profiles"
  """
  agency_profiles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [agency_profiles_stream_cursor_input]!

    """filter the rows returned"""
    where: agency_profiles_bool_exp
  ): [agency_profiles!]!

  """
  fetch data from the table: "agency_tasks"
  """
  agency_tasks(
    """distinct select on columns"""
    distinct_on: [agency_tasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_tasks_order_by!]

    """filter the rows returned"""
    where: agency_tasks_bool_exp
  ): [agency_tasks!]!

  """
  fetch aggregated fields from the table: "agency_tasks"
  """
  agency_tasks_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_tasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_tasks_order_by!]

    """filter the rows returned"""
    where: agency_tasks_bool_exp
  ): agency_tasks_aggregate!

  """fetch data from the table: "agency_tasks" using primary key columns"""
  agency_tasks_by_pk(id: uuid!): agency_tasks

  """
  fetch data from the table in a streaming manner: "agency_tasks"
  """
  agency_tasks_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [agency_tasks_stream_cursor_input]!

    """filter the rows returned"""
    where: agency_tasks_bool_exp
  ): [agency_tasks!]!

  """
  fetch data from the table: "agency_team_members"
  """
  agency_team_members(
    """distinct select on columns"""
    distinct_on: [agency_team_members_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_team_members_order_by!]

    """filter the rows returned"""
    where: agency_team_members_bool_exp
  ): [agency_team_members!]!

  """
  fetch aggregated fields from the table: "agency_team_members"
  """
  agency_team_members_aggregate(
    """distinct select on columns"""
    distinct_on: [agency_team_members_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agency_team_members_order_by!]

    """filter the rows returned"""
    where: agency_team_members_bool_exp
  ): agency_team_members_aggregate!

  """
  fetch data from the table: "agency_team_members" using primary key columns
  """
  agency_team_members_by_pk(id: uuid!): agency_team_members

  """
  fetch data from the table in a streaming manner: "agency_team_members"
  """
  agency_team_members_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [agency_team_members_stream_cursor_input]!

    """filter the rows returned"""
    where: agency_team_members_bool_exp
  ): [agency_team_members!]!

  """
  fetch data from the table: "analytics_cache"
  """
  analytics_cache(
    """distinct select on columns"""
    distinct_on: [analytics_cache_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [analytics_cache_order_by!]

    """filter the rows returned"""
    where: analytics_cache_bool_exp
  ): [analytics_cache!]!

  """
  fetch aggregated fields from the table: "analytics_cache"
  """
  analytics_cache_aggregate(
    """distinct select on columns"""
    distinct_on: [analytics_cache_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [analytics_cache_order_by!]

    """filter the rows returned"""
    where: analytics_cache_bool_exp
  ): analytics_cache_aggregate!

  """fetch data from the table: "analytics_cache" using primary key columns"""
  analytics_cache_by_pk(id: uuid!): analytics_cache

  """
  fetch data from the table in a streaming manner: "analytics_cache"
  """
  analytics_cache_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [analytics_cache_stream_cursor_input]!

    """filter the rows returned"""
    where: analytics_cache_bool_exp
  ): [analytics_cache!]!

  """
  fetch data from the table: "announcement_views"
  """
  announcement_views(
    """distinct select on columns"""
    distinct_on: [announcement_views_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [announcement_views_order_by!]

    """filter the rows returned"""
    where: announcement_views_bool_exp
  ): [announcement_views!]!

  """
  fetch aggregated fields from the table: "announcement_views"
  """
  announcement_views_aggregate(
    """distinct select on columns"""
    distinct_on: [announcement_views_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [announcement_views_order_by!]

    """filter the rows returned"""
    where: announcement_views_bool_exp
  ): announcement_views_aggregate!

  """
  fetch data from the table: "announcement_views" using primary key columns
  """
  announcement_views_by_pk(id: uuid!): announcement_views

  """
  fetch data from the table in a streaming manner: "announcement_views"
  """
  announcement_views_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [announcement_views_stream_cursor_input]!

    """filter the rows returned"""
    where: announcement_views_bool_exp
  ): [announcement_views!]!

  """An array relationship"""
  applications(
    """distinct select on columns"""
    distinct_on: [applications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [applications_order_by!]

    """filter the rows returned"""
    where: applications_bool_exp
  ): [applications!]!

  """An aggregate relationship"""
  applications_aggregate(
    """distinct select on columns"""
    distinct_on: [applications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [applications_order_by!]

    """filter the rows returned"""
    where: applications_bool_exp
  ): applications_aggregate!

  """fetch data from the table: "applications" using primary key columns"""
  applications_by_pk(id: uuid!): applications

  """
  fetch data from the table in a streaming manner: "applications"
  """
  applications_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [applications_stream_cursor_input]!

    """filter the rows returned"""
    where: applications_bool_exp
  ): [applications!]!

  """
  fetch data from the table: "audit_logs"
  """
  audit_logs(
    """distinct select on columns"""
    distinct_on: [audit_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [audit_logs_order_by!]

    """filter the rows returned"""
    where: audit_logs_bool_exp
  ): [audit_logs!]!

  """
  fetch aggregated fields from the table: "audit_logs"
  """
  audit_logs_aggregate(
    """distinct select on columns"""
    distinct_on: [audit_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [audit_logs_order_by!]

    """filter the rows returned"""
    where: audit_logs_bool_exp
  ): audit_logs_aggregate!

  """fetch data from the table: "audit_logs" using primary key columns"""
  audit_logs_by_pk(id: uuid!): audit_logs

  """
  fetch data from the table in a streaming manner: "audit_logs"
  """
  audit_logs_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [audit_logs_stream_cursor_input]!

    """filter the rows returned"""
    where: audit_logs_bool_exp
  ): [audit_logs!]!

  """
  fetch data from the table: "auth.audit_log_entries"
  """
  auth_audit_log_entries(
    """distinct select on columns"""
    distinct_on: [auth_audit_log_entries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_audit_log_entries_order_by!]

    """filter the rows returned"""
    where: auth_audit_log_entries_bool_exp
  ): [auth_audit_log_entries!]!

  """
  fetch aggregated fields from the table: "auth.audit_log_entries"
  """
  auth_audit_log_entries_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_audit_log_entries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_audit_log_entries_order_by!]

    """filter the rows returned"""
    where: auth_audit_log_entries_bool_exp
  ): auth_audit_log_entries_aggregate!

  """
  fetch data from the table: "auth.audit_log_entries" using primary key columns
  """
  auth_audit_log_entries_by_pk(id: uuid!): auth_audit_log_entries

  """
  fetch data from the table in a streaming manner: "auth.audit_log_entries"
  """
  auth_audit_log_entries_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [auth_audit_log_entries_stream_cursor_input]!

    """filter the rows returned"""
    where: auth_audit_log_entries_bool_exp
  ): [auth_audit_log_entries!]!

  """
  fetch data from the table: "auth.flow_state"
  """
  auth_flow_state(
    """distinct select on columns"""
    distinct_on: [auth_flow_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_flow_state_order_by!]

    """filter the rows returned"""
    where: auth_flow_state_bool_exp
  ): [auth_flow_state!]!

  """
  fetch aggregated fields from the table: "auth.flow_state"
  """
  auth_flow_state_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_flow_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_flow_state_order_by!]

    """filter the rows returned"""
    where: auth_flow_state_bool_exp
  ): auth_flow_state_aggregate!

  """fetch data from the table: "auth.flow_state" using primary key columns"""
  auth_flow_state_by_pk(id: uuid!): auth_flow_state

  """
  fetch data from the table in a streaming manner: "auth.flow_state"
  """
  auth_flow_state_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [auth_flow_state_stream_cursor_input]!

    """filter the rows returned"""
    where: auth_flow_state_bool_exp
  ): [auth_flow_state!]!

  """
  fetch data from the table: "auth.identities"
  """
  auth_identities(
    """distinct select on columns"""
    distinct_on: [auth_identities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_identities_order_by!]

    """filter the rows returned"""
    where: auth_identities_bool_exp
  ): [auth_identities!]!

  """
  fetch aggregated fields from the table: "auth.identities"
  """
  auth_identities_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_identities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_identities_order_by!]

    """filter the rows returned"""
    where: auth_identities_bool_exp
  ): auth_identities_aggregate!

  """fetch data from the table: "auth.identities" using primary key columns"""
  auth_identities_by_pk(id: uuid!): auth_identities

  """
  fetch data from the table in a streaming manner: "auth.identities"
  """
  auth_identities_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [auth_identities_stream_cursor_input]!

    """filter the rows returned"""
    where: auth_identities_bool_exp
  ): [auth_identities!]!

  """
  fetch data from the table: "auth.instances"
  """
  auth_instances(
    """distinct select on columns"""
    distinct_on: [auth_instances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_instances_order_by!]

    """filter the rows returned"""
    where: auth_instances_bool_exp
  ): [auth_instances!]!

  """
  fetch aggregated fields from the table: "auth.instances"
  """
  auth_instances_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_instances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_instances_order_by!]

    """filter the rows returned"""
    where: auth_instances_bool_exp
  ): auth_instances_aggregate!

  """fetch data from the table: "auth.instances" using primary key columns"""
  auth_instances_by_pk(id: uuid!): auth_instances

  """
  fetch data from the table in a streaming manner: "auth.instances"
  """
  auth_instances_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [auth_instances_stream_cursor_input]!

    """filter the rows returned"""
    where: auth_instances_bool_exp
  ): [auth_instances!]!

  """
  fetch data from the table: "auth.mfa_amr_claims"
  """
  auth_mfa_amr_claims(
    """distinct select on columns"""
    distinct_on: [auth_mfa_amr_claims_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_mfa_amr_claims_order_by!]

    """filter the rows returned"""
    where: auth_mfa_amr_claims_bool_exp
  ): [auth_mfa_amr_claims!]!

  """
  fetch aggregated fields from the table: "auth.mfa_amr_claims"
  """
  auth_mfa_amr_claims_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_mfa_amr_claims_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_mfa_amr_claims_order_by!]

    """filter the rows returned"""
    where: auth_mfa_amr_claims_bool_exp
  ): auth_mfa_amr_claims_aggregate!

  """
  fetch data from the table: "auth.mfa_amr_claims" using primary key columns
  """
  auth_mfa_amr_claims_by_pk(id: uuid!): auth_mfa_amr_claims

  """
  fetch data from the table in a streaming manner: "auth.mfa_amr_claims"
  """
  auth_mfa_amr_claims_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [auth_mfa_amr_claims_stream_cursor_input]!

    """filter the rows returned"""
    where: auth_mfa_amr_claims_bool_exp
  ): [auth_mfa_amr_claims!]!

  """
  fetch data from the table: "auth.mfa_challenges"
  """
  auth_mfa_challenges(
    """distinct select on columns"""
    distinct_on: [auth_mfa_challenges_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_mfa_challenges_order_by!]

    """filter the rows returned"""
    where: auth_mfa_challenges_bool_exp
  ): [auth_mfa_challenges!]!

  """
  fetch aggregated fields from the table: "auth.mfa_challenges"
  """
  auth_mfa_challenges_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_mfa_challenges_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_mfa_challenges_order_by!]

    """filter the rows returned"""
    where: auth_mfa_challenges_bool_exp
  ): auth_mfa_challenges_aggregate!

  """
  fetch data from the table: "auth.mfa_challenges" using primary key columns
  """
  auth_mfa_challenges_by_pk(id: uuid!): auth_mfa_challenges

  """
  fetch data from the table in a streaming manner: "auth.mfa_challenges"
  """
  auth_mfa_challenges_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [auth_mfa_challenges_stream_cursor_input]!

    """filter the rows returned"""
    where: auth_mfa_challenges_bool_exp
  ): [auth_mfa_challenges!]!

  """
  fetch data from the table: "auth.mfa_factors"
  """
  auth_mfa_factors(
    """distinct select on columns"""
    distinct_on: [auth_mfa_factors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_mfa_factors_order_by!]

    """filter the rows returned"""
    where: auth_mfa_factors_bool_exp
  ): [auth_mfa_factors!]!

  """
  fetch aggregated fields from the table: "auth.mfa_factors"
  """
  auth_mfa_factors_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_mfa_factors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_mfa_factors_order_by!]

    """filter the rows returned"""
    where: auth_mfa_factors_bool_exp
  ): auth_mfa_factors_aggregate!

  """
  fetch data from the table: "auth.mfa_factors" using primary key columns
  """
  auth_mfa_factors_by_pk(id: uuid!): auth_mfa_factors

  """
  fetch data from the table in a streaming manner: "auth.mfa_factors"
  """
  auth_mfa_factors_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [auth_mfa_factors_stream_cursor_input]!

    """filter the rows returned"""
    where: auth_mfa_factors_bool_exp
  ): [auth_mfa_factors!]!

  """
  fetch data from the table: "auth.oauth_authorizations"
  """
  auth_oauth_authorizations(
    """distinct select on columns"""
    distinct_on: [auth_oauth_authorizations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_oauth_authorizations_order_by!]

    """filter the rows returned"""
    where: auth_oauth_authorizations_bool_exp
  ): [auth_oauth_authorizations!]!

  """
  fetch aggregated fields from the table: "auth.oauth_authorizations"
  """
  auth_oauth_authorizations_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_oauth_authorizations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_oauth_authorizations_order_by!]

    """filter the rows returned"""
    where: auth_oauth_authorizations_bool_exp
  ): auth_oauth_authorizations_aggregate!

  """
  fetch data from the table: "auth.oauth_authorizations" using primary key columns
  """
  auth_oauth_authorizations_by_pk(id: uuid!): auth_oauth_authorizations

  """
  fetch data from the table in a streaming manner: "auth.oauth_authorizations"
  """
  auth_oauth_authorizations_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [auth_oauth_authorizations_stream_cursor_input]!

    """filter the rows returned"""
    where: auth_oauth_authorizations_bool_exp
  ): [auth_oauth_authorizations!]!

  """
  fetch data from the table: "auth.oauth_clients"
  """
  auth_oauth_clients(
    """distinct select on columns"""
    distinct_on: [auth_oauth_clients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_oauth_clients_order_by!]

    """filter the rows returned"""
    where: auth_oauth_clients_bool_exp
  ): [auth_oauth_clients!]!

  """
  fetch aggregated fields from the table: "auth.oauth_clients"
  """
  auth_oauth_clients_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_oauth_clients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_oauth_clients_order_by!]

    """filter the rows returned"""
    where: auth_oauth_clients_bool_exp
  ): auth_oauth_clients_aggregate!

  """
  fetch data from the table: "auth.oauth_clients" using primary key columns
  """
  auth_oauth_clients_by_pk(id: uuid!): auth_oauth_clients

  """
  fetch data from the table in a streaming manner: "auth.oauth_clients"
  """
  auth_oauth_clients_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [auth_oauth_clients_stream_cursor_input]!

    """filter the rows returned"""
    where: auth_oauth_clients_bool_exp
  ): [auth_oauth_clients!]!

  """
  fetch data from the table: "auth.oauth_consents"
  """
  auth_oauth_consents(
    """distinct select on columns"""
    distinct_on: [auth_oauth_consents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_oauth_consents_order_by!]

    """filter the rows returned"""
    where: auth_oauth_consents_bool_exp
  ): [auth_oauth_consents!]!

  """
  fetch aggregated fields from the table: "auth.oauth_consents"
  """
  auth_oauth_consents_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_oauth_consents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_oauth_consents_order_by!]

    """filter the rows returned"""
    where: auth_oauth_consents_bool_exp
  ): auth_oauth_consents_aggregate!

  """
  fetch data from the table: "auth.oauth_consents" using primary key columns
  """
  auth_oauth_consents_by_pk(id: uuid!): auth_oauth_consents

  """
  fetch data from the table in a streaming manner: "auth.oauth_consents"
  """
  auth_oauth_consents_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [auth_oauth_consents_stream_cursor_input]!

    """filter the rows returned"""
    where: auth_oauth_consents_bool_exp
  ): [auth_oauth_consents!]!

  """
  fetch data from the table: "auth.one_time_tokens"
  """
  auth_one_time_tokens(
    """distinct select on columns"""
    distinct_on: [auth_one_time_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_one_time_tokens_order_by!]

    """filter the rows returned"""
    where: auth_one_time_tokens_bool_exp
  ): [auth_one_time_tokens!]!

  """
  fetch aggregated fields from the table: "auth.one_time_tokens"
  """
  auth_one_time_tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_one_time_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_one_time_tokens_order_by!]

    """filter the rows returned"""
    where: auth_one_time_tokens_bool_exp
  ): auth_one_time_tokens_aggregate!

  """
  fetch data from the table: "auth.one_time_tokens" using primary key columns
  """
  auth_one_time_tokens_by_pk(id: uuid!): auth_one_time_tokens

  """
  fetch data from the table in a streaming manner: "auth.one_time_tokens"
  """
  auth_one_time_tokens_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [auth_one_time_tokens_stream_cursor_input]!

    """filter the rows returned"""
    where: auth_one_time_tokens_bool_exp
  ): [auth_one_time_tokens!]!

  """
  fetch data from the table: "auth.refresh_tokens"
  """
  auth_refresh_tokens(
    """distinct select on columns"""
    distinct_on: [auth_refresh_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_refresh_tokens_order_by!]

    """filter the rows returned"""
    where: auth_refresh_tokens_bool_exp
  ): [auth_refresh_tokens!]!

  """
  fetch aggregated fields from the table: "auth.refresh_tokens"
  """
  auth_refresh_tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_refresh_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_refresh_tokens_order_by!]

    """filter the rows returned"""
    where: auth_refresh_tokens_bool_exp
  ): auth_refresh_tokens_aggregate!

  """
  fetch data from the table: "auth.refresh_tokens" using primary key columns
  """
  auth_refresh_tokens_by_pk(id: bigint!): auth_refresh_tokens

  """
  fetch data from the table in a streaming manner: "auth.refresh_tokens"
  """
  auth_refresh_tokens_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [auth_refresh_tokens_stream_cursor_input]!

    """filter the rows returned"""
    where: auth_refresh_tokens_bool_exp
  ): [auth_refresh_tokens!]!

  """
  fetch data from the table: "auth.saml_providers"
  """
  auth_saml_providers(
    """distinct select on columns"""
    distinct_on: [auth_saml_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_saml_providers_order_by!]

    """filter the rows returned"""
    where: auth_saml_providers_bool_exp
  ): [auth_saml_providers!]!

  """
  fetch aggregated fields from the table: "auth.saml_providers"
  """
  auth_saml_providers_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_saml_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_saml_providers_order_by!]

    """filter the rows returned"""
    where: auth_saml_providers_bool_exp
  ): auth_saml_providers_aggregate!

  """
  fetch data from the table: "auth.saml_providers" using primary key columns
  """
  auth_saml_providers_by_pk(id: uuid!): auth_saml_providers

  """
  fetch data from the table in a streaming manner: "auth.saml_providers"
  """
  auth_saml_providers_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [auth_saml_providers_stream_cursor_input]!

    """filter the rows returned"""
    where: auth_saml_providers_bool_exp
  ): [auth_saml_providers!]!

  """
  fetch data from the table: "auth.saml_relay_states"
  """
  auth_saml_relay_states(
    """distinct select on columns"""
    distinct_on: [auth_saml_relay_states_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_saml_relay_states_order_by!]

    """filter the rows returned"""
    where: auth_saml_relay_states_bool_exp
  ): [auth_saml_relay_states!]!

  """
  fetch aggregated fields from the table: "auth.saml_relay_states"
  """
  auth_saml_relay_states_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_saml_relay_states_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_saml_relay_states_order_by!]

    """filter the rows returned"""
    where: auth_saml_relay_states_bool_exp
  ): auth_saml_relay_states_aggregate!

  """
  fetch data from the table: "auth.saml_relay_states" using primary key columns
  """
  auth_saml_relay_states_by_pk(id: uuid!): auth_saml_relay_states

  """
  fetch data from the table in a streaming manner: "auth.saml_relay_states"
  """
  auth_saml_relay_states_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [auth_saml_relay_states_stream_cursor_input]!

    """filter the rows returned"""
    where: auth_saml_relay_states_bool_exp
  ): [auth_saml_relay_states!]!

  """
  fetch data from the table: "auth.sessions"
  """
  auth_sessions(
    """distinct select on columns"""
    distinct_on: [auth_sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_sessions_order_by!]

    """filter the rows returned"""
    where: auth_sessions_bool_exp
  ): [auth_sessions!]!

  """
  fetch aggregated fields from the table: "auth.sessions"
  """
  auth_sessions_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_sessions_order_by!]

    """filter the rows returned"""
    where: auth_sessions_bool_exp
  ): auth_sessions_aggregate!

  """fetch data from the table: "auth.sessions" using primary key columns"""
  auth_sessions_by_pk(id: uuid!): auth_sessions

  """
  fetch data from the table in a streaming manner: "auth.sessions"
  """
  auth_sessions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [auth_sessions_stream_cursor_input]!

    """filter the rows returned"""
    where: auth_sessions_bool_exp
  ): [auth_sessions!]!

  """
  fetch data from the table: "auth.sso_domains"
  """
  auth_sso_domains(
    """distinct select on columns"""
    distinct_on: [auth_sso_domains_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_sso_domains_order_by!]

    """filter the rows returned"""
    where: auth_sso_domains_bool_exp
  ): [auth_sso_domains!]!

  """
  fetch aggregated fields from the table: "auth.sso_domains"
  """
  auth_sso_domains_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_sso_domains_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_sso_domains_order_by!]

    """filter the rows returned"""
    where: auth_sso_domains_bool_exp
  ): auth_sso_domains_aggregate!

  """
  fetch data from the table: "auth.sso_domains" using primary key columns
  """
  auth_sso_domains_by_pk(id: uuid!): auth_sso_domains

  """
  fetch data from the table in a streaming manner: "auth.sso_domains"
  """
  auth_sso_domains_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [auth_sso_domains_stream_cursor_input]!

    """filter the rows returned"""
    where: auth_sso_domains_bool_exp
  ): [auth_sso_domains!]!

  """
  fetch data from the table: "auth.sso_providers"
  """
  auth_sso_providers(
    """distinct select on columns"""
    distinct_on: [auth_sso_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_sso_providers_order_by!]

    """filter the rows returned"""
    where: auth_sso_providers_bool_exp
  ): [auth_sso_providers!]!

  """
  fetch aggregated fields from the table: "auth.sso_providers"
  """
  auth_sso_providers_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_sso_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_sso_providers_order_by!]

    """filter the rows returned"""
    where: auth_sso_providers_bool_exp
  ): auth_sso_providers_aggregate!

  """
  fetch data from the table: "auth.sso_providers" using primary key columns
  """
  auth_sso_providers_by_pk(id: uuid!): auth_sso_providers

  """
  fetch data from the table in a streaming manner: "auth.sso_providers"
  """
  auth_sso_providers_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [auth_sso_providers_stream_cursor_input]!

    """filter the rows returned"""
    where: auth_sso_providers_bool_exp
  ): [auth_sso_providers!]!

  """
  fetch data from the table: "auth.users"
  """
  auth_users(
    """distinct select on columns"""
    distinct_on: [auth_users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_users_order_by!]

    """filter the rows returned"""
    where: auth_users_bool_exp
  ): [auth_users!]!

  """
  fetch aggregated fields from the table: "auth.users"
  """
  auth_users_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_users_order_by!]

    """filter the rows returned"""
    where: auth_users_bool_exp
  ): auth_users_aggregate!

  """fetch data from the table: "auth.users" using primary key columns"""
  auth_users_by_pk(id: uuid!): auth_users

  """
  fetch data from the table in a streaming manner: "auth.users"
  """
  auth_users_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [auth_users_stream_cursor_input]!

    """filter the rows returned"""
    where: auth_users_bool_exp
  ): [auth_users!]!

  """
  fetch data from the table: "booking_requests"
  """
  booking_requests(
    """distinct select on columns"""
    distinct_on: [booking_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_requests_order_by!]

    """filter the rows returned"""
    where: booking_requests_bool_exp
  ): [booking_requests!]!

  """
  fetch aggregated fields from the table: "booking_requests"
  """
  booking_requests_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_requests_order_by!]

    """filter the rows returned"""
    where: booking_requests_bool_exp
  ): booking_requests_aggregate!

  """
  fetch data from the table: "booking_requests" using primary key columns
  """
  booking_requests_by_pk(id: uuid!): booking_requests

  """
  fetch data from the table in a streaming manner: "booking_requests"
  """
  booking_requests_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [booking_requests_stream_cursor_input]!

    """filter the rows returned"""
    where: booking_requests_bool_exp
  ): [booking_requests!]!

  """An array relationship"""
  bookings(
    """distinct select on columns"""
    distinct_on: [bookings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookings_order_by!]

    """filter the rows returned"""
    where: bookings_bool_exp
  ): [bookings!]!

  """An aggregate relationship"""
  bookings_aggregate(
    """distinct select on columns"""
    distinct_on: [bookings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookings_order_by!]

    """filter the rows returned"""
    where: bookings_bool_exp
  ): bookings_aggregate!

  """fetch data from the table: "bookings" using primary key columns"""
  bookings_by_pk(id: uuid!): bookings

  """
  fetch data from the table in a streaming manner: "bookings"
  """
  bookings_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [bookings_stream_cursor_input]!

    """filter the rows returned"""
    where: bookings_bool_exp
  ): [bookings!]!

  """
  fetch data from the table: "calendar_events"
  """
  calendar_events(
    """distinct select on columns"""
    distinct_on: [calendar_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [calendar_events_order_by!]

    """filter the rows returned"""
    where: calendar_events_bool_exp
  ): [calendar_events!]!

  """
  fetch aggregated fields from the table: "calendar_events"
  """
  calendar_events_aggregate(
    """distinct select on columns"""
    distinct_on: [calendar_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [calendar_events_order_by!]

    """filter the rows returned"""
    where: calendar_events_bool_exp
  ): calendar_events_aggregate!

  """fetch data from the table: "calendar_events" using primary key columns"""
  calendar_events_by_pk(id: uuid!): calendar_events

  """
  fetch data from the table in a streaming manner: "calendar_events"
  """
  calendar_events_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [calendar_events_stream_cursor_input]!

    """filter the rows returned"""
    where: calendar_events_bool_exp
  ): [calendar_events!]!

  """An array relationship"""
  client_satisfaction_ratings(
    """distinct select on columns"""
    distinct_on: [client_satisfaction_ratings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_satisfaction_ratings_order_by!]

    """filter the rows returned"""
    where: client_satisfaction_ratings_bool_exp
  ): [client_satisfaction_ratings!]!

  """An aggregate relationship"""
  client_satisfaction_ratings_aggregate(
    """distinct select on columns"""
    distinct_on: [client_satisfaction_ratings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_satisfaction_ratings_order_by!]

    """filter the rows returned"""
    where: client_satisfaction_ratings_bool_exp
  ): client_satisfaction_ratings_aggregate!

  """
  fetch data from the table: "client_satisfaction_ratings" using primary key columns
  """
  client_satisfaction_ratings_by_pk(id: uuid!): client_satisfaction_ratings

  """
  fetch data from the table in a streaming manner: "client_satisfaction_ratings"
  """
  client_satisfaction_ratings_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [client_satisfaction_ratings_stream_cursor_input]!

    """filter the rows returned"""
    where: client_satisfaction_ratings_bool_exp
  ): [client_satisfaction_ratings!]!

  """
  fetch data from the table: "compliance_categories"
  """
  compliance_categories(
    """distinct select on columns"""
    distinct_on: [compliance_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [compliance_categories_order_by!]

    """filter the rows returned"""
    where: compliance_categories_bool_exp
  ): [compliance_categories!]!

  """
  fetch aggregated fields from the table: "compliance_categories"
  """
  compliance_categories_aggregate(
    """distinct select on columns"""
    distinct_on: [compliance_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [compliance_categories_order_by!]

    """filter the rows returned"""
    where: compliance_categories_bool_exp
  ): compliance_categories_aggregate!

  """
  fetch data from the table: "compliance_categories" using primary key columns
  """
  compliance_categories_by_pk(id: uuid!): compliance_categories

  """
  fetch data from the table in a streaming manner: "compliance_categories"
  """
  compliance_categories_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [compliance_categories_stream_cursor_input]!

    """filter the rows returned"""
    where: compliance_categories_bool_exp
  ): [compliance_categories!]!

  """An array relationship"""
  compliance_items(
    """distinct select on columns"""
    distinct_on: [compliance_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [compliance_items_order_by!]

    """filter the rows returned"""
    where: compliance_items_bool_exp
  ): [compliance_items!]!

  """An aggregate relationship"""
  compliance_items_aggregate(
    """distinct select on columns"""
    distinct_on: [compliance_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [compliance_items_order_by!]

    """filter the rows returned"""
    where: compliance_items_bool_exp
  ): compliance_items_aggregate!

  """
  fetch data from the table: "compliance_items" using primary key columns
  """
  compliance_items_by_pk(id: uuid!): compliance_items

  """
  fetch data from the table in a streaming manner: "compliance_items"
  """
  compliance_items_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [compliance_items_stream_cursor_input]!

    """filter the rows returned"""
    where: compliance_items_bool_exp
  ): [compliance_items!]!

  """An array relationship"""
  contact_fees(
    """distinct select on columns"""
    distinct_on: [contact_fees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [contact_fees_order_by!]

    """filter the rows returned"""
    where: contact_fees_bool_exp
  ): [contact_fees!]!

  """An aggregate relationship"""
  contact_fees_aggregate(
    """distinct select on columns"""
    distinct_on: [contact_fees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [contact_fees_order_by!]

    """filter the rows returned"""
    where: contact_fees_bool_exp
  ): contact_fees_aggregate!

  """fetch data from the table: "contact_fees" using primary key columns"""
  contact_fees_by_pk(id: uuid!): contact_fees

  """
  fetch data from the table in a streaming manner: "contact_fees"
  """
  contact_fees_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [contact_fees_stream_cursor_input]!

    """filter the rows returned"""
    where: contact_fees_bool_exp
  ): [contact_fees!]!

  """An array relationship"""
  content_moderation_flags(
    """distinct select on columns"""
    distinct_on: [content_moderation_flags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [content_moderation_flags_order_by!]

    """filter the rows returned"""
    where: content_moderation_flags_bool_exp
  ): [content_moderation_flags!]!

  """An aggregate relationship"""
  content_moderation_flags_aggregate(
    """distinct select on columns"""
    distinct_on: [content_moderation_flags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [content_moderation_flags_order_by!]

    """filter the rows returned"""
    where: content_moderation_flags_bool_exp
  ): content_moderation_flags_aggregate!

  """
  fetch data from the table: "content_moderation_flags" using primary key columns
  """
  content_moderation_flags_by_pk(id: uuid!): content_moderation_flags

  """
  fetch data from the table in a streaming manner: "content_moderation_flags"
  """
  content_moderation_flags_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [content_moderation_flags_stream_cursor_input]!

    """filter the rows returned"""
    where: content_moderation_flags_bool_exp
  ): [content_moderation_flags!]!

  """
  fetch data from the table: "conversations"
  """
  conversations(
    """distinct select on columns"""
    distinct_on: [conversations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversations_order_by!]

    """filter the rows returned"""
    where: conversations_bool_exp
  ): [conversations!]!

  """
  fetch aggregated fields from the table: "conversations"
  """
  conversations_aggregate(
    """distinct select on columns"""
    distinct_on: [conversations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversations_order_by!]

    """filter the rows returned"""
    where: conversations_bool_exp
  ): conversations_aggregate!

  """fetch data from the table: "conversations" using primary key columns"""
  conversations_by_pk(id: uuid!): conversations

  """
  fetch data from the table in a streaming manner: "conversations"
  """
  conversations_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [conversations_stream_cursor_input]!

    """filter the rows returned"""
    where: conversations_bool_exp
  ): [conversations!]!

  """An array relationship"""
  conversion_events(
    """distinct select on columns"""
    distinct_on: [conversion_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversion_events_order_by!]

    """filter the rows returned"""
    where: conversion_events_bool_exp
  ): [conversion_events!]!

  """An aggregate relationship"""
  conversion_events_aggregate(
    """distinct select on columns"""
    distinct_on: [conversion_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversion_events_order_by!]

    """filter the rows returned"""
    where: conversion_events_bool_exp
  ): conversion_events_aggregate!

  """
  fetch data from the table: "conversion_events" using primary key columns
  """
  conversion_events_by_pk(id: uuid!): conversion_events

  """
  fetch data from the table in a streaming manner: "conversion_events"
  """
  conversion_events_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [conversion_events_stream_cursor_input]!

    """filter the rows returned"""
    where: conversion_events_bool_exp
  ): [conversion_events!]!

  """
  fetch data from the table: "countries"
  """
  countries(
    """distinct select on columns"""
    distinct_on: [countries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [countries_order_by!]

    """filter the rows returned"""
    where: countries_bool_exp
  ): [countries!]!

  """
  fetch aggregated fields from the table: "countries"
  """
  countries_aggregate(
    """distinct select on columns"""
    distinct_on: [countries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [countries_order_by!]

    """filter the rows returned"""
    where: countries_bool_exp
  ): countries_aggregate!

  """fetch data from the table: "countries" using primary key columns"""
  countries_by_pk(id: Int!): countries

  """
  fetch data from the table in a streaming manner: "countries"
  """
  countries_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [countries_stream_cursor_input]!

    """filter the rows returned"""
    where: countries_bool_exp
  ): [countries!]!

  """
  fetch data from the table: "country_codes"
  """
  country_codes(
    """distinct select on columns"""
    distinct_on: [country_codes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [country_codes_order_by!]

    """filter the rows returned"""
    where: country_codes_bool_exp
  ): [country_codes!]!

  """
  fetch aggregated fields from the table: "country_codes"
  """
  country_codes_aggregate(
    """distinct select on columns"""
    distinct_on: [country_codes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [country_codes_order_by!]

    """filter the rows returned"""
    where: country_codes_bool_exp
  ): country_codes_aggregate!

  """fetch data from the table: "country_codes" using primary key columns"""
  country_codes_by_pk(id: Int!): country_codes

  """
  fetch data from the table in a streaming manner: "country_codes"
  """
  country_codes_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [country_codes_stream_cursor_input]!

    """filter the rows returned"""
    where: country_codes_bool_exp
  ): [country_codes!]!

  """An array relationship"""
  credit_transactions(
    """distinct select on columns"""
    distinct_on: [credit_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [credit_transactions_order_by!]

    """filter the rows returned"""
    where: credit_transactions_bool_exp
  ): [credit_transactions!]!

  """An aggregate relationship"""
  credit_transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [credit_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [credit_transactions_order_by!]

    """filter the rows returned"""
    where: credit_transactions_bool_exp
  ): credit_transactions_aggregate!

  """
  fetch data from the table: "credit_transactions" using primary key columns
  """
  credit_transactions_by_pk(id: uuid!): credit_transactions

  """
  fetch data from the table in a streaming manner: "credit_transactions"
  """
  credit_transactions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [credit_transactions_stream_cursor_input]!

    """filter the rows returned"""
    where: credit_transactions_bool_exp
  ): [credit_transactions!]!

  """
  fetch data from the table: "dispute_evidence"
  """
  dispute_evidence(
    """distinct select on columns"""
    distinct_on: [dispute_evidence_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dispute_evidence_order_by!]

    """filter the rows returned"""
    where: dispute_evidence_bool_exp
  ): [dispute_evidence!]!

  """
  fetch aggregated fields from the table: "dispute_evidence"
  """
  dispute_evidence_aggregate(
    """distinct select on columns"""
    distinct_on: [dispute_evidence_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dispute_evidence_order_by!]

    """filter the rows returned"""
    where: dispute_evidence_bool_exp
  ): dispute_evidence_aggregate!

  """
  fetch data from the table: "dispute_evidence" using primary key columns
  """
  dispute_evidence_by_pk(id: uuid!): dispute_evidence

  """
  fetch data from the table in a streaming manner: "dispute_evidence"
  """
  dispute_evidence_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [dispute_evidence_stream_cursor_input]!

    """filter the rows returned"""
    where: dispute_evidence_bool_exp
  ): [dispute_evidence!]!

  """An array relationship"""
  dispute_messages(
    """distinct select on columns"""
    distinct_on: [dispute_messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dispute_messages_order_by!]

    """filter the rows returned"""
    where: dispute_messages_bool_exp
  ): [dispute_messages!]!

  """An aggregate relationship"""
  dispute_messages_aggregate(
    """distinct select on columns"""
    distinct_on: [dispute_messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dispute_messages_order_by!]

    """filter the rows returned"""
    where: dispute_messages_bool_exp
  ): dispute_messages_aggregate!

  """
  fetch data from the table: "dispute_messages" using primary key columns
  """
  dispute_messages_by_pk(id: uuid!): dispute_messages

  """
  fetch data from the table in a streaming manner: "dispute_messages"
  """
  dispute_messages_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [dispute_messages_stream_cursor_input]!

    """filter the rows returned"""
    where: dispute_messages_bool_exp
  ): [dispute_messages!]!

  """An array relationship"""
  dispute_parties(
    """distinct select on columns"""
    distinct_on: [dispute_parties_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dispute_parties_order_by!]

    """filter the rows returned"""
    where: dispute_parties_bool_exp
  ): [dispute_parties!]!

  """An aggregate relationship"""
  dispute_parties_aggregate(
    """distinct select on columns"""
    distinct_on: [dispute_parties_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dispute_parties_order_by!]

    """filter the rows returned"""
    where: dispute_parties_bool_exp
  ): dispute_parties_aggregate!

  """fetch data from the table: "dispute_parties" using primary key columns"""
  dispute_parties_by_pk(id: uuid!): dispute_parties

  """
  fetch data from the table in a streaming manner: "dispute_parties"
  """
  dispute_parties_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [dispute_parties_stream_cursor_input]!

    """filter the rows returned"""
    where: dispute_parties_bool_exp
  ): [dispute_parties!]!

  """An array relationship"""
  disputes(
    """distinct select on columns"""
    distinct_on: [disputes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [disputes_order_by!]

    """filter the rows returned"""
    where: disputes_bool_exp
  ): [disputes!]!

  """An aggregate relationship"""
  disputes_aggregate(
    """distinct select on columns"""
    distinct_on: [disputes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [disputes_order_by!]

    """filter the rows returned"""
    where: disputes_bool_exp
  ): disputes_aggregate!

  """fetch data from the table: "disputes" using primary key columns"""
  disputes_by_pk(id: uuid!): disputes

  """
  fetch data from the table in a streaming manner: "disputes"
  """
  disputes_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [disputes_stream_cursor_input]!

    """filter the rows returned"""
    where: disputes_bool_exp
  ): [disputes!]!

  """
  fetch data from the table: "favorites"
  """
  favorites(
    """distinct select on columns"""
    distinct_on: [favorites_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [favorites_order_by!]

    """filter the rows returned"""
    where: favorites_bool_exp
  ): [favorites!]!

  """
  fetch aggregated fields from the table: "favorites"
  """
  favorites_aggregate(
    """distinct select on columns"""
    distinct_on: [favorites_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [favorites_order_by!]

    """filter the rows returned"""
    where: favorites_bool_exp
  ): favorites_aggregate!

  """fetch data from the table: "favorites" using primary key columns"""
  favorites_by_pk(id: uuid!): favorites

  """
  fetch data from the table in a streaming manner: "favorites"
  """
  favorites_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [favorites_stream_cursor_input]!

    """filter the rows returned"""
    where: favorites_bool_exp
  ): [favorites!]!

  """An array relationship"""
  interview_notifications(
    """distinct select on columns"""
    distinct_on: [interview_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [interview_notifications_order_by!]

    """filter the rows returned"""
    where: interview_notifications_bool_exp
  ): [interview_notifications!]!

  """An aggregate relationship"""
  interview_notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [interview_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [interview_notifications_order_by!]

    """filter the rows returned"""
    where: interview_notifications_bool_exp
  ): interview_notifications_aggregate!

  """
  fetch data from the table: "interview_notifications" using primary key columns
  """
  interview_notifications_by_pk(id: uuid!): interview_notifications

  """
  fetch data from the table in a streaming manner: "interview_notifications"
  """
  interview_notifications_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [interview_notifications_stream_cursor_input]!

    """filter the rows returned"""
    where: interview_notifications_bool_exp
  ): [interview_notifications!]!

  """
  fetch data from the table: "interview_platform_templates"
  """
  interview_platform_templates(
    """distinct select on columns"""
    distinct_on: [interview_platform_templates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [interview_platform_templates_order_by!]

    """filter the rows returned"""
    where: interview_platform_templates_bool_exp
  ): [interview_platform_templates!]!

  """
  fetch aggregated fields from the table: "interview_platform_templates"
  """
  interview_platform_templates_aggregate(
    """distinct select on columns"""
    distinct_on: [interview_platform_templates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [interview_platform_templates_order_by!]

    """filter the rows returned"""
    where: interview_platform_templates_bool_exp
  ): interview_platform_templates_aggregate!

  """
  fetch data from the table: "interview_platform_templates" using primary key columns
  """
  interview_platform_templates_by_pk(id: uuid!): interview_platform_templates

  """
  fetch data from the table in a streaming manner: "interview_platform_templates"
  """
  interview_platform_templates_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [interview_platform_templates_stream_cursor_input]!

    """filter the rows returned"""
    where: interview_platform_templates_bool_exp
  ): [interview_platform_templates!]!

  """
  fetch data from the table: "job_applications"
  """
  job_applications(
    """distinct select on columns"""
    distinct_on: [job_applications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [job_applications_order_by!]

    """filter the rows returned"""
    where: job_applications_bool_exp
  ): [job_applications!]!

  """
  fetch aggregated fields from the table: "job_applications"
  """
  job_applications_aggregate(
    """distinct select on columns"""
    distinct_on: [job_applications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [job_applications_order_by!]

    """filter the rows returned"""
    where: job_applications_bool_exp
  ): job_applications_aggregate!

  """
  fetch data from the table: "job_applications" using primary key columns
  """
  job_applications_by_pk(id: uuid!): job_applications

  """
  fetch data from the table in a streaming manner: "job_applications"
  """
  job_applications_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [job_applications_stream_cursor_input]!

    """filter the rows returned"""
    where: job_applications_bool_exp
  ): [job_applications!]!

  """
  fetch data from the table: "job_postings"
  """
  job_postings(
    """distinct select on columns"""
    distinct_on: [job_postings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [job_postings_order_by!]

    """filter the rows returned"""
    where: job_postings_bool_exp
  ): [job_postings!]!

  """
  fetch aggregated fields from the table: "job_postings"
  """
  job_postings_aggregate(
    """distinct select on columns"""
    distinct_on: [job_postings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [job_postings_order_by!]

    """filter the rows returned"""
    where: job_postings_bool_exp
  ): job_postings_aggregate!

  """
  fetch data from the table in a streaming manner: "job_postings"
  """
  job_postings_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [job_postings_stream_cursor_input]!

    """filter the rows returned"""
    where: job_postings_bool_exp
  ): [job_postings!]!

  """
  fetch data from the table: "jobs"
  """
  jobs(
    """distinct select on columns"""
    distinct_on: [jobs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [jobs_order_by!]

    """filter the rows returned"""
    where: jobs_bool_exp
  ): [jobs!]!

  """
  fetch aggregated fields from the table: "jobs"
  """
  jobs_aggregate(
    """distinct select on columns"""
    distinct_on: [jobs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [jobs_order_by!]

    """filter the rows returned"""
    where: jobs_bool_exp
  ): jobs_aggregate!

  """fetch data from the table: "jobs" using primary key columns"""
  jobs_by_pk(id: uuid!): jobs

  """
  fetch data from the table in a streaming manner: "jobs"
  """
  jobs_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [jobs_stream_cursor_input]!

    """filter the rows returned"""
    where: jobs_bool_exp
  ): [jobs!]!

  """
  fetch data from the table: "maid_bookings"
  """
  maid_bookings(
    """distinct select on columns"""
    distinct_on: [maid_bookings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [maid_bookings_order_by!]

    """filter the rows returned"""
    where: maid_bookings_bool_exp
  ): [maid_bookings!]!

  """
  fetch aggregated fields from the table: "maid_bookings"
  """
  maid_bookings_aggregate(
    """distinct select on columns"""
    distinct_on: [maid_bookings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [maid_bookings_order_by!]

    """filter the rows returned"""
    where: maid_bookings_bool_exp
  ): maid_bookings_aggregate!

  """fetch data from the table: "maid_bookings" using primary key columns"""
  maid_bookings_by_pk(id: uuid!): maid_bookings

  """
  fetch data from the table in a streaming manner: "maid_bookings"
  """
  maid_bookings_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [maid_bookings_stream_cursor_input]!

    """filter the rows returned"""
    where: maid_bookings_bool_exp
  ): [maid_bookings!]!

  """
  fetch data from the table: "maid_documents"
  """
  maid_documents(
    """distinct select on columns"""
    distinct_on: [maid_documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [maid_documents_order_by!]

    """filter the rows returned"""
    where: maid_documents_bool_exp
  ): [maid_documents!]!

  """
  fetch aggregated fields from the table: "maid_documents"
  """
  maid_documents_aggregate(
    """distinct select on columns"""
    distinct_on: [maid_documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [maid_documents_order_by!]

    """filter the rows returned"""
    where: maid_documents_bool_exp
  ): maid_documents_aggregate!

  """fetch data from the table: "maid_documents" using primary key columns"""
  maid_documents_by_pk(id: uuid!): maid_documents

  """
  fetch data from the table in a streaming manner: "maid_documents"
  """
  maid_documents_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [maid_documents_stream_cursor_input]!

    """filter the rows returned"""
    where: maid_documents_bool_exp
  ): [maid_documents!]!

  """
  fetch data from the table: "maid_images"
  """
  maid_images(
    """distinct select on columns"""
    distinct_on: [maid_images_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [maid_images_order_by!]

    """filter the rows returned"""
    where: maid_images_bool_exp
  ): [maid_images!]!

  """
  fetch aggregated fields from the table: "maid_images"
  """
  maid_images_aggregate(
    """distinct select on columns"""
    distinct_on: [maid_images_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [maid_images_order_by!]

    """filter the rows returned"""
    where: maid_images_bool_exp
  ): maid_images_aggregate!

  """fetch data from the table: "maid_images" using primary key columns"""
  maid_images_by_pk(id: uuid!): maid_images

  """
  fetch data from the table in a streaming manner: "maid_images"
  """
  maid_images_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [maid_images_stream_cursor_input]!

    """filter the rows returned"""
    where: maid_images_bool_exp
  ): [maid_images!]!

  """
  fetch data from the table: "maid_profiles"
  """
  maid_profiles(
    """distinct select on columns"""
    distinct_on: [maid_profiles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [maid_profiles_order_by!]

    """filter the rows returned"""
    where: maid_profiles_bool_exp
  ): [maid_profiles!]!

  """
  fetch aggregated fields from the table: "maid_profiles"
  """
  maid_profiles_aggregate(
    """distinct select on columns"""
    distinct_on: [maid_profiles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [maid_profiles_order_by!]

    """filter the rows returned"""
    where: maid_profiles_bool_exp
  ): maid_profiles_aggregate!

  """fetch data from the table: "maid_profiles" using primary key columns"""
  maid_profiles_by_pk(id: String!): maid_profiles

  """
  fetch data from the table in a streaming manner: "maid_profiles"
  """
  maid_profiles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [maid_profiles_stream_cursor_input]!

    """filter the rows returned"""
    where: maid_profiles_bool_exp
  ): [maid_profiles!]!

  """
  fetch data from the table: "maid_videos"
  """
  maid_videos(
    """distinct select on columns"""
    distinct_on: [maid_videos_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [maid_videos_order_by!]

    """filter the rows returned"""
    where: maid_videos_bool_exp
  ): [maid_videos!]!

  """
  fetch aggregated fields from the table: "maid_videos"
  """
  maid_videos_aggregate(
    """distinct select on columns"""
    distinct_on: [maid_videos_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [maid_videos_order_by!]

    """filter the rows returned"""
    where: maid_videos_bool_exp
  ): maid_videos_aggregate!

  """fetch data from the table: "maid_videos" using primary key columns"""
  maid_videos_by_pk(id: uuid!): maid_videos

  """
  fetch data from the table in a streaming manner: "maid_videos"
  """
  maid_videos_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [maid_videos_stream_cursor_input]!

    """filter the rows returned"""
    where: maid_videos_bool_exp
  ): [maid_videos!]!

  """
  fetch data from the table: "message_templates"
  """
  message_templates(
    """distinct select on columns"""
    distinct_on: [message_templates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_templates_order_by!]

    """filter the rows returned"""
    where: message_templates_bool_exp
  ): [message_templates!]!

  """
  fetch aggregated fields from the table: "message_templates"
  """
  message_templates_aggregate(
    """distinct select on columns"""
    distinct_on: [message_templates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_templates_order_by!]

    """filter the rows returned"""
    where: message_templates_bool_exp
  ): message_templates_aggregate!

  """
  fetch data from the table: "message_templates" using primary key columns
  """
  message_templates_by_pk(id: uuid!): message_templates

  """
  fetch data from the table in a streaming manner: "message_templates"
  """
  message_templates_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [message_templates_stream_cursor_input]!

    """filter the rows returned"""
    where: message_templates_bool_exp
  ): [message_templates!]!

  """An array relationship"""
  messages(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): [messages!]!

  """An aggregate relationship"""
  messages_aggregate(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): messages_aggregate!

  """fetch data from the table: "messages" using primary key columns"""
  messages_by_pk(id: uuid!): messages

  """
  fetch data from the table in a streaming manner: "messages"
  """
  messages_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [messages_stream_cursor_input]!

    """filter the rows returned"""
    where: messages_bool_exp
  ): [messages!]!

  """
  fetch data from the table: "mv_agency_analytics_summary"
  """
  mv_agency_analytics_summary(
    """distinct select on columns"""
    distinct_on: [mv_agency_analytics_summary_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mv_agency_analytics_summary_order_by!]

    """filter the rows returned"""
    where: mv_agency_analytics_summary_bool_exp
  ): [mv_agency_analytics_summary!]!

  """
  fetch aggregated fields from the table: "mv_agency_analytics_summary"
  """
  mv_agency_analytics_summary_aggregate(
    """distinct select on columns"""
    distinct_on: [mv_agency_analytics_summary_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mv_agency_analytics_summary_order_by!]

    """filter the rows returned"""
    where: mv_agency_analytics_summary_bool_exp
  ): mv_agency_analytics_summary_aggregate!

  """
  fetch data from the table in a streaming manner: "mv_agency_analytics_summary"
  """
  mv_agency_analytics_summary_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [mv_agency_analytics_summary_stream_cursor_input]!

    """filter the rows returned"""
    where: mv_agency_analytics_summary_bool_exp
  ): [mv_agency_analytics_summary!]!

  """An array relationship"""
  news_items(
    """distinct select on columns"""
    distinct_on: [news_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [news_items_order_by!]

    """filter the rows returned"""
    where: news_items_bool_exp
  ): [news_items!]!

  """An aggregate relationship"""
  news_items_aggregate(
    """distinct select on columns"""
    distinct_on: [news_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [news_items_order_by!]

    """filter the rows returned"""
    where: news_items_bool_exp
  ): news_items_aggregate!

  """fetch data from the table: "news_items" using primary key columns"""
  news_items_by_pk(id: uuid!): news_items

  """
  fetch data from the table in a streaming manner: "news_items"
  """
  news_items_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [news_items_stream_cursor_input]!

    """filter the rows returned"""
    where: news_items_bool_exp
  ): [news_items!]!

  """
  fetch data from the table: "news_sources"
  """
  news_sources(
    """distinct select on columns"""
    distinct_on: [news_sources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [news_sources_order_by!]

    """filter the rows returned"""
    where: news_sources_bool_exp
  ): [news_sources!]!

  """
  fetch aggregated fields from the table: "news_sources"
  """
  news_sources_aggregate(
    """distinct select on columns"""
    distinct_on: [news_sources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [news_sources_order_by!]

    """filter the rows returned"""
    where: news_sources_bool_exp
  ): news_sources_aggregate!

  """fetch data from the table: "news_sources" using primary key columns"""
  news_sources_by_pk(id: uuid!): news_sources

  """
  fetch data from the table in a streaming manner: "news_sources"
  """
  news_sources_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [news_sources_stream_cursor_input]!

    """filter the rows returned"""
    where: news_sources_bool_exp
  ): [news_sources!]!

  """
  fetch data from the table: "notifications"
  """
  notifications(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): [notifications!]!

  """
  fetch aggregated fields from the table: "notifications"
  """
  notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): notifications_aggregate!

  """fetch data from the table: "notifications" using primary key columns"""
  notifications_by_pk(id: uuid!): notifications

  """
  fetch data from the table in a streaming manner: "notifications"
  """
  notifications_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notifications_stream_cursor_input]!

    """filter the rows returned"""
    where: notifications_bool_exp
  ): [notifications!]!

  """
  fetch data from the table: "page_views"
  """
  page_views(
    """distinct select on columns"""
    distinct_on: [page_views_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [page_views_order_by!]

    """filter the rows returned"""
    where: page_views_bool_exp
  ): [page_views!]!

  """
  fetch aggregated fields from the table: "page_views"
  """
  page_views_aggregate(
    """distinct select on columns"""
    distinct_on: [page_views_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [page_views_order_by!]

    """filter the rows returned"""
    where: page_views_bool_exp
  ): page_views_aggregate!

  """fetch data from the table: "page_views" using primary key columns"""
  page_views_by_pk(id: uuid!): page_views

  """
  fetch data from the table in a streaming manner: "page_views"
  """
  page_views_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [page_views_stream_cursor_input]!

    """filter the rows returned"""
    where: page_views_bool_exp
  ): [page_views!]!

  """
  fetch data from the table: "password_resets"
  """
  password_resets(
    """distinct select on columns"""
    distinct_on: [password_resets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [password_resets_order_by!]

    """filter the rows returned"""
    where: password_resets_bool_exp
  ): [password_resets!]!

  """
  fetch aggregated fields from the table: "password_resets"
  """
  password_resets_aggregate(
    """distinct select on columns"""
    distinct_on: [password_resets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [password_resets_order_by!]

    """filter the rows returned"""
    where: password_resets_bool_exp
  ): password_resets_aggregate!

  """fetch data from the table: "password_resets" using primary key columns"""
  password_resets_by_pk(
    """Unique identifier for the password reset request"""
    id: uuid!
  ): password_resets

  """
  fetch data from the table in a streaming manner: "password_resets"
  """
  password_resets_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [password_resets_stream_cursor_input]!

    """filter the rows returned"""
    where: password_resets_bool_exp
  ): [password_resets!]!

  """
  fetch data from the table: "payment_idempotency"
  """
  payment_idempotency(
    """distinct select on columns"""
    distinct_on: [payment_idempotency_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_idempotency_order_by!]

    """filter the rows returned"""
    where: payment_idempotency_bool_exp
  ): [payment_idempotency!]!

  """
  fetch aggregated fields from the table: "payment_idempotency"
  """
  payment_idempotency_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_idempotency_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_idempotency_order_by!]

    """filter the rows returned"""
    where: payment_idempotency_bool_exp
  ): payment_idempotency_aggregate!

  """
  fetch data from the table: "payment_idempotency" using primary key columns
  """
  payment_idempotency_by_pk(id: uuid!): payment_idempotency

  """
  fetch data from the table in a streaming manner: "payment_idempotency"
  """
  payment_idempotency_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [payment_idempotency_stream_cursor_input]!

    """filter the rows returned"""
    where: payment_idempotency_bool_exp
  ): [payment_idempotency!]!

  """
  fetch data from the table: "payment_methods"
  """
  payment_methods(
    """distinct select on columns"""
    distinct_on: [payment_methods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_methods_order_by!]

    """filter the rows returned"""
    where: payment_methods_bool_exp
  ): [payment_methods!]!

  """
  fetch aggregated fields from the table: "payment_methods"
  """
  payment_methods_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_methods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_methods_order_by!]

    """filter the rows returned"""
    where: payment_methods_bool_exp
  ): payment_methods_aggregate!

  """fetch data from the table: "payment_methods" using primary key columns"""
  payment_methods_by_pk(id: uuid!): payment_methods

  """
  fetch data from the table in a streaming manner: "payment_methods"
  """
  payment_methods_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [payment_methods_stream_cursor_input]!

    """filter the rows returned"""
    where: payment_methods_bool_exp
  ): [payment_methods!]!

  """An array relationship"""
  payments(
    """distinct select on columns"""
    distinct_on: [payments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_order_by!]

    """filter the rows returned"""
    where: payments_bool_exp
  ): [payments!]!

  """An aggregate relationship"""
  payments_aggregate(
    """distinct select on columns"""
    distinct_on: [payments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payments_order_by!]

    """filter the rows returned"""
    where: payments_bool_exp
  ): payments_aggregate!

  """fetch data from the table: "payments" using primary key columns"""
  payments_by_pk(id: uuid!): payments

  """
  fetch data from the table in a streaming manner: "payments"
  """
  payments_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [payments_stream_cursor_input]!

    """filter the rows returned"""
    where: payments_bool_exp
  ): [payments!]!

  """
  fetch data from the table: "payout_accounts"
  """
  payout_accounts(
    """distinct select on columns"""
    distinct_on: [payout_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payout_accounts_order_by!]

    """filter the rows returned"""
    where: payout_accounts_bool_exp
  ): [payout_accounts!]!

  """
  fetch aggregated fields from the table: "payout_accounts"
  """
  payout_accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [payout_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payout_accounts_order_by!]

    """filter the rows returned"""
    where: payout_accounts_bool_exp
  ): payout_accounts_aggregate!

  """fetch data from the table: "payout_accounts" using primary key columns"""
  payout_accounts_by_pk(id: uuid!): payout_accounts

  """
  fetch data from the table in a streaming manner: "payout_accounts"
  """
  payout_accounts_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [payout_accounts_stream_cursor_input]!

    """filter the rows returned"""
    where: payout_accounts_bool_exp
  ): [payout_accounts!]!

  """An array relationship"""
  payout_schedules(
    """distinct select on columns"""
    distinct_on: [payout_schedules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payout_schedules_order_by!]

    """filter the rows returned"""
    where: payout_schedules_bool_exp
  ): [payout_schedules!]!

  """An aggregate relationship"""
  payout_schedules_aggregate(
    """distinct select on columns"""
    distinct_on: [payout_schedules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payout_schedules_order_by!]

    """filter the rows returned"""
    where: payout_schedules_bool_exp
  ): payout_schedules_aggregate!

  """
  fetch data from the table: "payout_schedules" using primary key columns
  """
  payout_schedules_by_pk(id: uuid!): payout_schedules

  """
  fetch data from the table in a streaming manner: "payout_schedules"
  """
  payout_schedules_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [payout_schedules_stream_cursor_input]!

    """filter the rows returned"""
    where: payout_schedules_bool_exp
  ): [payout_schedules!]!

  """
  fetch data from the table: "phone_verification_log"
  """
  phone_verification_log(
    """distinct select on columns"""
    distinct_on: [phone_verification_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [phone_verification_log_order_by!]

    """filter the rows returned"""
    where: phone_verification_log_bool_exp
  ): [phone_verification_log!]!

  """
  fetch aggregated fields from the table: "phone_verification_log"
  """
  phone_verification_log_aggregate(
    """distinct select on columns"""
    distinct_on: [phone_verification_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [phone_verification_log_order_by!]

    """filter the rows returned"""
    where: phone_verification_log_bool_exp
  ): phone_verification_log_aggregate!

  """
  fetch data from the table: "phone_verification_log" using primary key columns
  """
  phone_verification_log_by_pk(id: uuid!): phone_verification_log

  """
  fetch data from the table in a streaming manner: "phone_verification_log"
  """
  phone_verification_log_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [phone_verification_log_stream_cursor_input]!

    """filter the rows returned"""
    where: phone_verification_log_bool_exp
  ): [phone_verification_log!]!

  """
  fetch data from the table: "phone_verifications"
  """
  phone_verifications(
    """distinct select on columns"""
    distinct_on: [phone_verifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [phone_verifications_order_by!]

    """filter the rows returned"""
    where: phone_verifications_bool_exp
  ): [phone_verifications!]!

  """
  fetch aggregated fields from the table: "phone_verifications"
  """
  phone_verifications_aggregate(
    """distinct select on columns"""
    distinct_on: [phone_verifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [phone_verifications_order_by!]

    """filter the rows returned"""
    where: phone_verifications_bool_exp
  ): phone_verifications_aggregate!

  """
  fetch data from the table: "phone_verifications" using primary key columns
  """
  phone_verifications_by_pk(id: uuid!): phone_verifications

  """
  fetch data from the table in a streaming manner: "phone_verifications"
  """
  phone_verifications_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [phone_verifications_stream_cursor_input]!

    """filter the rows returned"""
    where: phone_verifications_bool_exp
  ): [phone_verifications!]!

  """
  fetch data from the table: "pii_access_log"
  """
  pii_access_log(
    """distinct select on columns"""
    distinct_on: [pii_access_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pii_access_log_order_by!]

    """filter the rows returned"""
    where: pii_access_log_bool_exp
  ): [pii_access_log!]!

  """
  fetch aggregated fields from the table: "pii_access_log"
  """
  pii_access_log_aggregate(
    """distinct select on columns"""
    distinct_on: [pii_access_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pii_access_log_order_by!]

    """filter the rows returned"""
    where: pii_access_log_bool_exp
  ): pii_access_log_aggregate!

  """fetch data from the table: "pii_access_log" using primary key columns"""
  pii_access_log_by_pk(id: uuid!): pii_access_log

  """
  fetch data from the table in a streaming manner: "pii_access_log"
  """
  pii_access_log_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [pii_access_log_stream_cursor_input]!

    """filter the rows returned"""
    where: pii_access_log_bool_exp
  ): [pii_access_log!]!

  """An array relationship"""
  placement_contracts(
    """distinct select on columns"""
    distinct_on: [placement_contracts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [placement_contracts_order_by!]

    """filter the rows returned"""
    where: placement_contracts_bool_exp
  ): [placement_contracts!]!

  """An aggregate relationship"""
  placement_contracts_aggregate(
    """distinct select on columns"""
    distinct_on: [placement_contracts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [placement_contracts_order_by!]

    """filter the rows returned"""
    where: placement_contracts_bool_exp
  ): placement_contracts_aggregate!

  """
  fetch data from the table: "placement_contracts" using primary key columns
  """
  placement_contracts_by_pk(id: uuid!): placement_contracts

  """
  fetch data from the table in a streaming manner: "placement_contracts"
  """
  placement_contracts_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [placement_contracts_stream_cursor_input]!

    """filter the rows returned"""
    where: placement_contracts_bool_exp
  ): [placement_contracts!]!

  """An array relationship"""
  placement_fee_transactions(
    """distinct select on columns"""
    distinct_on: [placement_fee_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [placement_fee_transactions_order_by!]

    """filter the rows returned"""
    where: placement_fee_transactions_bool_exp
  ): [placement_fee_transactions!]!

  """An aggregate relationship"""
  placement_fee_transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [placement_fee_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [placement_fee_transactions_order_by!]

    """filter the rows returned"""
    where: placement_fee_transactions_bool_exp
  ): placement_fee_transactions_aggregate!

  """
  fetch data from the table: "placement_fee_transactions" using primary key columns
  """
  placement_fee_transactions_by_pk(id: uuid!): placement_fee_transactions

  """
  fetch data from the table in a streaming manner: "placement_fee_transactions"
  """
  placement_fee_transactions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [placement_fee_transactions_stream_cursor_input]!

    """filter the rows returned"""
    where: placement_fee_transactions_bool_exp
  ): [placement_fee_transactions!]!

  """
  fetch data from the table: "platform_announcements"
  """
  platform_announcements(
    """distinct select on columns"""
    distinct_on: [platform_announcements_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [platform_announcements_order_by!]

    """filter the rows returned"""
    where: platform_announcements_bool_exp
  ): [platform_announcements!]!

  """
  fetch aggregated fields from the table: "platform_announcements"
  """
  platform_announcements_aggregate(
    """distinct select on columns"""
    distinct_on: [platform_announcements_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [platform_announcements_order_by!]

    """filter the rows returned"""
    where: platform_announcements_bool_exp
  ): platform_announcements_aggregate!

  """
  fetch data from the table: "platform_announcements" using primary key columns
  """
  platform_announcements_by_pk(id: uuid!): platform_announcements

  """
  fetch data from the table in a streaming manner: "platform_announcements"
  """
  platform_announcements_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [platform_announcements_stream_cursor_input]!

    """filter the rows returned"""
    where: platform_announcements_bool_exp
  ): [platform_announcements!]!

  """
  fetch data from the table: "platform_settings"
  """
  platform_settings(
    """distinct select on columns"""
    distinct_on: [platform_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [platform_settings_order_by!]

    """filter the rows returned"""
    where: platform_settings_bool_exp
  ): [platform_settings!]!

  """
  fetch aggregated fields from the table: "platform_settings"
  """
  platform_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [platform_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [platform_settings_order_by!]

    """filter the rows returned"""
    where: platform_settings_bool_exp
  ): platform_settings_aggregate!

  """
  fetch data from the table: "platform_settings" using primary key columns
  """
  platform_settings_by_pk(id: uuid!): platform_settings

  """
  fetch data from the table in a streaming manner: "platform_settings"
  """
  platform_settings_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [platform_settings_stream_cursor_input]!

    """filter the rows returned"""
    where: platform_settings_bool_exp
  ): [platform_settings!]!

  """
  fetch data from the table: "profiles"
  """
  profiles(
    """distinct select on columns"""
    distinct_on: [profiles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [profiles_order_by!]

    """filter the rows returned"""
    where: profiles_bool_exp
  ): [profiles!]!

  """
  fetch aggregated fields from the table: "profiles"
  """
  profiles_aggregate(
    """distinct select on columns"""
    distinct_on: [profiles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [profiles_order_by!]

    """filter the rows returned"""
    where: profiles_bool_exp
  ): profiles_aggregate!

  """fetch data from the table: "profiles" using primary key columns"""
  profiles_by_pk(id: String!): profiles

  """
  fetch data from the table in a streaming manner: "profiles"
  """
  profiles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [profiles_stream_cursor_input]!

    """filter the rows returned"""
    where: profiles_bool_exp
  ): [profiles!]!

  """
  fetch data from the table: "realtime.messages"
  """
  realtime_messages(
    """distinct select on columns"""
    distinct_on: [realtime_messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [realtime_messages_order_by!]

    """filter the rows returned"""
    where: realtime_messages_bool_exp
  ): [realtime_messages!]!

  """
  fetch aggregated fields from the table: "realtime.messages"
  """
  realtime_messages_aggregate(
    """distinct select on columns"""
    distinct_on: [realtime_messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [realtime_messages_order_by!]

    """filter the rows returned"""
    where: realtime_messages_bool_exp
  ): realtime_messages_aggregate!

  """
  fetch data from the table: "realtime.messages" using primary key columns
  """
  realtime_messages_by_pk(id: uuid!, inserted_at: timestamp!): realtime_messages

  """
  fetch data from the table in a streaming manner: "realtime.messages"
  """
  realtime_messages_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [realtime_messages_stream_cursor_input]!

    """filter the rows returned"""
    where: realtime_messages_bool_exp
  ): [realtime_messages!]!

  """
  fetch data from the table: "realtime.subscription"
  """
  realtime_subscription(
    """distinct select on columns"""
    distinct_on: [realtime_subscription_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [realtime_subscription_order_by!]

    """filter the rows returned"""
    where: realtime_subscription_bool_exp
  ): [realtime_subscription!]!

  """
  fetch aggregated fields from the table: "realtime.subscription"
  """
  realtime_subscription_aggregate(
    """distinct select on columns"""
    distinct_on: [realtime_subscription_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [realtime_subscription_order_by!]

    """filter the rows returned"""
    where: realtime_subscription_bool_exp
  ): realtime_subscription_aggregate!

  """
  fetch data from the table: "realtime.subscription" using primary key columns
  """
  realtime_subscription_by_pk(id: bigint!): realtime_subscription

  """
  fetch data from the table in a streaming manner: "realtime.subscription"
  """
  realtime_subscription_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [realtime_subscription_stream_cursor_input]!

    """filter the rows returned"""
    where: realtime_subscription_bool_exp
  ): [realtime_subscription!]!

  """
  fetch data from the table: "reviews"
  """
  reviews(
    """distinct select on columns"""
    distinct_on: [reviews_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reviews_order_by!]

    """filter the rows returned"""
    where: reviews_bool_exp
  ): [reviews!]!

  """
  fetch aggregated fields from the table: "reviews"
  """
  reviews_aggregate(
    """distinct select on columns"""
    distinct_on: [reviews_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reviews_order_by!]

    """filter the rows returned"""
    where: reviews_bool_exp
  ): reviews_aggregate!

  """fetch data from the table: "reviews" using primary key columns"""
  reviews_by_pk(id: uuid!): reviews

  """
  fetch data from the table in a streaming manner: "reviews"
  """
  reviews_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [reviews_stream_cursor_input]!

    """filter the rows returned"""
    where: reviews_bool_exp
  ): [reviews!]!

  """An array relationship"""
  security_events(
    """distinct select on columns"""
    distinct_on: [security_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [security_events_order_by!]

    """filter the rows returned"""
    where: security_events_bool_exp
  ): [security_events!]!

  """An aggregate relationship"""
  security_events_aggregate(
    """distinct select on columns"""
    distinct_on: [security_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [security_events_order_by!]

    """filter the rows returned"""
    where: security_events_bool_exp
  ): security_events_aggregate!

  """fetch data from the table: "security_events" using primary key columns"""
  security_events_by_pk(id: uuid!): security_events

  """
  fetch data from the table in a streaming manner: "security_events"
  """
  security_events_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [security_events_stream_cursor_input]!

    """filter the rows returned"""
    where: security_events_bool_exp
  ): [security_events!]!

  """An array relationship"""
  shortlist_candidates(
    """distinct select on columns"""
    distinct_on: [shortlist_candidates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shortlist_candidates_order_by!]

    """filter the rows returned"""
    where: shortlist_candidates_bool_exp
  ): [shortlist_candidates!]!

  """An aggregate relationship"""
  shortlist_candidates_aggregate(
    """distinct select on columns"""
    distinct_on: [shortlist_candidates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shortlist_candidates_order_by!]

    """filter the rows returned"""
    where: shortlist_candidates_bool_exp
  ): shortlist_candidates_aggregate!

  """
  fetch data from the table: "shortlist_candidates" using primary key columns
  """
  shortlist_candidates_by_pk(id: uuid!): shortlist_candidates

  """
  fetch data from the table in a streaming manner: "shortlist_candidates"
  """
  shortlist_candidates_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [shortlist_candidates_stream_cursor_input]!

    """filter the rows returned"""
    where: shortlist_candidates_bool_exp
  ): [shortlist_candidates!]!

  """An array relationship"""
  shortlists(
    """distinct select on columns"""
    distinct_on: [shortlists_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shortlists_order_by!]

    """filter the rows returned"""
    where: shortlists_bool_exp
  ): [shortlists!]!

  """An aggregate relationship"""
  shortlists_aggregate(
    """distinct select on columns"""
    distinct_on: [shortlists_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shortlists_order_by!]

    """filter the rows returned"""
    where: shortlists_bool_exp
  ): shortlists_aggregate!

  """fetch data from the table: "shortlists" using primary key columns"""
  shortlists_by_pk(id: uuid!): shortlists

  """
  fetch data from the table in a streaming manner: "shortlists"
  """
  shortlists_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [shortlists_stream_cursor_input]!

    """filter the rows returned"""
    where: shortlists_bool_exp
  ): [shortlists!]!

  """
  fetch data from the table: "skills"
  """
  skills(
    """distinct select on columns"""
    distinct_on: [skills_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [skills_order_by!]

    """filter the rows returned"""
    where: skills_bool_exp
  ): [skills!]!

  """
  fetch aggregated fields from the table: "skills"
  """
  skills_aggregate(
    """distinct select on columns"""
    distinct_on: [skills_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [skills_order_by!]

    """filter the rows returned"""
    where: skills_bool_exp
  ): skills_aggregate!

  """fetch data from the table: "skills" using primary key columns"""
  skills_by_pk(id: Int!): skills

  """
  fetch data from the table in a streaming manner: "skills"
  """
  skills_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [skills_stream_cursor_input]!

    """filter the rows returned"""
    where: skills_bool_exp
  ): [skills!]!

  """
  fetch data from the table: "sponsor_document_verification"
  """
  sponsor_document_verification(
    """distinct select on columns"""
    distinct_on: [sponsor_document_verification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sponsor_document_verification_order_by!]

    """filter the rows returned"""
    where: sponsor_document_verification_bool_exp
  ): [sponsor_document_verification!]!

  """
  fetch aggregated fields from the table: "sponsor_document_verification"
  """
  sponsor_document_verification_aggregate(
    """distinct select on columns"""
    distinct_on: [sponsor_document_verification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sponsor_document_verification_order_by!]

    """filter the rows returned"""
    where: sponsor_document_verification_bool_exp
  ): sponsor_document_verification_aggregate!

  """
  fetch data from the table: "sponsor_document_verification" using primary key columns
  """
  sponsor_document_verification_by_pk(id: uuid!): sponsor_document_verification

  """
  fetch data from the table in a streaming manner: "sponsor_document_verification"
  """
  sponsor_document_verification_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [sponsor_document_verification_stream_cursor_input]!

    """filter the rows returned"""
    where: sponsor_document_verification_bool_exp
  ): [sponsor_document_verification!]!

  """An array relationship"""
  sponsor_jobs(
    """distinct select on columns"""
    distinct_on: [sponsor_jobs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sponsor_jobs_order_by!]

    """filter the rows returned"""
    where: sponsor_jobs_bool_exp
  ): [sponsor_jobs!]!

  """An aggregate relationship"""
  sponsor_jobs_aggregate(
    """distinct select on columns"""
    distinct_on: [sponsor_jobs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sponsor_jobs_order_by!]

    """filter the rows returned"""
    where: sponsor_jobs_bool_exp
  ): sponsor_jobs_aggregate!

  """fetch data from the table: "sponsor_jobs" using primary key columns"""
  sponsor_jobs_by_pk(id: uuid!): sponsor_jobs

  """
  fetch data from the table in a streaming manner: "sponsor_jobs"
  """
  sponsor_jobs_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [sponsor_jobs_stream_cursor_input]!

    """filter the rows returned"""
    where: sponsor_jobs_bool_exp
  ): [sponsor_jobs!]!

  """
  fetch data from the table: "sponsor_profiles"
  """
  sponsor_profiles(
    """distinct select on columns"""
    distinct_on: [sponsor_profiles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sponsor_profiles_order_by!]

    """filter the rows returned"""
    where: sponsor_profiles_bool_exp
  ): [sponsor_profiles!]!

  """
  fetch aggregated fields from the table: "sponsor_profiles"
  """
  sponsor_profiles_aggregate(
    """distinct select on columns"""
    distinct_on: [sponsor_profiles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sponsor_profiles_order_by!]

    """filter the rows returned"""
    where: sponsor_profiles_bool_exp
  ): sponsor_profiles_aggregate!

  """
  fetch data from the table: "sponsor_profiles" using primary key columns
  """
  sponsor_profiles_by_pk(id: String!): sponsor_profiles

  """
  fetch data from the table in a streaming manner: "sponsor_profiles"
  """
  sponsor_profiles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [sponsor_profiles_stream_cursor_input]!

    """filter the rows returned"""
    where: sponsor_profiles_bool_exp
  ): [sponsor_profiles!]!

  """
  fetch data from the table: "sponsors"
  """
  sponsors(
    """distinct select on columns"""
    distinct_on: [sponsors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sponsors_order_by!]

    """filter the rows returned"""
    where: sponsors_bool_exp
  ): [sponsors!]!

  """
  fetch aggregated fields from the table: "sponsors"
  """
  sponsors_aggregate(
    """distinct select on columns"""
    distinct_on: [sponsors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sponsors_order_by!]

    """filter the rows returned"""
    where: sponsors_bool_exp
  ): sponsors_aggregate!

  """fetch data from the table: "sponsors" using primary key columns"""
  sponsors_by_pk(id: uuid!): sponsors

  """
  fetch data from the table in a streaming manner: "sponsors"
  """
  sponsors_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [sponsors_stream_cursor_input]!

    """filter the rows returned"""
    where: sponsors_bool_exp
  ): [sponsors!]!

  """
  fetch data from the table: "storage.buckets"
  """
  storage_buckets(
    """distinct select on columns"""
    distinct_on: [storage_buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_buckets_order_by!]

    """filter the rows returned"""
    where: storage_buckets_bool_exp
  ): [storage_buckets!]!

  """
  fetch aggregated fields from the table: "storage.buckets"
  """
  storage_buckets_aggregate(
    """distinct select on columns"""
    distinct_on: [storage_buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_buckets_order_by!]

    """filter the rows returned"""
    where: storage_buckets_bool_exp
  ): storage_buckets_aggregate!

  """
  fetch data from the table: "storage.buckets_analytics"
  """
  storage_buckets_analytics(
    """distinct select on columns"""
    distinct_on: [storage_buckets_analytics_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_buckets_analytics_order_by!]

    """filter the rows returned"""
    where: storage_buckets_analytics_bool_exp
  ): [storage_buckets_analytics!]!

  """
  fetch aggregated fields from the table: "storage.buckets_analytics"
  """
  storage_buckets_analytics_aggregate(
    """distinct select on columns"""
    distinct_on: [storage_buckets_analytics_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_buckets_analytics_order_by!]

    """filter the rows returned"""
    where: storage_buckets_analytics_bool_exp
  ): storage_buckets_analytics_aggregate!

  """
  fetch data from the table: "storage.buckets_analytics" using primary key columns
  """
  storage_buckets_analytics_by_pk(id: uuid!): storage_buckets_analytics

  """
  fetch data from the table in a streaming manner: "storage.buckets_analytics"
  """
  storage_buckets_analytics_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [storage_buckets_analytics_stream_cursor_input]!

    """filter the rows returned"""
    where: storage_buckets_analytics_bool_exp
  ): [storage_buckets_analytics!]!

  """fetch data from the table: "storage.buckets" using primary key columns"""
  storage_buckets_by_pk(id: String!): storage_buckets

  """
  fetch data from the table in a streaming manner: "storage.buckets"
  """
  storage_buckets_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [storage_buckets_stream_cursor_input]!

    """filter the rows returned"""
    where: storage_buckets_bool_exp
  ): [storage_buckets!]!

  """
  fetch data from the table: "storage.migrations"
  """
  storage_migrations(
    """distinct select on columns"""
    distinct_on: [storage_migrations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_migrations_order_by!]

    """filter the rows returned"""
    where: storage_migrations_bool_exp
  ): [storage_migrations!]!

  """
  fetch aggregated fields from the table: "storage.migrations"
  """
  storage_migrations_aggregate(
    """distinct select on columns"""
    distinct_on: [storage_migrations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_migrations_order_by!]

    """filter the rows returned"""
    where: storage_migrations_bool_exp
  ): storage_migrations_aggregate!

  """
  fetch data from the table: "storage.migrations" using primary key columns
  """
  storage_migrations_by_pk(id: Int!): storage_migrations

  """
  fetch data from the table in a streaming manner: "storage.migrations"
  """
  storage_migrations_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [storage_migrations_stream_cursor_input]!

    """filter the rows returned"""
    where: storage_migrations_bool_exp
  ): [storage_migrations!]!

  """
  fetch data from the table: "storage.objects"
  """
  storage_objects(
    """distinct select on columns"""
    distinct_on: [storage_objects_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_objects_order_by!]

    """filter the rows returned"""
    where: storage_objects_bool_exp
  ): [storage_objects!]!

  """
  fetch aggregated fields from the table: "storage.objects"
  """
  storage_objects_aggregate(
    """distinct select on columns"""
    distinct_on: [storage_objects_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_objects_order_by!]

    """filter the rows returned"""
    where: storage_objects_bool_exp
  ): storage_objects_aggregate!

  """fetch data from the table: "storage.objects" using primary key columns"""
  storage_objects_by_pk(id: uuid!): storage_objects

  """
  fetch data from the table in a streaming manner: "storage.objects"
  """
  storage_objects_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [storage_objects_stream_cursor_input]!

    """filter the rows returned"""
    where: storage_objects_bool_exp
  ): [storage_objects!]!

  """
  fetch data from the table: "storage.prefixes"
  """
  storage_prefixes(
    """distinct select on columns"""
    distinct_on: [storage_prefixes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_prefixes_order_by!]

    """filter the rows returned"""
    where: storage_prefixes_bool_exp
  ): [storage_prefixes!]!

  """
  fetch aggregated fields from the table: "storage.prefixes"
  """
  storage_prefixes_aggregate(
    """distinct select on columns"""
    distinct_on: [storage_prefixes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_prefixes_order_by!]

    """filter the rows returned"""
    where: storage_prefixes_bool_exp
  ): storage_prefixes_aggregate!

  """
  fetch data from the table: "storage.prefixes" using primary key columns
  """
  storage_prefixes_by_pk(bucket_id: String!, level: Int!, name: String!): storage_prefixes

  """
  fetch data from the table in a streaming manner: "storage.prefixes"
  """
  storage_prefixes_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [storage_prefixes_stream_cursor_input]!

    """filter the rows returned"""
    where: storage_prefixes_bool_exp
  ): [storage_prefixes!]!

  """
  fetch data from the table: "storage.s3_multipart_uploads"
  """
  storage_s3_multipart_uploads(
    """distinct select on columns"""
    distinct_on: [storage_s3_multipart_uploads_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_s3_multipart_uploads_order_by!]

    """filter the rows returned"""
    where: storage_s3_multipart_uploads_bool_exp
  ): [storage_s3_multipart_uploads!]!

  """
  fetch aggregated fields from the table: "storage.s3_multipart_uploads"
  """
  storage_s3_multipart_uploads_aggregate(
    """distinct select on columns"""
    distinct_on: [storage_s3_multipart_uploads_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_s3_multipart_uploads_order_by!]

    """filter the rows returned"""
    where: storage_s3_multipart_uploads_bool_exp
  ): storage_s3_multipart_uploads_aggregate!

  """
  fetch data from the table: "storage.s3_multipart_uploads" using primary key columns
  """
  storage_s3_multipart_uploads_by_pk(id: String!): storage_s3_multipart_uploads

  """
  fetch data from the table: "storage.s3_multipart_uploads_parts"
  """
  storage_s3_multipart_uploads_parts(
    """distinct select on columns"""
    distinct_on: [storage_s3_multipart_uploads_parts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_s3_multipart_uploads_parts_order_by!]

    """filter the rows returned"""
    where: storage_s3_multipart_uploads_parts_bool_exp
  ): [storage_s3_multipart_uploads_parts!]!

  """
  fetch aggregated fields from the table: "storage.s3_multipart_uploads_parts"
  """
  storage_s3_multipart_uploads_parts_aggregate(
    """distinct select on columns"""
    distinct_on: [storage_s3_multipart_uploads_parts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storage_s3_multipart_uploads_parts_order_by!]

    """filter the rows returned"""
    where: storage_s3_multipart_uploads_parts_bool_exp
  ): storage_s3_multipart_uploads_parts_aggregate!

  """
  fetch data from the table: "storage.s3_multipart_uploads_parts" using primary key columns
  """
  storage_s3_multipart_uploads_parts_by_pk(id: uuid!): storage_s3_multipart_uploads_parts

  """
  fetch data from the table in a streaming manner: "storage.s3_multipart_uploads_parts"
  """
  storage_s3_multipart_uploads_parts_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [storage_s3_multipart_uploads_parts_stream_cursor_input]!

    """filter the rows returned"""
    where: storage_s3_multipart_uploads_parts_bool_exp
  ): [storage_s3_multipart_uploads_parts!]!

  """
  fetch data from the table in a streaming manner: "storage.s3_multipart_uploads"
  """
  storage_s3_multipart_uploads_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [storage_s3_multipart_uploads_stream_cursor_input]!

    """filter the rows returned"""
    where: storage_s3_multipart_uploads_bool_exp
  ): [storage_s3_multipart_uploads!]!

  """
  fetch data from the table: "subscription_limits"
  """
  subscription_limits(
    """distinct select on columns"""
    distinct_on: [subscription_limits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscription_limits_order_by!]

    """filter the rows returned"""
    where: subscription_limits_bool_exp
  ): [subscription_limits!]!

  """
  fetch aggregated fields from the table: "subscription_limits"
  """
  subscription_limits_aggregate(
    """distinct select on columns"""
    distinct_on: [subscription_limits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscription_limits_order_by!]

    """filter the rows returned"""
    where: subscription_limits_bool_exp
  ): subscription_limits_aggregate!

  """
  fetch data from the table: "subscription_limits" using primary key columns
  """
  subscription_limits_by_pk(id: uuid!): subscription_limits

  """
  fetch data from the table in a streaming manner: "subscription_limits"
  """
  subscription_limits_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [subscription_limits_stream_cursor_input]!

    """filter the rows returned"""
    where: subscription_limits_bool_exp
  ): [subscription_limits!]!

  """
  fetch data from the table: "subscription_status_log"
  """
  subscription_status_log(
    """distinct select on columns"""
    distinct_on: [subscription_status_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscription_status_log_order_by!]

    """filter the rows returned"""
    where: subscription_status_log_bool_exp
  ): [subscription_status_log!]!

  """
  fetch aggregated fields from the table: "subscription_status_log"
  """
  subscription_status_log_aggregate(
    """distinct select on columns"""
    distinct_on: [subscription_status_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscription_status_log_order_by!]

    """filter the rows returned"""
    where: subscription_status_log_bool_exp
  ): subscription_status_log_aggregate!

  """
  fetch data from the table: "subscription_status_log" using primary key columns
  """
  subscription_status_log_by_pk(id: uuid!): subscription_status_log

  """
  fetch data from the table in a streaming manner: "subscription_status_log"
  """
  subscription_status_log_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [subscription_status_log_stream_cursor_input]!

    """filter the rows returned"""
    where: subscription_status_log_bool_exp
  ): [subscription_status_log!]!

  """
  fetch data from the table: "subscription_usage"
  """
  subscription_usage(
    """distinct select on columns"""
    distinct_on: [subscription_usage_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscription_usage_order_by!]

    """filter the rows returned"""
    where: subscription_usage_bool_exp
  ): [subscription_usage!]!

  """
  fetch aggregated fields from the table: "subscription_usage"
  """
  subscription_usage_aggregate(
    """distinct select on columns"""
    distinct_on: [subscription_usage_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscription_usage_order_by!]

    """filter the rows returned"""
    where: subscription_usage_bool_exp
  ): subscription_usage_aggregate!

  """
  fetch data from the table: "subscription_usage" using primary key columns
  """
  subscription_usage_by_pk(id: uuid!): subscription_usage

  """
  fetch data from the table in a streaming manner: "subscription_usage"
  """
  subscription_usage_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [subscription_usage_stream_cursor_input]!

    """filter the rows returned"""
    where: subscription_usage_bool_exp
  ): [subscription_usage!]!

  """
  fetch data from the table: "subscriptions"
  """
  subscriptions(
    """distinct select on columns"""
    distinct_on: [subscriptions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscriptions_order_by!]

    """filter the rows returned"""
    where: subscriptions_bool_exp
  ): [subscriptions!]!

  """
  fetch aggregated fields from the table: "subscriptions"
  """
  subscriptions_aggregate(
    """distinct select on columns"""
    distinct_on: [subscriptions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscriptions_order_by!]

    """filter the rows returned"""
    where: subscriptions_bool_exp
  ): subscriptions_aggregate!

  """fetch data from the table: "subscriptions" using primary key columns"""
  subscriptions_by_pk(id: uuid!): subscriptions

  """
  fetch data from the table in a streaming manner: "subscriptions"
  """
  subscriptions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [subscriptions_stream_cursor_input]!

    """filter the rows returned"""
    where: subscriptions_bool_exp
  ): [subscriptions!]!

  """
  fetch data from the table: "supabase_migrations.schema_migrations"
  """
  supabase_migrations_schema_migrations(
    """distinct select on columns"""
    distinct_on: [supabase_migrations_schema_migrations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [supabase_migrations_schema_migrations_order_by!]

    """filter the rows returned"""
    where: supabase_migrations_schema_migrations_bool_exp
  ): [supabase_migrations_schema_migrations!]!

  """
  fetch aggregated fields from the table: "supabase_migrations.schema_migrations"
  """
  supabase_migrations_schema_migrations_aggregate(
    """distinct select on columns"""
    distinct_on: [supabase_migrations_schema_migrations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [supabase_migrations_schema_migrations_order_by!]

    """filter the rows returned"""
    where: supabase_migrations_schema_migrations_bool_exp
  ): supabase_migrations_schema_migrations_aggregate!

  """
  fetch data from the table: "supabase_migrations.schema_migrations" using primary key columns
  """
  supabase_migrations_schema_migrations_by_pk(version: String!): supabase_migrations_schema_migrations

  """
  fetch data from the table in a streaming manner: "supabase_migrations.schema_migrations"
  """
  supabase_migrations_schema_migrations_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [supabase_migrations_schema_migrations_stream_cursor_input]!

    """filter the rows returned"""
    where: supabase_migrations_schema_migrations_bool_exp
  ): [supabase_migrations_schema_migrations!]!

  """
  fetch data from the table: "supabase_migrations.seed_files"
  """
  supabase_migrations_seed_files(
    """distinct select on columns"""
    distinct_on: [supabase_migrations_seed_files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [supabase_migrations_seed_files_order_by!]

    """filter the rows returned"""
    where: supabase_migrations_seed_files_bool_exp
  ): [supabase_migrations_seed_files!]!

  """
  fetch aggregated fields from the table: "supabase_migrations.seed_files"
  """
  supabase_migrations_seed_files_aggregate(
    """distinct select on columns"""
    distinct_on: [supabase_migrations_seed_files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [supabase_migrations_seed_files_order_by!]

    """filter the rows returned"""
    where: supabase_migrations_seed_files_bool_exp
  ): supabase_migrations_seed_files_aggregate!

  """
  fetch data from the table: "supabase_migrations.seed_files" using primary key columns
  """
  supabase_migrations_seed_files_by_pk(path: String!): supabase_migrations_seed_files

  """
  fetch data from the table in a streaming manner: "supabase_migrations.seed_files"
  """
  supabase_migrations_seed_files_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [supabase_migrations_seed_files_stream_cursor_input]!

    """filter the rows returned"""
    where: supabase_migrations_seed_files_bool_exp
  ): [supabase_migrations_seed_files!]!

  """
  fetch data from the table: "support_agents"
  """
  support_agents(
    """distinct select on columns"""
    distinct_on: [support_agents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [support_agents_order_by!]

    """filter the rows returned"""
    where: support_agents_bool_exp
  ): [support_agents!]!

  """
  fetch aggregated fields from the table: "support_agents"
  """
  support_agents_aggregate(
    """distinct select on columns"""
    distinct_on: [support_agents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [support_agents_order_by!]

    """filter the rows returned"""
    where: support_agents_bool_exp
  ): support_agents_aggregate!

  """fetch data from the table: "support_agents" using primary key columns"""
  support_agents_by_pk(id: uuid!): support_agents

  """
  fetch data from the table in a streaming manner: "support_agents"
  """
  support_agents_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [support_agents_stream_cursor_input]!

    """filter the rows returned"""
    where: support_agents_bool_exp
  ): [support_agents!]!

  """
  fetch data from the table: "support_interactions"
  """
  support_interactions(
    """distinct select on columns"""
    distinct_on: [support_interactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [support_interactions_order_by!]

    """filter the rows returned"""
    where: support_interactions_bool_exp
  ): [support_interactions!]!

  """
  fetch aggregated fields from the table: "support_interactions"
  """
  support_interactions_aggregate(
    """distinct select on columns"""
    distinct_on: [support_interactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [support_interactions_order_by!]

    """filter the rows returned"""
    where: support_interactions_bool_exp
  ): support_interactions_aggregate!

  """
  fetch data from the table: "support_interactions" using primary key columns
  """
  support_interactions_by_pk(id: uuid!): support_interactions

  """
  fetch data from the table in a streaming manner: "support_interactions"
  """
  support_interactions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [support_interactions_stream_cursor_input]!

    """filter the rows returned"""
    where: support_interactions_bool_exp
  ): [support_interactions!]!

  """An array relationship"""
  support_messages(
    """distinct select on columns"""
    distinct_on: [support_messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [support_messages_order_by!]

    """filter the rows returned"""
    where: support_messages_bool_exp
  ): [support_messages!]!

  """An aggregate relationship"""
  support_messages_aggregate(
    """distinct select on columns"""
    distinct_on: [support_messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [support_messages_order_by!]

    """filter the rows returned"""
    where: support_messages_bool_exp
  ): support_messages_aggregate!

  """
  fetch data from the table: "support_messages" using primary key columns
  """
  support_messages_by_pk(id: uuid!): support_messages

  """
  fetch data from the table in a streaming manner: "support_messages"
  """
  support_messages_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [support_messages_stream_cursor_input]!

    """filter the rows returned"""
    where: support_messages_bool_exp
  ): [support_messages!]!

  """
  fetch data from the table: "support_tickets"
  """
  support_tickets(
    """distinct select on columns"""
    distinct_on: [support_tickets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [support_tickets_order_by!]

    """filter the rows returned"""
    where: support_tickets_bool_exp
  ): [support_tickets!]!

  """
  fetch aggregated fields from the table: "support_tickets"
  """
  support_tickets_aggregate(
    """distinct select on columns"""
    distinct_on: [support_tickets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [support_tickets_order_by!]

    """filter the rows returned"""
    where: support_tickets_bool_exp
  ): support_tickets_aggregate!

  """fetch data from the table: "support_tickets" using primary key columns"""
  support_tickets_by_pk(id: uuid!): support_tickets

  """
  fetch data from the table in a streaming manner: "support_tickets"
  """
  support_tickets_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [support_tickets_stream_cursor_input]!

    """filter the rows returned"""
    where: support_tickets_bool_exp
  ): [support_tickets!]!

  """An array relationship"""
  system_settings(
    """distinct select on columns"""
    distinct_on: [system_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [system_settings_order_by!]

    """filter the rows returned"""
    where: system_settings_bool_exp
  ): [system_settings!]!

  """An aggregate relationship"""
  system_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [system_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [system_settings_order_by!]

    """filter the rows returned"""
    where: system_settings_bool_exp
  ): system_settings_aggregate!

  """fetch data from the table: "system_settings" using primary key columns"""
  system_settings_by_pk(id: uuid!): system_settings

  """
  fetch data from the table in a streaming manner: "system_settings"
  """
  system_settings_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [system_settings_stream_cursor_input]!

    """filter the rows returned"""
    where: system_settings_bool_exp
  ): [system_settings!]!

  """
  fetch data from the table: "team_member_performance"
  """
  team_member_performance(
    """distinct select on columns"""
    distinct_on: [team_member_performance_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_member_performance_order_by!]

    """filter the rows returned"""
    where: team_member_performance_bool_exp
  ): [team_member_performance!]!

  """
  fetch aggregated fields from the table: "team_member_performance"
  """
  team_member_performance_aggregate(
    """distinct select on columns"""
    distinct_on: [team_member_performance_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_member_performance_order_by!]

    """filter the rows returned"""
    where: team_member_performance_bool_exp
  ): team_member_performance_aggregate!

  """
  fetch data from the table: "team_member_performance" using primary key columns
  """
  team_member_performance_by_pk(id: uuid!): team_member_performance

  """
  fetch data from the table in a streaming manner: "team_member_performance"
  """
  team_member_performance_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [team_member_performance_stream_cursor_input]!

    """filter the rows returned"""
    where: team_member_performance_bool_exp
  ): [team_member_performance!]!

  """
  fetch data from the table: "two_factor_backup_codes"
  """
  two_factor_backup_codes(
    """distinct select on columns"""
    distinct_on: [two_factor_backup_codes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [two_factor_backup_codes_order_by!]

    """filter the rows returned"""
    where: two_factor_backup_codes_bool_exp
  ): [two_factor_backup_codes!]!

  """
  fetch aggregated fields from the table: "two_factor_backup_codes"
  """
  two_factor_backup_codes_aggregate(
    """distinct select on columns"""
    distinct_on: [two_factor_backup_codes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [two_factor_backup_codes_order_by!]

    """filter the rows returned"""
    where: two_factor_backup_codes_bool_exp
  ): two_factor_backup_codes_aggregate!

  """
  fetch data from the table: "two_factor_backup_codes" using primary key columns
  """
  two_factor_backup_codes_by_pk(id: uuid!): two_factor_backup_codes

  """
  fetch data from the table in a streaming manner: "two_factor_backup_codes"
  """
  two_factor_backup_codes_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [two_factor_backup_codes_stream_cursor_input]!

    """filter the rows returned"""
    where: two_factor_backup_codes_bool_exp
  ): [two_factor_backup_codes!]!

  """
  fetch data from the table: "user_credits"
  """
  user_credits(
    """distinct select on columns"""
    distinct_on: [user_credits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_credits_order_by!]

    """filter the rows returned"""
    where: user_credits_bool_exp
  ): [user_credits!]!

  """
  fetch aggregated fields from the table: "user_credits"
  """
  user_credits_aggregate(
    """distinct select on columns"""
    distinct_on: [user_credits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_credits_order_by!]

    """filter the rows returned"""
    where: user_credits_bool_exp
  ): user_credits_aggregate!

  """fetch data from the table: "user_credits" using primary key columns"""
  user_credits_by_pk(id: uuid!): user_credits

  """
  fetch data from the table in a streaming manner: "user_credits"
  """
  user_credits_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_credits_stream_cursor_input]!

    """filter the rows returned"""
    where: user_credits_bool_exp
  ): [user_credits!]!

  """
  fetch data from the table: "user_events"
  """
  user_events(
    """distinct select on columns"""
    distinct_on: [user_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_events_order_by!]

    """filter the rows returned"""
    where: user_events_bool_exp
  ): [user_events!]!

  """
  fetch aggregated fields from the table: "user_events"
  """
  user_events_aggregate(
    """distinct select on columns"""
    distinct_on: [user_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_events_order_by!]

    """filter the rows returned"""
    where: user_events_bool_exp
  ): user_events_aggregate!

  """fetch data from the table: "user_events" using primary key columns"""
  user_events_by_pk(id: uuid!): user_events

  """
  fetch data from the table in a streaming manner: "user_events"
  """
  user_events_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_events_stream_cursor_input]!

    """filter the rows returned"""
    where: user_events_bool_exp
  ): [user_events!]!

  """
  fetch data from the table: "user_sessions"
  """
  user_sessions(
    """distinct select on columns"""
    distinct_on: [user_sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_sessions_order_by!]

    """filter the rows returned"""
    where: user_sessions_bool_exp
  ): [user_sessions!]!

  """
  fetch aggregated fields from the table: "user_sessions"
  """
  user_sessions_aggregate(
    """distinct select on columns"""
    distinct_on: [user_sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_sessions_order_by!]

    """filter the rows returned"""
    where: user_sessions_bool_exp
  ): user_sessions_aggregate!

  """fetch data from the table: "user_sessions" using primary key columns"""
  user_sessions_by_pk(id: uuid!): user_sessions

  """
  fetch data from the table in a streaming manner: "user_sessions"
  """
  user_sessions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_sessions_stream_cursor_input]!

    """filter the rows returned"""
    where: user_sessions_bool_exp
  ): [user_sessions!]!

  """An array relationship"""
  video_interviews(
    """distinct select on columns"""
    distinct_on: [video_interviews_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [video_interviews_order_by!]

    """filter the rows returned"""
    where: video_interviews_bool_exp
  ): [video_interviews!]!

  """An aggregate relationship"""
  video_interviews_aggregate(
    """distinct select on columns"""
    distinct_on: [video_interviews_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [video_interviews_order_by!]

    """filter the rows returned"""
    where: video_interviews_bool_exp
  ): video_interviews_aggregate!

  """
  fetch data from the table: "video_interviews" using primary key columns
  """
  video_interviews_by_pk(id: uuid!): video_interviews

  """
  fetch data from the table in a streaming manner: "video_interviews"
  """
  video_interviews_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [video_interviews_stream_cursor_input]!

    """filter the rows returned"""
    where: video_interviews_bool_exp
  ): [video_interviews!]!

  """An array relationship"""
  webhook_event_logs(
    """distinct select on columns"""
    distinct_on: [webhook_event_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [webhook_event_logs_order_by!]

    """filter the rows returned"""
    where: webhook_event_logs_bool_exp
  ): [webhook_event_logs!]!

  """An aggregate relationship"""
  webhook_event_logs_aggregate(
    """distinct select on columns"""
    distinct_on: [webhook_event_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [webhook_event_logs_order_by!]

    """filter the rows returned"""
    where: webhook_event_logs_bool_exp
  ): webhook_event_logs_aggregate!

  """
  fetch data from the table: "webhook_event_logs" using primary key columns
  """
  webhook_event_logs_by_pk(id: uuid!): webhook_event_logs

  """
  fetch data from the table in a streaming manner: "webhook_event_logs"
  """
  webhook_event_logs_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [webhook_event_logs_stream_cursor_input]!

    """filter the rows returned"""
    where: webhook_event_logs_bool_exp
  ): [webhook_event_logs!]!

  """
  fetch data from the table: "whatsapp_messages"
  """
  whatsapp_messages(
    """distinct select on columns"""
    distinct_on: [whatsapp_messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [whatsapp_messages_order_by!]

    """filter the rows returned"""
    where: whatsapp_messages_bool_exp
  ): [whatsapp_messages!]!

  """
  fetch aggregated fields from the table: "whatsapp_messages"
  """
  whatsapp_messages_aggregate(
    """distinct select on columns"""
    distinct_on: [whatsapp_messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [whatsapp_messages_order_by!]

    """filter the rows returned"""
    where: whatsapp_messages_bool_exp
  ): whatsapp_messages_aggregate!

  """
  fetch data from the table: "whatsapp_messages" using primary key columns
  """
  whatsapp_messages_by_pk(id: uuid!): whatsapp_messages

  """
  fetch data from the table in a streaming manner: "whatsapp_messages"
  """
  whatsapp_messages_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [whatsapp_messages_stream_cursor_input]!

    """filter the rows returned"""
    where: whatsapp_messages_bool_exp
  ): [whatsapp_messages!]!

  """
  fetch data from the table: "work_experience"
  """
  work_experience(
    """distinct select on columns"""
    distinct_on: [work_experience_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [work_experience_order_by!]

    """filter the rows returned"""
    where: work_experience_bool_exp
  ): [work_experience!]!

  """
  fetch aggregated fields from the table: "work_experience"
  """
  work_experience_aggregate(
    """distinct select on columns"""
    distinct_on: [work_experience_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [work_experience_order_by!]

    """filter the rows returned"""
    where: work_experience_bool_exp
  ): work_experience_aggregate!

  """fetch data from the table: "work_experience" using primary key columns"""
  work_experience_by_pk(id: uuid!): work_experience

  """
  fetch data from the table in a streaming manner: "work_experience"
  """
  work_experience_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [work_experience_stream_cursor_input]!

    """filter the rows returned"""
    where: work_experience_bool_exp
  ): [work_experience!]!
}

"""
Audit log of all subscription status changes for compliance and debugging
"""
type subscription_status_log {
  created_at: timestamptz
  created_by: uuid
  id: uuid!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  new_status: String!
  old_status: String
  reason: String

  """An object relationship"""
  subscription: subscriptions!
  subscription_id: uuid!

  """An object relationship"""
  user: auth_users
}

"""
aggregated selection of "subscription_status_log"
"""
type subscription_status_log_aggregate {
  aggregate: subscription_status_log_aggregate_fields
  nodes: [subscription_status_log!]!
}

input subscription_status_log_aggregate_bool_exp {
  count: subscription_status_log_aggregate_bool_exp_count
}

input subscription_status_log_aggregate_bool_exp_count {
  arguments: [subscription_status_log_select_column!]
  distinct: Boolean
  filter: subscription_status_log_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "subscription_status_log"
"""
type subscription_status_log_aggregate_fields {
  count(columns: [subscription_status_log_select_column!], distinct: Boolean): Int!
  max: subscription_status_log_max_fields
  min: subscription_status_log_min_fields
}

"""
order by aggregate values of table "subscription_status_log"
"""
input subscription_status_log_aggregate_order_by {
  count: order_by
  max: subscription_status_log_max_order_by
  min: subscription_status_log_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input subscription_status_log_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "subscription_status_log"
"""
input subscription_status_log_arr_rel_insert_input {
  data: [subscription_status_log_insert_input!]!

  """upsert condition"""
  on_conflict: subscription_status_log_on_conflict
}

"""
Boolean expression to filter rows from the table "subscription_status_log". All fields are combined with a logical 'AND'.
"""
input subscription_status_log_bool_exp {
  _and: [subscription_status_log_bool_exp!]
  _not: subscription_status_log_bool_exp
  _or: [subscription_status_log_bool_exp!]
  created_at: timestamptz_comparison_exp
  created_by: uuid_comparison_exp
  id: uuid_comparison_exp
  metadata: jsonb_comparison_exp
  new_status: String_comparison_exp
  old_status: String_comparison_exp
  reason: String_comparison_exp
  subscription: subscriptions_bool_exp
  subscription_id: uuid_comparison_exp
  user: auth_users_bool_exp
}

"""
unique or primary key constraints on table "subscription_status_log"
"""
enum subscription_status_log_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  subscription_status_log_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input subscription_status_log_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input subscription_status_log_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input subscription_status_log_delete_key_input {
  metadata: String
}

"""
input type for inserting data into table "subscription_status_log"
"""
input subscription_status_log_insert_input {
  created_at: timestamptz
  created_by: uuid
  id: uuid
  metadata: jsonb
  new_status: String
  old_status: String
  reason: String
  subscription: subscriptions_obj_rel_insert_input
  subscription_id: uuid
  user: auth_users_obj_rel_insert_input
}

"""aggregate max on columns"""
type subscription_status_log_max_fields {
  created_at: timestamptz
  created_by: uuid
  id: uuid
  new_status: String
  old_status: String
  reason: String
  subscription_id: uuid
}

"""
order by max() on columns of table "subscription_status_log"
"""
input subscription_status_log_max_order_by {
  created_at: order_by
  created_by: order_by
  id: order_by
  new_status: order_by
  old_status: order_by
  reason: order_by
  subscription_id: order_by
}

"""aggregate min on columns"""
type subscription_status_log_min_fields {
  created_at: timestamptz
  created_by: uuid
  id: uuid
  new_status: String
  old_status: String
  reason: String
  subscription_id: uuid
}

"""
order by min() on columns of table "subscription_status_log"
"""
input subscription_status_log_min_order_by {
  created_at: order_by
  created_by: order_by
  id: order_by
  new_status: order_by
  old_status: order_by
  reason: order_by
  subscription_id: order_by
}

"""
response of any mutation on the table "subscription_status_log"
"""
type subscription_status_log_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [subscription_status_log!]!
}

"""
on_conflict condition type for table "subscription_status_log"
"""
input subscription_status_log_on_conflict {
  constraint: subscription_status_log_constraint!
  update_columns: [subscription_status_log_update_column!]! = []
  where: subscription_status_log_bool_exp
}

"""Ordering options when selecting data from "subscription_status_log"."""
input subscription_status_log_order_by {
  created_at: order_by
  created_by: order_by
  id: order_by
  metadata: order_by
  new_status: order_by
  old_status: order_by
  reason: order_by
  subscription: subscriptions_order_by
  subscription_id: order_by
  user: auth_users_order_by
}

"""primary key columns input for table: subscription_status_log"""
input subscription_status_log_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input subscription_status_log_prepend_input {
  metadata: jsonb
}

"""
select columns of table "subscription_status_log"
"""
enum subscription_status_log_select_column {
  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  new_status

  """column name"""
  old_status

  """column name"""
  reason

  """column name"""
  subscription_id
}

"""
input type for updating data in table "subscription_status_log"
"""
input subscription_status_log_set_input {
  created_at: timestamptz
  created_by: uuid
  id: uuid
  metadata: jsonb
  new_status: String
  old_status: String
  reason: String
  subscription_id: uuid
}

"""
Streaming cursor of the table "subscription_status_log"
"""
input subscription_status_log_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: subscription_status_log_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input subscription_status_log_stream_cursor_value_input {
  created_at: timestamptz
  created_by: uuid
  id: uuid
  metadata: jsonb
  new_status: String
  old_status: String
  reason: String
  subscription_id: uuid
}

"""
update columns of table "subscription_status_log"
"""
enum subscription_status_log_update_column {
  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  new_status

  """column name"""
  old_status

  """column name"""
  reason

  """column name"""
  subscription_id
}

input subscription_status_log_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: subscription_status_log_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: subscription_status_log_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: subscription_status_log_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: subscription_status_log_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: subscription_status_log_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: subscription_status_log_set_input

  """filter the rows which have to be updated"""
  where: subscription_status_log_bool_exp!
}

"""
Tracks actual usage of subscription features per billing period for enforcement and analytics
"""
type subscription_usage {
  bulk_uploads_performed: Int
  candidate_searches_performed: Int
  candidates_saved: Int
  created_at: timestamptz
  id: uuid!
  job_applications_submitted: Int
  job_postings_active: Int
  maid_listings_active: Int
  message_threads_used: Int
  messages_sent: Int
  period_end: date!
  period_start: date!
  profile_views: Int
  sponsor_connections: Int

  """An object relationship"""
  subscription: subscriptions
  subscription_id: uuid
  updated_at: timestamptz

  """An object relationship"""
  user: auth_users!
  user_id: uuid!
}

"""
aggregated selection of "subscription_usage"
"""
type subscription_usage_aggregate {
  aggregate: subscription_usage_aggregate_fields
  nodes: [subscription_usage!]!
}

input subscription_usage_aggregate_bool_exp {
  count: subscription_usage_aggregate_bool_exp_count
}

input subscription_usage_aggregate_bool_exp_count {
  arguments: [subscription_usage_select_column!]
  distinct: Boolean
  filter: subscription_usage_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "subscription_usage"
"""
type subscription_usage_aggregate_fields {
  avg: subscription_usage_avg_fields
  count(columns: [subscription_usage_select_column!], distinct: Boolean): Int!
  max: subscription_usage_max_fields
  min: subscription_usage_min_fields
  stddev: subscription_usage_stddev_fields
  stddev_pop: subscription_usage_stddev_pop_fields
  stddev_samp: subscription_usage_stddev_samp_fields
  sum: subscription_usage_sum_fields
  var_pop: subscription_usage_var_pop_fields
  var_samp: subscription_usage_var_samp_fields
  variance: subscription_usage_variance_fields
}

"""
order by aggregate values of table "subscription_usage"
"""
input subscription_usage_aggregate_order_by {
  avg: subscription_usage_avg_order_by
  count: order_by
  max: subscription_usage_max_order_by
  min: subscription_usage_min_order_by
  stddev: subscription_usage_stddev_order_by
  stddev_pop: subscription_usage_stddev_pop_order_by
  stddev_samp: subscription_usage_stddev_samp_order_by
  sum: subscription_usage_sum_order_by
  var_pop: subscription_usage_var_pop_order_by
  var_samp: subscription_usage_var_samp_order_by
  variance: subscription_usage_variance_order_by
}

"""
input type for inserting array relation for remote table "subscription_usage"
"""
input subscription_usage_arr_rel_insert_input {
  data: [subscription_usage_insert_input!]!

  """upsert condition"""
  on_conflict: subscription_usage_on_conflict
}

"""aggregate avg on columns"""
type subscription_usage_avg_fields {
  bulk_uploads_performed: Float
  candidate_searches_performed: Float
  candidates_saved: Float
  job_applications_submitted: Float
  job_postings_active: Float
  maid_listings_active: Float
  message_threads_used: Float
  messages_sent: Float
  profile_views: Float
  sponsor_connections: Float
}

"""
order by avg() on columns of table "subscription_usage"
"""
input subscription_usage_avg_order_by {
  bulk_uploads_performed: order_by
  candidate_searches_performed: order_by
  candidates_saved: order_by
  job_applications_submitted: order_by
  job_postings_active: order_by
  maid_listings_active: order_by
  message_threads_used: order_by
  messages_sent: order_by
  profile_views: order_by
  sponsor_connections: order_by
}

"""
Boolean expression to filter rows from the table "subscription_usage". All fields are combined with a logical 'AND'.
"""
input subscription_usage_bool_exp {
  _and: [subscription_usage_bool_exp!]
  _not: subscription_usage_bool_exp
  _or: [subscription_usage_bool_exp!]
  bulk_uploads_performed: Int_comparison_exp
  candidate_searches_performed: Int_comparison_exp
  candidates_saved: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  job_applications_submitted: Int_comparison_exp
  job_postings_active: Int_comparison_exp
  maid_listings_active: Int_comparison_exp
  message_threads_used: Int_comparison_exp
  messages_sent: Int_comparison_exp
  period_end: date_comparison_exp
  period_start: date_comparison_exp
  profile_views: Int_comparison_exp
  sponsor_connections: Int_comparison_exp
  subscription: subscriptions_bool_exp
  subscription_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "subscription_usage"
"""
enum subscription_usage_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  subscription_usage_pkey

  """
  unique or primary key constraint on columns "user_id", "period_start"
  """
  unique_user_period
}

"""
input type for incrementing numeric columns in table "subscription_usage"
"""
input subscription_usage_inc_input {
  bulk_uploads_performed: Int
  candidate_searches_performed: Int
  candidates_saved: Int
  job_applications_submitted: Int
  job_postings_active: Int
  maid_listings_active: Int
  message_threads_used: Int
  messages_sent: Int
  profile_views: Int
  sponsor_connections: Int
}

"""
input type for inserting data into table "subscription_usage"
"""
input subscription_usage_insert_input {
  bulk_uploads_performed: Int
  candidate_searches_performed: Int
  candidates_saved: Int
  created_at: timestamptz
  id: uuid
  job_applications_submitted: Int
  job_postings_active: Int
  maid_listings_active: Int
  message_threads_used: Int
  messages_sent: Int
  period_end: date
  period_start: date
  profile_views: Int
  sponsor_connections: Int
  subscription: subscriptions_obj_rel_insert_input
  subscription_id: uuid
  updated_at: timestamptz
  user: auth_users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type subscription_usage_max_fields {
  bulk_uploads_performed: Int
  candidate_searches_performed: Int
  candidates_saved: Int
  created_at: timestamptz
  id: uuid
  job_applications_submitted: Int
  job_postings_active: Int
  maid_listings_active: Int
  message_threads_used: Int
  messages_sent: Int
  period_end: date
  period_start: date
  profile_views: Int
  sponsor_connections: Int
  subscription_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
order by max() on columns of table "subscription_usage"
"""
input subscription_usage_max_order_by {
  bulk_uploads_performed: order_by
  candidate_searches_performed: order_by
  candidates_saved: order_by
  created_at: order_by
  id: order_by
  job_applications_submitted: order_by
  job_postings_active: order_by
  maid_listings_active: order_by
  message_threads_used: order_by
  messages_sent: order_by
  period_end: order_by
  period_start: order_by
  profile_views: order_by
  sponsor_connections: order_by
  subscription_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type subscription_usage_min_fields {
  bulk_uploads_performed: Int
  candidate_searches_performed: Int
  candidates_saved: Int
  created_at: timestamptz
  id: uuid
  job_applications_submitted: Int
  job_postings_active: Int
  maid_listings_active: Int
  message_threads_used: Int
  messages_sent: Int
  period_end: date
  period_start: date
  profile_views: Int
  sponsor_connections: Int
  subscription_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
order by min() on columns of table "subscription_usage"
"""
input subscription_usage_min_order_by {
  bulk_uploads_performed: order_by
  candidate_searches_performed: order_by
  candidates_saved: order_by
  created_at: order_by
  id: order_by
  job_applications_submitted: order_by
  job_postings_active: order_by
  maid_listings_active: order_by
  message_threads_used: order_by
  messages_sent: order_by
  period_end: order_by
  period_start: order_by
  profile_views: order_by
  sponsor_connections: order_by
  subscription_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "subscription_usage"
"""
type subscription_usage_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [subscription_usage!]!
}

"""
on_conflict condition type for table "subscription_usage"
"""
input subscription_usage_on_conflict {
  constraint: subscription_usage_constraint!
  update_columns: [subscription_usage_update_column!]! = []
  where: subscription_usage_bool_exp
}

"""Ordering options when selecting data from "subscription_usage"."""
input subscription_usage_order_by {
  bulk_uploads_performed: order_by
  candidate_searches_performed: order_by
  candidates_saved: order_by
  created_at: order_by
  id: order_by
  job_applications_submitted: order_by
  job_postings_active: order_by
  maid_listings_active: order_by
  message_threads_used: order_by
  messages_sent: order_by
  period_end: order_by
  period_start: order_by
  profile_views: order_by
  sponsor_connections: order_by
  subscription: subscriptions_order_by
  subscription_id: order_by
  updated_at: order_by
  user: auth_users_order_by
  user_id: order_by
}

"""primary key columns input for table: subscription_usage"""
input subscription_usage_pk_columns_input {
  id: uuid!
}

"""
select columns of table "subscription_usage"
"""
enum subscription_usage_select_column {
  """column name"""
  bulk_uploads_performed

  """column name"""
  candidate_searches_performed

  """column name"""
  candidates_saved

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  job_applications_submitted

  """column name"""
  job_postings_active

  """column name"""
  maid_listings_active

  """column name"""
  message_threads_used

  """column name"""
  messages_sent

  """column name"""
  period_end

  """column name"""
  period_start

  """column name"""
  profile_views

  """column name"""
  sponsor_connections

  """column name"""
  subscription_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "subscription_usage"
"""
input subscription_usage_set_input {
  bulk_uploads_performed: Int
  candidate_searches_performed: Int
  candidates_saved: Int
  created_at: timestamptz
  id: uuid
  job_applications_submitted: Int
  job_postings_active: Int
  maid_listings_active: Int
  message_threads_used: Int
  messages_sent: Int
  period_end: date
  period_start: date
  profile_views: Int
  sponsor_connections: Int
  subscription_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate stddev on columns"""
type subscription_usage_stddev_fields {
  bulk_uploads_performed: Float
  candidate_searches_performed: Float
  candidates_saved: Float
  job_applications_submitted: Float
  job_postings_active: Float
  maid_listings_active: Float
  message_threads_used: Float
  messages_sent: Float
  profile_views: Float
  sponsor_connections: Float
}

"""
order by stddev() on columns of table "subscription_usage"
"""
input subscription_usage_stddev_order_by {
  bulk_uploads_performed: order_by
  candidate_searches_performed: order_by
  candidates_saved: order_by
  job_applications_submitted: order_by
  job_postings_active: order_by
  maid_listings_active: order_by
  message_threads_used: order_by
  messages_sent: order_by
  profile_views: order_by
  sponsor_connections: order_by
}

"""aggregate stddev_pop on columns"""
type subscription_usage_stddev_pop_fields {
  bulk_uploads_performed: Float
  candidate_searches_performed: Float
  candidates_saved: Float
  job_applications_submitted: Float
  job_postings_active: Float
  maid_listings_active: Float
  message_threads_used: Float
  messages_sent: Float
  profile_views: Float
  sponsor_connections: Float
}

"""
order by stddev_pop() on columns of table "subscription_usage"
"""
input subscription_usage_stddev_pop_order_by {
  bulk_uploads_performed: order_by
  candidate_searches_performed: order_by
  candidates_saved: order_by
  job_applications_submitted: order_by
  job_postings_active: order_by
  maid_listings_active: order_by
  message_threads_used: order_by
  messages_sent: order_by
  profile_views: order_by
  sponsor_connections: order_by
}

"""aggregate stddev_samp on columns"""
type subscription_usage_stddev_samp_fields {
  bulk_uploads_performed: Float
  candidate_searches_performed: Float
  candidates_saved: Float
  job_applications_submitted: Float
  job_postings_active: Float
  maid_listings_active: Float
  message_threads_used: Float
  messages_sent: Float
  profile_views: Float
  sponsor_connections: Float
}

"""
order by stddev_samp() on columns of table "subscription_usage"
"""
input subscription_usage_stddev_samp_order_by {
  bulk_uploads_performed: order_by
  candidate_searches_performed: order_by
  candidates_saved: order_by
  job_applications_submitted: order_by
  job_postings_active: order_by
  maid_listings_active: order_by
  message_threads_used: order_by
  messages_sent: order_by
  profile_views: order_by
  sponsor_connections: order_by
}

"""
Streaming cursor of the table "subscription_usage"
"""
input subscription_usage_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: subscription_usage_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input subscription_usage_stream_cursor_value_input {
  bulk_uploads_performed: Int
  candidate_searches_performed: Int
  candidates_saved: Int
  created_at: timestamptz
  id: uuid
  job_applications_submitted: Int
  job_postings_active: Int
  maid_listings_active: Int
  message_threads_used: Int
  messages_sent: Int
  period_end: date
  period_start: date
  profile_views: Int
  sponsor_connections: Int
  subscription_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate sum on columns"""
type subscription_usage_sum_fields {
  bulk_uploads_performed: Int
  candidate_searches_performed: Int
  candidates_saved: Int
  job_applications_submitted: Int
  job_postings_active: Int
  maid_listings_active: Int
  message_threads_used: Int
  messages_sent: Int
  profile_views: Int
  sponsor_connections: Int
}

"""
order by sum() on columns of table "subscription_usage"
"""
input subscription_usage_sum_order_by {
  bulk_uploads_performed: order_by
  candidate_searches_performed: order_by
  candidates_saved: order_by
  job_applications_submitted: order_by
  job_postings_active: order_by
  maid_listings_active: order_by
  message_threads_used: order_by
  messages_sent: order_by
  profile_views: order_by
  sponsor_connections: order_by
}

"""
update columns of table "subscription_usage"
"""
enum subscription_usage_update_column {
  """column name"""
  bulk_uploads_performed

  """column name"""
  candidate_searches_performed

  """column name"""
  candidates_saved

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  job_applications_submitted

  """column name"""
  job_postings_active

  """column name"""
  maid_listings_active

  """column name"""
  message_threads_used

  """column name"""
  messages_sent

  """column name"""
  period_end

  """column name"""
  period_start

  """column name"""
  profile_views

  """column name"""
  sponsor_connections

  """column name"""
  subscription_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

input subscription_usage_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: subscription_usage_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: subscription_usage_set_input

  """filter the rows which have to be updated"""
  where: subscription_usage_bool_exp!
}

"""aggregate var_pop on columns"""
type subscription_usage_var_pop_fields {
  bulk_uploads_performed: Float
  candidate_searches_performed: Float
  candidates_saved: Float
  job_applications_submitted: Float
  job_postings_active: Float
  maid_listings_active: Float
  message_threads_used: Float
  messages_sent: Float
  profile_views: Float
  sponsor_connections: Float
}

"""
order by var_pop() on columns of table "subscription_usage"
"""
input subscription_usage_var_pop_order_by {
  bulk_uploads_performed: order_by
  candidate_searches_performed: order_by
  candidates_saved: order_by
  job_applications_submitted: order_by
  job_postings_active: order_by
  maid_listings_active: order_by
  message_threads_used: order_by
  messages_sent: order_by
  profile_views: order_by
  sponsor_connections: order_by
}

"""aggregate var_samp on columns"""
type subscription_usage_var_samp_fields {
  bulk_uploads_performed: Float
  candidate_searches_performed: Float
  candidates_saved: Float
  job_applications_submitted: Float
  job_postings_active: Float
  maid_listings_active: Float
  message_threads_used: Float
  messages_sent: Float
  profile_views: Float
  sponsor_connections: Float
}

"""
order by var_samp() on columns of table "subscription_usage"
"""
input subscription_usage_var_samp_order_by {
  bulk_uploads_performed: order_by
  candidate_searches_performed: order_by
  candidates_saved: order_by
  job_applications_submitted: order_by
  job_postings_active: order_by
  maid_listings_active: order_by
  message_threads_used: order_by
  messages_sent: order_by
  profile_views: order_by
  sponsor_connections: order_by
}

"""aggregate variance on columns"""
type subscription_usage_variance_fields {
  bulk_uploads_performed: Float
  candidate_searches_performed: Float
  candidates_saved: Float
  job_applications_submitted: Float
  job_postings_active: Float
  maid_listings_active: Float
  message_threads_used: Float
  messages_sent: Float
  profile_views: Float
  sponsor_connections: Float
}

"""
order by variance() on columns of table "subscription_usage"
"""
input subscription_usage_variance_order_by {
  bulk_uploads_performed: order_by
  candidate_searches_performed: order_by
  candidates_saved: order_by
  job_applications_submitted: order_by
  job_postings_active: order_by
  maid_listings_active: order_by
  message_threads_used: order_by
  messages_sent: order_by
  profile_views: order_by
  sponsor_connections: order_by
}

"""Stores user subscription plans and billing information"""
type subscriptions {
  amount: numeric!
  billing_period: String
  cancelled_at: timestamptz
  created_at: timestamptz
  currency: String
  end_date: date
  expires_at: timestamptz
  features(
    """JSON select path"""
    path: String
  ): jsonb

  """
  When the grace period ends for past_due subscriptions. Typically 3 days after payment failure.
  """
  grace_period_ends: timestamptz
  id: uuid!
  last_payment_attempt: timestamptz
  metadata(
    """JSON select path"""
    path: String
  ): jsonb

  """Number of payment retry attempts for failed charges"""
  payment_retry_count: Int
  payment_status: String
  plan_id: String!
  plan_name: String!

  """Standardized plan type: free, pro, or premium"""
  plan_type: String
  start_date: date!

  """
  Subscription status: active (paid and current), past_due (payment failed, in grace period), cancelled (user cancelled), expired (period ended). Note: No trial periods - subscriptions start as active immediately upon payment.
  """
  status: String!
  stripe_customer_id: String
  stripe_subscription_id: String

  """An array relationship"""
  subscription_status_logs(
    """distinct select on columns"""
    distinct_on: [subscription_status_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscription_status_log_order_by!]

    """filter the rows returned"""
    where: subscription_status_log_bool_exp
  ): [subscription_status_log!]!

  """An aggregate relationship"""
  subscription_status_logs_aggregate(
    """distinct select on columns"""
    distinct_on: [subscription_status_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscription_status_log_order_by!]

    """filter the rows returned"""
    where: subscription_status_log_bool_exp
  ): subscription_status_log_aggregate!

  """An array relationship"""
  subscription_usages(
    """distinct select on columns"""
    distinct_on: [subscription_usage_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscription_usage_order_by!]

    """filter the rows returned"""
    where: subscription_usage_bool_exp
  ): [subscription_usage!]!

  """An aggregate relationship"""
  subscription_usages_aggregate(
    """distinct select on columns"""
    distinct_on: [subscription_usage_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscription_usage_order_by!]

    """filter the rows returned"""
    where: subscription_usage_bool_exp
  ): subscription_usage_aggregate!
  trial_end_date: date
  updated_at: timestamptz
  user_id: String

  """
  Type of user: maid, sponsor, or agency. Used for feature access control.
  """
  user_type: String

  """An array relationship"""
  webhook_event_logs(
    """distinct select on columns"""
    distinct_on: [webhook_event_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [webhook_event_logs_order_by!]

    """filter the rows returned"""
    where: webhook_event_logs_bool_exp
  ): [webhook_event_logs!]!

  """An aggregate relationship"""
  webhook_event_logs_aggregate(
    """distinct select on columns"""
    distinct_on: [webhook_event_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [webhook_event_logs_order_by!]

    """filter the rows returned"""
    where: webhook_event_logs_bool_exp
  ): webhook_event_logs_aggregate!
}

"""
aggregated selection of "subscriptions"
"""
type subscriptions_aggregate {
  aggregate: subscriptions_aggregate_fields
  nodes: [subscriptions!]!
}

"""
aggregate fields of "subscriptions"
"""
type subscriptions_aggregate_fields {
  avg: subscriptions_avg_fields
  count(columns: [subscriptions_select_column!], distinct: Boolean): Int!
  max: subscriptions_max_fields
  min: subscriptions_min_fields
  stddev: subscriptions_stddev_fields
  stddev_pop: subscriptions_stddev_pop_fields
  stddev_samp: subscriptions_stddev_samp_fields
  sum: subscriptions_sum_fields
  var_pop: subscriptions_var_pop_fields
  var_samp: subscriptions_var_samp_fields
  variance: subscriptions_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input subscriptions_append_input {
  features: jsonb
  metadata: jsonb
}

"""aggregate avg on columns"""
type subscriptions_avg_fields {
  amount: Float

  """Number of payment retry attempts for failed charges"""
  payment_retry_count: Float
}

"""
Boolean expression to filter rows from the table "subscriptions". All fields are combined with a logical 'AND'.
"""
input subscriptions_bool_exp {
  _and: [subscriptions_bool_exp!]
  _not: subscriptions_bool_exp
  _or: [subscriptions_bool_exp!]
  amount: numeric_comparison_exp
  billing_period: String_comparison_exp
  cancelled_at: timestamptz_comparison_exp
  created_at: timestamptz_comparison_exp
  currency: String_comparison_exp
  end_date: date_comparison_exp
  expires_at: timestamptz_comparison_exp
  features: jsonb_comparison_exp
  grace_period_ends: timestamptz_comparison_exp
  id: uuid_comparison_exp
  last_payment_attempt: timestamptz_comparison_exp
  metadata: jsonb_comparison_exp
  payment_retry_count: Int_comparison_exp
  payment_status: String_comparison_exp
  plan_id: String_comparison_exp
  plan_name: String_comparison_exp
  plan_type: String_comparison_exp
  start_date: date_comparison_exp
  status: String_comparison_exp
  stripe_customer_id: String_comparison_exp
  stripe_subscription_id: String_comparison_exp
  subscription_status_logs: subscription_status_log_bool_exp
  subscription_status_logs_aggregate: subscription_status_log_aggregate_bool_exp
  subscription_usages: subscription_usage_bool_exp
  subscription_usages_aggregate: subscription_usage_aggregate_bool_exp
  trial_end_date: date_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
  user_type: String_comparison_exp
  webhook_event_logs: webhook_event_logs_bool_exp
  webhook_event_logs_aggregate: webhook_event_logs_aggregate_bool_exp
}

"""
unique or primary key constraints on table "subscriptions"
"""
enum subscriptions_constraint {
  """
  unique or primary key constraint on columns "stripe_subscription_id"
  """
  idx_subscriptions_stripe_sub_id

  """
  unique or primary key constraint on columns "id"
  """
  subscriptions_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input subscriptions_delete_at_path_input {
  features: [String!]
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input subscriptions_delete_elem_input {
  features: Int
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input subscriptions_delete_key_input {
  features: String
  metadata: String
}

"""
input type for incrementing numeric columns in table "subscriptions"
"""
input subscriptions_inc_input {
  amount: numeric

  """Number of payment retry attempts for failed charges"""
  payment_retry_count: Int
}

"""
input type for inserting data into table "subscriptions"
"""
input subscriptions_insert_input {
  amount: numeric
  billing_period: String
  cancelled_at: timestamptz
  created_at: timestamptz
  currency: String
  end_date: date
  expires_at: timestamptz
  features: jsonb

  """
  When the grace period ends for past_due subscriptions. Typically 3 days after payment failure.
  """
  grace_period_ends: timestamptz
  id: uuid
  last_payment_attempt: timestamptz
  metadata: jsonb

  """Number of payment retry attempts for failed charges"""
  payment_retry_count: Int
  payment_status: String
  plan_id: String
  plan_name: String

  """Standardized plan type: free, pro, or premium"""
  plan_type: String
  start_date: date

  """
  Subscription status: active (paid and current), past_due (payment failed, in grace period), cancelled (user cancelled), expired (period ended). Note: No trial periods - subscriptions start as active immediately upon payment.
  """
  status: String
  stripe_customer_id: String
  stripe_subscription_id: String
  subscription_status_logs: subscription_status_log_arr_rel_insert_input
  subscription_usages: subscription_usage_arr_rel_insert_input
  trial_end_date: date
  updated_at: timestamptz
  user_id: String

  """
  Type of user: maid, sponsor, or agency. Used for feature access control.
  """
  user_type: String
  webhook_event_logs: webhook_event_logs_arr_rel_insert_input
}

"""aggregate max on columns"""
type subscriptions_max_fields {
  amount: numeric
  billing_period: String
  cancelled_at: timestamptz
  created_at: timestamptz
  currency: String
  end_date: date
  expires_at: timestamptz

  """
  When the grace period ends for past_due subscriptions. Typically 3 days after payment failure.
  """
  grace_period_ends: timestamptz
  id: uuid
  last_payment_attempt: timestamptz

  """Number of payment retry attempts for failed charges"""
  payment_retry_count: Int
  payment_status: String
  plan_id: String
  plan_name: String

  """Standardized plan type: free, pro, or premium"""
  plan_type: String
  start_date: date

  """
  Subscription status: active (paid and current), past_due (payment failed, in grace period), cancelled (user cancelled), expired (period ended). Note: No trial periods - subscriptions start as active immediately upon payment.
  """
  status: String
  stripe_customer_id: String
  stripe_subscription_id: String
  trial_end_date: date
  updated_at: timestamptz
  user_id: String

  """
  Type of user: maid, sponsor, or agency. Used for feature access control.
  """
  user_type: String
}

"""aggregate min on columns"""
type subscriptions_min_fields {
  amount: numeric
  billing_period: String
  cancelled_at: timestamptz
  created_at: timestamptz
  currency: String
  end_date: date
  expires_at: timestamptz

  """
  When the grace period ends for past_due subscriptions. Typically 3 days after payment failure.
  """
  grace_period_ends: timestamptz
  id: uuid
  last_payment_attempt: timestamptz

  """Number of payment retry attempts for failed charges"""
  payment_retry_count: Int
  payment_status: String
  plan_id: String
  plan_name: String

  """Standardized plan type: free, pro, or premium"""
  plan_type: String
  start_date: date

  """
  Subscription status: active (paid and current), past_due (payment failed, in grace period), cancelled (user cancelled), expired (period ended). Note: No trial periods - subscriptions start as active immediately upon payment.
  """
  status: String
  stripe_customer_id: String
  stripe_subscription_id: String
  trial_end_date: date
  updated_at: timestamptz
  user_id: String

  """
  Type of user: maid, sponsor, or agency. Used for feature access control.
  """
  user_type: String
}

"""
response of any mutation on the table "subscriptions"
"""
type subscriptions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [subscriptions!]!
}

"""
input type for inserting object relation for remote table "subscriptions"
"""
input subscriptions_obj_rel_insert_input {
  data: subscriptions_insert_input!

  """upsert condition"""
  on_conflict: subscriptions_on_conflict
}

"""
on_conflict condition type for table "subscriptions"
"""
input subscriptions_on_conflict {
  constraint: subscriptions_constraint!
  update_columns: [subscriptions_update_column!]! = []
  where: subscriptions_bool_exp
}

"""Ordering options when selecting data from "subscriptions"."""
input subscriptions_order_by {
  amount: order_by
  billing_period: order_by
  cancelled_at: order_by
  created_at: order_by
  currency: order_by
  end_date: order_by
  expires_at: order_by
  features: order_by
  grace_period_ends: order_by
  id: order_by
  last_payment_attempt: order_by
  metadata: order_by
  payment_retry_count: order_by
  payment_status: order_by
  plan_id: order_by
  plan_name: order_by
  plan_type: order_by
  start_date: order_by
  status: order_by
  stripe_customer_id: order_by
  stripe_subscription_id: order_by
  subscription_status_logs_aggregate: subscription_status_log_aggregate_order_by
  subscription_usages_aggregate: subscription_usage_aggregate_order_by
  trial_end_date: order_by
  updated_at: order_by
  user_id: order_by
  user_type: order_by
  webhook_event_logs_aggregate: webhook_event_logs_aggregate_order_by
}

"""primary key columns input for table: subscriptions"""
input subscriptions_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input subscriptions_prepend_input {
  features: jsonb
  metadata: jsonb
}

"""
select columns of table "subscriptions"
"""
enum subscriptions_select_column {
  """column name"""
  amount

  """column name"""
  billing_period

  """column name"""
  cancelled_at

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  end_date

  """column name"""
  expires_at

  """column name"""
  features

  """column name"""
  grace_period_ends

  """column name"""
  id

  """column name"""
  last_payment_attempt

  """column name"""
  metadata

  """column name"""
  payment_retry_count

  """column name"""
  payment_status

  """column name"""
  plan_id

  """column name"""
  plan_name

  """column name"""
  plan_type

  """column name"""
  start_date

  """column name"""
  status

  """column name"""
  stripe_customer_id

  """column name"""
  stripe_subscription_id

  """column name"""
  trial_end_date

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  user_type
}

"""
input type for updating data in table "subscriptions"
"""
input subscriptions_set_input {
  amount: numeric
  billing_period: String
  cancelled_at: timestamptz
  created_at: timestamptz
  currency: String
  end_date: date
  expires_at: timestamptz
  features: jsonb

  """
  When the grace period ends for past_due subscriptions. Typically 3 days after payment failure.
  """
  grace_period_ends: timestamptz
  id: uuid
  last_payment_attempt: timestamptz
  metadata: jsonb

  """Number of payment retry attempts for failed charges"""
  payment_retry_count: Int
  payment_status: String
  plan_id: String
  plan_name: String

  """Standardized plan type: free, pro, or premium"""
  plan_type: String
  start_date: date

  """
  Subscription status: active (paid and current), past_due (payment failed, in grace period), cancelled (user cancelled), expired (period ended). Note: No trial periods - subscriptions start as active immediately upon payment.
  """
  status: String
  stripe_customer_id: String
  stripe_subscription_id: String
  trial_end_date: date
  updated_at: timestamptz
  user_id: String

  """
  Type of user: maid, sponsor, or agency. Used for feature access control.
  """
  user_type: String
}

"""aggregate stddev on columns"""
type subscriptions_stddev_fields {
  amount: Float

  """Number of payment retry attempts for failed charges"""
  payment_retry_count: Float
}

"""aggregate stddev_pop on columns"""
type subscriptions_stddev_pop_fields {
  amount: Float

  """Number of payment retry attempts for failed charges"""
  payment_retry_count: Float
}

"""aggregate stddev_samp on columns"""
type subscriptions_stddev_samp_fields {
  amount: Float

  """Number of payment retry attempts for failed charges"""
  payment_retry_count: Float
}

"""
Streaming cursor of the table "subscriptions"
"""
input subscriptions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: subscriptions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input subscriptions_stream_cursor_value_input {
  amount: numeric
  billing_period: String
  cancelled_at: timestamptz
  created_at: timestamptz
  currency: String
  end_date: date
  expires_at: timestamptz
  features: jsonb

  """
  When the grace period ends for past_due subscriptions. Typically 3 days after payment failure.
  """
  grace_period_ends: timestamptz
  id: uuid
  last_payment_attempt: timestamptz
  metadata: jsonb

  """Number of payment retry attempts for failed charges"""
  payment_retry_count: Int
  payment_status: String
  plan_id: String
  plan_name: String

  """Standardized plan type: free, pro, or premium"""
  plan_type: String
  start_date: date

  """
  Subscription status: active (paid and current), past_due (payment failed, in grace period), cancelled (user cancelled), expired (period ended). Note: No trial periods - subscriptions start as active immediately upon payment.
  """
  status: String
  stripe_customer_id: String
  stripe_subscription_id: String
  trial_end_date: date
  updated_at: timestamptz
  user_id: String

  """
  Type of user: maid, sponsor, or agency. Used for feature access control.
  """
  user_type: String
}

"""aggregate sum on columns"""
type subscriptions_sum_fields {
  amount: numeric

  """Number of payment retry attempts for failed charges"""
  payment_retry_count: Int
}

"""
update columns of table "subscriptions"
"""
enum subscriptions_update_column {
  """column name"""
  amount

  """column name"""
  billing_period

  """column name"""
  cancelled_at

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  end_date

  """column name"""
  expires_at

  """column name"""
  features

  """column name"""
  grace_period_ends

  """column name"""
  id

  """column name"""
  last_payment_attempt

  """column name"""
  metadata

  """column name"""
  payment_retry_count

  """column name"""
  payment_status

  """column name"""
  plan_id

  """column name"""
  plan_name

  """column name"""
  plan_type

  """column name"""
  start_date

  """column name"""
  status

  """column name"""
  stripe_customer_id

  """column name"""
  stripe_subscription_id

  """column name"""
  trial_end_date

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  user_type
}

input subscriptions_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: subscriptions_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: subscriptions_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: subscriptions_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: subscriptions_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: subscriptions_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: subscriptions_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: subscriptions_set_input

  """filter the rows which have to be updated"""
  where: subscriptions_bool_exp!
}

"""aggregate var_pop on columns"""
type subscriptions_var_pop_fields {
  amount: Float

  """Number of payment retry attempts for failed charges"""
  payment_retry_count: Float
}

"""aggregate var_samp on columns"""
type subscriptions_var_samp_fields {
  amount: Float

  """Number of payment retry attempts for failed charges"""
  payment_retry_count: Float
}

"""aggregate variance on columns"""
type subscriptions_variance_fields {
  amount: Float

  """Number of payment retry attempts for failed charges"""
  payment_retry_count: Float
}

"""
columns and relationships of "supabase_migrations.schema_migrations"
"""
type supabase_migrations_schema_migrations {
  name: String
  statements: [String!]
  version: String!
}

"""
aggregated selection of "supabase_migrations.schema_migrations"
"""
type supabase_migrations_schema_migrations_aggregate {
  aggregate: supabase_migrations_schema_migrations_aggregate_fields
  nodes: [supabase_migrations_schema_migrations!]!
}

"""
aggregate fields of "supabase_migrations.schema_migrations"
"""
type supabase_migrations_schema_migrations_aggregate_fields {
  count(columns: [supabase_migrations_schema_migrations_select_column!], distinct: Boolean): Int!
  max: supabase_migrations_schema_migrations_max_fields
  min: supabase_migrations_schema_migrations_min_fields
}

"""
Boolean expression to filter rows from the table "supabase_migrations.schema_migrations". All fields are combined with a logical 'AND'.
"""
input supabase_migrations_schema_migrations_bool_exp {
  _and: [supabase_migrations_schema_migrations_bool_exp!]
  _not: supabase_migrations_schema_migrations_bool_exp
  _or: [supabase_migrations_schema_migrations_bool_exp!]
  name: String_comparison_exp
  statements: String_array_comparison_exp
  version: String_comparison_exp
}

"""
unique or primary key constraints on table "supabase_migrations.schema_migrations"
"""
enum supabase_migrations_schema_migrations_constraint {
  """
  unique or primary key constraint on columns "version"
  """
  schema_migrations_pkey
}

"""
input type for inserting data into table "supabase_migrations.schema_migrations"
"""
input supabase_migrations_schema_migrations_insert_input {
  name: String
  statements: [String!]
  version: String
}

"""aggregate max on columns"""
type supabase_migrations_schema_migrations_max_fields {
  name: String
  statements: [String!]
  version: String
}

"""aggregate min on columns"""
type supabase_migrations_schema_migrations_min_fields {
  name: String
  statements: [String!]
  version: String
}

"""
response of any mutation on the table "supabase_migrations.schema_migrations"
"""
type supabase_migrations_schema_migrations_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [supabase_migrations_schema_migrations!]!
}

"""
on_conflict condition type for table "supabase_migrations.schema_migrations"
"""
input supabase_migrations_schema_migrations_on_conflict {
  constraint: supabase_migrations_schema_migrations_constraint!
  update_columns: [supabase_migrations_schema_migrations_update_column!]! = []
  where: supabase_migrations_schema_migrations_bool_exp
}

"""
Ordering options when selecting data from "supabase_migrations.schema_migrations".
"""
input supabase_migrations_schema_migrations_order_by {
  name: order_by
  statements: order_by
  version: order_by
}

"""
primary key columns input for table: supabase_migrations.schema_migrations
"""
input supabase_migrations_schema_migrations_pk_columns_input {
  version: String!
}

"""
select columns of table "supabase_migrations.schema_migrations"
"""
enum supabase_migrations_schema_migrations_select_column {
  """column name"""
  name

  """column name"""
  statements

  """column name"""
  version
}

"""
input type for updating data in table "supabase_migrations.schema_migrations"
"""
input supabase_migrations_schema_migrations_set_input {
  name: String
  statements: [String!]
  version: String
}

"""
Streaming cursor of the table "supabase_migrations_schema_migrations"
"""
input supabase_migrations_schema_migrations_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: supabase_migrations_schema_migrations_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input supabase_migrations_schema_migrations_stream_cursor_value_input {
  name: String
  statements: [String!]
  version: String
}

"""
update columns of table "supabase_migrations.schema_migrations"
"""
enum supabase_migrations_schema_migrations_update_column {
  """column name"""
  name

  """column name"""
  statements

  """column name"""
  version
}

input supabase_migrations_schema_migrations_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: supabase_migrations_schema_migrations_set_input

  """filter the rows which have to be updated"""
  where: supabase_migrations_schema_migrations_bool_exp!
}

"""
columns and relationships of "supabase_migrations.seed_files"
"""
type supabase_migrations_seed_files {
  hash: String!
  path: String!
}

"""
aggregated selection of "supabase_migrations.seed_files"
"""
type supabase_migrations_seed_files_aggregate {
  aggregate: supabase_migrations_seed_files_aggregate_fields
  nodes: [supabase_migrations_seed_files!]!
}

"""
aggregate fields of "supabase_migrations.seed_files"
"""
type supabase_migrations_seed_files_aggregate_fields {
  count(columns: [supabase_migrations_seed_files_select_column!], distinct: Boolean): Int!
  max: supabase_migrations_seed_files_max_fields
  min: supabase_migrations_seed_files_min_fields
}

"""
Boolean expression to filter rows from the table "supabase_migrations.seed_files". All fields are combined with a logical 'AND'.
"""
input supabase_migrations_seed_files_bool_exp {
  _and: [supabase_migrations_seed_files_bool_exp!]
  _not: supabase_migrations_seed_files_bool_exp
  _or: [supabase_migrations_seed_files_bool_exp!]
  hash: String_comparison_exp
  path: String_comparison_exp
}

"""
unique or primary key constraints on table "supabase_migrations.seed_files"
"""
enum supabase_migrations_seed_files_constraint {
  """
  unique or primary key constraint on columns "path"
  """
  seed_files_pkey
}

"""
input type for inserting data into table "supabase_migrations.seed_files"
"""
input supabase_migrations_seed_files_insert_input {
  hash: String
  path: String
}

"""aggregate max on columns"""
type supabase_migrations_seed_files_max_fields {
  hash: String
  path: String
}

"""aggregate min on columns"""
type supabase_migrations_seed_files_min_fields {
  hash: String
  path: String
}

"""
response of any mutation on the table "supabase_migrations.seed_files"
"""
type supabase_migrations_seed_files_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [supabase_migrations_seed_files!]!
}

"""
on_conflict condition type for table "supabase_migrations.seed_files"
"""
input supabase_migrations_seed_files_on_conflict {
  constraint: supabase_migrations_seed_files_constraint!
  update_columns: [supabase_migrations_seed_files_update_column!]! = []
  where: supabase_migrations_seed_files_bool_exp
}

"""
Ordering options when selecting data from "supabase_migrations.seed_files".
"""
input supabase_migrations_seed_files_order_by {
  hash: order_by
  path: order_by
}

"""primary key columns input for table: supabase_migrations.seed_files"""
input supabase_migrations_seed_files_pk_columns_input {
  path: String!
}

"""
select columns of table "supabase_migrations.seed_files"
"""
enum supabase_migrations_seed_files_select_column {
  """column name"""
  hash

  """column name"""
  path
}

"""
input type for updating data in table "supabase_migrations.seed_files"
"""
input supabase_migrations_seed_files_set_input {
  hash: String
  path: String
}

"""
Streaming cursor of the table "supabase_migrations_seed_files"
"""
input supabase_migrations_seed_files_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: supabase_migrations_seed_files_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input supabase_migrations_seed_files_stream_cursor_value_input {
  hash: String
  path: String
}

"""
update columns of table "supabase_migrations.seed_files"
"""
enum supabase_migrations_seed_files_update_column {
  """column name"""
  hash

  """column name"""
  path
}

input supabase_migrations_seed_files_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: supabase_migrations_seed_files_set_input

  """filter the rows which have to be updated"""
  where: supabase_migrations_seed_files_bool_exp!
}

"""Support agent profiles and availability"""
type support_agents {
  agent_email: String!
  agent_name: String!
  average_response_time: interval
  created_at: timestamptz
  department: String
  id: uuid!
  is_available: Boolean
  languages: [String!]
  last_active_at: timestamptz
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  resolved_tickets: Int
  satisfaction_rating: numeric
  specialties: [String!]

  """Agent availability status: online, away, busy, offline"""
  status: String!
  total_tickets: Int
  updated_at: timestamptz
  user_id: uuid!
  working_hours(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
aggregated selection of "support_agents"
"""
type support_agents_aggregate {
  aggregate: support_agents_aggregate_fields
  nodes: [support_agents!]!
}

"""
aggregate fields of "support_agents"
"""
type support_agents_aggregate_fields {
  avg: support_agents_avg_fields
  count(columns: [support_agents_select_column!], distinct: Boolean): Int!
  max: support_agents_max_fields
  min: support_agents_min_fields
  stddev: support_agents_stddev_fields
  stddev_pop: support_agents_stddev_pop_fields
  stddev_samp: support_agents_stddev_samp_fields
  sum: support_agents_sum_fields
  var_pop: support_agents_var_pop_fields
  var_samp: support_agents_var_samp_fields
  variance: support_agents_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input support_agents_append_input {
  metadata: jsonb
  working_hours: jsonb
}

"""aggregate avg on columns"""
type support_agents_avg_fields {
  resolved_tickets: Float
  satisfaction_rating: Float
  total_tickets: Float
}

"""
Boolean expression to filter rows from the table "support_agents". All fields are combined with a logical 'AND'.
"""
input support_agents_bool_exp {
  _and: [support_agents_bool_exp!]
  _not: support_agents_bool_exp
  _or: [support_agents_bool_exp!]
  agent_email: String_comparison_exp
  agent_name: String_comparison_exp
  average_response_time: interval_comparison_exp
  created_at: timestamptz_comparison_exp
  department: String_comparison_exp
  id: uuid_comparison_exp
  is_available: Boolean_comparison_exp
  languages: String_array_comparison_exp
  last_active_at: timestamptz_comparison_exp
  metadata: jsonb_comparison_exp
  resolved_tickets: Int_comparison_exp
  satisfaction_rating: numeric_comparison_exp
  specialties: String_array_comparison_exp
  status: String_comparison_exp
  total_tickets: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: uuid_comparison_exp
  working_hours: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "support_agents"
"""
enum support_agents_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  support_agents_pkey

  """
  unique or primary key constraint on columns "user_id"
  """
  support_agents_user_id_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input support_agents_delete_at_path_input {
  metadata: [String!]
  working_hours: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input support_agents_delete_elem_input {
  metadata: Int
  working_hours: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input support_agents_delete_key_input {
  metadata: String
  working_hours: String
}

"""
input type for incrementing numeric columns in table "support_agents"
"""
input support_agents_inc_input {
  resolved_tickets: Int
  satisfaction_rating: numeric
  total_tickets: Int
}

"""
input type for inserting data into table "support_agents"
"""
input support_agents_insert_input {
  agent_email: String
  agent_name: String
  average_response_time: interval
  created_at: timestamptz
  department: String
  id: uuid
  is_available: Boolean
  languages: [String!]
  last_active_at: timestamptz
  metadata: jsonb
  resolved_tickets: Int
  satisfaction_rating: numeric
  specialties: [String!]

  """Agent availability status: online, away, busy, offline"""
  status: String
  total_tickets: Int
  updated_at: timestamptz
  user_id: uuid
  working_hours: jsonb
}

"""aggregate max on columns"""
type support_agents_max_fields {
  agent_email: String
  agent_name: String
  created_at: timestamptz
  department: String
  id: uuid
  languages: [String!]
  last_active_at: timestamptz
  resolved_tickets: Int
  satisfaction_rating: numeric
  specialties: [String!]

  """Agent availability status: online, away, busy, offline"""
  status: String
  total_tickets: Int
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate min on columns"""
type support_agents_min_fields {
  agent_email: String
  agent_name: String
  created_at: timestamptz
  department: String
  id: uuid
  languages: [String!]
  last_active_at: timestamptz
  resolved_tickets: Int
  satisfaction_rating: numeric
  specialties: [String!]

  """Agent availability status: online, away, busy, offline"""
  status: String
  total_tickets: Int
  updated_at: timestamptz
  user_id: uuid
}

"""
response of any mutation on the table "support_agents"
"""
type support_agents_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [support_agents!]!
}

"""
on_conflict condition type for table "support_agents"
"""
input support_agents_on_conflict {
  constraint: support_agents_constraint!
  update_columns: [support_agents_update_column!]! = []
  where: support_agents_bool_exp
}

"""Ordering options when selecting data from "support_agents"."""
input support_agents_order_by {
  agent_email: order_by
  agent_name: order_by
  average_response_time: order_by
  created_at: order_by
  department: order_by
  id: order_by
  is_available: order_by
  languages: order_by
  last_active_at: order_by
  metadata: order_by
  resolved_tickets: order_by
  satisfaction_rating: order_by
  specialties: order_by
  status: order_by
  total_tickets: order_by
  updated_at: order_by
  user_id: order_by
  working_hours: order_by
}

"""primary key columns input for table: support_agents"""
input support_agents_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input support_agents_prepend_input {
  metadata: jsonb
  working_hours: jsonb
}

"""
select columns of table "support_agents"
"""
enum support_agents_select_column {
  """column name"""
  agent_email

  """column name"""
  agent_name

  """column name"""
  average_response_time

  """column name"""
  created_at

  """column name"""
  department

  """column name"""
  id

  """column name"""
  is_available

  """column name"""
  languages

  """column name"""
  last_active_at

  """column name"""
  metadata

  """column name"""
  resolved_tickets

  """column name"""
  satisfaction_rating

  """column name"""
  specialties

  """column name"""
  status

  """column name"""
  total_tickets

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  working_hours
}

"""
input type for updating data in table "support_agents"
"""
input support_agents_set_input {
  agent_email: String
  agent_name: String
  average_response_time: interval
  created_at: timestamptz
  department: String
  id: uuid
  is_available: Boolean
  languages: [String!]
  last_active_at: timestamptz
  metadata: jsonb
  resolved_tickets: Int
  satisfaction_rating: numeric
  specialties: [String!]

  """Agent availability status: online, away, busy, offline"""
  status: String
  total_tickets: Int
  updated_at: timestamptz
  user_id: uuid
  working_hours: jsonb
}

"""aggregate stddev on columns"""
type support_agents_stddev_fields {
  resolved_tickets: Float
  satisfaction_rating: Float
  total_tickets: Float
}

"""aggregate stddev_pop on columns"""
type support_agents_stddev_pop_fields {
  resolved_tickets: Float
  satisfaction_rating: Float
  total_tickets: Float
}

"""aggregate stddev_samp on columns"""
type support_agents_stddev_samp_fields {
  resolved_tickets: Float
  satisfaction_rating: Float
  total_tickets: Float
}

"""
Streaming cursor of the table "support_agents"
"""
input support_agents_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: support_agents_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input support_agents_stream_cursor_value_input {
  agent_email: String
  agent_name: String
  average_response_time: interval
  created_at: timestamptz
  department: String
  id: uuid
  is_available: Boolean
  languages: [String!]
  last_active_at: timestamptz
  metadata: jsonb
  resolved_tickets: Int
  satisfaction_rating: numeric
  specialties: [String!]

  """Agent availability status: online, away, busy, offline"""
  status: String
  total_tickets: Int
  updated_at: timestamptz
  user_id: uuid
  working_hours: jsonb
}

"""aggregate sum on columns"""
type support_agents_sum_fields {
  resolved_tickets: Int
  satisfaction_rating: numeric
  total_tickets: Int
}

"""
update columns of table "support_agents"
"""
enum support_agents_update_column {
  """column name"""
  agent_email

  """column name"""
  agent_name

  """column name"""
  average_response_time

  """column name"""
  created_at

  """column name"""
  department

  """column name"""
  id

  """column name"""
  is_available

  """column name"""
  languages

  """column name"""
  last_active_at

  """column name"""
  metadata

  """column name"""
  resolved_tickets

  """column name"""
  satisfaction_rating

  """column name"""
  specialties

  """column name"""
  status

  """column name"""
  total_tickets

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  working_hours
}

input support_agents_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: support_agents_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: support_agents_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: support_agents_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: support_agents_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: support_agents_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: support_agents_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: support_agents_set_input

  """filter the rows which have to be updated"""
  where: support_agents_bool_exp!
}

"""aggregate var_pop on columns"""
type support_agents_var_pop_fields {
  resolved_tickets: Float
  satisfaction_rating: Float
  total_tickets: Float
}

"""aggregate var_samp on columns"""
type support_agents_var_samp_fields {
  resolved_tickets: Float
  satisfaction_rating: Float
  total_tickets: Float
}

"""aggregate variance on columns"""
type support_agents_variance_fields {
  resolved_tickets: Float
  satisfaction_rating: Float
  total_tickets: Float
}

"""User interactions with support system"""
type support_interactions {
  created_at: timestamptz
  id: uuid!
  interaction_data(
    """JSON select path"""
    path: String
  ): jsonb
  interaction_type: String!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  page_url: String
  session_id: String
  user_agent: String
  user_id: uuid
}

"""
aggregated selection of "support_interactions"
"""
type support_interactions_aggregate {
  aggregate: support_interactions_aggregate_fields
  nodes: [support_interactions!]!
}

"""
aggregate fields of "support_interactions"
"""
type support_interactions_aggregate_fields {
  count(columns: [support_interactions_select_column!], distinct: Boolean): Int!
  max: support_interactions_max_fields
  min: support_interactions_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input support_interactions_append_input {
  interaction_data: jsonb
  metadata: jsonb
}

"""
Boolean expression to filter rows from the table "support_interactions". All fields are combined with a logical 'AND'.
"""
input support_interactions_bool_exp {
  _and: [support_interactions_bool_exp!]
  _not: support_interactions_bool_exp
  _or: [support_interactions_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  interaction_data: jsonb_comparison_exp
  interaction_type: String_comparison_exp
  metadata: jsonb_comparison_exp
  page_url: String_comparison_exp
  session_id: String_comparison_exp
  user_agent: String_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "support_interactions"
"""
enum support_interactions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  support_interactions_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input support_interactions_delete_at_path_input {
  interaction_data: [String!]
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input support_interactions_delete_elem_input {
  interaction_data: Int
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input support_interactions_delete_key_input {
  interaction_data: String
  metadata: String
}

"""
input type for inserting data into table "support_interactions"
"""
input support_interactions_insert_input {
  created_at: timestamptz
  id: uuid
  interaction_data: jsonb
  interaction_type: String
  metadata: jsonb
  page_url: String
  session_id: String
  user_agent: String
  user_id: uuid
}

"""aggregate max on columns"""
type support_interactions_max_fields {
  created_at: timestamptz
  id: uuid
  interaction_type: String
  page_url: String
  session_id: String
  user_agent: String
  user_id: uuid
}

"""aggregate min on columns"""
type support_interactions_min_fields {
  created_at: timestamptz
  id: uuid
  interaction_type: String
  page_url: String
  session_id: String
  user_agent: String
  user_id: uuid
}

"""
response of any mutation on the table "support_interactions"
"""
type support_interactions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [support_interactions!]!
}

"""
on_conflict condition type for table "support_interactions"
"""
input support_interactions_on_conflict {
  constraint: support_interactions_constraint!
  update_columns: [support_interactions_update_column!]! = []
  where: support_interactions_bool_exp
}

"""Ordering options when selecting data from "support_interactions"."""
input support_interactions_order_by {
  created_at: order_by
  id: order_by
  interaction_data: order_by
  interaction_type: order_by
  metadata: order_by
  page_url: order_by
  session_id: order_by
  user_agent: order_by
  user_id: order_by
}

"""primary key columns input for table: support_interactions"""
input support_interactions_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input support_interactions_prepend_input {
  interaction_data: jsonb
  metadata: jsonb
}

"""
select columns of table "support_interactions"
"""
enum support_interactions_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  interaction_data

  """column name"""
  interaction_type

  """column name"""
  metadata

  """column name"""
  page_url

  """column name"""
  session_id

  """column name"""
  user_agent

  """column name"""
  user_id
}

"""
input type for updating data in table "support_interactions"
"""
input support_interactions_set_input {
  created_at: timestamptz
  id: uuid
  interaction_data: jsonb
  interaction_type: String
  metadata: jsonb
  page_url: String
  session_id: String
  user_agent: String
  user_id: uuid
}

"""
Streaming cursor of the table "support_interactions"
"""
input support_interactions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: support_interactions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input support_interactions_stream_cursor_value_input {
  created_at: timestamptz
  id: uuid
  interaction_data: jsonb
  interaction_type: String
  metadata: jsonb
  page_url: String
  session_id: String
  user_agent: String
  user_id: uuid
}

"""
update columns of table "support_interactions"
"""
enum support_interactions_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  interaction_data

  """column name"""
  interaction_type

  """column name"""
  metadata

  """column name"""
  page_url

  """column name"""
  session_id

  """column name"""
  user_agent

  """column name"""
  user_id
}

input support_interactions_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: support_interactions_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: support_interactions_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: support_interactions_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: support_interactions_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: support_interactions_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: support_interactions_set_input

  """filter the rows which have to be updated"""
  where: support_interactions_bool_exp!
}

"""Messages within support tickets"""
type support_messages {
  attachments(
    """JSON select path"""
    path: String
  ): jsonb
  created_at: timestamptz
  id: uuid!
  is_internal: Boolean
  is_read: Boolean
  message: String!
  message_type: String
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  read_at: timestamptz
  sender_id: uuid
  sender_name: String!
  sender_type: String!

  """An object relationship"""
  support_ticket: support_tickets!
  ticket_id: uuid!
  updated_at: timestamptz
}

"""
aggregated selection of "support_messages"
"""
type support_messages_aggregate {
  aggregate: support_messages_aggregate_fields
  nodes: [support_messages!]!
}

input support_messages_aggregate_bool_exp {
  bool_and: support_messages_aggregate_bool_exp_bool_and
  bool_or: support_messages_aggregate_bool_exp_bool_or
  count: support_messages_aggregate_bool_exp_count
}

input support_messages_aggregate_bool_exp_bool_and {
  arguments: support_messages_select_column_support_messages_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: support_messages_bool_exp
  predicate: Boolean_comparison_exp!
}

input support_messages_aggregate_bool_exp_bool_or {
  arguments: support_messages_select_column_support_messages_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: support_messages_bool_exp
  predicate: Boolean_comparison_exp!
}

input support_messages_aggregate_bool_exp_count {
  arguments: [support_messages_select_column!]
  distinct: Boolean
  filter: support_messages_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "support_messages"
"""
type support_messages_aggregate_fields {
  count(columns: [support_messages_select_column!], distinct: Boolean): Int!
  max: support_messages_max_fields
  min: support_messages_min_fields
}

"""
order by aggregate values of table "support_messages"
"""
input support_messages_aggregate_order_by {
  count: order_by
  max: support_messages_max_order_by
  min: support_messages_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input support_messages_append_input {
  attachments: jsonb
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "support_messages"
"""
input support_messages_arr_rel_insert_input {
  data: [support_messages_insert_input!]!

  """upsert condition"""
  on_conflict: support_messages_on_conflict
}

"""
Boolean expression to filter rows from the table "support_messages". All fields are combined with a logical 'AND'.
"""
input support_messages_bool_exp {
  _and: [support_messages_bool_exp!]
  _not: support_messages_bool_exp
  _or: [support_messages_bool_exp!]
  attachments: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  is_internal: Boolean_comparison_exp
  is_read: Boolean_comparison_exp
  message: String_comparison_exp
  message_type: String_comparison_exp
  metadata: jsonb_comparison_exp
  read_at: timestamptz_comparison_exp
  sender_id: uuid_comparison_exp
  sender_name: String_comparison_exp
  sender_type: String_comparison_exp
  support_ticket: support_tickets_bool_exp
  ticket_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "support_messages"
"""
enum support_messages_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  support_messages_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input support_messages_delete_at_path_input {
  attachments: [String!]
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input support_messages_delete_elem_input {
  attachments: Int
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input support_messages_delete_key_input {
  attachments: String
  metadata: String
}

"""
input type for inserting data into table "support_messages"
"""
input support_messages_insert_input {
  attachments: jsonb
  created_at: timestamptz
  id: uuid
  is_internal: Boolean
  is_read: Boolean
  message: String
  message_type: String
  metadata: jsonb
  read_at: timestamptz
  sender_id: uuid
  sender_name: String
  sender_type: String
  support_ticket: support_tickets_obj_rel_insert_input
  ticket_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type support_messages_max_fields {
  created_at: timestamptz
  id: uuid
  message: String
  message_type: String
  read_at: timestamptz
  sender_id: uuid
  sender_name: String
  sender_type: String
  ticket_id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "support_messages"
"""
input support_messages_max_order_by {
  created_at: order_by
  id: order_by
  message: order_by
  message_type: order_by
  read_at: order_by
  sender_id: order_by
  sender_name: order_by
  sender_type: order_by
  ticket_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type support_messages_min_fields {
  created_at: timestamptz
  id: uuid
  message: String
  message_type: String
  read_at: timestamptz
  sender_id: uuid
  sender_name: String
  sender_type: String
  ticket_id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "support_messages"
"""
input support_messages_min_order_by {
  created_at: order_by
  id: order_by
  message: order_by
  message_type: order_by
  read_at: order_by
  sender_id: order_by
  sender_name: order_by
  sender_type: order_by
  ticket_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "support_messages"
"""
type support_messages_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [support_messages!]!
}

"""
on_conflict condition type for table "support_messages"
"""
input support_messages_on_conflict {
  constraint: support_messages_constraint!
  update_columns: [support_messages_update_column!]! = []
  where: support_messages_bool_exp
}

"""Ordering options when selecting data from "support_messages"."""
input support_messages_order_by {
  attachments: order_by
  created_at: order_by
  id: order_by
  is_internal: order_by
  is_read: order_by
  message: order_by
  message_type: order_by
  metadata: order_by
  read_at: order_by
  sender_id: order_by
  sender_name: order_by
  sender_type: order_by
  support_ticket: support_tickets_order_by
  ticket_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: support_messages"""
input support_messages_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input support_messages_prepend_input {
  attachments: jsonb
  metadata: jsonb
}

"""
select columns of table "support_messages"
"""
enum support_messages_select_column {
  """column name"""
  attachments

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  is_internal

  """column name"""
  is_read

  """column name"""
  message

  """column name"""
  message_type

  """column name"""
  metadata

  """column name"""
  read_at

  """column name"""
  sender_id

  """column name"""
  sender_name

  """column name"""
  sender_type

  """column name"""
  ticket_id

  """column name"""
  updated_at
}

"""
select "support_messages_aggregate_bool_exp_bool_and_arguments_columns" columns of table "support_messages"
"""
enum support_messages_select_column_support_messages_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_internal

  """column name"""
  is_read
}

"""
select "support_messages_aggregate_bool_exp_bool_or_arguments_columns" columns of table "support_messages"
"""
enum support_messages_select_column_support_messages_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_internal

  """column name"""
  is_read
}

"""
input type for updating data in table "support_messages"
"""
input support_messages_set_input {
  attachments: jsonb
  created_at: timestamptz
  id: uuid
  is_internal: Boolean
  is_read: Boolean
  message: String
  message_type: String
  metadata: jsonb
  read_at: timestamptz
  sender_id: uuid
  sender_name: String
  sender_type: String
  ticket_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "support_messages"
"""
input support_messages_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: support_messages_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input support_messages_stream_cursor_value_input {
  attachments: jsonb
  created_at: timestamptz
  id: uuid
  is_internal: Boolean
  is_read: Boolean
  message: String
  message_type: String
  metadata: jsonb
  read_at: timestamptz
  sender_id: uuid
  sender_name: String
  sender_type: String
  ticket_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "support_messages"
"""
enum support_messages_update_column {
  """column name"""
  attachments

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  is_internal

  """column name"""
  is_read

  """column name"""
  message

  """column name"""
  message_type

  """column name"""
  metadata

  """column name"""
  read_at

  """column name"""
  sender_id

  """column name"""
  sender_name

  """column name"""
  sender_type

  """column name"""
  ticket_id

  """column name"""
  updated_at
}

input support_messages_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: support_messages_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: support_messages_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: support_messages_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: support_messages_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: support_messages_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: support_messages_set_input

  """filter the rows which have to be updated"""
  where: support_messages_bool_exp!
}

"""Customer support tickets and inquiries"""
type support_tickets {
  assigned_agent_id: uuid
  assigned_agent_name: String
  browser_info(
    """JSON select path"""
    path: String
  ): jsonb

  """Support category for routing and analytics"""
  category: String!
  closed_at: timestamptz
  created_at: timestamptz
  current_page: String
  feedback_comment: String
  first_response_at: timestamptz
  id: uuid!
  internal_notes: String
  last_response_at: timestamptz
  message: String!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb

  """Ticket priority: low, normal, high, urgent"""
  priority: String!
  resolved_at: timestamptz
  response_count: Int
  satisfaction_rating: Int

  """Ticket status: open, in_progress, waiting_user, resolved, closed"""
  status: String!
  subject: String

  """An array relationship"""
  support_messages(
    """distinct select on columns"""
    distinct_on: [support_messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [support_messages_order_by!]

    """filter the rows returned"""
    where: support_messages_bool_exp
  ): [support_messages!]!

  """An aggregate relationship"""
  support_messages_aggregate(
    """distinct select on columns"""
    distinct_on: [support_messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [support_messages_order_by!]

    """filter the rows returned"""
    where: support_messages_bool_exp
  ): support_messages_aggregate!
  tags: [String!]
  updated_at: timestamptz
  user_agent: String
  user_email: String!
  user_id: uuid
  user_name: String!
  user_type: String!
}

"""
aggregated selection of "support_tickets"
"""
type support_tickets_aggregate {
  aggregate: support_tickets_aggregate_fields
  nodes: [support_tickets!]!
}

"""
aggregate fields of "support_tickets"
"""
type support_tickets_aggregate_fields {
  avg: support_tickets_avg_fields
  count(columns: [support_tickets_select_column!], distinct: Boolean): Int!
  max: support_tickets_max_fields
  min: support_tickets_min_fields
  stddev: support_tickets_stddev_fields
  stddev_pop: support_tickets_stddev_pop_fields
  stddev_samp: support_tickets_stddev_samp_fields
  sum: support_tickets_sum_fields
  var_pop: support_tickets_var_pop_fields
  var_samp: support_tickets_var_samp_fields
  variance: support_tickets_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input support_tickets_append_input {
  browser_info: jsonb
  metadata: jsonb
}

"""aggregate avg on columns"""
type support_tickets_avg_fields {
  response_count: Float
  satisfaction_rating: Float
}

"""
Boolean expression to filter rows from the table "support_tickets". All fields are combined with a logical 'AND'.
"""
input support_tickets_bool_exp {
  _and: [support_tickets_bool_exp!]
  _not: support_tickets_bool_exp
  _or: [support_tickets_bool_exp!]
  assigned_agent_id: uuid_comparison_exp
  assigned_agent_name: String_comparison_exp
  browser_info: jsonb_comparison_exp
  category: String_comparison_exp
  closed_at: timestamptz_comparison_exp
  created_at: timestamptz_comparison_exp
  current_page: String_comparison_exp
  feedback_comment: String_comparison_exp
  first_response_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  internal_notes: String_comparison_exp
  last_response_at: timestamptz_comparison_exp
  message: String_comparison_exp
  metadata: jsonb_comparison_exp
  priority: String_comparison_exp
  resolved_at: timestamptz_comparison_exp
  response_count: Int_comparison_exp
  satisfaction_rating: Int_comparison_exp
  status: String_comparison_exp
  subject: String_comparison_exp
  support_messages: support_messages_bool_exp
  support_messages_aggregate: support_messages_aggregate_bool_exp
  tags: String_array_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_agent: String_comparison_exp
  user_email: String_comparison_exp
  user_id: uuid_comparison_exp
  user_name: String_comparison_exp
  user_type: String_comparison_exp
}

"""
unique or primary key constraints on table "support_tickets"
"""
enum support_tickets_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  support_tickets_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input support_tickets_delete_at_path_input {
  browser_info: [String!]
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input support_tickets_delete_elem_input {
  browser_info: Int
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input support_tickets_delete_key_input {
  browser_info: String
  metadata: String
}

"""
input type for incrementing numeric columns in table "support_tickets"
"""
input support_tickets_inc_input {
  response_count: Int
  satisfaction_rating: Int
}

"""
input type for inserting data into table "support_tickets"
"""
input support_tickets_insert_input {
  assigned_agent_id: uuid
  assigned_agent_name: String
  browser_info: jsonb

  """Support category for routing and analytics"""
  category: String
  closed_at: timestamptz
  created_at: timestamptz
  current_page: String
  feedback_comment: String
  first_response_at: timestamptz
  id: uuid
  internal_notes: String
  last_response_at: timestamptz
  message: String
  metadata: jsonb

  """Ticket priority: low, normal, high, urgent"""
  priority: String
  resolved_at: timestamptz
  response_count: Int
  satisfaction_rating: Int

  """Ticket status: open, in_progress, waiting_user, resolved, closed"""
  status: String
  subject: String
  support_messages: support_messages_arr_rel_insert_input
  tags: [String!]
  updated_at: timestamptz
  user_agent: String
  user_email: String
  user_id: uuid
  user_name: String
  user_type: String
}

"""aggregate max on columns"""
type support_tickets_max_fields {
  assigned_agent_id: uuid
  assigned_agent_name: String

  """Support category for routing and analytics"""
  category: String
  closed_at: timestamptz
  created_at: timestamptz
  current_page: String
  feedback_comment: String
  first_response_at: timestamptz
  id: uuid
  internal_notes: String
  last_response_at: timestamptz
  message: String

  """Ticket priority: low, normal, high, urgent"""
  priority: String
  resolved_at: timestamptz
  response_count: Int
  satisfaction_rating: Int

  """Ticket status: open, in_progress, waiting_user, resolved, closed"""
  status: String
  subject: String
  tags: [String!]
  updated_at: timestamptz
  user_agent: String
  user_email: String
  user_id: uuid
  user_name: String
  user_type: String
}

"""aggregate min on columns"""
type support_tickets_min_fields {
  assigned_agent_id: uuid
  assigned_agent_name: String

  """Support category for routing and analytics"""
  category: String
  closed_at: timestamptz
  created_at: timestamptz
  current_page: String
  feedback_comment: String
  first_response_at: timestamptz
  id: uuid
  internal_notes: String
  last_response_at: timestamptz
  message: String

  """Ticket priority: low, normal, high, urgent"""
  priority: String
  resolved_at: timestamptz
  response_count: Int
  satisfaction_rating: Int

  """Ticket status: open, in_progress, waiting_user, resolved, closed"""
  status: String
  subject: String
  tags: [String!]
  updated_at: timestamptz
  user_agent: String
  user_email: String
  user_id: uuid
  user_name: String
  user_type: String
}

"""
response of any mutation on the table "support_tickets"
"""
type support_tickets_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [support_tickets!]!
}

"""
input type for inserting object relation for remote table "support_tickets"
"""
input support_tickets_obj_rel_insert_input {
  data: support_tickets_insert_input!

  """upsert condition"""
  on_conflict: support_tickets_on_conflict
}

"""
on_conflict condition type for table "support_tickets"
"""
input support_tickets_on_conflict {
  constraint: support_tickets_constraint!
  update_columns: [support_tickets_update_column!]! = []
  where: support_tickets_bool_exp
}

"""Ordering options when selecting data from "support_tickets"."""
input support_tickets_order_by {
  assigned_agent_id: order_by
  assigned_agent_name: order_by
  browser_info: order_by
  category: order_by
  closed_at: order_by
  created_at: order_by
  current_page: order_by
  feedback_comment: order_by
  first_response_at: order_by
  id: order_by
  internal_notes: order_by
  last_response_at: order_by
  message: order_by
  metadata: order_by
  priority: order_by
  resolved_at: order_by
  response_count: order_by
  satisfaction_rating: order_by
  status: order_by
  subject: order_by
  support_messages_aggregate: support_messages_aggregate_order_by
  tags: order_by
  updated_at: order_by
  user_agent: order_by
  user_email: order_by
  user_id: order_by
  user_name: order_by
  user_type: order_by
}

"""primary key columns input for table: support_tickets"""
input support_tickets_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input support_tickets_prepend_input {
  browser_info: jsonb
  metadata: jsonb
}

"""
select columns of table "support_tickets"
"""
enum support_tickets_select_column {
  """column name"""
  assigned_agent_id

  """column name"""
  assigned_agent_name

  """column name"""
  browser_info

  """column name"""
  category

  """column name"""
  closed_at

  """column name"""
  created_at

  """column name"""
  current_page

  """column name"""
  feedback_comment

  """column name"""
  first_response_at

  """column name"""
  id

  """column name"""
  internal_notes

  """column name"""
  last_response_at

  """column name"""
  message

  """column name"""
  metadata

  """column name"""
  priority

  """column name"""
  resolved_at

  """column name"""
  response_count

  """column name"""
  satisfaction_rating

  """column name"""
  status

  """column name"""
  subject

  """column name"""
  tags

  """column name"""
  updated_at

  """column name"""
  user_agent

  """column name"""
  user_email

  """column name"""
  user_id

  """column name"""
  user_name

  """column name"""
  user_type
}

"""
input type for updating data in table "support_tickets"
"""
input support_tickets_set_input {
  assigned_agent_id: uuid
  assigned_agent_name: String
  browser_info: jsonb

  """Support category for routing and analytics"""
  category: String
  closed_at: timestamptz
  created_at: timestamptz
  current_page: String
  feedback_comment: String
  first_response_at: timestamptz
  id: uuid
  internal_notes: String
  last_response_at: timestamptz
  message: String
  metadata: jsonb

  """Ticket priority: low, normal, high, urgent"""
  priority: String
  resolved_at: timestamptz
  response_count: Int
  satisfaction_rating: Int

  """Ticket status: open, in_progress, waiting_user, resolved, closed"""
  status: String
  subject: String
  tags: [String!]
  updated_at: timestamptz
  user_agent: String
  user_email: String
  user_id: uuid
  user_name: String
  user_type: String
}

"""aggregate stddev on columns"""
type support_tickets_stddev_fields {
  response_count: Float
  satisfaction_rating: Float
}

"""aggregate stddev_pop on columns"""
type support_tickets_stddev_pop_fields {
  response_count: Float
  satisfaction_rating: Float
}

"""aggregate stddev_samp on columns"""
type support_tickets_stddev_samp_fields {
  response_count: Float
  satisfaction_rating: Float
}

"""
Streaming cursor of the table "support_tickets"
"""
input support_tickets_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: support_tickets_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input support_tickets_stream_cursor_value_input {
  assigned_agent_id: uuid
  assigned_agent_name: String
  browser_info: jsonb

  """Support category for routing and analytics"""
  category: String
  closed_at: timestamptz
  created_at: timestamptz
  current_page: String
  feedback_comment: String
  first_response_at: timestamptz
  id: uuid
  internal_notes: String
  last_response_at: timestamptz
  message: String
  metadata: jsonb

  """Ticket priority: low, normal, high, urgent"""
  priority: String
  resolved_at: timestamptz
  response_count: Int
  satisfaction_rating: Int

  """Ticket status: open, in_progress, waiting_user, resolved, closed"""
  status: String
  subject: String
  tags: [String!]
  updated_at: timestamptz
  user_agent: String
  user_email: String
  user_id: uuid
  user_name: String
  user_type: String
}

"""aggregate sum on columns"""
type support_tickets_sum_fields {
  response_count: Int
  satisfaction_rating: Int
}

"""
update columns of table "support_tickets"
"""
enum support_tickets_update_column {
  """column name"""
  assigned_agent_id

  """column name"""
  assigned_agent_name

  """column name"""
  browser_info

  """column name"""
  category

  """column name"""
  closed_at

  """column name"""
  created_at

  """column name"""
  current_page

  """column name"""
  feedback_comment

  """column name"""
  first_response_at

  """column name"""
  id

  """column name"""
  internal_notes

  """column name"""
  last_response_at

  """column name"""
  message

  """column name"""
  metadata

  """column name"""
  priority

  """column name"""
  resolved_at

  """column name"""
  response_count

  """column name"""
  satisfaction_rating

  """column name"""
  status

  """column name"""
  subject

  """column name"""
  tags

  """column name"""
  updated_at

  """column name"""
  user_agent

  """column name"""
  user_email

  """column name"""
  user_id

  """column name"""
  user_name

  """column name"""
  user_type
}

input support_tickets_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: support_tickets_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: support_tickets_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: support_tickets_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: support_tickets_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: support_tickets_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: support_tickets_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: support_tickets_set_input

  """filter the rows which have to be updated"""
  where: support_tickets_bool_exp!
}

"""aggregate var_pop on columns"""
type support_tickets_var_pop_fields {
  response_count: Float
  satisfaction_rating: Float
}

"""aggregate var_samp on columns"""
type support_tickets_var_samp_fields {
  response_count: Float
  satisfaction_rating: Float
}

"""aggregate variance on columns"""
type support_tickets_variance_fields {
  response_count: Float
  satisfaction_rating: Float
}

"""
columns and relationships of "system_settings"
"""
type system_settings {
  """An object relationship"""
  admin_user: admin_users
  description: String
  id: uuid!
  setting_key: String!
  setting_value(
    """JSON select path"""
    path: String
  ): jsonb!
  updated_at: timestamptz
  updated_by: uuid
}

"""
aggregated selection of "system_settings"
"""
type system_settings_aggregate {
  aggregate: system_settings_aggregate_fields
  nodes: [system_settings!]!
}

input system_settings_aggregate_bool_exp {
  count: system_settings_aggregate_bool_exp_count
}

input system_settings_aggregate_bool_exp_count {
  arguments: [system_settings_select_column!]
  distinct: Boolean
  filter: system_settings_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "system_settings"
"""
type system_settings_aggregate_fields {
  count(columns: [system_settings_select_column!], distinct: Boolean): Int!
  max: system_settings_max_fields
  min: system_settings_min_fields
}

"""
order by aggregate values of table "system_settings"
"""
input system_settings_aggregate_order_by {
  count: order_by
  max: system_settings_max_order_by
  min: system_settings_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input system_settings_append_input {
  setting_value: jsonb
}

"""
input type for inserting array relation for remote table "system_settings"
"""
input system_settings_arr_rel_insert_input {
  data: [system_settings_insert_input!]!

  """upsert condition"""
  on_conflict: system_settings_on_conflict
}

"""
Boolean expression to filter rows from the table "system_settings". All fields are combined with a logical 'AND'.
"""
input system_settings_bool_exp {
  _and: [system_settings_bool_exp!]
  _not: system_settings_bool_exp
  _or: [system_settings_bool_exp!]
  admin_user: admin_users_bool_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  setting_key: String_comparison_exp
  setting_value: jsonb_comparison_exp
  updated_at: timestamptz_comparison_exp
  updated_by: uuid_comparison_exp
}

"""
unique or primary key constraints on table "system_settings"
"""
enum system_settings_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  system_settings_pkey

  """
  unique or primary key constraint on columns "setting_key"
  """
  system_settings_setting_key_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input system_settings_delete_at_path_input {
  setting_value: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input system_settings_delete_elem_input {
  setting_value: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input system_settings_delete_key_input {
  setting_value: String
}

"""
input type for inserting data into table "system_settings"
"""
input system_settings_insert_input {
  admin_user: admin_users_obj_rel_insert_input
  description: String
  id: uuid
  setting_key: String
  setting_value: jsonb
  updated_at: timestamptz
  updated_by: uuid
}

"""aggregate max on columns"""
type system_settings_max_fields {
  description: String
  id: uuid
  setting_key: String
  updated_at: timestamptz
  updated_by: uuid
}

"""
order by max() on columns of table "system_settings"
"""
input system_settings_max_order_by {
  description: order_by
  id: order_by
  setting_key: order_by
  updated_at: order_by
  updated_by: order_by
}

"""aggregate min on columns"""
type system_settings_min_fields {
  description: String
  id: uuid
  setting_key: String
  updated_at: timestamptz
  updated_by: uuid
}

"""
order by min() on columns of table "system_settings"
"""
input system_settings_min_order_by {
  description: order_by
  id: order_by
  setting_key: order_by
  updated_at: order_by
  updated_by: order_by
}

"""
response of any mutation on the table "system_settings"
"""
type system_settings_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [system_settings!]!
}

"""
on_conflict condition type for table "system_settings"
"""
input system_settings_on_conflict {
  constraint: system_settings_constraint!
  update_columns: [system_settings_update_column!]! = []
  where: system_settings_bool_exp
}

"""Ordering options when selecting data from "system_settings"."""
input system_settings_order_by {
  admin_user: admin_users_order_by
  description: order_by
  id: order_by
  setting_key: order_by
  setting_value: order_by
  updated_at: order_by
  updated_by: order_by
}

"""primary key columns input for table: system_settings"""
input system_settings_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input system_settings_prepend_input {
  setting_value: jsonb
}

"""
select columns of table "system_settings"
"""
enum system_settings_select_column {
  """column name"""
  description

  """column name"""
  id

  """column name"""
  setting_key

  """column name"""
  setting_value

  """column name"""
  updated_at

  """column name"""
  updated_by
}

"""
input type for updating data in table "system_settings"
"""
input system_settings_set_input {
  description: String
  id: uuid
  setting_key: String
  setting_value: jsonb
  updated_at: timestamptz
  updated_by: uuid
}

"""
Streaming cursor of the table "system_settings"
"""
input system_settings_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: system_settings_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input system_settings_stream_cursor_value_input {
  description: String
  id: uuid
  setting_key: String
  setting_value: jsonb
  updated_at: timestamptz
  updated_by: uuid
}

"""
update columns of table "system_settings"
"""
enum system_settings_update_column {
  """column name"""
  description

  """column name"""
  id

  """column name"""
  setting_key

  """column name"""
  setting_value

  """column name"""
  updated_at

  """column name"""
  updated_by
}

input system_settings_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: system_settings_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: system_settings_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: system_settings_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: system_settings_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: system_settings_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: system_settings_set_input

  """filter the rows which have to be updated"""
  where: system_settings_bool_exp!
}

"""Tracks monthly performance metrics for team members"""
type team_member_performance {
  agency_id: uuid!

  """An object relationship"""
  agency_team_member: agency_team_members!
  applications_processed: Int
  average_time_to_hire: numeric
  client_satisfaction_avg: numeric
  conversion_rate: numeric
  created_at: timestamptz
  id: uuid!
  interviews_conducted: Int
  month: date!
  performance_score: numeric
  placements_count: Int
  revenue_generated: numeric
  team_member_id: uuid!
  updated_at: timestamptz

  """An object relationship"""
  user: auth_users!
}

"""
aggregated selection of "team_member_performance"
"""
type team_member_performance_aggregate {
  aggregate: team_member_performance_aggregate_fields
  nodes: [team_member_performance!]!
}

input team_member_performance_aggregate_bool_exp {
  count: team_member_performance_aggregate_bool_exp_count
}

input team_member_performance_aggregate_bool_exp_count {
  arguments: [team_member_performance_select_column!]
  distinct: Boolean
  filter: team_member_performance_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "team_member_performance"
"""
type team_member_performance_aggregate_fields {
  avg: team_member_performance_avg_fields
  count(columns: [team_member_performance_select_column!], distinct: Boolean): Int!
  max: team_member_performance_max_fields
  min: team_member_performance_min_fields
  stddev: team_member_performance_stddev_fields
  stddev_pop: team_member_performance_stddev_pop_fields
  stddev_samp: team_member_performance_stddev_samp_fields
  sum: team_member_performance_sum_fields
  var_pop: team_member_performance_var_pop_fields
  var_samp: team_member_performance_var_samp_fields
  variance: team_member_performance_variance_fields
}

"""
order by aggregate values of table "team_member_performance"
"""
input team_member_performance_aggregate_order_by {
  avg: team_member_performance_avg_order_by
  count: order_by
  max: team_member_performance_max_order_by
  min: team_member_performance_min_order_by
  stddev: team_member_performance_stddev_order_by
  stddev_pop: team_member_performance_stddev_pop_order_by
  stddev_samp: team_member_performance_stddev_samp_order_by
  sum: team_member_performance_sum_order_by
  var_pop: team_member_performance_var_pop_order_by
  var_samp: team_member_performance_var_samp_order_by
  variance: team_member_performance_variance_order_by
}

"""
input type for inserting array relation for remote table "team_member_performance"
"""
input team_member_performance_arr_rel_insert_input {
  data: [team_member_performance_insert_input!]!

  """upsert condition"""
  on_conflict: team_member_performance_on_conflict
}

"""aggregate avg on columns"""
type team_member_performance_avg_fields {
  applications_processed: Float
  average_time_to_hire: Float
  client_satisfaction_avg: Float
  conversion_rate: Float
  interviews_conducted: Float
  performance_score: Float
  placements_count: Float
  revenue_generated: Float
}

"""
order by avg() on columns of table "team_member_performance"
"""
input team_member_performance_avg_order_by {
  applications_processed: order_by
  average_time_to_hire: order_by
  client_satisfaction_avg: order_by
  conversion_rate: order_by
  interviews_conducted: order_by
  performance_score: order_by
  placements_count: order_by
  revenue_generated: order_by
}

"""
Boolean expression to filter rows from the table "team_member_performance". All fields are combined with a logical 'AND'.
"""
input team_member_performance_bool_exp {
  _and: [team_member_performance_bool_exp!]
  _not: team_member_performance_bool_exp
  _or: [team_member_performance_bool_exp!]
  agency_id: uuid_comparison_exp
  agency_team_member: agency_team_members_bool_exp
  applications_processed: Int_comparison_exp
  average_time_to_hire: numeric_comparison_exp
  client_satisfaction_avg: numeric_comparison_exp
  conversion_rate: numeric_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  interviews_conducted: Int_comparison_exp
  month: date_comparison_exp
  performance_score: numeric_comparison_exp
  placements_count: Int_comparison_exp
  revenue_generated: numeric_comparison_exp
  team_member_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
}

"""
unique or primary key constraints on table "team_member_performance"
"""
enum team_member_performance_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  team_member_performance_pkey

  """
  unique or primary key constraint on columns "team_member_id", "month"
  """
  team_member_performance_team_member_id_month_key
}

"""
input type for incrementing numeric columns in table "team_member_performance"
"""
input team_member_performance_inc_input {
  applications_processed: Int
  average_time_to_hire: numeric
  client_satisfaction_avg: numeric
  conversion_rate: numeric
  interviews_conducted: Int
  performance_score: numeric
  placements_count: Int
  revenue_generated: numeric
}

"""
input type for inserting data into table "team_member_performance"
"""
input team_member_performance_insert_input {
  agency_id: uuid
  agency_team_member: agency_team_members_obj_rel_insert_input
  applications_processed: Int
  average_time_to_hire: numeric
  client_satisfaction_avg: numeric
  conversion_rate: numeric
  created_at: timestamptz
  id: uuid
  interviews_conducted: Int
  month: date
  performance_score: numeric
  placements_count: Int
  revenue_generated: numeric
  team_member_id: uuid
  updated_at: timestamptz
  user: auth_users_obj_rel_insert_input
}

"""aggregate max on columns"""
type team_member_performance_max_fields {
  agency_id: uuid
  applications_processed: Int
  average_time_to_hire: numeric
  client_satisfaction_avg: numeric
  conversion_rate: numeric
  created_at: timestamptz
  id: uuid
  interviews_conducted: Int
  month: date
  performance_score: numeric
  placements_count: Int
  revenue_generated: numeric
  team_member_id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "team_member_performance"
"""
input team_member_performance_max_order_by {
  agency_id: order_by
  applications_processed: order_by
  average_time_to_hire: order_by
  client_satisfaction_avg: order_by
  conversion_rate: order_by
  created_at: order_by
  id: order_by
  interviews_conducted: order_by
  month: order_by
  performance_score: order_by
  placements_count: order_by
  revenue_generated: order_by
  team_member_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type team_member_performance_min_fields {
  agency_id: uuid
  applications_processed: Int
  average_time_to_hire: numeric
  client_satisfaction_avg: numeric
  conversion_rate: numeric
  created_at: timestamptz
  id: uuid
  interviews_conducted: Int
  month: date
  performance_score: numeric
  placements_count: Int
  revenue_generated: numeric
  team_member_id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "team_member_performance"
"""
input team_member_performance_min_order_by {
  agency_id: order_by
  applications_processed: order_by
  average_time_to_hire: order_by
  client_satisfaction_avg: order_by
  conversion_rate: order_by
  created_at: order_by
  id: order_by
  interviews_conducted: order_by
  month: order_by
  performance_score: order_by
  placements_count: order_by
  revenue_generated: order_by
  team_member_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "team_member_performance"
"""
type team_member_performance_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [team_member_performance!]!
}

"""
on_conflict condition type for table "team_member_performance"
"""
input team_member_performance_on_conflict {
  constraint: team_member_performance_constraint!
  update_columns: [team_member_performance_update_column!]! = []
  where: team_member_performance_bool_exp
}

"""Ordering options when selecting data from "team_member_performance"."""
input team_member_performance_order_by {
  agency_id: order_by
  agency_team_member: agency_team_members_order_by
  applications_processed: order_by
  average_time_to_hire: order_by
  client_satisfaction_avg: order_by
  conversion_rate: order_by
  created_at: order_by
  id: order_by
  interviews_conducted: order_by
  month: order_by
  performance_score: order_by
  placements_count: order_by
  revenue_generated: order_by
  team_member_id: order_by
  updated_at: order_by
  user: auth_users_order_by
}

"""primary key columns input for table: team_member_performance"""
input team_member_performance_pk_columns_input {
  id: uuid!
}

"""
select columns of table "team_member_performance"
"""
enum team_member_performance_select_column {
  """column name"""
  agency_id

  """column name"""
  applications_processed

  """column name"""
  average_time_to_hire

  """column name"""
  client_satisfaction_avg

  """column name"""
  conversion_rate

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  interviews_conducted

  """column name"""
  month

  """column name"""
  performance_score

  """column name"""
  placements_count

  """column name"""
  revenue_generated

  """column name"""
  team_member_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "team_member_performance"
"""
input team_member_performance_set_input {
  agency_id: uuid
  applications_processed: Int
  average_time_to_hire: numeric
  client_satisfaction_avg: numeric
  conversion_rate: numeric
  created_at: timestamptz
  id: uuid
  interviews_conducted: Int
  month: date
  performance_score: numeric
  placements_count: Int
  revenue_generated: numeric
  team_member_id: uuid
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type team_member_performance_stddev_fields {
  applications_processed: Float
  average_time_to_hire: Float
  client_satisfaction_avg: Float
  conversion_rate: Float
  interviews_conducted: Float
  performance_score: Float
  placements_count: Float
  revenue_generated: Float
}

"""
order by stddev() on columns of table "team_member_performance"
"""
input team_member_performance_stddev_order_by {
  applications_processed: order_by
  average_time_to_hire: order_by
  client_satisfaction_avg: order_by
  conversion_rate: order_by
  interviews_conducted: order_by
  performance_score: order_by
  placements_count: order_by
  revenue_generated: order_by
}

"""aggregate stddev_pop on columns"""
type team_member_performance_stddev_pop_fields {
  applications_processed: Float
  average_time_to_hire: Float
  client_satisfaction_avg: Float
  conversion_rate: Float
  interviews_conducted: Float
  performance_score: Float
  placements_count: Float
  revenue_generated: Float
}

"""
order by stddev_pop() on columns of table "team_member_performance"
"""
input team_member_performance_stddev_pop_order_by {
  applications_processed: order_by
  average_time_to_hire: order_by
  client_satisfaction_avg: order_by
  conversion_rate: order_by
  interviews_conducted: order_by
  performance_score: order_by
  placements_count: order_by
  revenue_generated: order_by
}

"""aggregate stddev_samp on columns"""
type team_member_performance_stddev_samp_fields {
  applications_processed: Float
  average_time_to_hire: Float
  client_satisfaction_avg: Float
  conversion_rate: Float
  interviews_conducted: Float
  performance_score: Float
  placements_count: Float
  revenue_generated: Float
}

"""
order by stddev_samp() on columns of table "team_member_performance"
"""
input team_member_performance_stddev_samp_order_by {
  applications_processed: order_by
  average_time_to_hire: order_by
  client_satisfaction_avg: order_by
  conversion_rate: order_by
  interviews_conducted: order_by
  performance_score: order_by
  placements_count: order_by
  revenue_generated: order_by
}

"""
Streaming cursor of the table "team_member_performance"
"""
input team_member_performance_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: team_member_performance_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input team_member_performance_stream_cursor_value_input {
  agency_id: uuid
  applications_processed: Int
  average_time_to_hire: numeric
  client_satisfaction_avg: numeric
  conversion_rate: numeric
  created_at: timestamptz
  id: uuid
  interviews_conducted: Int
  month: date
  performance_score: numeric
  placements_count: Int
  revenue_generated: numeric
  team_member_id: uuid
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type team_member_performance_sum_fields {
  applications_processed: Int
  average_time_to_hire: numeric
  client_satisfaction_avg: numeric
  conversion_rate: numeric
  interviews_conducted: Int
  performance_score: numeric
  placements_count: Int
  revenue_generated: numeric
}

"""
order by sum() on columns of table "team_member_performance"
"""
input team_member_performance_sum_order_by {
  applications_processed: order_by
  average_time_to_hire: order_by
  client_satisfaction_avg: order_by
  conversion_rate: order_by
  interviews_conducted: order_by
  performance_score: order_by
  placements_count: order_by
  revenue_generated: order_by
}

"""
update columns of table "team_member_performance"
"""
enum team_member_performance_update_column {
  """column name"""
  agency_id

  """column name"""
  applications_processed

  """column name"""
  average_time_to_hire

  """column name"""
  client_satisfaction_avg

  """column name"""
  conversion_rate

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  interviews_conducted

  """column name"""
  month

  """column name"""
  performance_score

  """column name"""
  placements_count

  """column name"""
  revenue_generated

  """column name"""
  team_member_id

  """column name"""
  updated_at
}

input team_member_performance_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: team_member_performance_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: team_member_performance_set_input

  """filter the rows which have to be updated"""
  where: team_member_performance_bool_exp!
}

"""aggregate var_pop on columns"""
type team_member_performance_var_pop_fields {
  applications_processed: Float
  average_time_to_hire: Float
  client_satisfaction_avg: Float
  conversion_rate: Float
  interviews_conducted: Float
  performance_score: Float
  placements_count: Float
  revenue_generated: Float
}

"""
order by var_pop() on columns of table "team_member_performance"
"""
input team_member_performance_var_pop_order_by {
  applications_processed: order_by
  average_time_to_hire: order_by
  client_satisfaction_avg: order_by
  conversion_rate: order_by
  interviews_conducted: order_by
  performance_score: order_by
  placements_count: order_by
  revenue_generated: order_by
}

"""aggregate var_samp on columns"""
type team_member_performance_var_samp_fields {
  applications_processed: Float
  average_time_to_hire: Float
  client_satisfaction_avg: Float
  conversion_rate: Float
  interviews_conducted: Float
  performance_score: Float
  placements_count: Float
  revenue_generated: Float
}

"""
order by var_samp() on columns of table "team_member_performance"
"""
input team_member_performance_var_samp_order_by {
  applications_processed: order_by
  average_time_to_hire: order_by
  client_satisfaction_avg: order_by
  conversion_rate: order_by
  interviews_conducted: order_by
  performance_score: order_by
  placements_count: order_by
  revenue_generated: order_by
}

"""aggregate variance on columns"""
type team_member_performance_variance_fields {
  applications_processed: Float
  average_time_to_hire: Float
  client_satisfaction_avg: Float
  conversion_rate: Float
  interviews_conducted: Float
  performance_score: Float
  placements_count: Float
  revenue_generated: Float
}

"""
order by variance() on columns of table "team_member_performance"
"""
input team_member_performance_variance_order_by {
  applications_processed: order_by
  average_time_to_hire: order_by
  client_satisfaction_avg: order_by
  conversion_rate: order_by
  interviews_conducted: order_by
  performance_score: order_by
  placements_count: order_by
  revenue_generated: order_by
}

scalar time

"""
Boolean expression to compare columns of type "time". All fields are combined with logical 'AND'.
"""
input time_comparison_exp {
  _eq: time
  _gt: time
  _gte: time
  _in: [time!]
  _is_null: Boolean
  _lt: time
  _lte: time
  _neq: time
  _nin: [time!]
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "two_factor_backup_codes"
"""
type two_factor_backup_codes {
  code: String!
  created_at: timestamptz
  id: uuid!
  used: Boolean
  used_at: timestamptz

  """An object relationship"""
  user: auth_users!
  user_id: uuid!
}

"""
aggregated selection of "two_factor_backup_codes"
"""
type two_factor_backup_codes_aggregate {
  aggregate: two_factor_backup_codes_aggregate_fields
  nodes: [two_factor_backup_codes!]!
}

"""
aggregate fields of "two_factor_backup_codes"
"""
type two_factor_backup_codes_aggregate_fields {
  count(columns: [two_factor_backup_codes_select_column!], distinct: Boolean): Int!
  max: two_factor_backup_codes_max_fields
  min: two_factor_backup_codes_min_fields
}

"""
Boolean expression to filter rows from the table "two_factor_backup_codes". All fields are combined with a logical 'AND'.
"""
input two_factor_backup_codes_bool_exp {
  _and: [two_factor_backup_codes_bool_exp!]
  _not: two_factor_backup_codes_bool_exp
  _or: [two_factor_backup_codes_bool_exp!]
  code: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  used: Boolean_comparison_exp
  used_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "two_factor_backup_codes"
"""
enum two_factor_backup_codes_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  two_factor_backup_codes_pkey

  """
  unique or primary key constraint on columns "user_id", "code"
  """
  unique_backup_code
}

"""
input type for inserting data into table "two_factor_backup_codes"
"""
input two_factor_backup_codes_insert_input {
  code: String
  created_at: timestamptz
  id: uuid
  used: Boolean
  used_at: timestamptz
  user: auth_users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type two_factor_backup_codes_max_fields {
  code: String
  created_at: timestamptz
  id: uuid
  used_at: timestamptz
  user_id: uuid
}

"""aggregate min on columns"""
type two_factor_backup_codes_min_fields {
  code: String
  created_at: timestamptz
  id: uuid
  used_at: timestamptz
  user_id: uuid
}

"""
response of any mutation on the table "two_factor_backup_codes"
"""
type two_factor_backup_codes_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [two_factor_backup_codes!]!
}

"""
on_conflict condition type for table "two_factor_backup_codes"
"""
input two_factor_backup_codes_on_conflict {
  constraint: two_factor_backup_codes_constraint!
  update_columns: [two_factor_backup_codes_update_column!]! = []
  where: two_factor_backup_codes_bool_exp
}

"""Ordering options when selecting data from "two_factor_backup_codes"."""
input two_factor_backup_codes_order_by {
  code: order_by
  created_at: order_by
  id: order_by
  used: order_by
  used_at: order_by
  user: auth_users_order_by
  user_id: order_by
}

"""primary key columns input for table: two_factor_backup_codes"""
input two_factor_backup_codes_pk_columns_input {
  id: uuid!
}

"""
select columns of table "two_factor_backup_codes"
"""
enum two_factor_backup_codes_select_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  used

  """column name"""
  used_at

  """column name"""
  user_id
}

"""
input type for updating data in table "two_factor_backup_codes"
"""
input two_factor_backup_codes_set_input {
  code: String
  created_at: timestamptz
  id: uuid
  used: Boolean
  used_at: timestamptz
  user_id: uuid
}

"""
Streaming cursor of the table "two_factor_backup_codes"
"""
input two_factor_backup_codes_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: two_factor_backup_codes_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input two_factor_backup_codes_stream_cursor_value_input {
  code: String
  created_at: timestamptz
  id: uuid
  used: Boolean
  used_at: timestamptz
  user_id: uuid
}

"""
update columns of table "two_factor_backup_codes"
"""
enum two_factor_backup_codes_update_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  used

  """column name"""
  used_at

  """column name"""
  user_id
}

input two_factor_backup_codes_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: two_factor_backup_codes_set_input

  """filter the rows which have to be updated"""
  where: two_factor_backup_codes_bool_exp!
}

"""
columns and relationships of "user_credits"
"""
type user_credits {
  created_at: timestamptz
  credits_available: Int!
  credits_total_purchased: Int!
  id: uuid!
  last_purchase_at: timestamptz
  updated_at: timestamptz

  """An object relationship"""
  user: auth_users
  user_id: uuid
}

"""
aggregated selection of "user_credits"
"""
type user_credits_aggregate {
  aggregate: user_credits_aggregate_fields
  nodes: [user_credits!]!
}

"""
aggregate fields of "user_credits"
"""
type user_credits_aggregate_fields {
  avg: user_credits_avg_fields
  count(columns: [user_credits_select_column!], distinct: Boolean): Int!
  max: user_credits_max_fields
  min: user_credits_min_fields
  stddev: user_credits_stddev_fields
  stddev_pop: user_credits_stddev_pop_fields
  stddev_samp: user_credits_stddev_samp_fields
  sum: user_credits_sum_fields
  var_pop: user_credits_var_pop_fields
  var_samp: user_credits_var_samp_fields
  variance: user_credits_variance_fields
}

"""aggregate avg on columns"""
type user_credits_avg_fields {
  credits_available: Float
  credits_total_purchased: Float
}

"""
Boolean expression to filter rows from the table "user_credits". All fields are combined with a logical 'AND'.
"""
input user_credits_bool_exp {
  _and: [user_credits_bool_exp!]
  _not: user_credits_bool_exp
  _or: [user_credits_bool_exp!]
  created_at: timestamptz_comparison_exp
  credits_available: Int_comparison_exp
  credits_total_purchased: Int_comparison_exp
  id: uuid_comparison_exp
  last_purchase_at: timestamptz_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: auth_users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "user_credits"
"""
enum user_credits_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_credits_pkey
}

"""
input type for incrementing numeric columns in table "user_credits"
"""
input user_credits_inc_input {
  credits_available: Int
  credits_total_purchased: Int
}

"""
input type for inserting data into table "user_credits"
"""
input user_credits_insert_input {
  created_at: timestamptz
  credits_available: Int
  credits_total_purchased: Int
  id: uuid
  last_purchase_at: timestamptz
  updated_at: timestamptz
  user: auth_users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type user_credits_max_fields {
  created_at: timestamptz
  credits_available: Int
  credits_total_purchased: Int
  id: uuid
  last_purchase_at: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate min on columns"""
type user_credits_min_fields {
  created_at: timestamptz
  credits_available: Int
  credits_total_purchased: Int
  id: uuid
  last_purchase_at: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""
response of any mutation on the table "user_credits"
"""
type user_credits_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_credits!]!
}

"""
on_conflict condition type for table "user_credits"
"""
input user_credits_on_conflict {
  constraint: user_credits_constraint!
  update_columns: [user_credits_update_column!]! = []
  where: user_credits_bool_exp
}

"""Ordering options when selecting data from "user_credits"."""
input user_credits_order_by {
  created_at: order_by
  credits_available: order_by
  credits_total_purchased: order_by
  id: order_by
  last_purchase_at: order_by
  updated_at: order_by
  user: auth_users_order_by
  user_id: order_by
}

"""primary key columns input for table: user_credits"""
input user_credits_pk_columns_input {
  id: uuid!
}

"""
select columns of table "user_credits"
"""
enum user_credits_select_column {
  """column name"""
  created_at

  """column name"""
  credits_available

  """column name"""
  credits_total_purchased

  """column name"""
  id

  """column name"""
  last_purchase_at

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "user_credits"
"""
input user_credits_set_input {
  created_at: timestamptz
  credits_available: Int
  credits_total_purchased: Int
  id: uuid
  last_purchase_at: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate stddev on columns"""
type user_credits_stddev_fields {
  credits_available: Float
  credits_total_purchased: Float
}

"""aggregate stddev_pop on columns"""
type user_credits_stddev_pop_fields {
  credits_available: Float
  credits_total_purchased: Float
}

"""aggregate stddev_samp on columns"""
type user_credits_stddev_samp_fields {
  credits_available: Float
  credits_total_purchased: Float
}

"""
Streaming cursor of the table "user_credits"
"""
input user_credits_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_credits_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_credits_stream_cursor_value_input {
  created_at: timestamptz
  credits_available: Int
  credits_total_purchased: Int
  id: uuid
  last_purchase_at: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate sum on columns"""
type user_credits_sum_fields {
  credits_available: Int
  credits_total_purchased: Int
}

"""
update columns of table "user_credits"
"""
enum user_credits_update_column {
  """column name"""
  created_at

  """column name"""
  credits_available

  """column name"""
  credits_total_purchased

  """column name"""
  id

  """column name"""
  last_purchase_at

  """column name"""
  updated_at

  """column name"""
  user_id
}

input user_credits_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: user_credits_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: user_credits_set_input

  """filter the rows which have to be updated"""
  where: user_credits_bool_exp!
}

"""aggregate var_pop on columns"""
type user_credits_var_pop_fields {
  credits_available: Float
  credits_total_purchased: Float
}

"""aggregate var_samp on columns"""
type user_credits_var_samp_fields {
  credits_available: Float
  credits_total_purchased: Float
}

"""aggregate variance on columns"""
type user_credits_variance_fields {
  credits_available: Float
  credits_total_purchased: Float
}

scalar user_defined_filter

"""
Boolean expression to compare columns of type "user_defined_filter". All fields are combined with logical 'AND'.
"""
input user_defined_filter_array_comparison_exp {
  """is the array contained in the given array value"""
  _contained_in: [user_defined_filter!]

  """does the array contain the given value"""
  _contains: [user_defined_filter!]
  _eq: [user_defined_filter!]
  _gt: [user_defined_filter!]
  _gte: [user_defined_filter!]
  _in: [[user_defined_filter!]!]
  _is_null: Boolean
  _lt: [user_defined_filter!]
  _lte: [user_defined_filter!]
  _neq: [user_defined_filter!]
  _nin: [[user_defined_filter!]!]
}

"""Tracks user interactions and custom events"""
type user_events {
  created_at: timestamptz
  element_id: String
  element_text: String
  event_action: String
  event_category: String
  event_label: String
  event_name: String!
  event_value: numeric
  id: uuid!
  occurred_at: timestamptz
  page_path: String
  properties(
    """JSON select path"""
    path: String
  ): jsonb
  session_id: uuid!
  user_id: uuid
}

"""
aggregated selection of "user_events"
"""
type user_events_aggregate {
  aggregate: user_events_aggregate_fields
  nodes: [user_events!]!
}

"""
aggregate fields of "user_events"
"""
type user_events_aggregate_fields {
  avg: user_events_avg_fields
  count(columns: [user_events_select_column!], distinct: Boolean): Int!
  max: user_events_max_fields
  min: user_events_min_fields
  stddev: user_events_stddev_fields
  stddev_pop: user_events_stddev_pop_fields
  stddev_samp: user_events_stddev_samp_fields
  sum: user_events_sum_fields
  var_pop: user_events_var_pop_fields
  var_samp: user_events_var_samp_fields
  variance: user_events_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input user_events_append_input {
  properties: jsonb
}

"""aggregate avg on columns"""
type user_events_avg_fields {
  event_value: Float
}

"""
Boolean expression to filter rows from the table "user_events". All fields are combined with a logical 'AND'.
"""
input user_events_bool_exp {
  _and: [user_events_bool_exp!]
  _not: user_events_bool_exp
  _or: [user_events_bool_exp!]
  created_at: timestamptz_comparison_exp
  element_id: String_comparison_exp
  element_text: String_comparison_exp
  event_action: String_comparison_exp
  event_category: String_comparison_exp
  event_label: String_comparison_exp
  event_name: String_comparison_exp
  event_value: numeric_comparison_exp
  id: uuid_comparison_exp
  occurred_at: timestamptz_comparison_exp
  page_path: String_comparison_exp
  properties: jsonb_comparison_exp
  session_id: uuid_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "user_events"
"""
enum user_events_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_events_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input user_events_delete_at_path_input {
  properties: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input user_events_delete_elem_input {
  properties: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input user_events_delete_key_input {
  properties: String
}

"""
input type for incrementing numeric columns in table "user_events"
"""
input user_events_inc_input {
  event_value: numeric
}

"""
input type for inserting data into table "user_events"
"""
input user_events_insert_input {
  created_at: timestamptz
  element_id: String
  element_text: String
  event_action: String
  event_category: String
  event_label: String
  event_name: String
  event_value: numeric
  id: uuid
  occurred_at: timestamptz
  page_path: String
  properties: jsonb
  session_id: uuid
  user_id: uuid
}

"""aggregate max on columns"""
type user_events_max_fields {
  created_at: timestamptz
  element_id: String
  element_text: String
  event_action: String
  event_category: String
  event_label: String
  event_name: String
  event_value: numeric
  id: uuid
  occurred_at: timestamptz
  page_path: String
  session_id: uuid
  user_id: uuid
}

"""aggregate min on columns"""
type user_events_min_fields {
  created_at: timestamptz
  element_id: String
  element_text: String
  event_action: String
  event_category: String
  event_label: String
  event_name: String
  event_value: numeric
  id: uuid
  occurred_at: timestamptz
  page_path: String
  session_id: uuid
  user_id: uuid
}

"""
response of any mutation on the table "user_events"
"""
type user_events_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_events!]!
}

"""
on_conflict condition type for table "user_events"
"""
input user_events_on_conflict {
  constraint: user_events_constraint!
  update_columns: [user_events_update_column!]! = []
  where: user_events_bool_exp
}

"""Ordering options when selecting data from "user_events"."""
input user_events_order_by {
  created_at: order_by
  element_id: order_by
  element_text: order_by
  event_action: order_by
  event_category: order_by
  event_label: order_by
  event_name: order_by
  event_value: order_by
  id: order_by
  occurred_at: order_by
  page_path: order_by
  properties: order_by
  session_id: order_by
  user_id: order_by
}

"""primary key columns input for table: user_events"""
input user_events_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input user_events_prepend_input {
  properties: jsonb
}

"""
select columns of table "user_events"
"""
enum user_events_select_column {
  """column name"""
  created_at

  """column name"""
  element_id

  """column name"""
  element_text

  """column name"""
  event_action

  """column name"""
  event_category

  """column name"""
  event_label

  """column name"""
  event_name

  """column name"""
  event_value

  """column name"""
  id

  """column name"""
  occurred_at

  """column name"""
  page_path

  """column name"""
  properties

  """column name"""
  session_id

  """column name"""
  user_id
}

"""
input type for updating data in table "user_events"
"""
input user_events_set_input {
  created_at: timestamptz
  element_id: String
  element_text: String
  event_action: String
  event_category: String
  event_label: String
  event_name: String
  event_value: numeric
  id: uuid
  occurred_at: timestamptz
  page_path: String
  properties: jsonb
  session_id: uuid
  user_id: uuid
}

"""aggregate stddev on columns"""
type user_events_stddev_fields {
  event_value: Float
}

"""aggregate stddev_pop on columns"""
type user_events_stddev_pop_fields {
  event_value: Float
}

"""aggregate stddev_samp on columns"""
type user_events_stddev_samp_fields {
  event_value: Float
}

"""
Streaming cursor of the table "user_events"
"""
input user_events_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_events_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_events_stream_cursor_value_input {
  created_at: timestamptz
  element_id: String
  element_text: String
  event_action: String
  event_category: String
  event_label: String
  event_name: String
  event_value: numeric
  id: uuid
  occurred_at: timestamptz
  page_path: String
  properties: jsonb
  session_id: uuid
  user_id: uuid
}

"""aggregate sum on columns"""
type user_events_sum_fields {
  event_value: numeric
}

"""
update columns of table "user_events"
"""
enum user_events_update_column {
  """column name"""
  created_at

  """column name"""
  element_id

  """column name"""
  element_text

  """column name"""
  event_action

  """column name"""
  event_category

  """column name"""
  event_label

  """column name"""
  event_name

  """column name"""
  event_value

  """column name"""
  id

  """column name"""
  occurred_at

  """column name"""
  page_path

  """column name"""
  properties

  """column name"""
  session_id

  """column name"""
  user_id
}

input user_events_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: user_events_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: user_events_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: user_events_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: user_events_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: user_events_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: user_events_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: user_events_set_input

  """filter the rows which have to be updated"""
  where: user_events_bool_exp!
}

"""aggregate var_pop on columns"""
type user_events_var_pop_fields {
  event_value: Float
}

"""aggregate var_samp on columns"""
type user_events_var_samp_fields {
  event_value: Float
}

"""aggregate variance on columns"""
type user_events_variance_fields {
  event_value: Float
}

"""Aggregates user sessions with metrics"""
type user_sessions {
  browser: String
  city: String

  """An array relationship"""
  conversion_events(
    """distinct select on columns"""
    distinct_on: [conversion_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversion_events_order_by!]

    """filter the rows returned"""
    where: conversion_events_bool_exp
  ): [conversion_events!]!

  """An aggregate relationship"""
  conversion_events_aggregate(
    """distinct select on columns"""
    distinct_on: [conversion_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversion_events_order_by!]

    """filter the rows returned"""
    where: conversion_events_bool_exp
  ): conversion_events_aggregate!
  country: String
  created_at: timestamptz
  device_type: String
  duration: Int
  entry_page: String
  events_count: Int
  exit_page: String
  id: uuid!
  is_active: Boolean
  os: String
  page_views_count: Int
  session_end: timestamptz
  session_start: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""
aggregated selection of "user_sessions"
"""
type user_sessions_aggregate {
  aggregate: user_sessions_aggregate_fields
  nodes: [user_sessions!]!
}

"""
aggregate fields of "user_sessions"
"""
type user_sessions_aggregate_fields {
  avg: user_sessions_avg_fields
  count(columns: [user_sessions_select_column!], distinct: Boolean): Int!
  max: user_sessions_max_fields
  min: user_sessions_min_fields
  stddev: user_sessions_stddev_fields
  stddev_pop: user_sessions_stddev_pop_fields
  stddev_samp: user_sessions_stddev_samp_fields
  sum: user_sessions_sum_fields
  var_pop: user_sessions_var_pop_fields
  var_samp: user_sessions_var_samp_fields
  variance: user_sessions_variance_fields
}

"""aggregate avg on columns"""
type user_sessions_avg_fields {
  duration: Float
  events_count: Float
  page_views_count: Float
}

"""
Boolean expression to filter rows from the table "user_sessions". All fields are combined with a logical 'AND'.
"""
input user_sessions_bool_exp {
  _and: [user_sessions_bool_exp!]
  _not: user_sessions_bool_exp
  _or: [user_sessions_bool_exp!]
  browser: String_comparison_exp
  city: String_comparison_exp
  conversion_events: conversion_events_bool_exp
  conversion_events_aggregate: conversion_events_aggregate_bool_exp
  country: String_comparison_exp
  created_at: timestamptz_comparison_exp
  device_type: String_comparison_exp
  duration: Int_comparison_exp
  entry_page: String_comparison_exp
  events_count: Int_comparison_exp
  exit_page: String_comparison_exp
  id: uuid_comparison_exp
  is_active: Boolean_comparison_exp
  os: String_comparison_exp
  page_views_count: Int_comparison_exp
  session_end: timestamptz_comparison_exp
  session_start: timestamptz_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "user_sessions"
"""
enum user_sessions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_sessions_pkey
}

"""
input type for incrementing numeric columns in table "user_sessions"
"""
input user_sessions_inc_input {
  duration: Int
  events_count: Int
  page_views_count: Int
}

"""
input type for inserting data into table "user_sessions"
"""
input user_sessions_insert_input {
  browser: String
  city: String
  conversion_events: conversion_events_arr_rel_insert_input
  country: String
  created_at: timestamptz
  device_type: String
  duration: Int
  entry_page: String
  events_count: Int
  exit_page: String
  id: uuid
  is_active: Boolean
  os: String
  page_views_count: Int
  session_end: timestamptz
  session_start: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate max on columns"""
type user_sessions_max_fields {
  browser: String
  city: String
  country: String
  created_at: timestamptz
  device_type: String
  duration: Int
  entry_page: String
  events_count: Int
  exit_page: String
  id: uuid
  os: String
  page_views_count: Int
  session_end: timestamptz
  session_start: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate min on columns"""
type user_sessions_min_fields {
  browser: String
  city: String
  country: String
  created_at: timestamptz
  device_type: String
  duration: Int
  entry_page: String
  events_count: Int
  exit_page: String
  id: uuid
  os: String
  page_views_count: Int
  session_end: timestamptz
  session_start: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""
response of any mutation on the table "user_sessions"
"""
type user_sessions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_sessions!]!
}

"""
input type for inserting object relation for remote table "user_sessions"
"""
input user_sessions_obj_rel_insert_input {
  data: user_sessions_insert_input!

  """upsert condition"""
  on_conflict: user_sessions_on_conflict
}

"""
on_conflict condition type for table "user_sessions"
"""
input user_sessions_on_conflict {
  constraint: user_sessions_constraint!
  update_columns: [user_sessions_update_column!]! = []
  where: user_sessions_bool_exp
}

"""Ordering options when selecting data from "user_sessions"."""
input user_sessions_order_by {
  browser: order_by
  city: order_by
  conversion_events_aggregate: conversion_events_aggregate_order_by
  country: order_by
  created_at: order_by
  device_type: order_by
  duration: order_by
  entry_page: order_by
  events_count: order_by
  exit_page: order_by
  id: order_by
  is_active: order_by
  os: order_by
  page_views_count: order_by
  session_end: order_by
  session_start: order_by
  updated_at: order_by
  user_id: order_by
}

"""primary key columns input for table: user_sessions"""
input user_sessions_pk_columns_input {
  id: uuid!
}

"""
select columns of table "user_sessions"
"""
enum user_sessions_select_column {
  """column name"""
  browser

  """column name"""
  city

  """column name"""
  country

  """column name"""
  created_at

  """column name"""
  device_type

  """column name"""
  duration

  """column name"""
  entry_page

  """column name"""
  events_count

  """column name"""
  exit_page

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  os

  """column name"""
  page_views_count

  """column name"""
  session_end

  """column name"""
  session_start

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "user_sessions"
"""
input user_sessions_set_input {
  browser: String
  city: String
  country: String
  created_at: timestamptz
  device_type: String
  duration: Int
  entry_page: String
  events_count: Int
  exit_page: String
  id: uuid
  is_active: Boolean
  os: String
  page_views_count: Int
  session_end: timestamptz
  session_start: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate stddev on columns"""
type user_sessions_stddev_fields {
  duration: Float
  events_count: Float
  page_views_count: Float
}

"""aggregate stddev_pop on columns"""
type user_sessions_stddev_pop_fields {
  duration: Float
  events_count: Float
  page_views_count: Float
}

"""aggregate stddev_samp on columns"""
type user_sessions_stddev_samp_fields {
  duration: Float
  events_count: Float
  page_views_count: Float
}

"""
Streaming cursor of the table "user_sessions"
"""
input user_sessions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_sessions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_sessions_stream_cursor_value_input {
  browser: String
  city: String
  country: String
  created_at: timestamptz
  device_type: String
  duration: Int
  entry_page: String
  events_count: Int
  exit_page: String
  id: uuid
  is_active: Boolean
  os: String
  page_views_count: Int
  session_end: timestamptz
  session_start: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate sum on columns"""
type user_sessions_sum_fields {
  duration: Int
  events_count: Int
  page_views_count: Int
}

"""
update columns of table "user_sessions"
"""
enum user_sessions_update_column {
  """column name"""
  browser

  """column name"""
  city

  """column name"""
  country

  """column name"""
  created_at

  """column name"""
  device_type

  """column name"""
  duration

  """column name"""
  entry_page

  """column name"""
  events_count

  """column name"""
  exit_page

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  os

  """column name"""
  page_views_count

  """column name"""
  session_end

  """column name"""
  session_start

  """column name"""
  updated_at

  """column name"""
  user_id
}

input user_sessions_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: user_sessions_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: user_sessions_set_input

  """filter the rows which have to be updated"""
  where: user_sessions_bool_exp!
}

"""aggregate var_pop on columns"""
type user_sessions_var_pop_fields {
  duration: Float
  events_count: Float
  page_views_count: Float
}

"""aggregate var_samp on columns"""
type user_sessions_var_samp_fields {
  duration: Float
  events_count: Float
  page_views_count: Float
}

"""aggregate variance on columns"""
type user_sessions_variance_fields {
  duration: Float
  events_count: Float
  page_views_count: Float
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""Stores scheduled video interviews between sponsors and maids"""
type video_interviews {
  """When admin approved the interview request"""
  admin_confirmed_at: timestamptz

  """Which admin approved the request"""
  admin_confirmed_by: uuid
  admin_notes: String

  """An object relationship"""
  admin_user: admin_users

  """Agency managing this maid (if applicable)"""
  agency_id: uuid
  agency_notified_at: timestamptz
  booking_id: uuid
  cancelled_at: timestamptz
  completed_at: timestamptz
  confirmed_at: timestamptz
  created_at: timestamptz
  created_via: String
  duration_minutes: Int
  id: uuid!

  """An array relationship"""
  interview_notifications(
    """distinct select on columns"""
    distinct_on: [interview_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [interview_notifications_order_by!]

    """filter the rows returned"""
    where: interview_notifications_bool_exp
  ): [interview_notifications!]!

  """An aggregate relationship"""
  interview_notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [interview_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [interview_notifications_order_by!]

    """filter the rows returned"""
    where: interview_notifications_bool_exp
  ): interview_notifications_aggregate!

  """Platform to be used for the video interview"""
  interview_type: String

  """An object relationship"""
  maid_booking: maid_bookings
  maid_confirmation_sent_at: timestamptz

  """When maid confirmed availability"""
  maid_confirmed_at: timestamptz
  maid_feedback: String
  maid_id: uuid
  maid_notes: String
  maid_phone: String

  """Maid rates sponsor after interview (1-5)"""
  maid_rating: Int
  meeting_id: String

  """Video call link (Zoom, Google Meet, etc.)"""
  meeting_link: String
  meeting_password: String
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  notes: String

  """JSON with setup instructions, download links, etc."""
  platform_instructions(
    """JSON select path"""
    path: String
  ): jsonb
  platform_link_type: String
  rejection_reason: String

  """Reminder sent 1 hour before interview"""
  reminder_sent_1h: Boolean

  """Reminder sent 15 minutes before interview"""
  reminder_sent_15min: Boolean

  """Reminder sent 24 hours before interview"""
  reminder_sent_24h: Boolean
  scheduled_date: timestamptz!
  sponsor_confirmation_sent_at: timestamptz
  sponsor_feedback: String
  sponsor_id: uuid
  sponsor_name: String
  sponsor_notes: String
  sponsor_phone: String!

  """Sponsor rates maid after interview (1-5)"""
  sponsor_rating: Int
  started_at: timestamptz
  status: String
  timezone: String
  updated_at: timestamptz
}

"""
aggregated selection of "video_interviews"
"""
type video_interviews_aggregate {
  aggregate: video_interviews_aggregate_fields
  nodes: [video_interviews!]!
}

input video_interviews_aggregate_bool_exp {
  bool_and: video_interviews_aggregate_bool_exp_bool_and
  bool_or: video_interviews_aggregate_bool_exp_bool_or
  count: video_interviews_aggregate_bool_exp_count
}

input video_interviews_aggregate_bool_exp_bool_and {
  arguments: video_interviews_select_column_video_interviews_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: video_interviews_bool_exp
  predicate: Boolean_comparison_exp!
}

input video_interviews_aggregate_bool_exp_bool_or {
  arguments: video_interviews_select_column_video_interviews_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: video_interviews_bool_exp
  predicate: Boolean_comparison_exp!
}

input video_interviews_aggregate_bool_exp_count {
  arguments: [video_interviews_select_column!]
  distinct: Boolean
  filter: video_interviews_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "video_interviews"
"""
type video_interviews_aggregate_fields {
  avg: video_interviews_avg_fields
  count(columns: [video_interviews_select_column!], distinct: Boolean): Int!
  max: video_interviews_max_fields
  min: video_interviews_min_fields
  stddev: video_interviews_stddev_fields
  stddev_pop: video_interviews_stddev_pop_fields
  stddev_samp: video_interviews_stddev_samp_fields
  sum: video_interviews_sum_fields
  var_pop: video_interviews_var_pop_fields
  var_samp: video_interviews_var_samp_fields
  variance: video_interviews_variance_fields
}

"""
order by aggregate values of table "video_interviews"
"""
input video_interviews_aggregate_order_by {
  avg: video_interviews_avg_order_by
  count: order_by
  max: video_interviews_max_order_by
  min: video_interviews_min_order_by
  stddev: video_interviews_stddev_order_by
  stddev_pop: video_interviews_stddev_pop_order_by
  stddev_samp: video_interviews_stddev_samp_order_by
  sum: video_interviews_sum_order_by
  var_pop: video_interviews_var_pop_order_by
  var_samp: video_interviews_var_samp_order_by
  variance: video_interviews_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input video_interviews_append_input {
  metadata: jsonb

  """JSON with setup instructions, download links, etc."""
  platform_instructions: jsonb
}

"""
input type for inserting array relation for remote table "video_interviews"
"""
input video_interviews_arr_rel_insert_input {
  data: [video_interviews_insert_input!]!

  """upsert condition"""
  on_conflict: video_interviews_on_conflict
}

"""aggregate avg on columns"""
type video_interviews_avg_fields {
  duration_minutes: Float

  """Maid rates sponsor after interview (1-5)"""
  maid_rating: Float

  """Sponsor rates maid after interview (1-5)"""
  sponsor_rating: Float
}

"""
order by avg() on columns of table "video_interviews"
"""
input video_interviews_avg_order_by {
  duration_minutes: order_by

  """Maid rates sponsor after interview (1-5)"""
  maid_rating: order_by

  """Sponsor rates maid after interview (1-5)"""
  sponsor_rating: order_by
}

"""
Boolean expression to filter rows from the table "video_interviews". All fields are combined with a logical 'AND'.
"""
input video_interviews_bool_exp {
  _and: [video_interviews_bool_exp!]
  _not: video_interviews_bool_exp
  _or: [video_interviews_bool_exp!]
  admin_confirmed_at: timestamptz_comparison_exp
  admin_confirmed_by: uuid_comparison_exp
  admin_notes: String_comparison_exp
  admin_user: admin_users_bool_exp
  agency_id: uuid_comparison_exp
  agency_notified_at: timestamptz_comparison_exp
  booking_id: uuid_comparison_exp
  cancelled_at: timestamptz_comparison_exp
  completed_at: timestamptz_comparison_exp
  confirmed_at: timestamptz_comparison_exp
  created_at: timestamptz_comparison_exp
  created_via: String_comparison_exp
  duration_minutes: Int_comparison_exp
  id: uuid_comparison_exp
  interview_notifications: interview_notifications_bool_exp
  interview_notifications_aggregate: interview_notifications_aggregate_bool_exp
  interview_type: String_comparison_exp
  maid_booking: maid_bookings_bool_exp
  maid_confirmation_sent_at: timestamptz_comparison_exp
  maid_confirmed_at: timestamptz_comparison_exp
  maid_feedback: String_comparison_exp
  maid_id: uuid_comparison_exp
  maid_notes: String_comparison_exp
  maid_phone: String_comparison_exp
  maid_rating: Int_comparison_exp
  meeting_id: String_comparison_exp
  meeting_link: String_comparison_exp
  meeting_password: String_comparison_exp
  metadata: jsonb_comparison_exp
  notes: String_comparison_exp
  platform_instructions: jsonb_comparison_exp
  platform_link_type: String_comparison_exp
  rejection_reason: String_comparison_exp
  reminder_sent_1h: Boolean_comparison_exp
  reminder_sent_15min: Boolean_comparison_exp
  reminder_sent_24h: Boolean_comparison_exp
  scheduled_date: timestamptz_comparison_exp
  sponsor_confirmation_sent_at: timestamptz_comparison_exp
  sponsor_feedback: String_comparison_exp
  sponsor_id: uuid_comparison_exp
  sponsor_name: String_comparison_exp
  sponsor_notes: String_comparison_exp
  sponsor_phone: String_comparison_exp
  sponsor_rating: Int_comparison_exp
  started_at: timestamptz_comparison_exp
  status: String_comparison_exp
  timezone: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "video_interviews"
"""
enum video_interviews_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  video_interviews_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input video_interviews_delete_at_path_input {
  metadata: [String!]

  """JSON with setup instructions, download links, etc."""
  platform_instructions: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input video_interviews_delete_elem_input {
  metadata: Int

  """JSON with setup instructions, download links, etc."""
  platform_instructions: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input video_interviews_delete_key_input {
  metadata: String

  """JSON with setup instructions, download links, etc."""
  platform_instructions: String
}

"""
input type for incrementing numeric columns in table "video_interviews"
"""
input video_interviews_inc_input {
  duration_minutes: Int

  """Maid rates sponsor after interview (1-5)"""
  maid_rating: Int

  """Sponsor rates maid after interview (1-5)"""
  sponsor_rating: Int
}

"""
input type for inserting data into table "video_interviews"
"""
input video_interviews_insert_input {
  """When admin approved the interview request"""
  admin_confirmed_at: timestamptz

  """Which admin approved the request"""
  admin_confirmed_by: uuid
  admin_notes: String
  admin_user: admin_users_obj_rel_insert_input

  """Agency managing this maid (if applicable)"""
  agency_id: uuid
  agency_notified_at: timestamptz
  booking_id: uuid
  cancelled_at: timestamptz
  completed_at: timestamptz
  confirmed_at: timestamptz
  created_at: timestamptz
  created_via: String
  duration_minutes: Int
  id: uuid
  interview_notifications: interview_notifications_arr_rel_insert_input

  """Platform to be used for the video interview"""
  interview_type: String
  maid_booking: maid_bookings_obj_rel_insert_input
  maid_confirmation_sent_at: timestamptz

  """When maid confirmed availability"""
  maid_confirmed_at: timestamptz
  maid_feedback: String
  maid_id: uuid
  maid_notes: String
  maid_phone: String

  """Maid rates sponsor after interview (1-5)"""
  maid_rating: Int
  meeting_id: String

  """Video call link (Zoom, Google Meet, etc.)"""
  meeting_link: String
  meeting_password: String
  metadata: jsonb
  notes: String

  """JSON with setup instructions, download links, etc."""
  platform_instructions: jsonb
  platform_link_type: String
  rejection_reason: String

  """Reminder sent 1 hour before interview"""
  reminder_sent_1h: Boolean

  """Reminder sent 15 minutes before interview"""
  reminder_sent_15min: Boolean

  """Reminder sent 24 hours before interview"""
  reminder_sent_24h: Boolean
  scheduled_date: timestamptz
  sponsor_confirmation_sent_at: timestamptz
  sponsor_feedback: String
  sponsor_id: uuid
  sponsor_name: String
  sponsor_notes: String
  sponsor_phone: String

  """Sponsor rates maid after interview (1-5)"""
  sponsor_rating: Int
  started_at: timestamptz
  status: String
  timezone: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type video_interviews_max_fields {
  """When admin approved the interview request"""
  admin_confirmed_at: timestamptz

  """Which admin approved the request"""
  admin_confirmed_by: uuid
  admin_notes: String

  """Agency managing this maid (if applicable)"""
  agency_id: uuid
  agency_notified_at: timestamptz
  booking_id: uuid
  cancelled_at: timestamptz
  completed_at: timestamptz
  confirmed_at: timestamptz
  created_at: timestamptz
  created_via: String
  duration_minutes: Int
  id: uuid

  """Platform to be used for the video interview"""
  interview_type: String
  maid_confirmation_sent_at: timestamptz

  """When maid confirmed availability"""
  maid_confirmed_at: timestamptz
  maid_feedback: String
  maid_id: uuid
  maid_notes: String
  maid_phone: String

  """Maid rates sponsor after interview (1-5)"""
  maid_rating: Int
  meeting_id: String

  """Video call link (Zoom, Google Meet, etc.)"""
  meeting_link: String
  meeting_password: String
  notes: String
  platform_link_type: String
  rejection_reason: String
  scheduled_date: timestamptz
  sponsor_confirmation_sent_at: timestamptz
  sponsor_feedback: String
  sponsor_id: uuid
  sponsor_name: String
  sponsor_notes: String
  sponsor_phone: String

  """Sponsor rates maid after interview (1-5)"""
  sponsor_rating: Int
  started_at: timestamptz
  status: String
  timezone: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "video_interviews"
"""
input video_interviews_max_order_by {
  """When admin approved the interview request"""
  admin_confirmed_at: order_by

  """Which admin approved the request"""
  admin_confirmed_by: order_by
  admin_notes: order_by

  """Agency managing this maid (if applicable)"""
  agency_id: order_by
  agency_notified_at: order_by
  booking_id: order_by
  cancelled_at: order_by
  completed_at: order_by
  confirmed_at: order_by
  created_at: order_by
  created_via: order_by
  duration_minutes: order_by
  id: order_by

  """Platform to be used for the video interview"""
  interview_type: order_by
  maid_confirmation_sent_at: order_by

  """When maid confirmed availability"""
  maid_confirmed_at: order_by
  maid_feedback: order_by
  maid_id: order_by
  maid_notes: order_by
  maid_phone: order_by

  """Maid rates sponsor after interview (1-5)"""
  maid_rating: order_by
  meeting_id: order_by

  """Video call link (Zoom, Google Meet, etc.)"""
  meeting_link: order_by
  meeting_password: order_by
  notes: order_by
  platform_link_type: order_by
  rejection_reason: order_by
  scheduled_date: order_by
  sponsor_confirmation_sent_at: order_by
  sponsor_feedback: order_by
  sponsor_id: order_by
  sponsor_name: order_by
  sponsor_notes: order_by
  sponsor_phone: order_by

  """Sponsor rates maid after interview (1-5)"""
  sponsor_rating: order_by
  started_at: order_by
  status: order_by
  timezone: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type video_interviews_min_fields {
  """When admin approved the interview request"""
  admin_confirmed_at: timestamptz

  """Which admin approved the request"""
  admin_confirmed_by: uuid
  admin_notes: String

  """Agency managing this maid (if applicable)"""
  agency_id: uuid
  agency_notified_at: timestamptz
  booking_id: uuid
  cancelled_at: timestamptz
  completed_at: timestamptz
  confirmed_at: timestamptz
  created_at: timestamptz
  created_via: String
  duration_minutes: Int
  id: uuid

  """Platform to be used for the video interview"""
  interview_type: String
  maid_confirmation_sent_at: timestamptz

  """When maid confirmed availability"""
  maid_confirmed_at: timestamptz
  maid_feedback: String
  maid_id: uuid
  maid_notes: String
  maid_phone: String

  """Maid rates sponsor after interview (1-5)"""
  maid_rating: Int
  meeting_id: String

  """Video call link (Zoom, Google Meet, etc.)"""
  meeting_link: String
  meeting_password: String
  notes: String
  platform_link_type: String
  rejection_reason: String
  scheduled_date: timestamptz
  sponsor_confirmation_sent_at: timestamptz
  sponsor_feedback: String
  sponsor_id: uuid
  sponsor_name: String
  sponsor_notes: String
  sponsor_phone: String

  """Sponsor rates maid after interview (1-5)"""
  sponsor_rating: Int
  started_at: timestamptz
  status: String
  timezone: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "video_interviews"
"""
input video_interviews_min_order_by {
  """When admin approved the interview request"""
  admin_confirmed_at: order_by

  """Which admin approved the request"""
  admin_confirmed_by: order_by
  admin_notes: order_by

  """Agency managing this maid (if applicable)"""
  agency_id: order_by
  agency_notified_at: order_by
  booking_id: order_by
  cancelled_at: order_by
  completed_at: order_by
  confirmed_at: order_by
  created_at: order_by
  created_via: order_by
  duration_minutes: order_by
  id: order_by

  """Platform to be used for the video interview"""
  interview_type: order_by
  maid_confirmation_sent_at: order_by

  """When maid confirmed availability"""
  maid_confirmed_at: order_by
  maid_feedback: order_by
  maid_id: order_by
  maid_notes: order_by
  maid_phone: order_by

  """Maid rates sponsor after interview (1-5)"""
  maid_rating: order_by
  meeting_id: order_by

  """Video call link (Zoom, Google Meet, etc.)"""
  meeting_link: order_by
  meeting_password: order_by
  notes: order_by
  platform_link_type: order_by
  rejection_reason: order_by
  scheduled_date: order_by
  sponsor_confirmation_sent_at: order_by
  sponsor_feedback: order_by
  sponsor_id: order_by
  sponsor_name: order_by
  sponsor_notes: order_by
  sponsor_phone: order_by

  """Sponsor rates maid after interview (1-5)"""
  sponsor_rating: order_by
  started_at: order_by
  status: order_by
  timezone: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "video_interviews"
"""
type video_interviews_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [video_interviews!]!
}

"""
input type for inserting object relation for remote table "video_interviews"
"""
input video_interviews_obj_rel_insert_input {
  data: video_interviews_insert_input!

  """upsert condition"""
  on_conflict: video_interviews_on_conflict
}

"""
on_conflict condition type for table "video_interviews"
"""
input video_interviews_on_conflict {
  constraint: video_interviews_constraint!
  update_columns: [video_interviews_update_column!]! = []
  where: video_interviews_bool_exp
}

"""Ordering options when selecting data from "video_interviews"."""
input video_interviews_order_by {
  admin_confirmed_at: order_by
  admin_confirmed_by: order_by
  admin_notes: order_by
  admin_user: admin_users_order_by
  agency_id: order_by
  agency_notified_at: order_by
  booking_id: order_by
  cancelled_at: order_by
  completed_at: order_by
  confirmed_at: order_by
  created_at: order_by
  created_via: order_by
  duration_minutes: order_by
  id: order_by
  interview_notifications_aggregate: interview_notifications_aggregate_order_by
  interview_type: order_by
  maid_booking: maid_bookings_order_by
  maid_confirmation_sent_at: order_by
  maid_confirmed_at: order_by
  maid_feedback: order_by
  maid_id: order_by
  maid_notes: order_by
  maid_phone: order_by
  maid_rating: order_by
  meeting_id: order_by
  meeting_link: order_by
  meeting_password: order_by
  metadata: order_by
  notes: order_by
  platform_instructions: order_by
  platform_link_type: order_by
  rejection_reason: order_by
  reminder_sent_1h: order_by
  reminder_sent_15min: order_by
  reminder_sent_24h: order_by
  scheduled_date: order_by
  sponsor_confirmation_sent_at: order_by
  sponsor_feedback: order_by
  sponsor_id: order_by
  sponsor_name: order_by
  sponsor_notes: order_by
  sponsor_phone: order_by
  sponsor_rating: order_by
  started_at: order_by
  status: order_by
  timezone: order_by
  updated_at: order_by
}

"""primary key columns input for table: video_interviews"""
input video_interviews_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input video_interviews_prepend_input {
  metadata: jsonb

  """JSON with setup instructions, download links, etc."""
  platform_instructions: jsonb
}

"""
select columns of table "video_interviews"
"""
enum video_interviews_select_column {
  """column name"""
  admin_confirmed_at

  """column name"""
  admin_confirmed_by

  """column name"""
  admin_notes

  """column name"""
  agency_id

  """column name"""
  agency_notified_at

  """column name"""
  booking_id

  """column name"""
  cancelled_at

  """column name"""
  completed_at

  """column name"""
  confirmed_at

  """column name"""
  created_at

  """column name"""
  created_via

  """column name"""
  duration_minutes

  """column name"""
  id

  """column name"""
  interview_type

  """column name"""
  maid_confirmation_sent_at

  """column name"""
  maid_confirmed_at

  """column name"""
  maid_feedback

  """column name"""
  maid_id

  """column name"""
  maid_notes

  """column name"""
  maid_phone

  """column name"""
  maid_rating

  """column name"""
  meeting_id

  """column name"""
  meeting_link

  """column name"""
  meeting_password

  """column name"""
  metadata

  """column name"""
  notes

  """column name"""
  platform_instructions

  """column name"""
  platform_link_type

  """column name"""
  rejection_reason

  """column name"""
  reminder_sent_1h

  """column name"""
  reminder_sent_15min

  """column name"""
  reminder_sent_24h

  """column name"""
  scheduled_date

  """column name"""
  sponsor_confirmation_sent_at

  """column name"""
  sponsor_feedback

  """column name"""
  sponsor_id

  """column name"""
  sponsor_name

  """column name"""
  sponsor_notes

  """column name"""
  sponsor_phone

  """column name"""
  sponsor_rating

  """column name"""
  started_at

  """column name"""
  status

  """column name"""
  timezone

  """column name"""
  updated_at
}

"""
select "video_interviews_aggregate_bool_exp_bool_and_arguments_columns" columns of table "video_interviews"
"""
enum video_interviews_select_column_video_interviews_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  reminder_sent_1h

  """column name"""
  reminder_sent_15min

  """column name"""
  reminder_sent_24h
}

"""
select "video_interviews_aggregate_bool_exp_bool_or_arguments_columns" columns of table "video_interviews"
"""
enum video_interviews_select_column_video_interviews_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  reminder_sent_1h

  """column name"""
  reminder_sent_15min

  """column name"""
  reminder_sent_24h
}

"""
input type for updating data in table "video_interviews"
"""
input video_interviews_set_input {
  """When admin approved the interview request"""
  admin_confirmed_at: timestamptz

  """Which admin approved the request"""
  admin_confirmed_by: uuid
  admin_notes: String

  """Agency managing this maid (if applicable)"""
  agency_id: uuid
  agency_notified_at: timestamptz
  booking_id: uuid
  cancelled_at: timestamptz
  completed_at: timestamptz
  confirmed_at: timestamptz
  created_at: timestamptz
  created_via: String
  duration_minutes: Int
  id: uuid

  """Platform to be used for the video interview"""
  interview_type: String
  maid_confirmation_sent_at: timestamptz

  """When maid confirmed availability"""
  maid_confirmed_at: timestamptz
  maid_feedback: String
  maid_id: uuid
  maid_notes: String
  maid_phone: String

  """Maid rates sponsor after interview (1-5)"""
  maid_rating: Int
  meeting_id: String

  """Video call link (Zoom, Google Meet, etc.)"""
  meeting_link: String
  meeting_password: String
  metadata: jsonb
  notes: String

  """JSON with setup instructions, download links, etc."""
  platform_instructions: jsonb
  platform_link_type: String
  rejection_reason: String

  """Reminder sent 1 hour before interview"""
  reminder_sent_1h: Boolean

  """Reminder sent 15 minutes before interview"""
  reminder_sent_15min: Boolean

  """Reminder sent 24 hours before interview"""
  reminder_sent_24h: Boolean
  scheduled_date: timestamptz
  sponsor_confirmation_sent_at: timestamptz
  sponsor_feedback: String
  sponsor_id: uuid
  sponsor_name: String
  sponsor_notes: String
  sponsor_phone: String

  """Sponsor rates maid after interview (1-5)"""
  sponsor_rating: Int
  started_at: timestamptz
  status: String
  timezone: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type video_interviews_stddev_fields {
  duration_minutes: Float

  """Maid rates sponsor after interview (1-5)"""
  maid_rating: Float

  """Sponsor rates maid after interview (1-5)"""
  sponsor_rating: Float
}

"""
order by stddev() on columns of table "video_interviews"
"""
input video_interviews_stddev_order_by {
  duration_minutes: order_by

  """Maid rates sponsor after interview (1-5)"""
  maid_rating: order_by

  """Sponsor rates maid after interview (1-5)"""
  sponsor_rating: order_by
}

"""aggregate stddev_pop on columns"""
type video_interviews_stddev_pop_fields {
  duration_minutes: Float

  """Maid rates sponsor after interview (1-5)"""
  maid_rating: Float

  """Sponsor rates maid after interview (1-5)"""
  sponsor_rating: Float
}

"""
order by stddev_pop() on columns of table "video_interviews"
"""
input video_interviews_stddev_pop_order_by {
  duration_minutes: order_by

  """Maid rates sponsor after interview (1-5)"""
  maid_rating: order_by

  """Sponsor rates maid after interview (1-5)"""
  sponsor_rating: order_by
}

"""aggregate stddev_samp on columns"""
type video_interviews_stddev_samp_fields {
  duration_minutes: Float

  """Maid rates sponsor after interview (1-5)"""
  maid_rating: Float

  """Sponsor rates maid after interview (1-5)"""
  sponsor_rating: Float
}

"""
order by stddev_samp() on columns of table "video_interviews"
"""
input video_interviews_stddev_samp_order_by {
  duration_minutes: order_by

  """Maid rates sponsor after interview (1-5)"""
  maid_rating: order_by

  """Sponsor rates maid after interview (1-5)"""
  sponsor_rating: order_by
}

"""
Streaming cursor of the table "video_interviews"
"""
input video_interviews_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: video_interviews_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input video_interviews_stream_cursor_value_input {
  """When admin approved the interview request"""
  admin_confirmed_at: timestamptz

  """Which admin approved the request"""
  admin_confirmed_by: uuid
  admin_notes: String

  """Agency managing this maid (if applicable)"""
  agency_id: uuid
  agency_notified_at: timestamptz
  booking_id: uuid
  cancelled_at: timestamptz
  completed_at: timestamptz
  confirmed_at: timestamptz
  created_at: timestamptz
  created_via: String
  duration_minutes: Int
  id: uuid

  """Platform to be used for the video interview"""
  interview_type: String
  maid_confirmation_sent_at: timestamptz

  """When maid confirmed availability"""
  maid_confirmed_at: timestamptz
  maid_feedback: String
  maid_id: uuid
  maid_notes: String
  maid_phone: String

  """Maid rates sponsor after interview (1-5)"""
  maid_rating: Int
  meeting_id: String

  """Video call link (Zoom, Google Meet, etc.)"""
  meeting_link: String
  meeting_password: String
  metadata: jsonb
  notes: String

  """JSON with setup instructions, download links, etc."""
  platform_instructions: jsonb
  platform_link_type: String
  rejection_reason: String

  """Reminder sent 1 hour before interview"""
  reminder_sent_1h: Boolean

  """Reminder sent 15 minutes before interview"""
  reminder_sent_15min: Boolean

  """Reminder sent 24 hours before interview"""
  reminder_sent_24h: Boolean
  scheduled_date: timestamptz
  sponsor_confirmation_sent_at: timestamptz
  sponsor_feedback: String
  sponsor_id: uuid
  sponsor_name: String
  sponsor_notes: String
  sponsor_phone: String

  """Sponsor rates maid after interview (1-5)"""
  sponsor_rating: Int
  started_at: timestamptz
  status: String
  timezone: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type video_interviews_sum_fields {
  duration_minutes: Int

  """Maid rates sponsor after interview (1-5)"""
  maid_rating: Int

  """Sponsor rates maid after interview (1-5)"""
  sponsor_rating: Int
}

"""
order by sum() on columns of table "video_interviews"
"""
input video_interviews_sum_order_by {
  duration_minutes: order_by

  """Maid rates sponsor after interview (1-5)"""
  maid_rating: order_by

  """Sponsor rates maid after interview (1-5)"""
  sponsor_rating: order_by
}

"""
update columns of table "video_interviews"
"""
enum video_interviews_update_column {
  """column name"""
  admin_confirmed_at

  """column name"""
  admin_confirmed_by

  """column name"""
  admin_notes

  """column name"""
  agency_id

  """column name"""
  agency_notified_at

  """column name"""
  booking_id

  """column name"""
  cancelled_at

  """column name"""
  completed_at

  """column name"""
  confirmed_at

  """column name"""
  created_at

  """column name"""
  created_via

  """column name"""
  duration_minutes

  """column name"""
  id

  """column name"""
  interview_type

  """column name"""
  maid_confirmation_sent_at

  """column name"""
  maid_confirmed_at

  """column name"""
  maid_feedback

  """column name"""
  maid_id

  """column name"""
  maid_notes

  """column name"""
  maid_phone

  """column name"""
  maid_rating

  """column name"""
  meeting_id

  """column name"""
  meeting_link

  """column name"""
  meeting_password

  """column name"""
  metadata

  """column name"""
  notes

  """column name"""
  platform_instructions

  """column name"""
  platform_link_type

  """column name"""
  rejection_reason

  """column name"""
  reminder_sent_1h

  """column name"""
  reminder_sent_15min

  """column name"""
  reminder_sent_24h

  """column name"""
  scheduled_date

  """column name"""
  sponsor_confirmation_sent_at

  """column name"""
  sponsor_feedback

  """column name"""
  sponsor_id

  """column name"""
  sponsor_name

  """column name"""
  sponsor_notes

  """column name"""
  sponsor_phone

  """column name"""
  sponsor_rating

  """column name"""
  started_at

  """column name"""
  status

  """column name"""
  timezone

  """column name"""
  updated_at
}

input video_interviews_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: video_interviews_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: video_interviews_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: video_interviews_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: video_interviews_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: video_interviews_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: video_interviews_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: video_interviews_set_input

  """filter the rows which have to be updated"""
  where: video_interviews_bool_exp!
}

"""aggregate var_pop on columns"""
type video_interviews_var_pop_fields {
  duration_minutes: Float

  """Maid rates sponsor after interview (1-5)"""
  maid_rating: Float

  """Sponsor rates maid after interview (1-5)"""
  sponsor_rating: Float
}

"""
order by var_pop() on columns of table "video_interviews"
"""
input video_interviews_var_pop_order_by {
  duration_minutes: order_by

  """Maid rates sponsor after interview (1-5)"""
  maid_rating: order_by

  """Sponsor rates maid after interview (1-5)"""
  sponsor_rating: order_by
}

"""aggregate var_samp on columns"""
type video_interviews_var_samp_fields {
  duration_minutes: Float

  """Maid rates sponsor after interview (1-5)"""
  maid_rating: Float

  """Sponsor rates maid after interview (1-5)"""
  sponsor_rating: Float
}

"""
order by var_samp() on columns of table "video_interviews"
"""
input video_interviews_var_samp_order_by {
  duration_minutes: order_by

  """Maid rates sponsor after interview (1-5)"""
  maid_rating: order_by

  """Sponsor rates maid after interview (1-5)"""
  sponsor_rating: order_by
}

"""aggregate variance on columns"""
type video_interviews_variance_fields {
  duration_minutes: Float

  """Maid rates sponsor after interview (1-5)"""
  maid_rating: Float

  """Sponsor rates maid after interview (1-5)"""
  sponsor_rating: Float
}

"""
order by variance() on columns of table "video_interviews"
"""
input video_interviews_variance_order_by {
  duration_minutes: order_by

  """Maid rates sponsor after interview (1-5)"""
  maid_rating: order_by

  """Sponsor rates maid after interview (1-5)"""
  sponsor_rating: order_by
}

"""Audit trail for all Stripe webhook events"""
type webhook_event_logs {
  client_ip: String
  created_at: timestamptz!
  error_code: String
  error_message: String

  """Unique Stripe event ID (e.g., evt_1234567890)"""
  event_id: String!

  """Type of webhook event from Stripe"""
  event_type: String!
  id: uuid!
  last_retry_at: timestamptz
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  processing_completed_at: timestamptz
  processing_duration_ms: Int
  processing_started_at: timestamptz
  received_at: timestamptz!

  """Full webhook payload for replay capability"""
  request_body(
    """JSON select path"""
    path: String
  ): jsonb
  response_body(
    """JSON select path"""
    path: String
  ): jsonb
  response_status: Int

  """Number of times Stripe retried this webhook"""
  retry_count: Int

  """Processing status: pending, processing, success, failed, skipped"""
  status: String!
  stripe_signature: String

  """An object relationship"""
  subscription: subscriptions
  subscription_id: uuid

  """An object relationship"""
  user: auth_users
  user_id: uuid
}

"""
aggregated selection of "webhook_event_logs"
"""
type webhook_event_logs_aggregate {
  aggregate: webhook_event_logs_aggregate_fields
  nodes: [webhook_event_logs!]!
}

input webhook_event_logs_aggregate_bool_exp {
  count: webhook_event_logs_aggregate_bool_exp_count
}

input webhook_event_logs_aggregate_bool_exp_count {
  arguments: [webhook_event_logs_select_column!]
  distinct: Boolean
  filter: webhook_event_logs_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "webhook_event_logs"
"""
type webhook_event_logs_aggregate_fields {
  avg: webhook_event_logs_avg_fields
  count(columns: [webhook_event_logs_select_column!], distinct: Boolean): Int!
  max: webhook_event_logs_max_fields
  min: webhook_event_logs_min_fields
  stddev: webhook_event_logs_stddev_fields
  stddev_pop: webhook_event_logs_stddev_pop_fields
  stddev_samp: webhook_event_logs_stddev_samp_fields
  sum: webhook_event_logs_sum_fields
  var_pop: webhook_event_logs_var_pop_fields
  var_samp: webhook_event_logs_var_samp_fields
  variance: webhook_event_logs_variance_fields
}

"""
order by aggregate values of table "webhook_event_logs"
"""
input webhook_event_logs_aggregate_order_by {
  avg: webhook_event_logs_avg_order_by
  count: order_by
  max: webhook_event_logs_max_order_by
  min: webhook_event_logs_min_order_by
  stddev: webhook_event_logs_stddev_order_by
  stddev_pop: webhook_event_logs_stddev_pop_order_by
  stddev_samp: webhook_event_logs_stddev_samp_order_by
  sum: webhook_event_logs_sum_order_by
  var_pop: webhook_event_logs_var_pop_order_by
  var_samp: webhook_event_logs_var_samp_order_by
  variance: webhook_event_logs_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input webhook_event_logs_append_input {
  metadata: jsonb

  """Full webhook payload for replay capability"""
  request_body: jsonb
  response_body: jsonb
}

"""
input type for inserting array relation for remote table "webhook_event_logs"
"""
input webhook_event_logs_arr_rel_insert_input {
  data: [webhook_event_logs_insert_input!]!

  """upsert condition"""
  on_conflict: webhook_event_logs_on_conflict
}

"""aggregate avg on columns"""
type webhook_event_logs_avg_fields {
  processing_duration_ms: Float
  response_status: Float

  """Number of times Stripe retried this webhook"""
  retry_count: Float
}

"""
order by avg() on columns of table "webhook_event_logs"
"""
input webhook_event_logs_avg_order_by {
  processing_duration_ms: order_by
  response_status: order_by

  """Number of times Stripe retried this webhook"""
  retry_count: order_by
}

"""
Boolean expression to filter rows from the table "webhook_event_logs". All fields are combined with a logical 'AND'.
"""
input webhook_event_logs_bool_exp {
  _and: [webhook_event_logs_bool_exp!]
  _not: webhook_event_logs_bool_exp
  _or: [webhook_event_logs_bool_exp!]
  client_ip: String_comparison_exp
  created_at: timestamptz_comparison_exp
  error_code: String_comparison_exp
  error_message: String_comparison_exp
  event_id: String_comparison_exp
  event_type: String_comparison_exp
  id: uuid_comparison_exp
  last_retry_at: timestamptz_comparison_exp
  metadata: jsonb_comparison_exp
  processing_completed_at: timestamptz_comparison_exp
  processing_duration_ms: Int_comparison_exp
  processing_started_at: timestamptz_comparison_exp
  received_at: timestamptz_comparison_exp
  request_body: jsonb_comparison_exp
  response_body: jsonb_comparison_exp
  response_status: Int_comparison_exp
  retry_count: Int_comparison_exp
  status: String_comparison_exp
  stripe_signature: String_comparison_exp
  subscription: subscriptions_bool_exp
  subscription_id: uuid_comparison_exp
  user: auth_users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "webhook_event_logs"
"""
enum webhook_event_logs_constraint {
  """
  unique or primary key constraint on columns "event_id"
  """
  webhook_event_logs_event_id_key

  """
  unique or primary key constraint on columns "id"
  """
  webhook_event_logs_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input webhook_event_logs_delete_at_path_input {
  metadata: [String!]

  """Full webhook payload for replay capability"""
  request_body: [String!]
  response_body: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input webhook_event_logs_delete_elem_input {
  metadata: Int

  """Full webhook payload for replay capability"""
  request_body: Int
  response_body: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input webhook_event_logs_delete_key_input {
  metadata: String

  """Full webhook payload for replay capability"""
  request_body: String
  response_body: String
}

"""
input type for incrementing numeric columns in table "webhook_event_logs"
"""
input webhook_event_logs_inc_input {
  processing_duration_ms: Int
  response_status: Int

  """Number of times Stripe retried this webhook"""
  retry_count: Int
}

"""
input type for inserting data into table "webhook_event_logs"
"""
input webhook_event_logs_insert_input {
  client_ip: String
  created_at: timestamptz
  error_code: String
  error_message: String

  """Unique Stripe event ID (e.g., evt_1234567890)"""
  event_id: String

  """Type of webhook event from Stripe"""
  event_type: String
  id: uuid
  last_retry_at: timestamptz
  metadata: jsonb
  processing_completed_at: timestamptz
  processing_duration_ms: Int
  processing_started_at: timestamptz
  received_at: timestamptz

  """Full webhook payload for replay capability"""
  request_body: jsonb
  response_body: jsonb
  response_status: Int

  """Number of times Stripe retried this webhook"""
  retry_count: Int

  """Processing status: pending, processing, success, failed, skipped"""
  status: String
  stripe_signature: String
  subscription: subscriptions_obj_rel_insert_input
  subscription_id: uuid
  user: auth_users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type webhook_event_logs_max_fields {
  client_ip: String
  created_at: timestamptz
  error_code: String
  error_message: String

  """Unique Stripe event ID (e.g., evt_1234567890)"""
  event_id: String

  """Type of webhook event from Stripe"""
  event_type: String
  id: uuid
  last_retry_at: timestamptz
  processing_completed_at: timestamptz
  processing_duration_ms: Int
  processing_started_at: timestamptz
  received_at: timestamptz
  response_status: Int

  """Number of times Stripe retried this webhook"""
  retry_count: Int

  """Processing status: pending, processing, success, failed, skipped"""
  status: String
  stripe_signature: String
  subscription_id: uuid
  user_id: uuid
}

"""
order by max() on columns of table "webhook_event_logs"
"""
input webhook_event_logs_max_order_by {
  client_ip: order_by
  created_at: order_by
  error_code: order_by
  error_message: order_by

  """Unique Stripe event ID (e.g., evt_1234567890)"""
  event_id: order_by

  """Type of webhook event from Stripe"""
  event_type: order_by
  id: order_by
  last_retry_at: order_by
  processing_completed_at: order_by
  processing_duration_ms: order_by
  processing_started_at: order_by
  received_at: order_by
  response_status: order_by

  """Number of times Stripe retried this webhook"""
  retry_count: order_by

  """Processing status: pending, processing, success, failed, skipped"""
  status: order_by
  stripe_signature: order_by
  subscription_id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type webhook_event_logs_min_fields {
  client_ip: String
  created_at: timestamptz
  error_code: String
  error_message: String

  """Unique Stripe event ID (e.g., evt_1234567890)"""
  event_id: String

  """Type of webhook event from Stripe"""
  event_type: String
  id: uuid
  last_retry_at: timestamptz
  processing_completed_at: timestamptz
  processing_duration_ms: Int
  processing_started_at: timestamptz
  received_at: timestamptz
  response_status: Int

  """Number of times Stripe retried this webhook"""
  retry_count: Int

  """Processing status: pending, processing, success, failed, skipped"""
  status: String
  stripe_signature: String
  subscription_id: uuid
  user_id: uuid
}

"""
order by min() on columns of table "webhook_event_logs"
"""
input webhook_event_logs_min_order_by {
  client_ip: order_by
  created_at: order_by
  error_code: order_by
  error_message: order_by

  """Unique Stripe event ID (e.g., evt_1234567890)"""
  event_id: order_by

  """Type of webhook event from Stripe"""
  event_type: order_by
  id: order_by
  last_retry_at: order_by
  processing_completed_at: order_by
  processing_duration_ms: order_by
  processing_started_at: order_by
  received_at: order_by
  response_status: order_by

  """Number of times Stripe retried this webhook"""
  retry_count: order_by

  """Processing status: pending, processing, success, failed, skipped"""
  status: order_by
  stripe_signature: order_by
  subscription_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "webhook_event_logs"
"""
type webhook_event_logs_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [webhook_event_logs!]!
}

"""
on_conflict condition type for table "webhook_event_logs"
"""
input webhook_event_logs_on_conflict {
  constraint: webhook_event_logs_constraint!
  update_columns: [webhook_event_logs_update_column!]! = []
  where: webhook_event_logs_bool_exp
}

"""Ordering options when selecting data from "webhook_event_logs"."""
input webhook_event_logs_order_by {
  client_ip: order_by
  created_at: order_by
  error_code: order_by
  error_message: order_by
  event_id: order_by
  event_type: order_by
  id: order_by
  last_retry_at: order_by
  metadata: order_by
  processing_completed_at: order_by
  processing_duration_ms: order_by
  processing_started_at: order_by
  received_at: order_by
  request_body: order_by
  response_body: order_by
  response_status: order_by
  retry_count: order_by
  status: order_by
  stripe_signature: order_by
  subscription: subscriptions_order_by
  subscription_id: order_by
  user: auth_users_order_by
  user_id: order_by
}

"""primary key columns input for table: webhook_event_logs"""
input webhook_event_logs_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input webhook_event_logs_prepend_input {
  metadata: jsonb

  """Full webhook payload for replay capability"""
  request_body: jsonb
  response_body: jsonb
}

"""
select columns of table "webhook_event_logs"
"""
enum webhook_event_logs_select_column {
  """column name"""
  client_ip

  """column name"""
  created_at

  """column name"""
  error_code

  """column name"""
  error_message

  """column name"""
  event_id

  """column name"""
  event_type

  """column name"""
  id

  """column name"""
  last_retry_at

  """column name"""
  metadata

  """column name"""
  processing_completed_at

  """column name"""
  processing_duration_ms

  """column name"""
  processing_started_at

  """column name"""
  received_at

  """column name"""
  request_body

  """column name"""
  response_body

  """column name"""
  response_status

  """column name"""
  retry_count

  """column name"""
  status

  """column name"""
  stripe_signature

  """column name"""
  subscription_id

  """column name"""
  user_id
}

"""
input type for updating data in table "webhook_event_logs"
"""
input webhook_event_logs_set_input {
  client_ip: String
  created_at: timestamptz
  error_code: String
  error_message: String

  """Unique Stripe event ID (e.g., evt_1234567890)"""
  event_id: String

  """Type of webhook event from Stripe"""
  event_type: String
  id: uuid
  last_retry_at: timestamptz
  metadata: jsonb
  processing_completed_at: timestamptz
  processing_duration_ms: Int
  processing_started_at: timestamptz
  received_at: timestamptz

  """Full webhook payload for replay capability"""
  request_body: jsonb
  response_body: jsonb
  response_status: Int

  """Number of times Stripe retried this webhook"""
  retry_count: Int

  """Processing status: pending, processing, success, failed, skipped"""
  status: String
  stripe_signature: String
  subscription_id: uuid
  user_id: uuid
}

"""aggregate stddev on columns"""
type webhook_event_logs_stddev_fields {
  processing_duration_ms: Float
  response_status: Float

  """Number of times Stripe retried this webhook"""
  retry_count: Float
}

"""
order by stddev() on columns of table "webhook_event_logs"
"""
input webhook_event_logs_stddev_order_by {
  processing_duration_ms: order_by
  response_status: order_by

  """Number of times Stripe retried this webhook"""
  retry_count: order_by
}

"""aggregate stddev_pop on columns"""
type webhook_event_logs_stddev_pop_fields {
  processing_duration_ms: Float
  response_status: Float

  """Number of times Stripe retried this webhook"""
  retry_count: Float
}

"""
order by stddev_pop() on columns of table "webhook_event_logs"
"""
input webhook_event_logs_stddev_pop_order_by {
  processing_duration_ms: order_by
  response_status: order_by

  """Number of times Stripe retried this webhook"""
  retry_count: order_by
}

"""aggregate stddev_samp on columns"""
type webhook_event_logs_stddev_samp_fields {
  processing_duration_ms: Float
  response_status: Float

  """Number of times Stripe retried this webhook"""
  retry_count: Float
}

"""
order by stddev_samp() on columns of table "webhook_event_logs"
"""
input webhook_event_logs_stddev_samp_order_by {
  processing_duration_ms: order_by
  response_status: order_by

  """Number of times Stripe retried this webhook"""
  retry_count: order_by
}

"""
Streaming cursor of the table "webhook_event_logs"
"""
input webhook_event_logs_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: webhook_event_logs_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input webhook_event_logs_stream_cursor_value_input {
  client_ip: String
  created_at: timestamptz
  error_code: String
  error_message: String

  """Unique Stripe event ID (e.g., evt_1234567890)"""
  event_id: String

  """Type of webhook event from Stripe"""
  event_type: String
  id: uuid
  last_retry_at: timestamptz
  metadata: jsonb
  processing_completed_at: timestamptz
  processing_duration_ms: Int
  processing_started_at: timestamptz
  received_at: timestamptz

  """Full webhook payload for replay capability"""
  request_body: jsonb
  response_body: jsonb
  response_status: Int

  """Number of times Stripe retried this webhook"""
  retry_count: Int

  """Processing status: pending, processing, success, failed, skipped"""
  status: String
  stripe_signature: String
  subscription_id: uuid
  user_id: uuid
}

"""aggregate sum on columns"""
type webhook_event_logs_sum_fields {
  processing_duration_ms: Int
  response_status: Int

  """Number of times Stripe retried this webhook"""
  retry_count: Int
}

"""
order by sum() on columns of table "webhook_event_logs"
"""
input webhook_event_logs_sum_order_by {
  processing_duration_ms: order_by
  response_status: order_by

  """Number of times Stripe retried this webhook"""
  retry_count: order_by
}

"""
update columns of table "webhook_event_logs"
"""
enum webhook_event_logs_update_column {
  """column name"""
  client_ip

  """column name"""
  created_at

  """column name"""
  error_code

  """column name"""
  error_message

  """column name"""
  event_id

  """column name"""
  event_type

  """column name"""
  id

  """column name"""
  last_retry_at

  """column name"""
  metadata

  """column name"""
  processing_completed_at

  """column name"""
  processing_duration_ms

  """column name"""
  processing_started_at

  """column name"""
  received_at

  """column name"""
  request_body

  """column name"""
  response_body

  """column name"""
  response_status

  """column name"""
  retry_count

  """column name"""
  status

  """column name"""
  stripe_signature

  """column name"""
  subscription_id

  """column name"""
  user_id
}

input webhook_event_logs_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: webhook_event_logs_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: webhook_event_logs_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: webhook_event_logs_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: webhook_event_logs_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: webhook_event_logs_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: webhook_event_logs_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: webhook_event_logs_set_input

  """filter the rows which have to be updated"""
  where: webhook_event_logs_bool_exp!
}

"""aggregate var_pop on columns"""
type webhook_event_logs_var_pop_fields {
  processing_duration_ms: Float
  response_status: Float

  """Number of times Stripe retried this webhook"""
  retry_count: Float
}

"""
order by var_pop() on columns of table "webhook_event_logs"
"""
input webhook_event_logs_var_pop_order_by {
  processing_duration_ms: order_by
  response_status: order_by

  """Number of times Stripe retried this webhook"""
  retry_count: order_by
}

"""aggregate var_samp on columns"""
type webhook_event_logs_var_samp_fields {
  processing_duration_ms: Float
  response_status: Float

  """Number of times Stripe retried this webhook"""
  retry_count: Float
}

"""
order by var_samp() on columns of table "webhook_event_logs"
"""
input webhook_event_logs_var_samp_order_by {
  processing_duration_ms: order_by
  response_status: order_by

  """Number of times Stripe retried this webhook"""
  retry_count: order_by
}

"""aggregate variance on columns"""
type webhook_event_logs_variance_fields {
  processing_duration_ms: Float
  response_status: Float

  """Number of times Stripe retried this webhook"""
  retry_count: Float
}

"""
order by variance() on columns of table "webhook_event_logs"
"""
input webhook_event_logs_variance_order_by {
  processing_duration_ms: order_by
  response_status: order_by

  """Number of times Stripe retried this webhook"""
  retry_count: order_by
}

"""Stores WhatsApp conversation history between users and AI assistant"""
type whatsapp_messages {
  """Full AI response JSON including tool results"""
  ai_response: String
  created_at: timestamptz
  id: uuid!
  message_content: String!

  """Type of message: text, image, or document"""
  message_type: String!
  phone_number: String!

  """Whether the message has been processed"""
  processed: Boolean
  received_at: timestamptz

  """
  Either "user" or "assistant"
  """
  sender: String!
}

"""
aggregated selection of "whatsapp_messages"
"""
type whatsapp_messages_aggregate {
  aggregate: whatsapp_messages_aggregate_fields
  nodes: [whatsapp_messages!]!
}

"""
aggregate fields of "whatsapp_messages"
"""
type whatsapp_messages_aggregate_fields {
  count(columns: [whatsapp_messages_select_column!], distinct: Boolean): Int!
  max: whatsapp_messages_max_fields
  min: whatsapp_messages_min_fields
}

"""
Boolean expression to filter rows from the table "whatsapp_messages". All fields are combined with a logical 'AND'.
"""
input whatsapp_messages_bool_exp {
  _and: [whatsapp_messages_bool_exp!]
  _not: whatsapp_messages_bool_exp
  _or: [whatsapp_messages_bool_exp!]
  ai_response: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  message_content: String_comparison_exp
  message_type: String_comparison_exp
  phone_number: String_comparison_exp
  processed: Boolean_comparison_exp
  received_at: timestamptz_comparison_exp
  sender: String_comparison_exp
}

"""
unique or primary key constraints on table "whatsapp_messages"
"""
enum whatsapp_messages_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  whatsapp_messages_pkey
}

"""
input type for inserting data into table "whatsapp_messages"
"""
input whatsapp_messages_insert_input {
  """Full AI response JSON including tool results"""
  ai_response: String
  created_at: timestamptz
  id: uuid
  message_content: String

  """Type of message: text, image, or document"""
  message_type: String
  phone_number: String

  """Whether the message has been processed"""
  processed: Boolean
  received_at: timestamptz

  """
  Either "user" or "assistant"
  """
  sender: String
}

"""aggregate max on columns"""
type whatsapp_messages_max_fields {
  """Full AI response JSON including tool results"""
  ai_response: String
  created_at: timestamptz
  id: uuid
  message_content: String

  """Type of message: text, image, or document"""
  message_type: String
  phone_number: String
  received_at: timestamptz

  """
  Either "user" or "assistant"
  """
  sender: String
}

"""aggregate min on columns"""
type whatsapp_messages_min_fields {
  """Full AI response JSON including tool results"""
  ai_response: String
  created_at: timestamptz
  id: uuid
  message_content: String

  """Type of message: text, image, or document"""
  message_type: String
  phone_number: String
  received_at: timestamptz

  """
  Either "user" or "assistant"
  """
  sender: String
}

"""
response of any mutation on the table "whatsapp_messages"
"""
type whatsapp_messages_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [whatsapp_messages!]!
}

"""
on_conflict condition type for table "whatsapp_messages"
"""
input whatsapp_messages_on_conflict {
  constraint: whatsapp_messages_constraint!
  update_columns: [whatsapp_messages_update_column!]! = []
  where: whatsapp_messages_bool_exp
}

"""Ordering options when selecting data from "whatsapp_messages"."""
input whatsapp_messages_order_by {
  ai_response: order_by
  created_at: order_by
  id: order_by
  message_content: order_by
  message_type: order_by
  phone_number: order_by
  processed: order_by
  received_at: order_by
  sender: order_by
}

"""primary key columns input for table: whatsapp_messages"""
input whatsapp_messages_pk_columns_input {
  id: uuid!
}

"""
select columns of table "whatsapp_messages"
"""
enum whatsapp_messages_select_column {
  """column name"""
  ai_response

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  message_content

  """column name"""
  message_type

  """column name"""
  phone_number

  """column name"""
  processed

  """column name"""
  received_at

  """column name"""
  sender
}

"""
input type for updating data in table "whatsapp_messages"
"""
input whatsapp_messages_set_input {
  """Full AI response JSON including tool results"""
  ai_response: String
  created_at: timestamptz
  id: uuid
  message_content: String

  """Type of message: text, image, or document"""
  message_type: String
  phone_number: String

  """Whether the message has been processed"""
  processed: Boolean
  received_at: timestamptz

  """
  Either "user" or "assistant"
  """
  sender: String
}

"""
Streaming cursor of the table "whatsapp_messages"
"""
input whatsapp_messages_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: whatsapp_messages_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input whatsapp_messages_stream_cursor_value_input {
  """Full AI response JSON including tool results"""
  ai_response: String
  created_at: timestamptz
  id: uuid
  message_content: String

  """Type of message: text, image, or document"""
  message_type: String
  phone_number: String

  """Whether the message has been processed"""
  processed: Boolean
  received_at: timestamptz

  """
  Either "user" or "assistant"
  """
  sender: String
}

"""
update columns of table "whatsapp_messages"
"""
enum whatsapp_messages_update_column {
  """column name"""
  ai_response

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  message_content

  """column name"""
  message_type

  """column name"""
  phone_number

  """column name"""
  processed

  """column name"""
  received_at

  """column name"""
  sender
}

input whatsapp_messages_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: whatsapp_messages_set_input

  """filter the rows which have to be updated"""
  where: whatsapp_messages_bool_exp!
}

"""Work experience entries for maid profiles"""
type work_experience {
  country_of_employment: String!
  created_at: timestamptz
  duration: String!
  employer_name: String
  end_date: date
  id: uuid!
  job_description: String
  maid_id: uuid!
  position: String!
  position_other: String
  reason_for_leaving: String!
  reason_for_leaving_other: String
  start_date: date
  updated_at: timestamptz
}

"""
aggregated selection of "work_experience"
"""
type work_experience_aggregate {
  aggregate: work_experience_aggregate_fields
  nodes: [work_experience!]!
}

"""
aggregate fields of "work_experience"
"""
type work_experience_aggregate_fields {
  count(columns: [work_experience_select_column!], distinct: Boolean): Int!
  max: work_experience_max_fields
  min: work_experience_min_fields
}

"""
Boolean expression to filter rows from the table "work_experience". All fields are combined with a logical 'AND'.
"""
input work_experience_bool_exp {
  _and: [work_experience_bool_exp!]
  _not: work_experience_bool_exp
  _or: [work_experience_bool_exp!]
  country_of_employment: String_comparison_exp
  created_at: timestamptz_comparison_exp
  duration: String_comparison_exp
  employer_name: String_comparison_exp
  end_date: date_comparison_exp
  id: uuid_comparison_exp
  job_description: String_comparison_exp
  maid_id: uuid_comparison_exp
  position: String_comparison_exp
  position_other: String_comparison_exp
  reason_for_leaving: String_comparison_exp
  reason_for_leaving_other: String_comparison_exp
  start_date: date_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "work_experience"
"""
enum work_experience_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  work_experience_pkey
}

"""
input type for inserting data into table "work_experience"
"""
input work_experience_insert_input {
  country_of_employment: String
  created_at: timestamptz
  duration: String
  employer_name: String
  end_date: date
  id: uuid
  job_description: String
  maid_id: uuid
  position: String
  position_other: String
  reason_for_leaving: String
  reason_for_leaving_other: String
  start_date: date
  updated_at: timestamptz
}

"""aggregate max on columns"""
type work_experience_max_fields {
  country_of_employment: String
  created_at: timestamptz
  duration: String
  employer_name: String
  end_date: date
  id: uuid
  job_description: String
  maid_id: uuid
  position: String
  position_other: String
  reason_for_leaving: String
  reason_for_leaving_other: String
  start_date: date
  updated_at: timestamptz
}

"""aggregate min on columns"""
type work_experience_min_fields {
  country_of_employment: String
  created_at: timestamptz
  duration: String
  employer_name: String
  end_date: date
  id: uuid
  job_description: String
  maid_id: uuid
  position: String
  position_other: String
  reason_for_leaving: String
  reason_for_leaving_other: String
  start_date: date
  updated_at: timestamptz
}

"""
response of any mutation on the table "work_experience"
"""
type work_experience_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [work_experience!]!
}

"""
on_conflict condition type for table "work_experience"
"""
input work_experience_on_conflict {
  constraint: work_experience_constraint!
  update_columns: [work_experience_update_column!]! = []
  where: work_experience_bool_exp
}

"""Ordering options when selecting data from "work_experience"."""
input work_experience_order_by {
  country_of_employment: order_by
  created_at: order_by
  duration: order_by
  employer_name: order_by
  end_date: order_by
  id: order_by
  job_description: order_by
  maid_id: order_by
  position: order_by
  position_other: order_by
  reason_for_leaving: order_by
  reason_for_leaving_other: order_by
  start_date: order_by
  updated_at: order_by
}

"""primary key columns input for table: work_experience"""
input work_experience_pk_columns_input {
  id: uuid!
}

"""
select columns of table "work_experience"
"""
enum work_experience_select_column {
  """column name"""
  country_of_employment

  """column name"""
  created_at

  """column name"""
  duration

  """column name"""
  employer_name

  """column name"""
  end_date

  """column name"""
  id

  """column name"""
  job_description

  """column name"""
  maid_id

  """column name"""
  position

  """column name"""
  position_other

  """column name"""
  reason_for_leaving

  """column name"""
  reason_for_leaving_other

  """column name"""
  start_date

  """column name"""
  updated_at
}

"""
input type for updating data in table "work_experience"
"""
input work_experience_set_input {
  country_of_employment: String
  created_at: timestamptz
  duration: String
  employer_name: String
  end_date: date
  id: uuid
  job_description: String
  maid_id: uuid
  position: String
  position_other: String
  reason_for_leaving: String
  reason_for_leaving_other: String
  start_date: date
  updated_at: timestamptz
}

"""
Streaming cursor of the table "work_experience"
"""
input work_experience_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: work_experience_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input work_experience_stream_cursor_value_input {
  country_of_employment: String
  created_at: timestamptz
  duration: String
  employer_name: String
  end_date: date
  id: uuid
  job_description: String
  maid_id: uuid
  position: String
  position_other: String
  reason_for_leaving: String
  reason_for_leaving_other: String
  start_date: date
  updated_at: timestamptz
}

"""
update columns of table "work_experience"
"""
enum work_experience_update_column {
  """column name"""
  country_of_employment

  """column name"""
  created_at

  """column name"""
  duration

  """column name"""
  employer_name

  """column name"""
  end_date

  """column name"""
  id

  """column name"""
  job_description

  """column name"""
  maid_id

  """column name"""
  position

  """column name"""
  position_other

  """column name"""
  reason_for_leaving

  """column name"""
  reason_for_leaving_other

  """column name"""
  start_date

  """column name"""
  updated_at
}

input work_experience_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: work_experience_set_input

  """filter the rows which have to be updated"""
  where: work_experience_bool_exp!
}